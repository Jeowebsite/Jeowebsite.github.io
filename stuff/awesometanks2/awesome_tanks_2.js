Math.sign || (Math.sign = function(t) {
        return t = +t, 0 === t || isNaN(t) ? Number(t) : t > 0 ? 1 : -1
    }), String.prototype.repeat || (String.prototype.repeat = function(t) {
        "use strict";
        if (null == this) throw new TypeError("can't convert " + this + " to object");
        var e = "" + this;
        if (t = +t, t != t && (t = 0), t < 0) throw new RangeError("repeat count must be non-negative");
        if (t == 1 / 0) throw new RangeError("repeat count must be less than infinity");
        if (t = Math.floor(t), 0 == e.length || 0 == t) return "";
        if (e.length * t >= 1 << 28) throw new RangeError("repeat count must not overflow maximum string size");
        for (var i = ""; 1 == (1 & t) && (i += e), 0 != (t >>>= 1);) e += e;
        return i
    }), String.prototype.startsWith || (String.prototype.startsWith = function(t, e) {
        return this.substr(e || 0, t.length) === t
    }),
    function() {
        function t(t, e, i) {
            return t.call.apply(t.bind, arguments)
        }

        function e(t, e, i) {
            if (!t) throw Error();
            if (2 < arguments.length) {
                var o = Array.prototype.slice.call(arguments, 2);
                return function() {
                    var i = Array.prototype.slice.call(arguments);
                    return Array.prototype.unshift.apply(i, o), t.apply(e, i)
                }
            }
            return function() {
                return t.apply(e, arguments)
            }
        }

        function i(o, s, n) {
            return i = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? t : e, i.apply(null, arguments)
        }

        function o(t, e) {
            this.a = t, this.o = e || t, this.c = this.o.document
        }

        function s(t, e, i, o) {
            if (e = t.c.createElement(e), i)
                for (var s in i) i.hasOwnProperty(s) && ("style" == s ? e.style.cssText = i[s] : e.setAttribute(s, i[s]));
            return o && e.appendChild(t.c.createTextNode(o)), e
        }

        function n(t, e, i) {
            t = t.c.getElementsByTagName(e)[0], t || (t = document.documentElement), t.insertBefore(i, t.lastChild)
        }

        function r(t) {
            t.parentNode && t.parentNode.removeChild(t)
        }

        function a(t, e, i) {
            e = e || [], i = i || [];
            for (var o = t.className.split(/\s+/), s = 0; s < e.length; s += 1) {
                for (var n = !1, r = 0; r < o.length; r += 1)
                    if (e[s] === o[r]) {
                        n = !0;
                        break
                    }
                n || o.push(e[s])
            }
            for (e = [], s = 0; s < o.length; s += 1) {
                for (n = !1, r = 0; r < i.length; r += 1)
                    if (o[s] === i[r]) {
                        n = !0;
                        break
                    }
                n || e.push(o[s])
            }
            t.className = e.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "")
        }

        function h(t, e) {
            for (var i = t.className.split(/\s+/), o = 0, s = i.length; o < s; o++)
                if (i[o] == e) return !0;
            return !1
        }

        function l(t) {
            return t.o.location.hostname || t.a.location.hostname
        }

        function d(t, e, i) {
            function o() {
                l && r && a && (l(h), l = null)
            }
            e = s(t, "link", {
                rel: "stylesheet",
                href: e,
                media: "all"
            });
            var r = !1,
                a = !0,
                h = null,
                l = i || null;
            et ? (e.onload = function() {
                r = !0, o()
            }, e.onerror = function() {
                r = !0, h = Error("Stylesheet failed to load"), o()
            }) : setTimeout(function() {
                r = !0, o()
            }, 0), n(t, "head", e)
        }

        function c(t, e, i, o) {
            var n = t.c.getElementsByTagName("head")[0];
            if (n) {
                var r = s(t, "script", {
                        src: e
                    }),
                    a = !1;
                return r.onload = r.onreadystatechange = function() {
                    a || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (a = !0, i && i(null), r.onload = r.onreadystatechange = null, "HEAD" == r.parentNode.tagName && n.removeChild(r))
                }, n.appendChild(r), setTimeout(function() {
                    a || (a = !0, i && i(Error("Script load timeout")))
                }, o || 5e3), r
            }
            return null
        }

        function p() {
            this.a = 0, this.c = null
        }

        function u(t) {
            return t.a++,
                function() {
                    t.a--, m(t)
                }
        }

        function b(t, e) {
            t.c = e, m(t)
        }

        function m(t) {
            0 == t.a && t.c && (t.c(), t.c = null)
        }

        function y(t) {
            this.a = t || "-"
        }

        function f(t, e) {
            this.c = t, this.f = 4, this.a = "n";
            var i = (e || "n4").match(/^([nio])([1-9])$/i);
            i && (this.a = i[1], this.f = parseInt(i[2], 10))
        }

        function g(t) {
            return v(t) + " " + t.f + "00 300px " + x(t.c)
        }

        function x(t) {
            var e = [];
            t = t.split(/,\s*/);
            for (var i = 0; i < t.length; i++) {
                var o = t[i].replace(/['"]/g, ""); - 1 != o.indexOf(" ") || /^\d/.test(o) ? e.push("'" + o + "'") : e.push(o)
            }
            return e.join(",")
        }

        function _(t) {
            return t.a + t.f
        }

        function v(t) {
            var e = "normal";
            return "o" === t.a ? e = "oblique" : "i" === t.a && (e = "italic"), e
        }

        function w(t) {
            var e = 4,
                i = "n",
                o = null;
            return t && ((o = t.match(/(normal|oblique|italic)/i)) && o[1] && (i = o[1].substr(0, 1).toLowerCase()), (o = t.match(/([1-9]00|normal|bold)/i)) && o[1] && (/bold/i.test(o[1]) ? e = 7 : /[1-9]00/.test(o[1]) && (e = parseInt(o[1].substr(0, 1), 10)))), i + e
        }

        function C(t, e) {
            this.c = t, this.f = t.o.document.documentElement, this.h = e, this.a = new y("-"), this.j = !1 !== e.events, this.g = !1 !== e.classes
        }

        function S(t) {
            t.g && a(t.f, [t.a.c("wf", "loading")]), T(t, "loading")
        }

        function A(t) {
            if (t.g) {
                var e = h(t.f, t.a.c("wf", "active")),
                    i = [],
                    o = [t.a.c("wf", "loading")];
                e || i.push(t.a.c("wf", "inactive")), a(t.f, i, o)
            }
            T(t, "inactive")
        }

        function T(t, e, i) {
            t.j && t.h[e] && (i ? t.h[e](i.c, _(i)) : t.h[e]())
        }

        function P() {
            this.c = {}
        }

        function B(t, e, i) {
            var o, s = [];
            for (o in e)
                if (e.hasOwnProperty(o)) {
                    var n = t.c[o];
                    n && s.push(n(e[o], i))
                }
            return s
        }

        function M(t, e) {
            this.c = t, this.f = e, this.a = s(this.c, "span", {
                "aria-hidden": "true"
            }, this.f)
        }

        function I(t) {
            n(t.c, "body", t.a)
        }

        function R(t) {
            return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + x(t.c) + ";font-style:" + v(t) + ";font-weight:" + t.f + "00;"
        }

        function D(t, e, i, o, s, n) {
            this.g = t, this.j = e, this.a = o, this.c = i, this.f = s || 3e3, this.h = n || void 0
        }

        function k(t, e, i, o, s, n, r) {
            this.v = t, this.B = e, this.c = i, this.a = o, this.s = r || "BESbswy", this.f = {}, this.w = s || 3e3, this.u = n || null, this.m = this.j = this.h = this.g = null, this.g = new M(this.c, this.s), this.h = new M(this.c, this.s), this.j = new M(this.c, this.s), this.m = new M(this.c, this.s), t = new f(this.a.c + ",serif", _(this.a)), t = R(t), this.g.a.style.cssText = t, t = new f(this.a.c + ",sans-serif", _(this.a)), t = R(t), this.h.a.style.cssText = t, t = new f("serif", _(this.a)), t = R(t), this.j.a.style.cssText = t, t = new f("sans-serif", _(this.a)), t = R(t), this.m.a.style.cssText = t, I(this.g), I(this.h), I(this.j), I(this.m)
        }

        function V() {
            if (null === ot) {
                var t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
                ot = !!t && (536 > parseInt(t[1], 10) || 536 === parseInt(t[1], 10) && 11 >= parseInt(t[2], 10))
            }
            return ot
        }

        function E(t, e, i) {
            for (var o in it)
                if (it.hasOwnProperty(o) && e === t.f[it[o]] && i === t.f[it[o]]) return !0;
            return !1
        }

        function L(t) {
            var e, i = t.g.a.offsetWidth,
                o = t.h.a.offsetWidth;
            (e = i === t.f.serif && o === t.f["sans-serif"]) || (e = V() && E(t, i, o)), e ? tt() - t.A >= t.w ? V() && E(t, i, o) && (null === t.u || t.u.hasOwnProperty(t.a.c)) ? O(t, t.v) : O(t, t.B) : F(t) : O(t, t.v)
        }

        function F(t) {
            setTimeout(i(function() {
                L(this)
            }, t), 50)
        }

        function O(t, e) {
            setTimeout(i(function() {
                r(this.g.a), r(this.h.a), r(this.j.a), r(this.m.a), e(this.a)
            }, t), 0)
        }

        function G(t, e, i) {
            this.c = t, this.a = e, this.f = 0, this.m = this.j = !1, this.s = i
        }

        function U(t) {
            0 == --t.f && t.j && (t.m ? (t = t.a, t.g && a(t.f, [t.a.c("wf", "active")], [t.a.c("wf", "loading"), t.a.c("wf", "inactive")]), T(t, "active")) : A(t.a))
        }

        function N(t) {
            this.j = t, this.a = new P, this.h = 0, this.f = this.g = !0
        }

        function W(t, e, o, s, n) {
            var r = 0 == --t.h;
            (t.f || t.g) && setTimeout(function() {
                var t = n || null,
                    h = s || null || {};
                if (0 === o.length && r) A(e.a);
                else {
                    e.f += o.length, r && (e.j = r);
                    var l, d = [];
                    for (l = 0; l < o.length; l++) {
                        var c = o[l],
                            p = h[c.c],
                            u = e.a,
                            b = c;
                        if (u.g && a(u.f, [u.a.c("wf", b.c, _(b).toString(), "loading")]), T(u, "fontloading", b), u = null, null === st)
                            if (window.FontFace) {
                                var b = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                                    m = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                                st = b ? 42 < parseInt(b[1], 10) : !m
                            } else st = !1;
                        u = st ? new D(i(e.g, e), i(e.h, e), e.c, c, e.s, p) : new k(i(e.g, e), i(e.h, e), e.c, c, e.s, t, p), d.push(u)
                    }
                    for (l = 0; l < d.length; l++) d[l].start()
                }
            }, 0)
        }

        function J(t, e, i) {
            var o = [],
                s = i.timeout;
            S(e);
            var o = B(t.a, i, t.c),
                n = new G(t.c, e, s);
            for (t.h = o.length, e = 0, i = o.length; e < i; e++) o[e].load(function(e, i, o) {
                W(t, n, e, i, o)
            })
        }

        function X(t, e) {
            this.c = t, this.a = e
        }

        function j(t, e) {
            this.c = t, this.a = e
        }

        function H(t, e) {
            this.c = t || nt, this.a = [], this.f = [], this.g = e || ""
        }

        function z(t, e) {
            for (var i = e.length, o = 0; o < i; o++) {
                var s = e[o].split(":");
                3 == s.length && t.f.push(s.pop());
                var n = "";
                2 == s.length && "" != s[1] && (n = ":"), t.a.push(s.join(n))
            }
        }

        function Y(t) {
            if (0 == t.a.length) throw Error("No fonts to load!");
            if (-1 != t.c.indexOf("kit=")) return t.c;
            for (var e = t.a.length, i = [], o = 0; o < e; o++) i.push(t.a[o].replace(/ /g, "+"));
            return e = t.c + "?family=" + i.join("%7C"), 0 < t.f.length && (e += "&subset=" + t.f.join(",")), 0 < t.g.length && (e += "&text=" + encodeURIComponent(t.g)), e
        }

        function q(t) {
            this.f = t, this.a = [], this.c = {}
        }

        function K(t) {
            for (var e = t.f.length, i = 0; i < e; i++) {
                var o = t.f[i].split(":"),
                    s = o[0].replace(/\+/g, " "),
                    n = ["n4"];
                if (2 <= o.length) {
                    var r, a = o[1];
                    if (r = [], a)
                        for (var a = a.split(","), h = a.length, l = 0; l < h; l++) {
                            var d;
                            if (d = a[l], d.match(/^[\w-]+$/)) {
                                var c = lt.exec(d.toLowerCase());
                                if (null == c) d = "";
                                else {
                                    if (d = c[2], d = null == d || "" == d ? "n" : ht[d], null == (c = c[1]) || "" == c) c = "4";
                                    else var p = at[c],
                                        c = p || (isNaN(c) ? "4" : c.substr(0, 1));
                                    d = [d, c].join("")
                                }
                            } else d = "";
                            d && r.push(d)
                        }
                    0 < r.length && (n = r), 3 == o.length && (o = o[2], r = [], o = o ? o.split(",") : r, 0 < o.length && (o = rt[o[0]]) && (t.c[s] = o))
                }
                for (t.c[s] || (o = rt[s]) && (t.c[s] = o), o = 0; o < n.length; o += 1) t.a.push(new f(s, n[o]))
            }
        }

        function Z(t, e) {
            this.c = t, this.a = e
        }

        function Q(t, e) {
            this.c = t, this.a = e
        }

        function $(t, e) {
            this.c = t, this.f = e, this.a = []
        }
        var tt = Date.now || function() {
                return +new Date
            },
            et = !!window.FontFace;
        y.prototype.c = function(t) {
            for (var e = [], i = 0; i < arguments.length; i++) e.push(arguments[i].replace(/[\W_]+/g, "").toLowerCase());
            return e.join(this.a)
        }, D.prototype.start = function() {
            var t = this.c.o.document,
                e = this,
                i = tt(),
                o = new Promise(function(o, s) {
                    function n() {
                        tt() - i >= e.f ? s() : t.fonts.load(g(e.a), e.h).then(function(t) {
                            1 <= t.length ? o() : setTimeout(n, 25)
                        }, function() {
                            s()
                        })
                    }
                    n()
                }),
                s = null,
                n = new Promise(function(t, i) {
                    s = setTimeout(i, e.f)
                });
            Promise.race([n, o]).then(function() {
                s && (clearTimeout(s), s = null), e.g(e.a)
            }, function() {
                e.j(e.a)
            })
        };
        var it = {
                D: "serif",
                C: "sans-serif"
            },
            ot = null;
        k.prototype.start = function() {
            this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = tt(), L(this)
        };
        var st = null;
        G.prototype.g = function(t) {
            var e = this.a;
            e.g && a(e.f, [e.a.c("wf", t.c, _(t).toString(), "active")], [e.a.c("wf", t.c, _(t).toString(), "loading"), e.a.c("wf", t.c, _(t).toString(), "inactive")]), T(e, "fontactive", t), this.m = !0, U(this)
        }, G.prototype.h = function(t) {
            var e = this.a;
            if (e.g) {
                var i = h(e.f, e.a.c("wf", t.c, _(t).toString(), "active")),
                    o = [],
                    s = [e.a.c("wf", t.c, _(t).toString(), "loading")];
                i || o.push(e.a.c("wf", t.c, _(t).toString(), "inactive")), a(e.f, o, s)
            }
            T(e, "fontinactive", t), U(this)
        }, N.prototype.load = function(t) {
            this.c = new o(this.j, t.context || this.j), this.g = !1 !== t.events, this.f = !1 !== t.classes, J(this, new C(this.c, t), t)
        }, X.prototype.load = function(t) {
            function e() {
                if (n["__mti_fntLst" + o]) {
                    var i, s = n["__mti_fntLst" + o](),
                        r = [];
                    if (s)
                        for (var a = 0; a < s.length; a++) {
                            var h = s[a].fontfamily;
                            void 0 != s[a].fontStyle && void 0 != s[a].fontWeight ? (i = s[a].fontStyle + s[a].fontWeight, r.push(new f(h, i))) : r.push(new f(h))
                        }
                    t(r)
                } else setTimeout(function() {
                    e()
                }, 50)
            }
            var i = this,
                o = i.a.projectId,
                s = i.a.version;
            if (o) {
                var n = i.c.o;
                c(this.c, (i.a.api || "https://fast.fonts.net/jsapi") + "/" + o + ".js" + (s ? "?v=" + s : ""), function(s) {
                    s ? t([]) : (n["__MonotypeConfiguration__" + o] = function() {
                        return i.a
                    }, e())
                }).id = "__MonotypeAPIScript__" + o
            } else t([])
        }, j.prototype.load = function(t) {
            var e, i, o = this.a.urls || [],
                s = this.a.families || [],
                n = this.a.testStrings || {},
                r = new p;
            for (e = 0, i = o.length; e < i; e++) d(this.c, o[e], u(r));
            var a = [];
            for (e = 0, i = s.length; e < i; e++)
                if (o = s[e].split(":"), o[1])
                    for (var h = o[1].split(","), l = 0; l < h.length; l += 1) a.push(new f(o[0], h[l]));
                else a.push(new f(o[0]));
            b(r, function() {
                t(a, n)
            })
        };
        var nt = "https://fonts.googleapis.com/css",
            rt = {
                latin: "BESbswy",
                "latin-ext": "çöüğş",
                cyrillic: "йяЖ",
                greek: "αβΣ",
                khmer: "កខគ",
                Hanuman: "កខគ"
            },
            at = {
                thin: "1",
                extralight: "2",
                "extra-light": "2",
                ultralight: "2",
                "ultra-light": "2",
                light: "3",
                regular: "4",
                book: "4",
                medium: "5",
                "semi-bold": "6",
                semibold: "6",
                "demi-bold": "6",
                demibold: "6",
                bold: "7",
                "extra-bold": "8",
                extrabold: "8",
                "ultra-bold": "8",
                ultrabold: "8",
                black: "9",
                heavy: "9",
                l: "3",
                r: "4",
                b: "7"
            },
            ht = {
                i: "i",
                italic: "i",
                n: "n",
                normal: "n"
            },
            lt = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/,
            dt = {
                Arimo: !0,
                Cousine: !0,
                Tinos: !0
            };
        Z.prototype.load = function(t) {
            var e = new p,
                i = this.c,
                o = new H(this.a.api, this.a.text),
                s = this.a.families;
            z(o, s);
            var n = new q(s);
            K(n), d(i, Y(o), u(e)), b(e, function() {
                t(n.a, n.c, dt)
            })
        }, Q.prototype.load = function(t) {
            var e = this.a.id,
                i = this.c.o;
            e ? c(this.c, (this.a.api || "https://use.typekit.net") + "/" + e + ".js", function(e) {
                if (e) t([]);
                else if (i.Typekit && i.Typekit.config && i.Typekit.config.fn) {
                    e = i.Typekit.config.fn;
                    for (var o = [], s = 0; s < e.length; s += 2)
                        for (var n = e[s], r = e[s + 1], a = 0; a < r.length; a++) o.push(new f(n, r[a]));
                    try {
                        i.Typekit.load({
                            events: !1,
                            classes: !1,
                            async: !0
                        })
                    } catch (t) {}
                    t(o)
                }
            }, 2e3) : t([])
        }, $.prototype.load = function(t) {
            var e = this.f.id,
                i = this.c.o,
                o = this;
            e ? (i.__webfontfontdeckmodule__ || (i.__webfontfontdeckmodule__ = {}), i.__webfontfontdeckmodule__[e] = function(e, i) {
                for (var s = 0, n = i.fonts.length; s < n; ++s) {
                    var r = i.fonts[s];
                    o.a.push(new f(r.name, w("font-weight:" + r.weight + ";font-style:" + r.style)))
                }
                t(o.a)
            }, c(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + l(this.c) + "/" + e + ".js", function(e) {
                e && t([])
            })) : t([])
        };
        var ct = new N(window);
        ct.a.c.custom = function(t, e) {
            return new j(e, t)
        }, ct.a.c.fontdeck = function(t, e) {
            return new $(e, t)
        }, ct.a.c.monotype = function(t, e) {
            return new X(e, t)
        }, ct.a.c.typekit = function(t, e) {
            return new Q(e, t)
        }, ct.a.c.google = function(t, e) {
            return new Z(e, t)
        };
        var pt = {
            load: i(ct.load, ct)
        };
        "function" == typeof define && define.amd ? define(function() {
            return pt
        }) : "undefined" != typeof module && module.exports ? module.exports = pt : (window.WebFont = pt, window.WebFontConfig && ct.load(window.WebFontConfig))
    }(),
    function() {
        var t = this,
            e = e || {};
        return e.game = null, e.WEBGL_RENDERER = 0, e.CANVAS_RENDERER = 1, e.VERSION = "v2.2.9", e._UID = 0, "undefined" != typeof Float32Array ? (e.Float32Array = Float32Array, e.Uint16Array = Uint16Array, e.Uint32Array = Uint32Array, e.ArrayBuffer = ArrayBuffer) : (e.Float32Array = Array, e.Uint16Array = Array), e.PI_2 = 2 * Math.PI, e.RAD_TO_DEG = 180 / Math.PI, e.DEG_TO_RAD = Math.PI / 180, e.RETINA_PREFIX = "@2x", e.DisplayObject = function() {
            this.position = new e.Point(0, 0), this.scale = new e.Point(1, 1), this.pivot = new e.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new e.Matrix, this.worldPosition = new e.Point(0, 0), this.worldScale = new e.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new e.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
        }, e.DisplayObject.prototype.constructor = e.DisplayObject, e.DisplayObject.prototype = {
            destroy: function() {
                if (this.children) {
                    for (var t = this.children.length; t--;) this.children[t].destroy();
                    this.children = []
                }
                this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite()
            },
            updateTransform: function(t) {
                if (!t && !this.parent && !this.game) return this;
                var i = this.parent;
                t ? i = t : this.parent || (i = this.game.world);
                var o, s, n, r, a, h, l = i.worldTransform,
                    d = this.worldTransform,
                    c = this.scale.x,
                    p = this.scale.y;
                return this.rotation % e.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), o = this._cr * c, s = this._sr * c, n = -this._sr * p, r = this._cr * p, a = this.position.x, h = this.position.y, (this.pivot.x || this.pivot.y) && (a -= this.pivot.x * o + this.pivot.y * n, h -= this.pivot.x * s + this.pivot.y * r), d.a = o * l.a + s * l.c, d.b = o * l.b + s * l.d, d.c = n * l.a + r * l.c, d.d = n * l.b + r * l.d, d.tx = a * l.a + h * l.c + l.tx, d.ty = a * l.b + h * l.d + l.ty) : (a = this.position.x - this.pivot.x * c, h = this.position.y - this.pivot.y * p, d.a = c * l.a, d.b = c * l.b, d.c = p * l.c, d.d = p * l.d, d.tx = a * l.a + h * l.c + l.tx, d.ty = a * l.b + h * l.d + l.ty), this.worldAlpha = this.alpha * i.worldAlpha, this.worldPosition.set(d.tx, d.ty), this.worldScale.set(c * Math.sqrt(d.a * d.a + d.c * d.c), p * Math.sqrt(d.b * d.b + d.d * d.d)), this.worldRotation = Math.atan2(-d.c, d.d), this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, d, l), this
            },
            preUpdate: function() {},
            generateTexture: function(t, i, o) {
                var s = this.getLocalBounds(),
                    n = new e.RenderTexture(0 | s.width, 0 | s.height, o, i, t);
                return e.DisplayObject._tempMatrix.tx = -s.x, e.DisplayObject._tempMatrix.ty = -s.y, n.render(this, e.DisplayObject._tempMatrix), n
            },
            updateCache: function() {
                return this._generateCachedSprite(), this
            },
            toGlobal: function(t) {
                return this.updateTransform(), this.worldTransform.apply(t)
            },
            toLocal: function(t, e) {
                return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t)
            },
            _renderCachedSprite: function(t) {
                this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? e.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : e.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
            },
            _generateCachedSprite: function() {
                this._cacheAsBitmap = !1;
                var t = this.getLocalBounds();
                if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height);
                else {
                    var i = new e.RenderTexture(t.width, t.height);
                    this._cachedSprite = new e.Sprite(i), this._cachedSprite.worldTransform = this.worldTransform
                }
                var o = this._filters;
                this._filters = null, this._cachedSprite.filters = o, e.DisplayObject._tempMatrix.tx = -t.x, e.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, e.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = o, this._cacheAsBitmap = !0
            },
            _destroyCachedSprite: function() {
                this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
            }
        }, e.DisplayObject.prototype.displayObjectUpdateTransform = e.DisplayObject.prototype.updateTransform, Object.defineProperties(e.DisplayObject.prototype, {
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t
                }
            },
            worldVisible: {
                get: function() {
                    if (this.visible) {
                        var t = this.parent;
                        if (!t) return this.visible;
                        do {
                            if (!t.visible) return !1;
                            t = t.parent
                        } while (t);
                        return !0
                    }
                    return !1
                }
            },
            mask: {
                get: function() {
                    return this._mask
                },
                set: function(t) {
                    this._mask && (this._mask.isMask = !1), this._mask = t, t && (this._mask.isMask = !0)
                }
            },
            filters: {
                get: function() {
                    return this._filters
                },
                set: function(t) {
                    if (Array.isArray(t)) {
                        for (var i = [], o = 0; o < t.length; o++)
                            for (var s = t[o].passes, n = 0; n < s.length; n++) i.push(s[n]);
                        this._filterBlock = {
                            target: this,
                            filterPasses: i
                        }
                    }
                    this._filters = t, this.blendMode && this.blendMode === e.blendModes.MULTIPLY && (this.blendMode = e.blendModes.NORMAL)
                }
            },
            cacheAsBitmap: {
                get: function() {
                    return this._cacheAsBitmap
                },
                set: function(t) {
                    this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
                }
            }
        }), e.DisplayObjectContainer = function() {
            e.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
        }, e.DisplayObjectContainer.prototype = Object.create(e.DisplayObject.prototype), e.DisplayObjectContainer.prototype.constructor = e.DisplayObjectContainer, e.DisplayObjectContainer.prototype.addChild = function(t) {
            return this.addChildAt(t, this.children.length)
        }, e.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
            if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), t;
            throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
        }, e.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
            if (t !== e) {
                var i = this.getChildIndex(t),
                    o = this.getChildIndex(e);
                if (i < 0 || o < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                this.children[i] = e, this.children[o] = t
            }
        }, e.DisplayObjectContainer.prototype.getChildIndex = function(t) {
            var e = this.children.indexOf(t);
            if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
            return e
        }, e.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
            if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
            var i = this.getChildIndex(t);
            this.children.splice(i, 1), this.children.splice(e, 0, t)
        }, e.DisplayObjectContainer.prototype.getChildAt = function(t) {
            if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
            return this.children[t]
        }, e.DisplayObjectContainer.prototype.removeChild = function(t) {
            var e = this.children.indexOf(t);
            if (-1 !== e) return this.removeChildAt(e)
        }, e.DisplayObjectContainer.prototype.removeChildAt = function(t) {
            var e = this.getChildAt(t);
            return e && (e.parent = void 0, this.children.splice(t, 1)), e
        }, e.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
            var i = e - t;
            if (i > 0 && i <= e) {
                for (var o = this.children.splice(begin, i), s = 0; s < o.length; s++) {
                    o[s].parent = void 0
                }
                return o
            }
            if (0 === i && 0 === this.children.length) return [];
            throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
        }, e.DisplayObjectContainer.prototype.updateTransform = function() {
            if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
                for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
        }, e.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = e.DisplayObjectContainer.prototype.updateTransform, e.DisplayObjectContainer.prototype.getBounds = function(t) {
            var i = t && t instanceof e.DisplayObject,
                o = !0;
            i ? o = t instanceof e.DisplayObjectContainer && t.contains(this) : t = this;
            var s;
            if (i) {
                var n = t.worldTransform;
                for (t.worldTransform = e.identityMatrix, s = 0; s < t.children.length; s++) t.children[s].updateTransform()
            }
            var r, a, h, l = 1 / 0,
                d = 1 / 0,
                c = -1 / 0,
                p = -1 / 0,
                u = !1;
            for (s = 0; s < this.children.length; s++) {
                this.children[s].visible && (u = !0, r = this.children[s].getBounds(), l = l < r.x ? l : r.x, d = d < r.y ? d : r.y, a = r.width + r.x, h = r.height + r.y, c = c > a ? c : a, p = p > h ? p : h)
            }
            var b = this._bounds;
            if (!u) {
                b = new e.Rectangle;
                var m = b.x,
                    y = b.width + b.x,
                    f = b.y,
                    g = b.height + b.y,
                    x = this.worldTransform,
                    _ = x.a,
                    v = x.b,
                    w = x.c,
                    C = x.d,
                    S = x.tx,
                    A = x.ty,
                    T = _ * y + w * g + S,
                    P = C * g + v * y + A,
                    B = _ * m + w * g + S,
                    M = C * g + v * m + A,
                    I = _ * m + w * f + S,
                    R = C * f + v * m + A,
                    D = _ * y + w * f + S,
                    k = C * f + v * y + A;
                c = T, p = P, l = T, d = P, l = B < l ? B : l, l = I < l ? I : l, l = D < l ? D : l, d = M < d ? M : d, d = R < d ? R : d, d = k < d ? k : d, c = B > c ? B : c, c = I > c ? I : c, c = D > c ? D : c, p = M > p ? M : p, p = R > p ? R : p, p = k > p ? k : p
            }
            if (b.x = l, b.y = d, b.width = c - l, b.height = p - d, i)
                for (t.worldTransform = n, s = 0; s < t.children.length; s++) t.children[s].updateTransform();
            if (!o) {
                var V = t.getBounds();
                b.x -= V.x, b.y -= V.y
            }
            return b
        }, e.DisplayObjectContainer.prototype.getLocalBounds = function() {
            return this.getBounds(this)
        }, e.DisplayObjectContainer.prototype.contains = function(t) {
            return !!t && (t === this || this.contains(t.parent))
        }, e.DisplayObjectContainer.prototype._renderWebGL = function(t) {
            if (this.visible && !(this.alpha <= 0)) {
                if (this._cacheAsBitmap) return void this._renderCachedSprite(t);
                var e;
                if (this._mask || this._filters) {
                    for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                    t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
                } else
                    for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
            }
        }, e.DisplayObjectContainer.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha) {
                if (this._cacheAsBitmap) return void this._renderCachedSprite(t);
                this._mask && t.maskManager.pushMask(this._mask, t);
                for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, Object.defineProperty(e.DisplayObjectContainer.prototype, "width", {
            get: function() {
                return this.getLocalBounds().width * this.scale.x
            },
            set: function(t) {
                var e = this.getLocalBounds().width;
                this.scale.x = 0 !== e ? t / e : 1, this._width = t
            }
        }), Object.defineProperty(e.DisplayObjectContainer.prototype, "height", {
            get: function() {
                return this.getLocalBounds().height * this.scale.y
            },
            set: function(t) {
                var e = this.getLocalBounds().height;
                this.scale.y = 0 !== e ? t / e : 1, this._height = t
            }
        }), e.Sprite = function(t) {
            e.DisplayObjectContainer.call(this), this.anchor = new e.Point, this.texture = t || e.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = e.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
        }, e.Sprite.prototype = Object.create(e.DisplayObjectContainer.prototype), e.Sprite.prototype.constructor = e.Sprite, Object.defineProperty(e.Sprite.prototype, "width", {
            get: function() {
                return this.scale.x * this.texture.frame.width
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width, this._width = t
            }
        }), Object.defineProperty(e.Sprite.prototype, "height", {
            get: function() {
                return this.scale.y * this.texture.frame.height
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height, this._height = t
            }
        }), e.Sprite.prototype.setTexture = function(t, e) {
            void 0 !== e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1
        }, e.Sprite.prototype.onTextureUpdate = function() {
            this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
        }, e.Sprite.prototype.getBounds = function(t) {
            var e = this.texture.frame.width,
                i = this.texture.frame.height,
                o = e * (1 - this.anchor.x),
                s = e * -this.anchor.x,
                n = i * (1 - this.anchor.y),
                r = i * -this.anchor.y,
                a = t || this.worldTransform,
                h = a.a,
                l = a.b,
                d = a.c,
                c = a.d,
                p = a.tx,
                u = a.ty,
                b = -1 / 0,
                m = -1 / 0,
                y = 1 / 0,
                f = 1 / 0;
            if (0 === l && 0 === d) {
                if (h < 0) {
                    h *= -1;
                    var g = o;
                    o = -s, s = -g
                }
                if (c < 0) {
                    c *= -1;
                    var g = n;
                    n = -r, r = -g
                }
                y = h * s + p, b = h * o + p, f = c * r + u, m = c * n + u
            } else {
                var x = h * s + d * r + p,
                    _ = c * r + l * s + u,
                    v = h * o + d * r + p,
                    w = c * r + l * o + u,
                    C = h * o + d * n + p,
                    S = c * n + l * o + u,
                    A = h * s + d * n + p,
                    T = c * n + l * s + u;
                y = x < y ? x : y, y = v < y ? v : y, y = C < y ? C : y, y = A < y ? A : y, f = _ < f ? _ : f, f = w < f ? w : f, f = S < f ? S : f, f = T < f ? T : f, b = x > b ? x : b, b = v > b ? v : b, b = C > b ? C : b, b = A > b ? A : b, m = _ > m ? _ : m, m = w > m ? w : m, m = S > m ? S : m, m = T > m ? T : m
            }
            var P = this._bounds;
            return P.x = y, P.width = b - y, P.y = f, P.height = m - f, this._currentBounds = P, P
        }, e.Sprite.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = e.identityMatrix;
            for (var i = 0; i < this.children.length; i++) this.children[i].updateTransform();
            var o = this.getBounds();
            for (this.worldTransform = t, i = 0; i < this.children.length; i++) this.children[i].updateTransform();
            return o
        }, e.Sprite.prototype._renderWebGL = function(t, e) {
            if (this.visible && !(this.alpha <= 0) && this.renderable) {
                var i = this.worldTransform;
                if (e && (i = e), this._mask || this._filters) {
                    var o = t.spriteBatch;
                    this._filters && (o.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (o.stop(), t.maskManager.pushMask(this.mask, t), o.start()), o.render(this);
                    for (var s = 0; s < this.children.length; s++) this.children[s]._renderWebGL(t);
                    o.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), o.start()
                } else {
                    t.spriteBatch.render(this);
                    for (var s = 0; s < this.children.length; s++) this.children[s]._renderWebGL(t, i)
                }
            }
        }, e.Sprite.prototype._renderCanvas = function(t, i) {
            if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
                var o = this.worldTransform;
                if (i && (o = i), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = e.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                    var s = this.texture.baseTexture.resolution / t.resolution;
                    t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === e.scaleModes.LINEAR);
                    var n = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                        r = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                        a = o.tx * t.resolution + t.shakeX,
                        h = o.ty * t.resolution + t.shakeY;
                    t.roundPixels ? (t.context.setTransform(o.a, o.b, o.c, o.d, 0 | a, 0 | h), n |= 0, r |= 0) : t.context.setTransform(o.a, o.b, o.c, o.d, a, h);
                    var l = this.texture.crop.width,
                        d = this.texture.crop.height;
                    if (n /= s, r /= s, 16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = e.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, l, d, n, r, l / s, d / s);
                    else {
                        var c = this.texture.crop.x,
                            p = this.texture.crop.y;
                        t.context.drawImage(this.texture.baseTexture.source, c, p, l, d, n, r, l / s, d / s)
                    }
                }
                for (var u = 0; u < this.children.length; u++) this.children[u]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, e.SpriteBatch = function(t) {
            e.DisplayObjectContainer.call(this), this.textureThing = t, this.ready = !1
        }, e.SpriteBatch.prototype = Object.create(e.DisplayObjectContainer.prototype), e.SpriteBatch.prototype.constructor = e.SpriteBatch, e.SpriteBatch.prototype.initWebGL = function(t) {
            this.fastSpriteBatch = new e.WebGLFastSpriteBatch(t), this.ready = !0
        }, e.SpriteBatch.prototype.updateTransform = function() {
            this.displayObjectUpdateTransform()
        }, e.SpriteBatch.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(t.gl), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start())
        }, e.SpriteBatch.prototype._renderCanvas = function(t) {
            if (this.visible && !(this.alpha <= 0) && this.children.length) {
                var e = t.context;
                e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
                for (var i = this.worldTransform, o = !0, s = 0; s < this.children.length; s++) {
                    var n = this.children[s];
                    if (n.visible) {
                        var r = n.texture,
                            a = r.frame;
                        if (e.globalAlpha = this.worldAlpha * n.alpha, n.rotation % (2 * Math.PI) == 0) o && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), o = !1), e.drawImage(r.baseTexture.source, a.x, a.y, a.width, a.height, n.anchor.x * (-a.width * n.scale.x) + n.position.x + .5 + t.shakeX | 0, n.anchor.y * (-a.height * n.scale.y) + n.position.y + .5 + t.shakeY | 0, a.width * n.scale.x, a.height * n.scale.y);
                        else {
                            o || (o = !0), n.displayObjectUpdateTransform();
                            var h = n.worldTransform,
                                l = h.tx * t.resolution + t.shakeX,
                                d = h.ty * t.resolution + t.shakeY;
                            t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | d) : e.setTransform(h.a, h.b, h.c, h.d, l, d), e.drawImage(r.baseTexture.source, a.x, a.y, a.width, a.height, n.anchor.x * -a.width + .5 | 0, n.anchor.y * -a.height + .5 | 0, a.width, a.height)
                        }
                    }
                }
            }
        }, e.hex2rgb = function(t) {
            return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
        }, e.rgb2hex = function(t) {
            return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
        }, e.canUseNewCanvasBlendModes = function() {
            if (void 0 === document) return !1;
            var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
                i = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
                o = new Image;
            o.src = t + "AP804Oa6" + i;
            var s = new Image;
            s.src = t + "/wCKxvRF" + i;
            var n = e.CanvasPool.create(this, 6, 1),
                r = n.getContext("2d");
            if (r.globalCompositeOperation = "multiply", r.drawImage(o, 0, 0), r.drawImage(s, 2, 0), !r.getImageData(2, 0, 1, 1)) return !1;
            var a = r.getImageData(2, 0, 1, 1).data;
            return e.CanvasPool.remove(this), 255 === a[0] && 0 === a[1] && 0 === a[2]
        }, e.getNextPowerOfTwo = function(t) {
            if (t > 0 && 0 == (t & t - 1)) return t;
            for (var e = 1; e < t;) e <<= 1;
            return e
        }, e.isPowerOfTwo = function(t, e) {
            return t > 0 && 0 == (t & t - 1) && e > 0 && 0 == (e & e - 1)
        }, e.CanvasPool = {
            create: function(t, i, o) {
                var s, n = e.CanvasPool.getFirst();
                if (-1 === n) {
                    var r = {
                        parent: t,
                        canvas: document.createElement("canvas")
                    };
                    e.CanvasPool.pool.push(r), s = r.canvas
                } else e.CanvasPool.pool[n].parent = t, s = e.CanvasPool.pool[n].canvas;
                return void 0 !== i && (s.width = i, s.height = o), s
            },
            getFirst: function() {
                for (var t = e.CanvasPool.pool, i = 0; i < t.length; i++)
                    if (!t[i].parent) return i;
                return -1
            },
            remove: function(t) {
                for (var i = e.CanvasPool.pool, o = 0; o < i.length; o++) i[o].parent === t && (i[o].parent = null, i[o].canvas.width = 1, i[o].canvas.height = 1)
            },
            removeByCanvas: function(t) {
                for (var i = e.CanvasPool.pool, o = 0; o < i.length; o++) i[o].canvas === t && (i[o].parent = null, i[o].canvas.width = 1, i[o].canvas.height = 1)
            },
            getTotal: function() {
                for (var t = e.CanvasPool.pool, i = 0, o = 0; o < t.length; o++) t[o].parent && i++;
                return i
            },
            getFree: function() {
                for (var t = e.CanvasPool.pool, i = 0, o = 0; o < t.length; o++) t[o].parent || i++;
                return i
            }
        }, e.CanvasPool.pool = [], e.initDefaultShaders = function() {}, e.CompileVertexShader = function(t, i) {
            return e._CompileShader(t, i, t.VERTEX_SHADER)
        }, e.CompileFragmentShader = function(t, i) {
            return e._CompileShader(t, i, t.FRAGMENT_SHADER)
        }, e._CompileShader = function(t, e, i) {
            var o = e;
            Array.isArray(e) && (o = e.join("\n"));
            var s = t.createShader(i);
            return t.shaderSource(s, o), t.compileShader(s), t.getShaderParameter(s, t.COMPILE_STATUS) ? s : (window.console.log(t.getShaderInfoLog(s)), null)
        }, e.compileProgram = function(t, i, o) {
            var s = e.CompileFragmentShader(t, o),
                n = e.CompileVertexShader(t, i),
                r = t.createProgram();
            return t.attachShader(r, n), t.attachShader(r, s), t.linkProgram(r), t.getProgramParameter(r, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(r)), window.console.log("Could not initialise shaders")), r
        }, e.PixiShader = function(t) {
            this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init()
        }, e.PixiShader.prototype.constructor = e.PixiShader, e.PixiShader.prototype.init = function() {
            var t = this.gl,
                i = e.compileProgram(t, this.vertexSrc || e.PixiShader.defaultVertexSrc, this.fragmentSrc);
            t.useProgram(i), this.uSampler = t.getUniformLocation(i, "uSampler"), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.dimensions = t.getUniformLocation(i, "dimensions"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(i, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(i, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];
            for (var o in this.uniforms) this.uniforms[o].uniformLocation = t.getUniformLocation(i, o);
            this.initUniforms(), this.program = i
        }, e.PixiShader.prototype.initUniforms = function() {
            this.textureCount = 1;
            var t, e = this.gl;
            for (var i in this.uniforms) {
                t = this.uniforms[i];
                var o = t.type;
                "sampler2D" === o ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === o || "mat3" === o || "mat4" === o ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === o ? t.glFunc = e.uniformMatrix2fv : "mat3" === o ? t.glFunc = e.uniformMatrix3fv : "mat4" === o && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + o], t.glValueLength = "2f" === o || "2i" === o ? 2 : "3f" === o || "3i" === o ? 3 : "4f" === o || "4i" === o ? 4 : 1)
            }
        }, e.PixiShader.prototype.initSampler2D = function(t) {
            if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
                var e = this.gl;
                if (e.activeTexture(e["TEXTURE" + this.textureCount]), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                    var i = t.textureData,
                        o = i.magFilter ? i.magFilter : e.LINEAR,
                        s = i.minFilter ? i.minFilter : e.LINEAR,
                        n = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                        r = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE,
                        a = i.luminance ? e.LUMINANCE : e.RGBA;
                    if (i.repeat && (n = e.REPEAT, r = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                        var h = i.width ? i.width : 512,
                            l = i.height ? i.height : 2,
                            d = i.border ? i.border : 0;
                        e.texImage2D(e.TEXTURE_2D, 0, a, h, l, d, a, e.UNSIGNED_BYTE, null)
                    } else e.texImage2D(e.TEXTURE_2D, 0, a, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, o), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, r)
                }
                e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++
            }
        }, e.PixiShader.prototype.syncUniforms = function() {
            this.textureCount = 1;
            var t, i = this.gl;
            for (var o in this.uniforms) t = this.uniforms[o], 1 === t.glValueLength ? !0 === t.glMatrix ? t.glFunc.call(i, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(i, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (i.activeTexture(i["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[i.id] ? e.instances[i.id].updateTexture(t.value.baseTexture) : i.bindTexture(i.TEXTURE_2D, t.value.baseTexture._glTextures[i.id]), i.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
        }, e.PixiShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, e.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"], e.PixiFastShader = function(t) {
            this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
        }, e.PixiFastShader.prototype.constructor = e.PixiFastShader, e.PixiFastShader.prototype.init = function() {
            var t = this.gl,
                i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(i), this.uSampler = t.getUniformLocation(i, "uSampler"), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.dimensions = t.getUniformLocation(i, "dimensions"), this.uMatrix = t.getUniformLocation(i, "uMatrix"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(i, "aPositionCoord"), this.aScale = t.getAttribLocation(i, "aScale"), this.aRotation = t.getAttribLocation(i, "aRotation"), this.aTextureCoord = t.getAttribLocation(i, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(i, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute], this.program = i
        }, e.PixiFastShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, e.StripShader = function(t) {
            this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], this.init()
        }, e.StripShader.prototype.constructor = e.StripShader, e.StripShader.prototype.init = function() {
            var t = this.gl,
                i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(i), this.uSampler = t.getUniformLocation(i, "uSampler"), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.colorAttribute = t.getAttribLocation(i, "aColor"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(i, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord], this.translationMatrix = t.getUniformLocation(i, "translationMatrix"), this.alpha = t.getUniformLocation(i, "alpha"), this.program = i
        }, e.StripShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
        }, e.PrimitiveShader = function(t) {
            this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
        }, e.PrimitiveShader.prototype.constructor = e.PrimitiveShader, e.PrimitiveShader.prototype.init = function() {
            var t = this.gl,
                i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(i), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.tintColor = t.getUniformLocation(i, "tint"), this.flipY = t.getUniformLocation(i, "flipY"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(i, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(i, "translationMatrix"), this.alpha = t.getUniformLocation(i, "alpha"), this.program = i
        }, e.PrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, e.ComplexPrimitiveShader = function(t) {
            this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
        }, e.ComplexPrimitiveShader.prototype.constructor = e.ComplexPrimitiveShader, e.ComplexPrimitiveShader.prototype.init = function() {
            var t = this.gl,
                i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(i), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.tintColor = t.getUniformLocation(i, "tint"), this.color = t.getUniformLocation(i, "color"), this.flipY = t.getUniformLocation(i, "flipY"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(i, "translationMatrix"), this.alpha = t.getUniformLocation(i, "alpha"), this.program = i
        }, e.ComplexPrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
        }, e.glContexts = [], e.instances = [], e.WebGLRenderer = function(t) {
            this.game = t, e.defaultRenderer || (e.defaultRenderer = this), this.type = e.WEBGL_RENDERER, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = {
                alpha: this.transparent,
                antialias: t.antialias,
                premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
                stencil: !0,
                preserveDrawingBuffer: this.preserveDrawingBuffer
            }, this.projection = new e.Point, this.offset = new e.Point, this.shaderManager = new e.WebGLShaderManager, this.spriteBatch = new e.WebGLSpriteBatch, this.maskManager = new e.WebGLMaskManager, this.filterManager = new e.WebGLFilterManager, this.stencilManager = new e.WebGLStencilManager, this.blendModeManager = new e.WebGLBlendModeManager, this.renderSession = {}, this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, this.renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes()
        }, e.WebGLRenderer.prototype.constructor = e.WebGLRenderer, e.WebGLRenderer.prototype.initContext = function() {
            var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
            if (this.gl = t, !t) throw new Error("This browser does not support webGL. Try using the canvas renderer");
            this.glContextId = t.id = e.WebGLRenderer.glContextId++, e.glContexts[this.glContextId] = t, e.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height)
        }, e.WebGLRenderer.prototype.render = function(t) {
            if (!this.contextLost) {
                var e = this.gl;
                e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection)
            }
        }, e.WebGLRenderer.prototype.renderDisplayObject = function(t, i, o, s) {
            this.renderSession.blendModeManager.setBlendMode(e.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = o ? -1 : 1, this.renderSession.projection = i, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, o), t._renderWebGL(this.renderSession, s), this.spriteBatch.end()
        }, e.WebGLRenderer.prototype.resize = function(t, e) {
            this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution
        }, e.WebGLRenderer.prototype.updateTexture = function(t) {
            if (!t.hasLoaded) return !1;
            var i = this.gl;
            return t._glTextures[i.id] || (t._glTextures[i.id] = i.createTexture()), i.bindTexture(i.TEXTURE_2D, t._glTextures[i.id]), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, t.source), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, t.scaleMode === e.scaleModes.LINEAR ? i.LINEAR : i.NEAREST), t.mipmap && e.isPowerOfTwo(t.width, t.height) ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, t.scaleMode === e.scaleModes.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST), i.generateMipmap(i.TEXTURE_2D)) : i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, t.scaleMode === e.scaleModes.LINEAR ? i.LINEAR : i.NEAREST), t._powerOf2 ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE)), t._dirty[i.id] = !1, !0
        }, e.WebGLRenderer.prototype.destroy = function() {
            e.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, e.CanvasPool.remove(this), e.instances[this.glContextId] = null, e.WebGLRenderer.glContextId--
        }, e.WebGLRenderer.prototype.mapBlendModes = function() {
            var t = this.gl;
            if (!e.blendModesWebGL) {
                var i = [],
                    o = e.blendModes;
                i[o.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.ADD] = [t.SRC_ALPHA, t.DST_ALPHA], i[o.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], i[o.SCREEN] = [t.SRC_ALPHA, t.ONE], i[o.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e.blendModesWebGL = i
            }
        }, e.WebGLRenderer.glContextId = 0, e.WebGLBlendModeManager = function() {
            this.currentBlendMode = 99999
        }, e.WebGLBlendModeManager.prototype.constructor = e.WebGLBlendModeManager, e.WebGLBlendModeManager.prototype.setContext = function(t) {
            this.gl = t
        }, e.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
            if (this.currentBlendMode === t) return !1;
            this.currentBlendMode = t;
            var i = e.blendModesWebGL[this.currentBlendMode];
            return i && this.gl.blendFunc(i[0], i[1]), !0
        }, e.WebGLBlendModeManager.prototype.destroy = function() {
            this.gl = null
        }, e.WebGLMaskManager = function() {}, e.WebGLMaskManager.prototype.constructor = e.WebGLMaskManager, e.WebGLMaskManager.prototype.setContext = function(t) {
            this.gl = t
        }, e.WebGLMaskManager.prototype.pushMask = function(t, i) {
            var o = i.gl;
            t.dirty && e.WebGLGraphics.updateGraphics(t, o), void 0 !== t._webGL[o.id] && void 0 !== t._webGL[o.id].data && 0 !== t._webGL[o.id].data.length && i.stencilManager.pushStencil(t, t._webGL[o.id].data[0], i)
        }, e.WebGLMaskManager.prototype.popMask = function(t, e) {
            var i = this.gl;
            void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
        }, e.WebGLMaskManager.prototype.destroy = function() {
            this.gl = null
        }, e.WebGLStencilManager = function() {
            this.stencilStack = [], this.reverse = !0, this.count = 0
        }, e.WebGLStencilManager.prototype.setContext = function(t) {
            this.gl = t
        }, e.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
            var o = this.gl;
            this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (o.enable(o.STENCIL_TEST), o.clear(o.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
            var s = this.count;
            o.colorMask(!1, !1, !1, !1), o.stencilFunc(o.ALWAYS, 0, 255), o.stencilOp(o.KEEP, o.KEEP, o.INVERT), 1 === e.mode ? (o.drawElements(o.TRIANGLE_FAN, e.indices.length - 4, o.UNSIGNED_SHORT, 0), this.reverse ? (o.stencilFunc(o.EQUAL, 255 - s, 255), o.stencilOp(o.KEEP, o.KEEP, o.DECR)) : (o.stencilFunc(o.EQUAL, s, 255), o.stencilOp(o.KEEP, o.KEEP, o.INCR)), o.drawElements(o.TRIANGLE_FAN, 4, o.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? o.stencilFunc(o.EQUAL, 255 - (s + 1), 255) : o.stencilFunc(o.EQUAL, s + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (o.stencilFunc(o.EQUAL, s, 255), o.stencilOp(o.KEEP, o.KEEP, o.INCR)) : (o.stencilFunc(o.EQUAL, 255 - s, 255), o.stencilOp(o.KEEP, o.KEEP, o.DECR)), o.drawElements(o.TRIANGLE_STRIP, e.indices.length, o.UNSIGNED_SHORT, 0), this.reverse ? o.stencilFunc(o.EQUAL, s + 1, 255) : o.stencilFunc(o.EQUAL, 255 - (s + 1), 255)), o.colorMask(!0, !0, !0, !0), o.stencilOp(o.KEEP, o.KEEP, o.KEEP), this.count++
        }, e.WebGLStencilManager.prototype.bindGraphics = function(t, i, o) {
            this._currentGraphics = t;
            var s, n = this.gl,
                r = o.projection,
                a = o.offset;
            1 === i.mode ? (s = o.shaderManager.complexPrimitiveShader, o.shaderManager.setShader(s), n.uniform1f(s.flipY, o.flipY), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -a.x, -a.y), n.uniform3fv(s.tintColor, e.hex2rgb(t.tint)), n.uniform3fv(s.color, i.color), n.uniform1f(s.alpha, t.worldAlpha * i.alpha), n.bindBuffer(n.ARRAY_BUFFER, i.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 8, 0), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, i.indexBuffer)) : (s = o.shaderManager.primitiveShader, o.shaderManager.setShader(s), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(s.flipY, o.flipY), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -a.x, -a.y), n.uniform3fv(s.tintColor, e.hex2rgb(t.tint)), n.uniform1f(s.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, i.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(s.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, i.indexBuffer))
        }, e.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
            var o = this.gl;
            if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) o.disable(o.STENCIL_TEST);
            else {
                var s = this.count;
                this.bindGraphics(t, e, i), o.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (o.stencilFunc(o.EQUAL, 255 - (s + 1), 255), o.stencilOp(o.KEEP, o.KEEP, o.INCR)) : (o.stencilFunc(o.EQUAL, s + 1, 255), o.stencilOp(o.KEEP, o.KEEP, o.DECR)), o.drawElements(o.TRIANGLE_FAN, 4, o.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), o.stencilFunc(o.ALWAYS, 0, 255), o.stencilOp(o.KEEP, o.KEEP, o.INVERT), o.drawElements(o.TRIANGLE_FAN, e.indices.length - 4, o.UNSIGNED_SHORT, 0), this.reverse ? o.stencilFunc(o.EQUAL, s, 255) : o.stencilFunc(o.EQUAL, 255 - s, 255)) : (this.reverse ? (o.stencilFunc(o.EQUAL, s + 1, 255), o.stencilOp(o.KEEP, o.KEEP, o.DECR)) : (o.stencilFunc(o.EQUAL, 255 - (s + 1), 255), o.stencilOp(o.KEEP, o.KEEP, o.INCR)), o.drawElements(o.TRIANGLE_STRIP, e.indices.length, o.UNSIGNED_SHORT, 0), this.reverse ? o.stencilFunc(o.EQUAL, s, 255) : o.stencilFunc(o.EQUAL, 255 - s, 255)), o.colorMask(!0, !0, !0, !0), o.stencilOp(o.KEEP, o.KEEP, o.KEEP)
            }
        }, e.WebGLStencilManager.prototype.destroy = function() {
            this.stencilStack = null, this.gl = null
        }, e.WebGLShaderManager = function() {
            this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
            for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
            this.stack = []
        }, e.WebGLShaderManager.prototype.constructor = e.WebGLShaderManager, e.WebGLShaderManager.prototype.setContext = function(t) {
            this.gl = t, this.primitiveShader = new e.PrimitiveShader(t), this.complexPrimitiveShader = new e.ComplexPrimitiveShader(t), this.defaultShader = new e.PixiShader(t), this.fastShader = new e.PixiFastShader(t), this.stripShader = new e.StripShader(t), this.setShader(this.defaultShader)
        }, e.WebGLShaderManager.prototype.setAttribs = function(t) {
            var e;
            for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
            for (e = 0; e < t.length; e++) {
                var i = t[e];
                this.tempAttribState[i] = !0
            }
            var o = this.gl;
            for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? o.enableVertexAttribArray(e) : o.disableVertexAttribArray(e))
        }, e.WebGLShaderManager.prototype.setShader = function(t) {
            return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
        }, e.WebGLShaderManager.prototype.destroy = function() {
            this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.gl = null
        }, e.WebGLSpriteBatch = function() {
            this.vertSize = 5, this.size = 2e3;
            var t = 4 * this.size * 4 * this.vertSize,
                i = 6 * this.size;
            this.vertices = new e.ArrayBuffer(t), this.positions = new e.Float32Array(this.vertices), this.colors = new e.Uint32Array(this.vertices), this.indices = new e.Uint16Array(i), this.lastIndexCount = 0;
            for (var o = 0, s = 0; o < i; o += 6, s += 4) this.indices[o + 0] = s + 0, this.indices[o + 1] = s + 1, this.indices[o + 2] = s + 2, this.indices[o + 3] = s + 0, this.indices[o + 4] = s + 2, this.indices[o + 5] = s + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = new e.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"])
        }, e.WebGLSpriteBatch.prototype.setContext = function(t) {
            this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999;
            var i = new e.PixiShader(t);
            i.fragmentSrc = this.defaultShader.fragmentSrc, i.uniforms = {}, i.init(), this.defaultShader.shaders[t.id] = i
        }, e.WebGLSpriteBatch.prototype.begin = function(t) {
            this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
        }, e.WebGLSpriteBatch.prototype.end = function() {
            this.flush()
        }, e.WebGLSpriteBatch.prototype.render = function(t, e) {
            var i = t.texture,
                o = t.worldTransform;
            e && (o = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture);
            var s = i._uvs;
            if (s) {
                var n, r, a, h, l = t.anchor.x,
                    d = t.anchor.y;
                if (i.trim) {
                    var c = i.trim;
                    r = c.x - l * c.width, n = r + i.crop.width, h = c.y - d * c.height, a = h + i.crop.height
                } else n = i.frame.width * (1 - l), r = i.frame.width * -l, a = i.frame.height * (1 - d), h = i.frame.height * -d;
                var p = 4 * this.currentBatchSize * this.vertSize,
                    u = i.baseTexture.resolution,
                    b = o.a / u,
                    m = o.b / u,
                    y = o.c / u,
                    f = o.d / u,
                    g = o.tx,
                    x = o.ty,
                    _ = this.colors,
                    v = this.positions;
                this.renderSession.roundPixels ? (v[p] = b * r + y * h + g | 0, v[p + 1] = f * h + m * r + x | 0, v[p + 5] = b * n + y * h + g | 0, v[p + 6] = f * h + m * n + x | 0, v[p + 10] = b * n + y * a + g | 0, v[p + 11] = f * a + m * n + x | 0, v[p + 15] = b * r + y * a + g | 0, v[p + 16] = f * a + m * r + x | 0) : (v[p] = b * r + y * h + g, v[p + 1] = f * h + m * r + x, v[p + 5] = b * n + y * h + g, v[p + 6] = f * h + m * n + x, v[p + 10] = b * n + y * a + g, v[p + 11] = f * a + m * n + x, v[p + 15] = b * r + y * a + g, v[p + 16] = f * a + m * r + x), v[p + 2] = s.x0, v[p + 3] = s.y0, v[p + 7] = s.x1, v[p + 8] = s.y1, v[p + 12] = s.x2, v[p + 13] = s.y2, v[p + 17] = s.x3, v[p + 18] = s.y3;
                var w = t.tint;
                _[p + 4] = _[p + 9] = _[p + 14] = _[p + 19] = (w >> 16) + (65280 & w) + ((255 & w) << 16) + (255 * t.worldAlpha << 24), this.sprites[this.currentBatchSize++] = t
            }
        }, e.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
            var i = t.tilingTexture;
            this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture), t._uvs || (t._uvs = new e.TextureUvs);
            var o = t._uvs,
                s = i.baseTexture.width,
                n = i.baseTexture.height;
            t.tilePosition.x %= s * t.tileScaleOffset.x, t.tilePosition.y %= n * t.tileScaleOffset.y;
            var r = t.tilePosition.x / (s * t.tileScaleOffset.x),
                a = t.tilePosition.y / (n * t.tileScaleOffset.y),
                h = t.width / s / (t.tileScale.x * t.tileScaleOffset.x),
                l = t.height / n / (t.tileScale.y * t.tileScaleOffset.y);
            o.x0 = 0 - r, o.y0 = 0 - a, o.x1 = 1 * h - r, o.y1 = 0 - a, o.x2 = 1 * h - r, o.y2 = 1 * l - a, o.x3 = 0 - r, o.y3 = 1 * l - a;
            var d = t.tint,
                c = (d >> 16) + (65280 & d) + ((255 & d) << 16) + (255 * t.worldAlpha << 24),
                p = this.positions,
                u = this.colors,
                b = t.width,
                m = t.height,
                y = t.anchor.x,
                f = t.anchor.y,
                g = b * (1 - y),
                x = b * -y,
                _ = m * (1 - f),
                v = m * -f,
                w = 4 * this.currentBatchSize * this.vertSize,
                C = i.baseTexture.resolution,
                S = t.worldTransform,
                A = S.a / C,
                T = S.b / C,
                P = S.c / C,
                B = S.d / C,
                M = S.tx,
                I = S.ty;
            p[w++] = A * x + P * v + M, p[w++] = B * v + T * x + I, p[w++] = o.x0, p[w++] = o.y0, u[w++] = c, p[w++] = A * g + P * v + M, p[w++] = B * v + T * g + I, p[w++] = o.x1, p[w++] = o.y1, u[w++] = c, p[w++] = A * g + P * _ + M, p[w++] = B * _ + T * g + I, p[w++] = o.x2, p[w++] = o.y2, u[w++] = c, p[w++] = A * x + P * _ + M, p[w++] = B * _ + T * x + I, p[w++] = o.x3, p[w++] = o.y3, u[w++] = c, this.sprites[this.currentBatchSize++] = t
        }, e.WebGLSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var t, i = this.gl;
                if (this.dirty) {
                    this.dirty = !1, i.activeTexture(i.TEXTURE0), i.bindBuffer(i.ARRAY_BUFFER, this.vertexBuffer), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t = this.defaultShader.shaders[i.id];
                    var o = 4 * this.vertSize;
                    i.vertexAttribPointer(t.aVertexPosition, 2, i.FLOAT, !1, o, 0), i.vertexAttribPointer(t.aTextureCoord, 2, i.FLOAT, !1, o, 8), i.vertexAttribPointer(t.colorAttribute, 4, i.UNSIGNED_BYTE, !0, o, 16)
                }
                if (this.currentBatchSize > .5 * this.size) i.bufferSubData(i.ARRAY_BUFFER, 0, this.vertices);
                else {
                    var s = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                    i.bufferSubData(i.ARRAY_BUFFER, 0, s)
                }
                for (var n, r, a, h, l = 0, d = 0, c = null, p = this.renderSession.blendModeManager.currentBlendMode, u = null, b = !1, m = !1, y = 0, f = this.currentBatchSize; y < f; y++) {
                    h = this.sprites[y], n = h.tilingTexture ? h.tilingTexture.baseTexture : h.texture.baseTexture, r = h.blendMode, a = h.shader || this.defaultShader, b = p !== r, m = u !== a;
                    var g = n.skipRender;
                    if (g && h.children.length > 0 && (g = !1), (c !== n && !g || b || m) && (this.renderBatch(c, l, d), d = y, l = 0, c = n, b && (p = r, this.renderSession.blendModeManager.setBlendMode(p)), m)) {
                        u = a, t = u.shaders[i.id], t || (t = new e.PixiShader(i), t.fragmentSrc = u.fragmentSrc, t.uniforms = u.uniforms, t.init(), u.shaders[i.id] = t), this.renderSession.shaderManager.setShader(t), t.dirty && t.syncUniforms();
                        var x = this.renderSession.projection;
                        i.uniform2f(t.projectionVector, x.x, x.y);
                        var _ = this.renderSession.offset;
                        i.uniform2f(t.offsetVector, _.x, _.y)
                    }
                    l++
                }
                this.renderBatch(c, l, d), this.currentBatchSize = 0
            }
        }, e.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
            if (0 !== e) {
                var o = this.gl;
                if (t._dirty[o.id]) {
                    if (!this.renderSession.renderer.updateTexture(t)) return
                } else o.bindTexture(o.TEXTURE_2D, t._glTextures[o.id]);
                o.drawElements(o.TRIANGLES, 6 * e, o.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
            }
        }, e.WebGLSpriteBatch.prototype.stop = function() {
            this.flush(), this.dirty = !0
        }, e.WebGLSpriteBatch.prototype.start = function() {
            this.dirty = !0
        }, e.WebGLSpriteBatch.prototype.destroy = function() {
            this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
        }, e.WebGLFastSpriteBatch = function(t) {
            this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
            var i = 4 * this.size * this.vertSize,
                o = 6 * this.maxSize;
            this.vertices = new e.Float32Array(i), this.indices = new e.Uint16Array(o), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
            for (var s = 0, n = 0; s < o; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
        }, e.WebGLFastSpriteBatch.prototype.constructor = e.WebGLFastSpriteBatch, e.WebGLFastSpriteBatch.prototype.setContext = function(t) {
            this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
        }, e.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
            this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start()
        }, e.WebGLFastSpriteBatch.prototype.end = function() {
            this.flush()
        }, e.WebGLFastSpriteBatch.prototype.render = function(t) {
            var e = t.children,
                i = e[0];
            if (i.texture._uvs) {
                this.currentBaseTexture = i.texture.baseTexture, i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(i.blendMode));
                for (var o = 0, s = e.length; o < s; o++) this.renderSprite(e[o]);
                this.flush()
            }
        }, e.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
            if (t.visible && (t.texture.baseTexture === this.currentBaseTexture || t.texture.baseTexture.skipRender || (this.flush(), this.currentBaseTexture = t.texture.baseTexture, t.texture._uvs))) {
                var e, i, o, s, n, r, a = this.vertices;
                if (e = t.texture._uvs, t.texture.frame.width, t.texture.frame.height, t.texture.trim) {
                    var h = t.texture.trim;
                    o = h.x - t.anchor.x * h.width, i = o + t.texture.crop.width, n = h.y - t.anchor.y * h.height, s = n + t.texture.crop.height
                } else i = t.texture.frame.width * (1 - t.anchor.x), o = t.texture.frame.width * -t.anchor.x, s = t.texture.frame.height * (1 - t.anchor.y), n = t.texture.frame.height * -t.anchor.y;
                r = 4 * this.currentBatchSize * this.vertSize, a[r++] = o, a[r++] = n, a[r++] = t.position.x,
                    a[r++] = t.position.y, a[r++] = t.scale.x, a[r++] = t.scale.y, a[r++] = t.rotation, a[r++] = e.x0, a[r++] = e.y1, a[r++] = t.alpha, a[r++] = i, a[r++] = n, a[r++] = t.position.x, a[r++] = t.position.y, a[r++] = t.scale.x, a[r++] = t.scale.y, a[r++] = t.rotation, a[r++] = e.x1, a[r++] = e.y1, a[r++] = t.alpha, a[r++] = i, a[r++] = s, a[r++] = t.position.x, a[r++] = t.position.y, a[r++] = t.scale.x, a[r++] = t.scale.y, a[r++] = t.rotation, a[r++] = e.x2, a[r++] = e.y2, a[r++] = t.alpha, a[r++] = o, a[r++] = s, a[r++] = t.position.x, a[r++] = t.position.y, a[r++] = t.scale.x, a[r++] = t.scale.y, a[r++] = t.rotation, a[r++] = e.x3, a[r++] = e.y3, a[r++] = t.alpha, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush()
            }
        }, e.WebGLFastSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var t = this.gl;
                if (this.currentBaseTexture._glTextures[t.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, t), t.bindTexture(t.TEXTURE_2D, this.currentBaseTexture._glTextures[t.id]), this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
                else {
                    var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                    t.bufferSubData(t.ARRAY_BUFFER, 0, e)
                }
                t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
            }
        }, e.WebGLFastSpriteBatch.prototype.stop = function() {
            this.flush()
        }, e.WebGLFastSpriteBatch.prototype.start = function() {
            var t = this.gl;
            t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            var e = this.renderSession.projection;
            t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
            var i = 4 * this.vertSize;
            t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36)
        }, e.WebGLFilterManager = function() {
            this.filterStack = [], this.offsetX = 0, this.offsetY = 0
        }, e.WebGLFilterManager.prototype.constructor = e.WebGLFilterManager, e.WebGLFilterManager.prototype.setContext = function(t) {
            this.gl = t, this.texturePool = [], this.initShaderBuffers()
        }, e.WebGLFilterManager.prototype.begin = function(t, e) {
            this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
            var i = this.renderSession.projection;
            this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e
        }, e.WebGLFilterManager.prototype.pushFilter = function(t) {
            var i = this.gl,
                o = this.renderSession.projection,
                s = this.renderSession.offset;
            t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new e.WebGLStencilManager, this.renderSession.stencilManager.setContext(i), i.disable(i.STENCIL_TEST), this.filterStack.push(t);
            var n = t.filterPasses[0];
            this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
            var r = this.texturePool.pop();
            r ? r.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : r = new e.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), i.bindTexture(i.TEXTURE_2D, r.texture);
            var a = t._filterArea,
                h = n.padding;
            a.x -= h, a.y -= h, a.width += 2 * h, a.height += 2 * h, a.x < 0 && (a.x = 0), a.width > this.width && (a.width = this.width), a.y < 0 && (a.y = 0), a.height > this.height && (a.height = this.height), i.bindFramebuffer(i.FRAMEBUFFER, r.frameBuffer), i.viewport(0, 0, a.width * this.renderSession.resolution, a.height * this.renderSession.resolution), o.x = a.width / 2, o.y = -a.height / 2, s.x = -a.x, s.y = -a.y, i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.clear(i.COLOR_BUFFER_BIT), t._glFilterTexture = r
        }, e.WebGLFilterManager.prototype.popFilter = function() {
            var t = this.gl,
                i = this.filterStack.pop(),
                o = i._filterArea,
                s = i._glFilterTexture,
                n = this.renderSession.projection,
                r = this.renderSession.offset;
            if (i.filterPasses.length > 1) {
                t.viewport(0, 0, o.width * this.renderSession.resolution, o.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = o.height, this.vertexArray[2] = o.width, this.vertexArray[3] = o.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = o.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = o.width / this.width, this.uvArray[5] = o.height / this.height, this.uvArray[6] = o.width / this.width, this.uvArray[7] = o.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
                var a = s,
                    h = this.texturePool.pop();
                h || (h = new e.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), h.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
                for (var l = 0; l < i.filterPasses.length - 1; l++) {
                    var d = i.filterPasses[l];
                    t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, a.texture), this.applyFilterPass(d, o, o.width, o.height);
                    var c = a;
                    a = h, h = c
                }
                t.enable(t.BLEND), s = a, this.texturePool.push(h)
            }
            var p = i.filterPasses[i.filterPasses.length - 1];
            this.offsetX -= o.x, this.offsetY -= o.y;
            var u = this.width,
                b = this.height,
                m = 0,
                y = 0,
                f = this.buffer;
            if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
            else {
                var g = this.filterStack[this.filterStack.length - 1];
                o = g._filterArea, u = o.width, b = o.height, m = o.x, y = o.y, f = g._glFilterTexture.frameBuffer
            }
            n.x = u / 2, n.y = -b / 2, r.x = m, r.y = y, o = i._filterArea;
            var x = o.x - m,
                _ = o.y - y;
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = x, this.vertexArray[1] = _ + o.height, this.vertexArray[2] = x + o.width, this.vertexArray[3] = _ + o.height, this.vertexArray[4] = x, this.vertexArray[5] = _, this.vertexArray[6] = x + o.width, this.vertexArray[7] = _, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = o.width / this.width, this.uvArray[5] = o.height / this.height, this.uvArray[6] = o.width / this.width, this.uvArray[7] = o.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, u * this.renderSession.resolution, b * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, f), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, s.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = i._previous_stencil_mgr, i._previous_stencil_mgr = null, this.renderSession.stencilManager.count > 0 ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(p, o, u, b), this.texturePool.push(s), i._glFilterTexture = null
        }, e.WebGLFilterManager.prototype.applyFilterPass = function(t, i, o, s) {
            var n = this.gl,
                r = t.shaders[n.id];
            r || (r = new e.PixiShader(n), r.fragmentSrc = t.fragmentSrc, r.uniforms = t.uniforms, r.init(), t.shaders[n.id] = r), this.renderSession.shaderManager.setShader(r), n.uniform2f(r.projectionVector, o / 2, -s / 2), n.uniform2f(r.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), r.syncUniforms(), n.bindBuffer(n.ARRAY_BUFFER, this.vertexBuffer), n.vertexAttribPointer(r.aVertexPosition, 2, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ARRAY_BUFFER, this.uvBuffer), n.vertexAttribPointer(r.aTextureCoord, 2, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ARRAY_BUFFER, this.colorBuffer), n.vertexAttribPointer(r.colorAttribute, 2, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, this.indexBuffer), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
        }, e.WebGLFilterManager.prototype.initShaderBuffers = function() {
            var t = this.gl;
            this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new e.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new e.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new e.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
        }, e.WebGLFilterManager.prototype.destroy = function() {
            var t = this.gl;
            this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
            for (var e = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
            this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
        }, e.FilterTexture = function(t, i, o, s) {
            this.gl = t, this.frameBuffer = t.createFramebuffer(), this.texture = t.createTexture(), s = s || e.scaleModes.DEFAULT, t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, s === e.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, s === e.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0), this.renderBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this.renderBuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer), this.resize(i, o)
        }, e.FilterTexture.prototype.constructor = e.FilterTexture, e.FilterTexture.prototype.clear = function() {
            var t = this.gl;
            t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
        }, e.FilterTexture.prototype.resize = function(t, e) {
            if (this.width !== t || this.height !== e) {
                this.width = t, this.height = e;
                var i = this.gl;
                i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
            }
        }, e.FilterTexture.prototype.destroy = function() {
            var t = this.gl;
            t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
        }, e.CanvasBuffer = function(t, i) {
            this.width = t, this.height = i, this.canvas = e.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = i
        }, e.CanvasBuffer.prototype.constructor = e.CanvasBuffer, e.CanvasBuffer.prototype.clear = function() {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
        }, e.CanvasBuffer.prototype.resize = function(t, e) {
            this.width = this.canvas.width = t, this.height = this.canvas.height = e
        }, e.CanvasBuffer.prototype.destroy = function() {
            e.CanvasPool.remove(this)
        }, e.CanvasMaskManager = function() {}, e.CanvasMaskManager.prototype.constructor = e.CanvasMaskManager, e.CanvasMaskManager.prototype.pushMask = function(t, i) {
            var o = i.context;
            o.save();
            var s = t.alpha,
                n = t.worldTransform,
                r = i.resolution;
            o.setTransform(n.a * r, n.b * r, n.c * r, n.d * r, n.tx * r, n.ty * r), e.CanvasGraphics.renderGraphicsMask(t, o), o.clip(), t.worldAlpha = s
        }, e.CanvasMaskManager.prototype.popMask = function(t) {
            t.context.restore()
        }, e.CanvasTinter = function() {}, e.CanvasTinter.getTintedTexture = function(t, i) {
            var o = t.tintedTexture || e.CanvasPool.create(this);
            return e.CanvasTinter.tintMethod(t.texture, i, o), o
        }, e.CanvasTinter.tintWithMultiply = function(t, e, i) {
            var o = i.getContext("2d"),
                s = t.crop;
            i.width === s.width && i.height === s.height || (i.width = s.width, i.height = s.height), o.clearRect(0, 0, s.width, s.height), o.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), o.fillRect(0, 0, s.width, s.height), o.globalCompositeOperation = "multiply", o.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height), o.globalCompositeOperation = "destination-atop", o.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height)
        }, e.CanvasTinter.tintWithPerPixel = function(t, i, o) {
            var s = o.getContext("2d"),
                n = t.crop;
            o.width = n.width, o.height = n.height, s.globalCompositeOperation = "copy", s.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height);
            for (var r = e.hex2rgb(i), a = r[0], h = r[1], l = r[2], d = s.getImageData(0, 0, n.width, n.height), c = d.data, p = 0; p < c.length; p += 4)
                if (c[p + 0] *= a, c[p + 1] *= h, c[p + 2] *= l, !e.CanvasTinter.canHandleAlpha) {
                    var u = c[p + 3];
                    c[p + 0] /= 255 / u, c[p + 1] /= 255 / u, c[p + 2] /= 255 / u
                }
            s.putImageData(d, 0, 0)
        }, e.CanvasTinter.checkInverseAlpha = function() {
            var t = new e.CanvasBuffer(2, 1);
            t.context.fillStyle = "rgba(10, 20, 30, 0.5)", t.context.fillRect(0, 0, 1, 1);
            var i = t.context.getImageData(0, 0, 1, 1);
            if (null === i) return !1;
            t.context.putImageData(i, 1, 0);
            var o = t.context.getImageData(1, 0, 1, 1);
            return o.data[0] === i.data[0] && o.data[1] === i.data[1] && o.data[2] === i.data[2] && o.data[3] === i.data[3]
        }, e.CanvasTinter.canHandleAlpha = e.CanvasTinter.checkInverseAlpha(), e.CanvasTinter.canUseMultiply = e.canUseNewCanvasBlendModes(), e.CanvasTinter.tintMethod = e.CanvasTinter.canUseMultiply ? e.CanvasTinter.tintWithMultiply : e.CanvasTinter.tintWithPerPixel, e.CanvasRenderer = function(t) {
            this.game = t, e.defaultRenderer || (e.defaultRenderer = this), this.type = e.CANVAS_RENDERER, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {
                alpha: this.transparent
            }), this.refresh = !0, this.count = 0, this.maskManager = new e.CanvasMaskManager, this.renderSession = {
                context: this.context,
                maskManager: this.maskManager,
                scaleMode: null,
                smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
                roundPixels: !1
            }, this.mapBlendModes(), this.resize(this.width, this.height)
        }, e.CanvasRenderer.prototype.constructor = e.CanvasRenderer, e.CanvasRenderer.prototype.render = function(t) {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t)
        }, e.CanvasRenderer.prototype.destroy = function(t) {
            void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
        }, e.CanvasRenderer.prototype.resize = function(t, i) {
            this.width = t * this.resolution, this.height = i * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === e.scaleModes.LINEAR)
        }, e.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
            this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i)
        }, e.CanvasRenderer.prototype.mapBlendModes = function() {
            if (!e.blendModesCanvas) {
                var t = [],
                    i = e.blendModes,
                    o = e.canUseNewCanvasBlendModes();
                t[i.NORMAL] = "source-over", t[i.ADD] = "lighter", t[i.MULTIPLY] = o ? "multiply" : "source-over", t[i.SCREEN] = o ? "screen" : "source-over", t[i.OVERLAY] = o ? "overlay" : "source-over", t[i.DARKEN] = o ? "darken" : "source-over", t[i.LIGHTEN] = o ? "lighten" : "source-over", t[i.COLOR_DODGE] = o ? "color-dodge" : "source-over", t[i.COLOR_BURN] = o ? "color-burn" : "source-over", t[i.HARD_LIGHT] = o ? "hard-light" : "source-over", t[i.SOFT_LIGHT] = o ? "soft-light" : "source-over", t[i.DIFFERENCE] = o ? "difference" : "source-over", t[i.EXCLUSION] = o ? "exclusion" : "source-over", t[i.HUE] = o ? "hue" : "source-over", t[i.SATURATION] = o ? "saturation" : "source-over", t[i.COLOR] = o ? "color" : "source-over", t[i.LUMINOSITY] = o ? "luminosity" : "source-over", e.blendModesCanvas = t
            }
        }, e.BaseTexture = function(t, i) {
            this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = i || e.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
        }, e.BaseTexture.prototype.constructor = e.BaseTexture, e.BaseTexture.prototype.forceLoaded = function(t, e) {
            this.hasLoaded = !0, this.width = t, this.height = e, this.dirty()
        }, e.BaseTexture.prototype.destroy = function() {
            this.source && e.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
        }, e.BaseTexture.prototype.updateSourceImage = function(t) {
            console.warn("PIXI.BaseTexture.updateSourceImage is deprecated. Use Phaser.Sprite.loadTexture instead.")
        }, e.BaseTexture.prototype.dirty = function() {
            for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0
        }, e.BaseTexture.prototype.unloadFromGPU = function() {
            this.dirty();
            for (var t = this._glTextures.length - 1; t >= 0; t--) {
                var i = this._glTextures[t],
                    o = e.glContexts[t];
                o && i && o.deleteTexture(i)
            }
            this._glTextures.length = 0, this.dirty()
        }, e.BaseTexture.fromCanvas = function(t, i) {
            return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), new e.BaseTexture(t, i)
        }, e.TextureSilentFail = !1, e.Texture = function(t, i, o, s) {
            this.noFrame = !1, i || (this.noFrame = !0, i = new e.Rectangle(0, 0, 1, 1)), t instanceof e.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = i, this.trim = s, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = o || new e.Rectangle(0, 0, 1, 1), t.hasLoaded && (this.noFrame && (i = new e.Rectangle(0, 0, t.width, t.height)), this.setFrame(i))
        }, e.Texture.prototype.constructor = e.Texture, e.Texture.prototype.onBaseTextureLoaded = function() {
            var t = this.baseTexture;
            this.noFrame && (this.frame = new e.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
        }, e.Texture.prototype.destroy = function(t) {
            t && this.baseTexture.destroy(), this.valid = !1
        }, e.Texture.prototype.setFrame = function(t) {
            if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, !this.trim && (t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) {
                if (!e.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                return void(this.valid = !1)
            }
            this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs()
        }, e.Texture.prototype._updateUvs = function() {
            this._uvs || (this._uvs = new e.TextureUvs);
            var t = this.crop,
                i = this.baseTexture.width,
                o = this.baseTexture.height;
            this._uvs.x0 = t.x / i, this._uvs.y0 = t.y / o, this._uvs.x1 = (t.x + t.width) / i, this._uvs.y1 = t.y / o, this._uvs.x2 = (t.x + t.width) / i, this._uvs.y2 = (t.y + t.height) / o, this._uvs.x3 = t.x / i, this._uvs.y3 = (t.y + t.height) / o
        }, e.Texture.fromCanvas = function(t, i) {
            var o = e.BaseTexture.fromCanvas(t, i);
            return new e.Texture(o)
        }, e.TextureUvs = function() {
            this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
        }, e.RenderTexture = function(t, i, o, s, n) {
            if (this.width = t || 100, this.height = i || 100, this.resolution = n || 1, this.frame = new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.baseTexture = new e.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = s || e.scaleModes.DEFAULT, this.baseTexture.hasLoaded = !0, e.Texture.call(this, this.baseTexture, new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), this.renderer = o || e.defaultRenderer, this.renderer.type === e.WEBGL_RENDERER) {
                var r = this.renderer.gl;
                this.baseTexture._dirty[r.id] = !1, this.textureBuffer = new e.FilterTexture(r, this.width, this.height, this.baseTexture.scaleMode), this.baseTexture._glTextures[r.id] = this.textureBuffer.texture, this.render = this.renderWebGL, this.projection = new e.Point(.5 * this.width, .5 * -this.height)
            } else this.render = this.renderCanvas, this.textureBuffer = new e.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
            this.valid = !0, this.tempMatrix = new Phaser.Matrix, this._updateUvs()
        }, e.RenderTexture.prototype = Object.create(e.Texture.prototype), e.RenderTexture.prototype.constructor = e.RenderTexture, e.RenderTexture.prototype.resize = function(t, i, o) {
            t === this.width && i === this.height || (this.valid = t > 0 && i > 0, this.width = t, this.height = i, this.frame.width = this.crop.width = t * this.resolution, this.frame.height = this.crop.height = i * this.resolution, o && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === e.WEBGL_RENDERER && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height))
        }, e.RenderTexture.prototype.clear = function() {
            this.valid && (this.renderer.type === e.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
        }, e.RenderTexture.prototype.renderWebGL = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var o = t.worldTransform;
                o.identity(), o.translate(0, 2 * this.projection.y), e && o.append(e), o.scale(1, -1);
                for (var s = 0; s < t.children.length; s++) t.children[s].updateTransform();
                var n = this.renderer.gl;
                n.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), n.bindFramebuffer(n.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e), this.renderer.spriteBatch.dirty = !0
            }
        }, e.RenderTexture.prototype.renderCanvas = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var o = t.worldTransform;
                o.identity(), e && o.append(e);
                for (var s = 0; s < t.children.length; s++) t.children[s].updateTransform();
                i && this.textureBuffer.clear();
                var n = this.renderer.resolution;
                this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = n
            }
        }, e.RenderTexture.prototype.getImage = function() {
            var t = new Image;
            return t.src = this.getBase64(), t
        }, e.RenderTexture.prototype.getBase64 = function() {
            return this.getCanvas().toDataURL()
        }, e.RenderTexture.prototype.getCanvas = function() {
            if (this.renderer.type === e.WEBGL_RENDERER) {
                var t = this.renderer.gl,
                    i = this.textureBuffer.width,
                    o = this.textureBuffer.height,
                    s = new Uint8Array(4 * i * o);
                t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer), t.readPixels(0, 0, i, o, t.RGBA, t.UNSIGNED_BYTE, s), t.bindFramebuffer(t.FRAMEBUFFER, null);
                var n = new e.CanvasBuffer(i, o),
                    r = n.context.getImageData(0, 0, i, o);
                return r.data.set(s), n.context.putImageData(r, 0, 0), n.canvas
            }
            return this.textureBuffer.canvas
        }, e.AbstractFilter = function(t, e) {
            this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = e || {}, this.fragmentSrc = t || []
        }, e.AbstractFilter.prototype.constructor = e.AbstractFilter, e.AbstractFilter.prototype.syncUniforms = function() {
            for (var t = 0, e = this.shaders.length; t < e; t++) this.shaders[t].dirty = !0
        }, e.Strip = function(t) {
            e.DisplayObjectContainer.call(this), this.texture = t, this.uvs = new e.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = new e.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new e.Float32Array([1, 1, 1, 1]), this.indices = new e.Uint16Array([0, 1, 2, 3]), this.dirty = !0, this.blendMode = e.blendModes.NORMAL, this.canvasPadding = 0, this.drawMode = e.Strip.DrawModes.TRIANGLE_STRIP
        }, e.Strip.prototype = Object.create(e.DisplayObjectContainer.prototype), e.Strip.prototype.constructor = e.Strip, e.Strip.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || (t.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(t), t.shaderManager.setShader(t.shaderManager.stripShader), this._renderStrip(t), t.spriteBatch.start())
        }, e.Strip.prototype._initWebGL = function(t) {
            var e = t.gl;
            this._vertexBuffer = e.createBuffer(), this._indexBuffer = e.createBuffer(), this._uvBuffer = e.createBuffer(), this._colorBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer), e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)
        }, e.Strip.prototype._renderStrip = function(t) {
            var i = t.gl,
                o = t.projection,
                s = t.offset,
                n = t.shaderManager.stripShader,
                r = this.drawMode === e.Strip.DrawModes.TRIANGLE_STRIP ? i.TRIANGLE_STRIP : i.TRIANGLES;
            t.blendModeManager.setBlendMode(this.blendMode), i.uniformMatrix3fv(n.translationMatrix, !1, this.worldTransform.toArray(!0)), i.uniform2f(n.projectionVector, o.x, -o.y), i.uniform2f(n.offsetVector, -s.x, -s.y), i.uniform1f(n.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferData(i.ARRAY_BUFFER, this.vertices, i.STATIC_DRAW), i.vertexAttribPointer(n.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.bufferData(i.ARRAY_BUFFER, this.uvs, i.STATIC_DRAW), i.vertexAttribPointer(n.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? t.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, this.indices, i.STATIC_DRAW)) : (i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferSubData(i.ARRAY_BUFFER, 0, this.vertices), i.vertexAttribPointer(n.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.vertexAttribPointer(n.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? t.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), i.drawElements(r, this.indices.length, i.UNSIGNED_SHORT, 0)
        }, e.Strip.prototype._renderCanvas = function(t) {
            var i = t.context,
                o = this.worldTransform,
                s = o.tx * t.resolution + t.shakeX,
                n = o.ty * t.resolution + t.shakeY;
            t.roundPixels ? i.setTransform(o.a, o.b, o.c, o.d, 0 | s, 0 | n) : i.setTransform(o.a, o.b, o.c, o.d, s, n), this.drawMode === e.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(i) : this._renderCanvasTriangles(i)
        }, e.Strip.prototype._renderCanvasTriangleStrip = function(t) {
            var e = this.vertices,
                i = this.uvs,
                o = e.length / 2;
            this.count++;
            for (var s = 0; s < o - 2; s++) {
                var n = 2 * s;
                this._renderCanvasDrawTriangle(t, e, i, n, n + 2, n + 4)
            }
        }, e.Strip.prototype._renderCanvasTriangles = function(t) {
            var e = this.vertices,
                i = this.uvs,
                o = this.indices,
                s = o.length;
            this.count++;
            for (var n = 0; n < s; n += 3) {
                var r = 2 * o[n],
                    a = 2 * o[n + 1],
                    h = 2 * o[n + 2];
                this._renderCanvasDrawTriangle(t, e, i, r, a, h)
            }
        }, e.Strip.prototype._renderCanvasDrawTriangle = function(t, e, i, o, s, n) {
            var r = this.texture.baseTexture.source,
                a = this.texture.width,
                h = this.texture.height,
                l = e[o],
                d = e[s],
                c = e[n],
                p = e[o + 1],
                u = e[s + 1],
                b = e[n + 1],
                m = i[o] * a,
                y = i[s] * a,
                f = i[n] * a,
                g = i[o + 1] * h,
                x = i[s + 1] * h,
                _ = i[n + 1] * h;
            if (this.canvasPadding > 0) {
                var v = this.canvasPadding / this.worldTransform.a,
                    w = this.canvasPadding / this.worldTransform.d,
                    C = (l + d + c) / 3,
                    S = (p + u + b) / 3,
                    A = l - C,
                    T = p - S,
                    P = Math.sqrt(A * A + T * T);
                l = C + A / P * (P + v), p = S + T / P * (P + w), A = d - C, T = u - S, P = Math.sqrt(A * A + T * T), d = C + A / P * (P + v), u = S + T / P * (P + w), A = c - C, T = b - S, P = Math.sqrt(A * A + T * T), c = C + A / P * (P + v), b = S + T / P * (P + w)
            }
            t.save(), t.beginPath(), t.moveTo(l, p), t.lineTo(d, u), t.lineTo(c, b), t.closePath(), t.clip();
            var B = m * x + g * f + y * _ - x * f - g * y - m * _,
                M = l * x + g * c + d * _ - x * c - g * d - l * _,
                I = m * d + l * f + y * c - d * f - l * y - m * c,
                R = m * x * c + g * d * f + l * y * _ - l * x * f - g * y * c - m * d * _,
                D = p * x + g * b + u * _ - x * b - g * u - p * _,
                k = m * u + p * f + y * b - u * f - p * y - m * b,
                V = m * x * b + g * u * f + p * y * _ - p * x * f - g * y * b - m * u * _;
            t.transform(M / B, D / B, I / B, k / B, R / B, V / B), t.drawImage(r, 0, 0), t.restore()
        }, e.Strip.prototype.renderStripFlat = function(t) {
            var e = this.context,
                i = t.vertices,
                o = i.length / 2;
            this.count++, e.beginPath();
            for (var s = 1; s < o - 2; s++) {
                var n = 2 * s,
                    r = i[n],
                    a = i[n + 2],
                    h = i[n + 4],
                    l = i[n + 1],
                    d = i[n + 3],
                    c = i[n + 5];
                e.moveTo(r, l), e.lineTo(a, d), e.lineTo(h, c)
            }
            e.fillStyle = "#FF0000", e.fill(), e.closePath()
        }, e.Strip.prototype.onTextureUpdate = function() {
            this.updateFrame = !0
        }, e.Strip.prototype.getBounds = function(t) {
            for (var i = t || this.worldTransform, o = i.a, s = i.b, n = i.c, r = i.d, a = i.tx, h = i.ty, l = -1 / 0, d = -1 / 0, c = 1 / 0, p = 1 / 0, u = this.vertices, b = 0, m = u.length; b < m; b += 2) {
                var y = u[b],
                    f = u[b + 1],
                    g = o * y + n * f + a,
                    x = r * f + s * y + h;
                c = g < c ? g : c, p = x < p ? x : p, l = g > l ? g : l, d = x > d ? x : d
            }
            if (c === -1 / 0 || d === 1 / 0) return e.EmptyRectangle;
            var _ = this._bounds;
            return _.x = c, _.width = l - c, _.y = p, _.height = d - p, this._currentBounds = _, _
        }, e.Strip.DrawModes = {
            TRIANGLE_STRIP: 0,
            TRIANGLES: 1
        }, e.Rope = function(t, i) {
            e.Strip.call(this, t), this.points = i, this.vertices = new e.Float32Array(4 * i.length), this.uvs = new e.Float32Array(4 * i.length), this.colors = new e.Float32Array(2 * i.length), this.indices = new e.Uint16Array(2 * i.length), this.refresh()
        }, e.Rope.prototype = Object.create(e.Strip.prototype), e.Rope.prototype.constructor = e.Rope, e.Rope.prototype.refresh = function() {
            var t = this.points;
            if (!(t.length < 1)) {
                var e = this.uvs,
                    i = (t[0], this.indices),
                    o = this.colors;
                this.count -= .2, e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, o[0] = 1, o[1] = 1, i[0] = 0, i[1] = 1;
                for (var s, n, r, a = t.length, h = 1; h < a; h++) s = t[h], n = 4 * h, r = h / (a - 1), e[n] = r, e[n + 1] = 0, e[n + 2] = r, e[n + 3] = 1, n = 2 * h, o[n] = 1, o[n + 1] = 1, n = 2 * h, i[n] = n, i[n + 1] = n + 1, s
            }
        }, e.Rope.prototype.updateTransform = function() {
            var t = this.points;
            if (!(t.length < 1)) {
                var i, o = t[0],
                    s = {
                        x: 0,
                        y: 0
                    };
                this.count -= .2;
                for (var n, r, a, h, l, d = this.vertices, c = t.length, p = 0; p < c; p++) n = t[p], r = 4 * p, i = p < t.length - 1 ? t[p + 1] : n, s.y = -(i.x - o.x), s.x = i.y - o.y, a = 10 * (1 - p / (c - 1)), a > 1 && (a = 1), h = Math.sqrt(s.x * s.x + s.y * s.y), l = this.texture.height / 2, s.x /= h, s.y /= h, s.x *= l, s.y *= l, d[r] = n.x + s.x, d[r + 1] = n.y + s.y, d[r + 2] = n.x - s.x, d[r + 3] = n.y - s.y, o = n;
                e.DisplayObjectContainer.prototype.updateTransform.call(this)
            }
        }, e.Rope.prototype.setTexture = function(t) {
            this.texture = t
        }, e.TilingSprite = function(t, i, o) {
            e.Sprite.call(this, t), this._width = i || 128, this._height = o || 128, this.tileScale = new e.Point(1, 1), this.tileScaleOffset = new e.Point(1, 1), this.tilePosition = new e.Point, this.renderable = !0, this.tint = 16777215, this.textureDebug = !1, this.blendMode = e.blendModes.NORMAL, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0
        }, e.TilingSprite.prototype = Object.create(e.Sprite.prototype), e.TilingSprite.prototype.constructor = e.TilingSprite, e.TilingSprite.prototype.setTexture = function(t) {
            this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215)
        }, e.TilingSprite.prototype._renderWebGL = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                if (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                    if (this.generateTilingTexture(!0, t), !this.tilingTexture) return;
                    this.tilingTexture.needsUpdate && (t.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
                }
                t.spriteBatch.renderTilingSprite(this);
                for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                t.spriteBatch.stop(), this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this._mask, t), t.spriteBatch.start()
            }
        }, e.TilingSprite.prototype._renderCanvas = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                var i = t.context;
                this._mask && t.maskManager.pushMask(this._mask, t), i.globalAlpha = this.worldAlpha;
                var o = this.worldTransform,
                    s = t.resolution,
                    n = o.tx * s + t.shakeX,
                    r = o.ty * s + t.shakeY;
                if (i.setTransform(o.a * s, o.b * s, o.c * s, o.d * s, n, r), this.refreshTexture) {
                    if (this.generateTilingTexture(!1, t), !this.tilingTexture) return;
                    this.tilePattern = i.createPattern(this.tilingTexture.baseTexture.source, "repeat")
                }
                var a = t.currentBlendMode;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, i.globalCompositeOperation = e.blendModesCanvas[t.currentBlendMode]);
                var h = this.tilePosition,
                    l = this.tileScale;
                h.x %= this.tilingTexture.baseTexture.width, h.y %= this.tilingTexture.baseTexture.height, i.scale(l.x, l.y), i.translate(h.x + this.anchor.x * -this._width, h.y + this.anchor.y * -this._height), i.fillStyle = this.tilePattern;
                var n = -h.x,
                    r = -h.y,
                    d = this._width / l.x,
                    c = this._height / l.y;
                t.roundPixels && (n |= 0, r |= 0, d |= 0, c |= 0), i.fillRect(n, r, d, c), i.scale(1 / l.x, 1 / l.y), i.translate(-h.x + this.anchor.x * this._width, -h.y + this.anchor.y * this._height), this._mask && t.maskManager.popMask(t);
                for (var p = 0; p < this.children.length; p++) this.children[p]._renderCanvas(t);
                a !== this.blendMode && (t.currentBlendMode = a, i.globalCompositeOperation = e.blendModesCanvas[a])
            }
        }, e.TilingSprite.prototype.onTextureUpdate = function() {}, e.TilingSprite.prototype.generateTilingTexture = function(t, i) {
            if (this.texture.baseTexture.hasLoaded) {
                var o = this.texture,
                    s = o.frame,
                    n = this._frame.sourceSizeW || this._frame.width,
                    r = this._frame.sourceSizeH || this._frame.height,
                    a = 0,
                    h = 0;
                this._frame.trimmed && (a = this._frame.spriteSourceSizeX, h = this._frame.spriteSourceSizeY), t && (n = e.getNextPowerOfTwo(n), r = e.getNextPowerOfTwo(r)), this.canvasBuffer ? (this.canvasBuffer.resize(n, r), this.tilingTexture.baseTexture.width = n, this.tilingTexture.baseTexture.height = r, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new e.CanvasBuffer(n, r), this.tilingTexture = e.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, n, r));
                var l = o.crop.width,
                    d = o.crop.height;
                l === n && d === r || (l = n, d = r), this.canvasBuffer.context.drawImage(o.baseTexture.source, o.crop.x, o.crop.y, o.crop.width, o.crop.height, a, h, l, d), this.tileScaleOffset.x = s.width / n, this.tileScaleOffset.y = s.height / r, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
            }
        }, e.TilingSprite.prototype.getBounds = function() {
            var t = this._width,
                e = this._height,
                i = t * (1 - this.anchor.x),
                o = t * -this.anchor.x,
                s = e * (1 - this.anchor.y),
                n = e * -this.anchor.y,
                r = this.worldTransform,
                a = r.a,
                h = r.b,
                l = r.c,
                d = r.d,
                c = r.tx,
                p = r.ty,
                u = a * o + l * n + c,
                b = d * n + h * o + p,
                m = a * i + l * n + c,
                y = d * n + h * i + p,
                f = a * i + l * s + c,
                g = d * s + h * i + p,
                x = a * o + l * s + c,
                _ = d * s + h * o + p,
                v = -1 / 0,
                w = -1 / 0,
                C = 1 / 0,
                S = 1 / 0;
            C = u < C ? u : C, C = m < C ? m : C, C = f < C ? f : C, C = x < C ? x : C, S = b < S ? b : S, S = y < S ? y : S, S = g < S ? g : S, S = _ < S ? _ : S, v = u > v ? u : v, v = m > v ? m : v, v = f > v ? f : v, v = x > v ? x : v, w = b > w ? b : w, w = y > w ? y : w, w = g > w ? g : w, w = _ > w ? _ : w;
            var A = this._bounds;
            return A.x = C, A.width = v - C, A.y = S, A.height = w - S, this._currentBounds = A, A
        }, e.TilingSprite.prototype.destroy = function() {
            e.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null)
        }, Object.defineProperty(e.TilingSprite.prototype, "width", {
            get: function() {
                return this._width
            },
            set: function(t) {
                this._width = t
            }
        }), Object.defineProperty(e.TilingSprite.prototype, "height", {
            get: function() {
                return this._height
            },
            set: function(t) {
                this._height = t
            }
        }), "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = e), exports.PIXI = e) : "undefined" != typeof define && define.amd ? define("PIXI", function() {
            return t.PIXI = e
        }()) : t.PIXI = e, e
    }.call(this),
    function() {
        function t(t, e) {
            this._scaleFactor = t, this._deltaMode = e, this.originalEvent = null
        }
        var e = this,
            i = i || {
                VERSION: "2.6.2",
                GAMES: [],
                AUTO: 0,
                CANVAS: 1,
                WEBGL: 2,
                HEADLESS: 3,
                NONE: 0,
                LEFT: 1,
                RIGHT: 2,
                UP: 3,
                DOWN: 4,
                SPRITE: 0,
                BUTTON: 1,
                IMAGE: 2,
                GRAPHICS: 3,
                TEXT: 4,
                TILESPRITE: 5,
                BITMAPTEXT: 6,
                GROUP: 7,
                RENDERTEXTURE: 8,
                TILEMAP: 9,
                TILEMAPLAYER: 10,
                EMITTER: 11,
                POLYGON: 12,
                BITMAPDATA: 13,
                CANVAS_FILTER: 14,
                WEBGL_FILTER: 15,
                ELLIPSE: 16,
                SPRITEBATCH: 17,
                RETROFONT: 18,
                POINTER: 19,
                ROPE: 20,
                CIRCLE: 21,
                RECTANGLE: 22,
                LINE: 23,
                MATRIX: 24,
                POINT: 25,
                ROUNDEDRECTANGLE: 26,
                CREATURE: 27,
                VIDEO: 28,
                PENDING_ATLAS: -1,
                HORIZONTAL: 0,
                VERTICAL: 1,
                LANDSCAPE: 0,
                PORTRAIT: 1,
                ANGLE_UP: 270,
                ANGLE_DOWN: 90,
                ANGLE_LEFT: 180,
                ANGLE_RIGHT: 0,
                ANGLE_NORTH_EAST: 315,
                ANGLE_NORTH_WEST: 225,
                ANGLE_SOUTH_EAST: 45,
                ANGLE_SOUTH_WEST: 135,
                TOP_LEFT: 0,
                TOP_CENTER: 1,
                TOP_RIGHT: 2,
                LEFT_TOP: 3,
                LEFT_CENTER: 4,
                LEFT_BOTTOM: 5,
                CENTER: 6,
                RIGHT_TOP: 7,
                RIGHT_CENTER: 8,
                RIGHT_BOTTOM: 9,
                BOTTOM_LEFT: 10,
                BOTTOM_CENTER: 11,
                BOTTOM_RIGHT: 12,
                blendModes: {
                    NORMAL: 0,
                    ADD: 1,
                    MULTIPLY: 2,
                    SCREEN: 3,
                    OVERLAY: 4,
                    DARKEN: 5,
                    LIGHTEN: 6,
                    COLOR_DODGE: 7,
                    COLOR_BURN: 8,
                    HARD_LIGHT: 9,
                    SOFT_LIGHT: 10,
                    DIFFERENCE: 11,
                    EXCLUSION: 12,
                    HUE: 13,
                    SATURATION: 14,
                    COLOR: 15,
                    LUMINOSITY: 16
                },
                scaleModes: {
                    DEFAULT: 1,
                    LINEAR: 1,
                    NEAREST: 2
                },
                PIXI: PIXI || {}
            };
        if (Math.trunc || (Math.trunc = function(t) {
                return t < 0 ? Math.ceil(t) : Math.floor(t)
            }), Function.prototype.bind || (Function.prototype.bind = function() {
                var t = Array.prototype.slice;
                return function(e) {
                    function i() {
                        var n = s.concat(t.call(arguments));
                        o.apply(this instanceof i ? this : e, n)
                    }
                    var o = this,
                        s = t.call(arguments, 1);
                    if ("function" != typeof o) throw new TypeError;
                    return i.prototype = function t(e) {
                        if (e && (t.prototype = e), !(this instanceof t)) return new t
                    }(o.prototype), i
                }
            }()), Array.isArray || (Array.isArray = function(t) {
                return "[object Array]" === Object.prototype.toString.call(t)
            }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                "use strict";
                if (void 0 === this || null === this) throw new TypeError;
                var e = Object(this),
                    i = e.length >>> 0;
                if ("function" != typeof t) throw new TypeError;
                for (var o = arguments.length >= 2 ? arguments[1] : void 0, s = 0; s < i; s++) s in e && t.call(o, e[s], s, e)
            }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
            var o = function(t) {
                var e = new Array;
                window[t] = function(t) {
                    if ("number" == typeof t) {
                        Array.call(this, t), this.length = t;
                        for (var e = 0; e < this.length; e++) this[e] = 0
                    } else {
                        Array.call(this, t.length), this.length = t.length;
                        for (var e = 0; e < this.length; e++) this[e] = t[e]
                    }
                }, window[t].prototype = e, window[t].constructor = window[t]
            };
            o("Uint32Array"), o("Int16Array")
        }
        window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), i.Utils = {
            reverseString: function(t) {
                return t.split("").reverse().join("")
            },
            getProperty: function(t, e) {
                for (var i = e.split("."), o = i.pop(), s = i.length, n = 1, r = i[0]; n < s && (t = t[r]);) r = i[n], n++;
                return t ? t[o] : null
            },
            setProperty: function(t, e, i) {
                for (var o = e.split("."), s = o.pop(), n = o.length, r = 1, a = o[0]; r < n && (t = t[a]);) a = o[r], r++;
                return t && (t[s] = i), t
            },
            chanceRoll: function(t) {
                return void 0 === t && (t = 50), t > 0 && 100 * Math.random() <= t
            },
            randomChoice: function(t, e) {
                return Math.random() < .5 ? t : e
            },
            parseDimension: function(t, e) {
                var i = 0,
                    o = 0;
                return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, o = 0 === e ? window.innerWidth * i : window.innerHeight * i) : o = parseInt(t, 10) : o = t, o
            },
            pad: function(t, e, i, o) {
                if (void 0 === e) var e = 0;
                if (void 0 === i) var i = " ";
                if (void 0 === o) var o = 3;
                t = t.toString();
                var s = 0;
                if (e + 1 >= t.length) switch (o) {
                    case 1:
                        t = new Array(e + 1 - t.length).join(i) + t;
                        break;
                    case 3:
                        var n = Math.ceil((s = e - t.length) / 2),
                            r = s - n;
                        t = new Array(r + 1).join(i) + t + new Array(n + 1).join(i);
                        break;
                    default:
                        t += new Array(e + 1 - t.length).join(i)
                }
                return t
            },
            isPlainObject: function(t) {
                if ("object" != typeof t || t.nodeType || t === t.window) return !1;
                try {
                    if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1
                } catch (t) {
                    return !1
                }
                return !0
            },
            extend: function() {
                var t, e, o, s, n, r, a = arguments[0] || {},
                    h = 1,
                    l = arguments.length,
                    d = !1;
                for ("boolean" == typeof a && (d = a, a = arguments[1] || {}, h = 2), l === h && (a = this, --h); h < l; h++)
                    if (null != (t = arguments[h]))
                        for (e in t) o = a[e], s = t[e], a !== s && (d && s && (i.Utils.isPlainObject(s) || (n = Array.isArray(s))) ? (n ? (n = !1, r = o && Array.isArray(o) ? o : []) : r = o && i.Utils.isPlainObject(o) ? o : {}, a[e] = i.Utils.extend(d, r, s)) : void 0 !== s && (a[e] = s));
                return a
            },
            mixinPrototype: function(t, e, i) {
                void 0 === i && (i = !1);
                for (var o = Object.keys(e), s = 0; s < o.length; s++) {
                    var n = o[s],
                        r = e[n];
                    !i && n in t || (!r || "function" != typeof r.get && "function" != typeof r.set ? t[n] = r : "function" == typeof r.clone ? t[n] = r.clone() : Object.defineProperty(t, n, r))
                }
            },
            mixin: function(t, e) {
                if (!t || "object" != typeof t) return e;
                for (var o in t) {
                    var s = t[o];
                    if (!s.childNodes && !s.cloneNode) {
                        var n = typeof t[o];
                        t[o] && "object" === n ? typeof e[o] === n ? e[o] = i.Utils.mixin(t[o], e[o]) : e[o] = i.Utils.mixin(t[o], new s.constructor) : e[o] = t[o]
                    }
                }
                return e
            }
        }, i.Circle = function(t, e, o) {
            t = t || 0, e = e || 0, o = o || 0, this.x = t, this.y = e, this._diameter = o, this._radius = 0, o > 0 && (this._radius = .5 * o), this.type = i.CIRCLE
        }, i.Circle.prototype = {
            circumference: function() {
                return Math.PI * this._radius * 2
            },
            random: function(t) {
                void 0 === t && (t = new i.Point);
                var e = 2 * Math.PI * Math.random(),
                    o = Math.random() + Math.random(),
                    s = o > 1 ? 2 - o : o,
                    n = s * Math.cos(e),
                    r = s * Math.sin(e);
                return t.x = this.x + n * this.radius, t.y = this.y + r * this.radius, t
            },
            getBounds: function() {
                return new i.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
            },
            setTo: function(t, e, i) {
                return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this
            },
            copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.diameter)
            },
            copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t
            },
            distance: function(t, e) {
                var o = i.Math.distance(this.x, this.y, t.x, t.y);
                return e ? Math.round(o) : o
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new i.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t
            },
            contains: function(t, e) {
                return i.Circle.contains(this, t, e)
            },
            circumferencePoint: function(t, e, o) {
                return i.Circle.circumferencePoint(this, t, e, o)
            },
            offset: function(t, e) {
                return this.x += t, this.y += e, this
            },
            offsetPoint: function(t) {
                return this.offset(t.x, t.y)
            },
            toString: function() {
                return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
            }
        }, i.Circle.prototype.constructor = i.Circle, Object.defineProperty(i.Circle.prototype, "diameter", {
            get: function() {
                return this._diameter
            },
            set: function(t) {
                t > 0 && (this._diameter = t, this._radius = .5 * t)
            }
        }), Object.defineProperty(i.Circle.prototype, "radius", {
            get: function() {
                return this._radius
            },
            set: function(t) {
                t > 0 && (this._radius = t, this._diameter = 2 * t)
            }
        }), Object.defineProperty(i.Circle.prototype, "left", {
            get: function() {
                return this.x - this._radius
            },
            set: function(t) {
                t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
            }
        }), Object.defineProperty(i.Circle.prototype, "right", {
            get: function() {
                return this.x + this._radius
            },
            set: function(t) {
                t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
            }
        }), Object.defineProperty(i.Circle.prototype, "top", {
            get: function() {
                return this.y - this._radius
            },
            set: function(t) {
                t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
            }
        }), Object.defineProperty(i.Circle.prototype, "bottom", {
            get: function() {
                return this.y + this._radius
            },
            set: function(t) {
                t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
            }
        }), Object.defineProperty(i.Circle.prototype, "area", {
            get: function() {
                return this._radius > 0 ? Math.PI * this._radius * this._radius : 0
            }
        }), Object.defineProperty(i.Circle.prototype, "empty", {
            get: function() {
                return 0 === this._diameter
            },
            set: function(t) {
                !0 === t && this.setTo(0, 0, 0)
            }
        }), i.Circle.contains = function(t, e, i) {
            if (t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom) {
                return (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
            }
            return !1
        }, i.Circle.equals = function(t, e) {
            return t.x === e.x && t.y === e.y && t.diameter === e.diameter
        }, i.Circle.intersects = function(t, e) {
            return i.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius
        }, i.Circle.circumferencePoint = function(t, e, o, s) {
            return void 0 === o && (o = !1), void 0 === s && (s = new i.Point), !0 === o && (e = i.Math.degToRad(e)), s.x = t.x + t.radius * Math.cos(e), s.y = t.y + t.radius * Math.sin(e), s
        }, i.Circle.intersectsRectangle = function(t, e) {
            var i = Math.abs(t.x - e.x - e.halfWidth);
            if (i > e.halfWidth + t.radius) return !1;
            var o = Math.abs(t.y - e.y - e.halfHeight);
            if (o > e.halfHeight + t.radius) return !1;
            if (i <= e.halfWidth || o <= e.halfHeight) return !0;
            var s = i - e.halfWidth,
                n = o - e.halfHeight;
            return s * s + n * n <= t.radius * t.radius
        }, PIXI.Circle = i.Circle, i.Ellipse = function(t, e, o, s) {
            t = t || 0, e = e || 0, o = o || 0, s = s || 0, this.x = t, this.y = e, this.width = o, this.height = s, this.type = i.ELLIPSE
        }, i.Ellipse.prototype = {
            setTo: function(t, e, i, o) {
                return this.x = t, this.y = e, this.width = i, this.height = o, this
            },
            getBounds: function() {
                return new i.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
            },
            copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.width, t.height)
            },
            copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new i.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
            },
            contains: function(t, e) {
                return i.Ellipse.contains(this, t, e)
            },
            random: function(t) {
                void 0 === t && (t = new i.Point);
                var e = Math.random() * Math.PI * 2,
                    o = Math.random();
                return t.x = Math.sqrt(o) * Math.cos(e), t.y = Math.sqrt(o) * Math.sin(e), t.x = this.x + t.x * this.width / 2, t.y = this.y + t.y * this.height / 2, t
            },
            toString: function() {
                return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
            }
        }, i.Ellipse.prototype.constructor = i.Ellipse, Object.defineProperty(i.Ellipse.prototype, "left", {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        }), Object.defineProperty(i.Ellipse.prototype, "right", {
            get: function() {
                return this.x + this.width
            },
            set: function(t) {
                t < this.x ? this.width = 0 : this.width = t - this.x
            }
        }), Object.defineProperty(i.Ellipse.prototype, "top", {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        }), Object.defineProperty(i.Ellipse.prototype, "bottom", {
            get: function() {
                return this.y + this.height
            },
            set: function(t) {
                t < this.y ? this.height = 0 : this.height = t - this.y
            }
        }), Object.defineProperty(i.Ellipse.prototype, "empty", {
            get: function() {
                return 0 === this.width || 0 === this.height
            },
            set: function(t) {
                !0 === t && this.setTo(0, 0, 0, 0)
            }
        }), i.Ellipse.contains = function(t, e, i) {
            if (t.width <= 0 || t.height <= 0) return !1;
            var o = (e - t.x) / t.width - .5,
                s = (i - t.y) / t.height - .5;
            return o *= o, s *= s, o + s < .25
        }, PIXI.Ellipse = i.Ellipse, i.Line = function(t, e, o, s) {
            t = t || 0, e = e || 0, o = o || 0, s = s || 0, this.start = new i.Point(t, e), this.end = new i.Point(o, s), this.type = i.LINE
        }, i.Line.prototype = {
            setTo: function(t, e, i, o) {
                return this.start.setTo(t, e), this.end.setTo(i, o), this
            },
            fromSprite: function(t, e, i) {
                return void 0 === i && (i = !1), i ? this.setTo(t.center.x, t.center.y, e.center.x, e.center.y) : this.setTo(t.x, t.y, e.x, e.y)
            },
            fromAngle: function(t, e, i, o) {
                return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * o, e + Math.sin(i) * o), this
            },
            rotate: function(t, e) {
                var i = (this.start.x + this.end.x) / 2,
                    o = (this.start.y + this.end.y) / 2;
                return this.start.rotate(i, o, t, e), this.end.rotate(i, o, t, e), this
            },
            rotateAround: function(t, e, i, o) {
                return this.start.rotate(t, e, i, o), this.end.rotate(t, e, i, o), this
            },
            intersects: function(t, e, o) {
                return i.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, o)
            },
            reflect: function(t) {
                return i.Line.reflect(this, t)
            },
            midPoint: function(t) {
                return void 0 === t && (t = new i.Point), t.x = (this.start.x + this.end.x) / 2, t.y = (this.start.y + this.end.y) / 2, t
            },
            centerOn: function(t, e) {
                var i = (this.start.x + this.end.x) / 2,
                    o = (this.start.y + this.end.y) / 2,
                    s = t - i,
                    n = e - o;
                this.start.add(s, n), this.end.add(s, n)
            },
            pointOnLine: function(t, e) {
                return (t - this.start.x) * (this.end.y - this.start.y) == (this.end.x - this.start.x) * (e - this.start.y)
            },
            pointOnSegment: function(t, e) {
                var i = Math.min(this.start.x, this.end.x),
                    o = Math.max(this.start.x, this.end.x),
                    s = Math.min(this.start.y, this.end.y),
                    n = Math.max(this.start.y, this.end.y);
                return this.pointOnLine(t, e) && t >= i && t <= o && e >= s && e <= n
            },
            random: function(t) {
                void 0 === t && (t = new i.Point);
                var e = Math.random();
                return t.x = this.start.x + e * (this.end.x - this.start.x), t.y = this.start.y + e * (this.end.y - this.start.y), t
            },
            coordinatesOnLine: function(t, e) {
                void 0 === t && (t = 1), void 0 === e && (e = []);
                var i = Math.round(this.start.x),
                    o = Math.round(this.start.y),
                    s = Math.round(this.end.x),
                    n = Math.round(this.end.y),
                    r = Math.abs(s - i),
                    a = Math.abs(n - o),
                    h = i < s ? 1 : -1,
                    l = o < n ? 1 : -1,
                    d = r - a;
                e.push([i, o]);
                for (var c = 1; i !== s || o !== n;) {
                    var p = d << 1;
                    p > -a && (d -= a, i += h), p < r && (d += r, o += l), c % t == 0 && e.push([i, o]), c++
                }
                return e
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new i.Line(this.start.x, this.start.y, this.end.x, this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y), t
            }
        }, Object.defineProperty(i.Line.prototype, "length", {
            get: function() {
                return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
            }
        }), Object.defineProperty(i.Line.prototype, "angle", {
            get: function() {
                return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
            }
        }), Object.defineProperty(i.Line.prototype, "slope", {
            get: function() {
                return (this.end.y - this.start.y) / (this.end.x - this.start.x)
            }
        }), Object.defineProperty(i.Line.prototype, "perpSlope", {
            get: function() {
                return -(this.end.x - this.start.x) / (this.end.y - this.start.y)
            }
        }), Object.defineProperty(i.Line.prototype, "x", {
            get: function() {
                return Math.min(this.start.x, this.end.x)
            }
        }), Object.defineProperty(i.Line.prototype, "y", {
            get: function() {
                return Math.min(this.start.y, this.end.y)
            }
        }), Object.defineProperty(i.Line.prototype, "left", {
            get: function() {
                return Math.min(this.start.x, this.end.x)
            }
        }), Object.defineProperty(i.Line.prototype, "right", {
            get: function() {
                return Math.max(this.start.x, this.end.x)
            }
        }), Object.defineProperty(i.Line.prototype, "top", {
            get: function() {
                return Math.min(this.start.y, this.end.y)
            }
        }), Object.defineProperty(i.Line.prototype, "bottom", {
            get: function() {
                return Math.max(this.start.y, this.end.y)
            }
        }), Object.defineProperty(i.Line.prototype, "width", {
            get: function() {
                return Math.abs(this.start.x - this.end.x)
            }
        }), Object.defineProperty(i.Line.prototype, "height", {
            get: function() {
                return Math.abs(this.start.y - this.end.y)
            }
        }), Object.defineProperty(i.Line.prototype, "normalX", {
            get: function() {
                return Math.cos(this.angle - 1.5707963267948966)
            }
        }), Object.defineProperty(i.Line.prototype, "normalY", {
            get: function() {
                return Math.sin(this.angle - 1.5707963267948966)
            }
        }), Object.defineProperty(i.Line.prototype, "normalAngle", {
            get: function() {
                return i.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
            }
        }), i.Line.intersectsPoints = function(t, e, o, s, n, r) {
            void 0 === n && (n = !0), void 0 === r && (r = new i.Point);
            var a = e.y - t.y,
                h = s.y - o.y,
                l = t.x - e.x,
                d = o.x - s.x,
                c = e.x * t.y - t.x * e.y,
                p = s.x * o.y - o.x * s.y,
                u = a * d - h * l;
            if (0 === u) return null;
            if (r.x = (l * p - d * c) / u, r.y = (h * c - a * p) / u, n) {
                var b = (s.y - o.y) * (e.x - t.x) - (s.x - o.x) * (e.y - t.y),
                    m = ((s.x - o.x) * (t.y - o.y) - (s.y - o.y) * (t.x - o.x)) / b,
                    y = ((e.x - t.x) * (t.y - o.y) - (e.y - t.y) * (t.x - o.x)) / b;
                return m >= 0 && m <= 1 && y >= 0 && y <= 1 ? r : null
            }
            return r
        }, i.Line.intersects = function(t, e, o, s) {
            return i.Line.intersectsPoints(t.start, t.end, e.start, e.end, o, s)
        }, i.Line.intersectsRectangle = function(t, e) {
            if (!i.Rectangle.intersects(t, e)) return !1;
            var o = t.start.x,
                s = t.start.y,
                n = t.end.x,
                r = t.end.y,
                a = e.x,
                h = e.y,
                l = e.right,
                d = e.bottom,
                c = 0;
            if (o >= a && o <= l && s >= h && s <= d || n >= a && n <= l && r >= h && r <= d) return !0;
            if (o < a && n >= a) {
                if ((c = s + (r - s) * (a - o) / (n - o)) > h && c <= d) return !0
            } else if (o > l && n <= l && (c = s + (r - s) * (l - o) / (n - o)) >= h && c <= d) return !0;
            if (s < h && r >= h) {
                if ((c = o + (n - o) * (h - s) / (r - s)) >= a && c <= l) return !0
            } else if (s > d && r <= d && (c = o + (n - o) * (d - s) / (r - s)) >= a && c <= l) return !0;
            return !1
        }, i.Line.reflect = function(t, e) {
            return 2 * e.normalAngle - 3.141592653589793 - t.angle
        }, i.Matrix = function(t, e, o, s, n, r) {
            void 0 !== t && null !== t || (t = 1), void 0 !== e && null !== e || (e = 0), void 0 !== o && null !== o || (o = 0), void 0 !== s && null !== s || (s = 1), void 0 !== n && null !== n || (n = 0), void 0 !== r && null !== r || (r = 0), this.a = t, this.b = e, this.c = o, this.d = s, this.tx = n, this.ty = r, this.type = i.MATRIX
        }, i.Matrix.prototype = {
            fromArray: function(t) {
                return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
            },
            setTo: function(t, e, i, o, s, n) {
                return this.a = t, this.b = e, this.c = i, this.d = o, this.tx = s, this.ty = n, this
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new i.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty), t
            },
            copyTo: function(t) {
                return t.copyFrom(this), t
            },
            copyFrom: function(t) {
                return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
            },
            toArray: function(t, e) {
                return void 0 === e && (e = new PIXI.Float32Array(9)), t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1), e
            },
            apply: function(t, e) {
                return void 0 === e && (e = new i.Point), e.x = this.a * t.x + this.c * t.y + this.tx, e.y = this.b * t.x + this.d * t.y + this.ty, e
            },
            applyInverse: function(t, e) {
                void 0 === e && (e = new i.Point);
                var o = 1 / (this.a * this.d + this.c * -this.b),
                    s = t.x,
                    n = t.y;
                return e.x = this.d * o * s + -this.c * o * n + (this.ty * this.c - this.tx * this.d) * o, e.y = this.a * o * n + -this.b * o * s + (-this.ty * this.a + this.tx * this.b) * o, e
            },
            translate: function(t, e) {
                return this.tx += t, this.ty += e, this
            },
            scale: function(t, e) {
                return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
            },
            rotate: function(t) {
                var e = Math.cos(t),
                    i = Math.sin(t),
                    o = this.a,
                    s = this.c,
                    n = this.tx;
                return this.a = o * e - this.b * i, this.b = o * i + this.b * e, this.c = s * e - this.d * i, this.d = s * i + this.d * e, this.tx = n * e - this.ty * i, this.ty = n * i + this.ty * e, this
            },
            append: function(t) {
                var e = this.a,
                    i = this.b,
                    o = this.c,
                    s = this.d;
                return this.a = t.a * e + t.b * o, this.b = t.a * i + t.b * s, this.c = t.c * e + t.d * o, this.d = t.c * i + t.d * s, this.tx = t.tx * e + t.ty * o + this.tx, this.ty = t.tx * i + t.ty * s + this.ty, this
            },
            identity: function() {
                return this.setTo(1, 0, 0, 1, 0, 0)
            }
        }, i.identityMatrix = new i.Matrix, PIXI.Matrix = i.Matrix, PIXI.identityMatrix = i.identityMatrix, i.Point = function(t, e) {
            t = t || 0, e = e || 0, this.x = t, this.y = e, this.type = i.POINT
        }, i.Point.prototype = {
            copyFrom: function(t) {
                return this.setTo(t.x, t.y)
            },
            invert: function() {
                return this.setTo(this.y, this.x)
            },
            setTo: function(t, e) {
                return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
            },
            set: function(t, e) {
                return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
            },
            add: function(t, e) {
                return this.x += t, this.y += e, this
            },
            subtract: function(t, e) {
                return this.x -= t, this.y -= e, this
            },
            multiply: function(t, e) {
                return this.x *= t, this.y *= e, this
            },
            divide: function(t, e) {
                return this.x /= t, this.y /= e, this
            },
            clampX: function(t, e) {
                return this.x = i.Math.clamp(this.x, t, e), this
            },
            clampY: function(t, e) {
                return this.y = i.Math.clamp(this.y, t, e), this
            },
            clamp: function(t, e) {
                return this.x = i.Math.clamp(this.x, t, e), this.y = i.Math.clamp(this.y, t, e), this
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new i.Point(this.x, this.y) : t.setTo(this.x, this.y), t
            },
            copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t
            },
            distance: function(t, e) {
                return i.Point.distance(this, t, e)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y
            },
            angle: function(t, e) {
                return void 0 === e && (e = !1), e ? i.Math.radToDeg(Math.atan2(t.y - this.y, t.x - this.x)) : Math.atan2(t.y - this.y, t.x - this.x)
            },
            rotate: function(t, e, o, s, n) {
                return i.Point.rotate(this, t, e, o, s, n)
            },
            getMagnitude: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            getMagnitudeSq: function() {
                return this.x * this.x + this.y * this.y
            },
            setMagnitude: function(t) {
                return this.normalize().multiply(t, t)
            },
            normalize: function() {
                if (!this.isZero()) {
                    var t = this.getMagnitude();
                    this.x /= t, this.y /= t
                }
                return this
            },
            isZero: function() {
                return 0 === this.x && 0 === this.y
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y
            },
            cross: function(t) {
                return this.x * t.y - this.y * t.x
            },
            perp: function() {
                return this.setTo(-this.y, this.x)
            },
            rperp: function() {
                return this.setTo(this.y, -this.x)
            },
            normalRightHand: function() {
                return this.setTo(-1 * this.y, this.x)
            },
            floor: function() {
                return this.setTo(Math.floor(this.x), Math.floor(this.y))
            },
            ceil: function() {
                return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
            },
            toString: function() {
                return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
            }
        }, i.Point.prototype.constructor = i.Point, i.Point.add = function(t, e, o) {
            return void 0 === o && (o = new i.Point), o.x = t.x + e.x, o.y = t.y + e.y, o
        }, i.Point.subtract = function(t, e, o) {
            return void 0 === o && (o = new i.Point), o.x = t.x - e.x, o.y = t.y - e.y, o
        }, i.Point.multiply = function(t, e, o) {
            return void 0 === o && (o = new i.Point), o.x = t.x * e.x, o.y = t.y * e.y, o
        }, i.Point.divide = function(t, e, o) {
            return void 0 === o && (o = new i.Point), o.x = t.x / e.x, o.y = t.y / e.y, o
        }, i.Point.equals = function(t, e) {
            return t.x === e.x && t.y === e.y
        }, i.Point.angle = function(t, e) {
            return Math.atan2(t.y - e.y, t.x - e.x)
        }, i.Point.negative = function(t, e) {
            return void 0 === e && (e = new i.Point), e.setTo(-t.x, -t.y)
        }, i.Point.multiplyAdd = function(t, e, o, s) {
            return void 0 === s && (s = new i.Point), s.setTo(t.x + e.x * o, t.y + e.y * o)
        }, i.Point.interpolate = function(t, e, o, s) {
            return void 0 === s && (s = new i.Point), s.setTo(t.x + (e.x - t.x) * o, t.y + (e.y - t.y) * o)
        }, i.Point.perp = function(t, e) {
            return void 0 === e && (e = new i.Point), e.setTo(-t.y, t.x)
        }, i.Point.rperp = function(t, e) {
            return void 0 === e && (e = new i.Point), e.setTo(t.y, -t.x)
        }, i.Point.distance = function(t, e, o) {
            var s = i.Math.distance(t.x, t.y, e.x, e.y);
            return o ? Math.round(s) : s
        }, i.Point.project = function(t, e, o) {
            void 0 === o && (o = new i.Point);
            var s = t.dot(e) / e.getMagnitudeSq();
            return 0 !== s && o.setTo(s * e.x, s * e.y), o
        }, i.Point.projectUnit = function(t, e, o) {
            void 0 === o && (o = new i.Point);
            var s = t.dot(e);
            return 0 !== s && o.setTo(s * e.x, s * e.y), o
        }, i.Point.normalRightHand = function(t, e) {
            return void 0 === e && (e = new i.Point), e.setTo(-1 * t.y, t.x)
        }, i.Point.normalize = function(t, e) {
            void 0 === e && (e = new i.Point);
            var o = t.getMagnitude();
            return 0 !== o && e.setTo(t.x / o, t.y / o), e
        }, i.Point.rotate = function(t, e, o, s, n, r) {
            if (n && (s = i.Math.degToRad(s)), void 0 === r) {
                t.subtract(e, o);
                var a = Math.sin(s),
                    h = Math.cos(s),
                    l = h * t.x - a * t.y,
                    d = a * t.x + h * t.y;
                t.x = l + e, t.y = d + o
            } else {
                var c = s + Math.atan2(t.y - o, t.x - e);
                t.x = e + r * Math.cos(c), t.y = o + r * Math.sin(c)
            }
            return t
        }, i.Point.centroid = function(t, e) {
            if (void 0 === e && (e = new i.Point), "[object Array]" !== Object.prototype.toString.call(t)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
            var o = t.length;
            if (o < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
            if (1 === o) return e.copyFrom(t[0]), e;
            for (var s = 0; s < o; s++) i.Point.add(e, t[s], e);
            return e.divide(o, o), e
        }, i.Point.parse = function(t, e, o) {
            e = e || "x", o = o || "y";
            var s = new i.Point;
            return t[e] && (s.x = parseInt(t[e], 10)), t[o] && (s.y = parseInt(t[o], 10)), s
        }, PIXI.Point = i.Point, i.Polygon = function() {
            this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = i.POLYGON
        }, i.Polygon.prototype = {
            toNumberArray: function(t) {
                void 0 === t && (t = []);
                for (var e = 0; e < this._points.length; e++) "number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y));
                return t
            },
            flatten: function() {
                return this._points = this.toNumberArray(), this.flattened = !0, this
            },
            clone: function(t) {
                var e = this._points.slice();
                return void 0 === t || null === t ? t = new i.Polygon(e) : t.setTo(e), t
            },
            contains: function(t, e) {
                var i = !1;
                if (this.flattened)
                    for (var o = -2, s = this._points.length - 2;
                        (o += 2) < this._points.length; s = o) {
                        var n = this._points[o],
                            r = this._points[o + 1],
                            a = this._points[s],
                            h = this._points[s + 1];
                        (r <= e && e < h || h <= e && e < r) && t < (a - n) * (e - r) / (h - r) + n && (i = !i)
                    } else
                        for (var o = -1, s = this._points.length - 1; ++o < this._points.length; s = o) {
                            var n = this._points[o].x,
                                r = this._points[o].y,
                                a = this._points[s].x,
                                h = this._points[s].y;
                            (r <= e && e < h || h <= e && e < r) && t < (a - n) * (e - r) / (h - r) + n && (i = !i)
                        }
                return i
            },
            setTo: function(t) {
                if (this.area = 0, this._points = [], arguments.length > 0) {
                    Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                    for (var e = Number.MAX_VALUE, i = 0, o = t.length; i < o; i++) {
                        if ("number" == typeof t[i]) {
                            var s = new PIXI.Point(t[i], t[i + 1]);
                            i++
                        } else if (Array.isArray(t[i])) var s = new PIXI.Point(t[i][0], t[i][1]);
                        else var s = new PIXI.Point(t[i].x, t[i].y);
                        this._points.push(s), s.y < e && (e = s.y)
                    }
                    this.calculateArea(e)
                }
                return this
            },
            calculateArea: function(t) {
                for (var e, i, o, s, n = 0, r = this._points.length; n < r; n++) e = this._points[n], i = n === r - 1 ? this._points[0] : this._points[n + 1], o = (e.y - t + (i.y - t)) / 2, s = e.x - i.x, this.area += o * s;
                return this.area
            }
        }, i.Polygon.prototype.constructor = i.Polygon, Object.defineProperty(i.Polygon.prototype, "points", {
            get: function() {
                return this._points
            },
            set: function(t) {
                null != t ? this.setTo(t) : this.setTo()
            }
        }), PIXI.Polygon = i.Polygon, i.Rectangle = function(t, e, o, s) {
            t = t || 0, e = e || 0, o = o || 0, s = s || 0, this.x = t, this.y = e, this.width = o, this.height = s, this.type = i.RECTANGLE
        }, i.Rectangle.prototype = {
            offset: function(t, e) {
                return this.x += t, this.y += e, this
            },
            offsetPoint: function(t) {
                return this.offset(t.x, t.y)
            },
            setTo: function(t, e, i, o) {
                return this.x = t, this.y = e, this.width = i, this.height = o, this
            },
            scale: function(t, e) {
                return void 0 === e && (e = t), this.width *= t, this.height *= e, this
            },
            centerOn: function(t, e) {
                return this.centerX = t, this.centerY = e, this
            },
            floor: function() {
                this.x = Math.floor(this.x), this.y = Math.floor(this.y)
            },
            floorAll: function() {
                this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
            },
            ceil: function() {
                this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)
            },
            ceilAll: function() {
                this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height)
            },
            copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.width, t.height)
            },
            copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
            },
            inflate: function(t, e) {
                return i.Rectangle.inflate(this, t, e)
            },
            size: function(t) {
                return i.Rectangle.size(this, t)
            },
            resize: function(t, e) {
                return this.width = t, this.height = e, this
            },
            clone: function(t) {
                return i.Rectangle.clone(this, t)
            },
            contains: function(t, e) {
                return i.Rectangle.contains(this, t, e)
            },
            containsRect: function(t) {
                return i.Rectangle.containsRect(t, this)
            },
            equals: function(t) {
                return i.Rectangle.equals(this, t)
            },
            intersection: function(t, e) {
                return i.Rectangle.intersection(this, t, e)
            },
            intersects: function(t) {
                return i.Rectangle.intersects(this, t)
            },
            intersectsRaw: function(t, e, o, s, n) {
                return i.Rectangle.intersectsRaw(this, t, e, o, s, n)
            },
            union: function(t, e) {
                return i.Rectangle.union(this, t, e)
            },
            random: function(t) {
                return void 0 === t && (t = new i.Point), t.x = this.randomX, t.y = this.randomY, t
            },
            getPoint: function(t, e) {
                switch (void 0 === e && (e = new i.Point), t) {
                    default:
                        case i.TOP_LEFT:
                        return e.set(this.x, this.y);
                    case i.TOP_CENTER:
                            return e.set(this.centerX, this.y);
                    case i.TOP_RIGHT:
                            return e.set(this.right, this.y);
                    case i.LEFT_CENTER:
                            return e.set(this.x, this.centerY);
                    case i.CENTER:
                            return e.set(this.centerX, this.centerY);
                    case i.RIGHT_CENTER:
                            return e.set(this.right, this.centerY);
                    case i.BOTTOM_LEFT:
                            return e.set(this.x, this.bottom);
                    case i.BOTTOM_CENTER:
                            return e.set(this.centerX, this.bottom);
                    case i.BOTTOM_RIGHT:
                            return e.set(this.right, this.bottom)
                }
            },
            toString: function() {
                return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
            }
        }, Object.defineProperty(i.Rectangle.prototype, "halfWidth", {
            get: function() {
                return Math.round(this.width / 2)
            }
        }), Object.defineProperty(i.Rectangle.prototype, "halfHeight", {
            get: function() {
                return Math.round(this.height / 2)
            }
        }), Object.defineProperty(i.Rectangle.prototype, "bottom", {
            get: function() {
                return this.y + this.height
            },
            set: function(t) {
                t <= this.y ? this.height = 0 : this.height = t - this.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "bottomLeft", {
            get: function() {
                return new i.Point(this.x, this.bottom)
            },
            set: function(t) {
                this.x = t.x, this.bottom = t.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "bottomRight", {
            get: function() {
                return new i.Point(this.right, this.bottom)
            },
            set: function(t) {
                this.right = t.x, this.bottom = t.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "left", {
            get: function() {
                return this.x
            },
            set: function(t) {
                t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t
            }
        }), Object.defineProperty(i.Rectangle.prototype, "right", {
            get: function() {
                return this.x + this.width
            },
            set: function(t) {
                t <= this.x ? this.width = 0 : this.width = t - this.x
            }
        }), Object.defineProperty(i.Rectangle.prototype, "volume", {
            get: function() {
                return this.width * this.height
            }
        }), Object.defineProperty(i.Rectangle.prototype, "perimeter", {
            get: function() {
                return 2 * this.width + 2 * this.height
            }
        }), Object.defineProperty(i.Rectangle.prototype, "centerX", {
            get: function() {
                return this.x + this.halfWidth
            },
            set: function(t) {
                this.x = t - this.halfWidth
            }
        }), Object.defineProperty(i.Rectangle.prototype, "centerY", {
            get: function() {
                return this.y + this.halfHeight
            },
            set: function(t) {
                this.y = t - this.halfHeight
            }
        }), Object.defineProperty(i.Rectangle.prototype, "randomX", {
            get: function() {
                return this.x + Math.random() * this.width
            }
        }), Object.defineProperty(i.Rectangle.prototype, "randomY", {
            get: function() {
                return this.y + Math.random() * this.height
            }
        }), Object.defineProperty(i.Rectangle.prototype, "top", {
            get: function() {
                return this.y
            },
            set: function(t) {
                t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
            }
        }), Object.defineProperty(i.Rectangle.prototype, "topLeft", {
            get: function() {
                return new i.Point(this.x, this.y)
            },
            set: function(t) {
                this.x = t.x, this.y = t.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "topRight", {
            get: function() {
                return new i.Point(this.x + this.width, this.y)
            },
            set: function(t) {
                this.right = t.x, this.y = t.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "empty", {
            get: function() {
                return !this.width || !this.height
            },
            set: function(t) {
                !0 === t && this.setTo(0, 0, 0, 0)
            }
        }), i.Rectangle.prototype.constructor = i.Rectangle, i.Rectangle.inflate = function(t, e, i) {
            return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t
        }, i.Rectangle.inflatePoint = function(t, e) {
            return i.Rectangle.inflate(t, e.x, e.y)
        }, i.Rectangle.size = function(t, e) {
            return void 0 === e || null === e ? e = new i.Point(t.width, t.height) : e.setTo(t.width, t.height), e
        }, i.Rectangle.clone = function(t, e) {
            return void 0 === e || null === e ? e = new i.Rectangle(t.x, t.y, t.width, t.height) : e.setTo(t.x, t.y, t.width, t.height), e
        }, i.Rectangle.contains = function(t, e, i) {
            return !(t.width <= 0 || t.height <= 0) && (e >= t.x && e < t.right && i >= t.y && i < t.bottom)
        }, i.Rectangle.containsRaw = function(t, e, i, o, s, n) {
            return s >= t && s < t + i && n >= e && n < e + o
        }, i.Rectangle.containsPoint = function(t, e) {
            return i.Rectangle.contains(t, e.x, e.y)
        }, i.Rectangle.containsRect = function(t, e) {
            return !(t.volume > e.volume) && (t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom)
        }, i.Rectangle.equals = function(t, e) {
            return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
        }, i.Rectangle.sameDimensions = function(t, e) {
            return t.width === e.width && t.height === e.height
        }, i.Rectangle.intersection = function(t, e, o) {
            return void 0 === o && (o = new i.Rectangle), i.Rectangle.intersects(t, e) && (o.x = Math.max(t.x, e.x), o.y = Math.max(t.y, e.y), o.width = Math.min(t.right, e.right) - o.x, o.height = Math.min(t.bottom, e.bottom) - o.y), o
        }, i.Rectangle.intersects = function(t, e) {
            return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
        }, i.Rectangle.intersectsRaw = function(t, e, i, o, s, n) {
            return void 0 === n && (n = 0), !(e > t.right + n || i < t.left - n || o > t.bottom + n || s < t.top - n)
        }, i.Rectangle.union = function(t, e, o) {
            return void 0 === o && (o = new i.Rectangle), o.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top))
        }, i.Rectangle.aabb = function(t, e) {
            void 0 === e && (e = new i.Rectangle);
            var o = Number.NEGATIVE_INFINITY,
                s = Number.POSITIVE_INFINITY,
                n = Number.NEGATIVE_INFINITY,
                r = Number.POSITIVE_INFINITY;
            return t.forEach(function(t) {
                t.x > o && (o = t.x), t.x < s && (s = t.x), t.y > n && (n = t.y), t.y < r && (r = t.y)
            }), e.setTo(s, r, o - s, n - r), e
        }, PIXI.Rectangle = i.Rectangle, PIXI.EmptyRectangle = new i.Rectangle(0, 0, 0, 0), i.RoundedRectangle = function(t, e, o, s, n) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 20), this.x = t, this.y = e, this.width = o, this.height = s, this.radius = n || 20, this.type = i.ROUNDEDRECTANGLE
        }, i.RoundedRectangle.prototype = {
            clone: function() {
                return new i.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
            },
            contains: function(t, e) {
                if (this.width <= 0 || this.height <= 0) return !1;
                var i = this.x;
                if (t >= i && t <= i + this.width) {
                    var o = this.y;
                    if (e >= o && e <= o + this.height) return !0
                }
                return !1
            }
        }, i.RoundedRectangle.prototype.constructor = i.RoundedRectangle, PIXI.RoundedRectangle = i.RoundedRectangle, i.Camera = function(t, e, o, s, n, r) {
            this.game = t, this.world = t.world, this.id = 0, this.view = new i.Rectangle(o, s, n, r), this.bounds = new i.Rectangle(o, s, n, r), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
                x: !1,
                y: !1
            }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new i.Point(1, 1), this.onShakeComplete = new i.Signal, this.onFlashComplete = new i.Signal, this.onFadeComplete = new i.Signal, this.fx = null, this._targetPosition = new i.Point, this._edge = 0, this._position = new i.Point, this._shake = {
                intensity: 0,
                duration: 0,
                horizontal: !1,
                vertical: !1,
                shakeBounds: !0,
                x: 0,
                y: 0
            }, this._fxDuration = 0, this._fxType = 0
        }, i.Camera.FOLLOW_LOCKON = 0, i.Camera.FOLLOW_PLATFORMER = 1, i.Camera.FOLLOW_TOPDOWN = 2, i.Camera.FOLLOW_TOPDOWN_TIGHT = 3, i.Camera.SHAKE_BOTH = 4, i.Camera.SHAKE_HORIZONTAL = 5, i.Camera.SHAKE_VERTICAL = 6, i.Camera.ENABLE_FX = !0, i.Camera.prototype = {
            boot: function() {
                this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, i.Graphics && i.Camera.ENABLE_FX && (this.fx = new i.Graphics(this.game), this.game.stage.addChild(this.fx))
            },
            preUpdate: function() {
                this.totalInView = 0
            },
            follow: function(t, e, o, s) {
                void 0 === e && (e = i.Camera.FOLLOW_LOCKON), void 0 === o && (o = 1), void 0 === s && (s = 1), this.target = t, this.lerp.set(o, s);
                var n;
                switch (e) {
                    case i.Camera.FOLLOW_PLATFORMER:
                        var r = this.width / 8,
                            a = this.height / 3;
                        this.deadzone = new i.Rectangle((this.width - r) / 2, (this.height - a) / 2 - .25 * a, r, a);
                        break;
                    case i.Camera.FOLLOW_TOPDOWN:
                        n = Math.max(this.width, this.height) / 4, this.deadzone = new i.Rectangle((this.width - n) / 2, (this.height - n) / 2, n, n);
                        break;
                    case i.Camera.FOLLOW_TOPDOWN_TIGHT:
                        n = Math.max(this.width, this.height) / 8, this.deadzone = new i.Rectangle((this.width - n) / 2, (this.height - n) / 2, n, n);
                        break;
                    case i.Camera.FOLLOW_LOCKON:
                    default:
                        this.deadzone = null
                }
            },
            unfollow: function() {
                this.target = null
            },
            focusOn: function(t) {
                this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
            },
            focusOnXY: function(t, e) {
                this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
            },
            shake: function(t, e, o, s, n) {
                return void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === o && (o = !0), void 0 === s && (s = i.Camera.SHAKE_BOTH), void 0 === n && (n = !0), !(!o && this._shake.duration > 0) && (this._shake.intensity = t, this._shake.duration = e, this._shake.shakeBounds = n, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = s === i.Camera.SHAKE_BOTH || s === i.Camera.SHAKE_HORIZONTAL, this._shake.vertical = s === i.Camera.SHAKE_BOTH || s === i.Camera.SHAKE_VERTICAL, !0)
            },
            flash: function(t, e, i) {
                return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, this._fxType = 0, !0)
            },
            fade: function(t, e, i) {
                return void 0 === t && (t = 0), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, !0)
            },
            update: function() {
                this._fxDuration > 0 && this.updateFX(), this._shake.duration > 0 && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
            },
            updateFX: function() {
                0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
            },
            updateShake: function() {
                this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
            },
            updateTarget: function() {
                this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
            },
            setBoundsToWorld: function() {
                this.bounds && this.bounds.copyFrom(this.game.world.bounds)
            },
            checkBounds: function() {
                this.atLimit.x = !1, this.atLimit.y = !1;
                var t = this.view.x + this._shake.x,
                    e = this.view.right + this._shake.x,
                    i = this.view.y + this._shake.y,
                    o = this.view.bottom + this._shake.y;
                t <= this.bounds.x * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)), e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)), o >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
            },
            setPosition: function(t, e) {
                this.view.x = t, this.view.y = e, this.bounds && this.checkBounds()
            },
            setSize: function(t, e) {
                this.view.width = t, this.view.height = e
            },
            reset: function() {
                this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this.resetFX()
            },
            resetFX: function() {
                this.fx.clear(), this.fx.alpha = 0, this._fxDuration = 0
            }
        }, i.Camera.prototype.constructor = i.Camera, Object.defineProperty(i.Camera.prototype, "x", {
            get: function() {
                return this.view.x
            },
            set: function(t) {
                this.view.x = t, this.bounds && this.checkBounds()
            }
        }), Object.defineProperty(i.Camera.prototype, "y", {
            get: function() {
                return this.view.y
            },
            set: function(t) {
                this.view.y = t, this.bounds && this.checkBounds()
            }
        }), Object.defineProperty(i.Camera.prototype, "position", {
            get: function() {
                return this._position.set(this.view.x, this.view.y), this._position
            },
            set: function(t) {
                void 0 !== t.x && (this.view.x = t.x), void 0 !== t.y && (this.view.y = t.y), this.bounds && this.checkBounds()
            }
        }), Object.defineProperty(i.Camera.prototype, "width", {
            get: function() {
                return this.view.width
            },
            set: function(t) {
                this.view.width = t
            }
        }), Object.defineProperty(i.Camera.prototype, "height", {
            get: function() {
                return this.view.height
            },
            set: function(t) {
                this.view.height = t
            }
        }), Object.defineProperty(i.Camera.prototype, "shakeIntensity", {
            get: function() {
                return this._shake.intensity
            },
            set: function(t) {
                this._shake.intensity = t
            }
        }), i.State = function() {
            this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
        }, i.State.prototype = {
            init: function() {},
            preload: function() {},
            loadUpdate: function() {},
            loadRender: function() {},
            create: function() {},
            update: function() {},
            preRender: function() {},
            render: function() {},
            resize: function() {},
            paused: function() {},
            resumed: function() {},
            pauseUpdate: function() {},
            shutdown: function() {}
        }, i.State.prototype.constructor = i.State, i.StateManager = function(t, e) {
            this.game = t, this.states = {}, this._pendingState = null, void 0 !== e && null !== e && (this._pendingState = e), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new i.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
        }, i.StateManager.prototype = {
            boot: function() {
                this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
            },
            add: function(t, e, o) {
                void 0 === o && (o = !1);
                var s;
                return e instanceof i.State ? s = e : "object" == typeof e ? (s = e, s.game = this.game) : "function" == typeof e && (s = new e(this.game)), this.states[t] = s, o && (this.game.isBooted ? this.start(t) : this._pendingState = t), s
            },
            remove: function(t) {
                this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t]
            },
            start: function(t, e, i) {
                void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)))
            },
            restart: function(t, e) {
                void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2))
            },
            dummy: function() {},
            preUpdate: function() {
                if (this._pendingState && this.game.isBooted) {
                    var t = this.current;
                    if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current !== this._pendingState) return;
                    this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                }
            },
            clearCurrentState: function() {
                this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
            },
            checkState: function(t) {
                return this.states[t] ? !!(this.states[t].preload || this.states[t].create || this.states[t].update || this.states[t].render) || (console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render"), !1) : (console.warn("Phaser.StateManager - No state found with the key: " + t), !1)
            },
            link: function(t) {
                this.states[t].game = this.game, this.states[t].add = this.game.add, this.states[t].make = this.game.make, this.states[t].camera = this.game.camera, this.states[t].cache = this.game.cache, this.states[t].input = this.game.input, this.states[t].load = this.game.load, this.states[t].math = this.game.math, this.states[t].sound = this.game.sound, this.states[t].scale = this.game.scale, this.states[t].state = this, this.states[t].stage = this.game.stage, this.states[t].time = this.game.time, this.states[t].tweens = this.game.tweens, this.states[t].world = this.game.world, this.states[t].particles = this.game.particles, this.states[t].rnd = this.game.rnd, this.states[t].physics = this.game.physics, this.states[t].key = t
            },
            unlink: function(t) {
                this.states[t] && (this.states[t].game = null, this.states[t].add = null, this.states[t].make = null, this.states[t].camera = null, this.states[t].cache = null, this.states[t].input = null, this.states[t].load = null, this.states[t].math = null, this.states[t].sound = null, this.states[t].scale = null, this.states[t].state = null, this.states[t].stage = null, this.states[t].time = null, this.states[t].tweens = null, this.states[t].world = null, this.states[t].particles = null, this.states[t].rnd = null, this.states[t].physics = null)
            },
            setCurrentState: function(t) {
                this.callbackContext = this.states[t], this.link(t), this.onInitCallback = this.states[t].init || this.dummy, this.onPreloadCallback = this.states[t].preload || null, this.onLoadRenderCallback = this.states[t].loadRender || null, this.onLoadUpdateCallback = this.states[t].loadUpdate || null, this.onCreateCallback = this.states[t].create || null, this.onUpdateCallback = this.states[t].update || null, this.onPreRenderCallback = this.states[t].preRender || null, this.onRenderCallback = this.states[t].render || null, this.onResizeCallback = this.states[t].resize || null, this.onPausedCallback = this.states[t].paused || null, this.onResumedCallback = this.states[t].resumed || null, this.onPauseUpdateCallback = this.states[t].pauseUpdate || null, this.onShutDownCallback = this.states[t].shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0
            },
            getCurrentState: function() {
                return this.states[this.current]
            },
            loadComplete: function() {
                !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
            },
            pause: function() {
                this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
            },
            resume: function() {
                this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
            },
            update: function() {
                this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
            },
            pauseUpdate: function() {
                this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
            },
            preRender: function(t) {
                this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t)
            },
            resize: function(t, e) {
                this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
            },
            render: function() {
                this._created ? this.onRenderCallback && (this.game.renderType === i.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
            },
            destroy: function() {
                this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = ""
            }
        }, i.StateManager.prototype.constructor = i.StateManager, Object.defineProperty(i.StateManager.prototype, "created", {
            get: function() {
                return this._created
            }
        }), i.Signal = function() {}, i.Signal.prototype = {
            _bindings: null,
            _prevParams: null,
            memorize: !1,
            _shouldPropagate: !0,
            active: !0,
            _boundDispatch: !1,
            validateListener: function(t, e) {
                if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
            },
            _registerListener: function(t, e, o, s, n) {
                var r, a = this._indexOfListener(t, o);
                if (-1 !== a) {
                    if (r = this._bindings[a], r.isOnce() !== e) throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.")
                } else r = new i.SignalBinding(this, t, e, o, s, n), this._addBinding(r);
                return this.memorize && this._prevParams && r.execute(this._prevParams), r
            },
            _addBinding: function(t) {
                this._bindings || (this._bindings = []);
                var e = this._bindings.length;
                do {
                    e--
                } while (this._bindings[e] && t._priority <= this._bindings[e]._priority);
                this._bindings.splice(e + 1, 0, t)
            },
            _indexOfListener: function(t, e) {
                if (!this._bindings) return -1;
                void 0 === e && (e = null);
                for (var i, o = this._bindings.length; o--;)
                    if (i = this._bindings[o], i._listener === t && i.context === e) return o;
                return -1
            },
            has: function(t, e) {
                return -1 !== this._indexOfListener(t, e)
            },
            add: function(t, e, i) {
                this.validateListener(t, "add");
                var o = [];
                if (arguments.length > 3)
                    for (var s = 3; s < arguments.length; s++) o.push(arguments[s]);
                return this._registerListener(t, !1, e, i, o)
            },
            addOnce: function(t, e, i) {
                this.validateListener(t, "addOnce");
                var o = [];
                if (arguments.length > 3)
                    for (var s = 3; s < arguments.length; s++) o.push(arguments[s]);
                return this._registerListener(t, !0, e, i, o)
            },
            remove: function(t, e) {
                this.validateListener(t, "remove");
                var i = this._indexOfListener(t, e);
                return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t
            },
            removeAll: function(t) {
                if (void 0 === t && (t = null), this._bindings) {
                    for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                    t || (this._bindings.length = 0)
                }
            },
            getNumListeners: function() {
                return this._bindings ? this._bindings.length : 0
            },
            halt: function() {
                this._shouldPropagate = !1
            },
            dispatch: function() {
                if (this.active && this._bindings) {
                    var t, e = Array.prototype.slice.call(arguments),
                        i = this._bindings.length;
                    if (this.memorize && (this._prevParams = e), i) {
                        t = this._bindings.slice(), this._shouldPropagate = !0;
                        do {
                            i--
                        } while (t[i] && this._shouldPropagate && !1 !== t[i].execute(e))
                    }
                }
            },
            forget: function() {
                this._prevParams && (this._prevParams = null)
            },
            dispose: function() {
                this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null)
            },
            toString: function() {
                return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
            }
        }, Object.defineProperty(i.Signal.prototype, "boundDispatch", {
            get: function() {
                var t = this;
                return this._boundDispatch || (this._boundDispatch = function() {
                    return t.dispatch.apply(t, arguments)
                })
            }
        }), i.Signal.prototype.constructor = i.Signal, i.SignalBinding = function(t, e, i, o, s, n) {
            this._listener = e, i && (this._isOnce = !0), null != o && (this.context = o), this._signal = t, s && (this._priority = s), n && n.length && (this._args = n)
        }, i.SignalBinding.prototype = {
            context: null,
            _isOnce: !1,
            _priority: 0,
            _args: null,
            callCount: 0,
            active: !0,
            params: null,
            execute: function(t) {
                var e, i;
                return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()), e
            },
            detach: function() {
                return this.isBound() ? this._signal.remove(this._listener, this.context) : null
            },
            isBound: function() {
                return !!this._signal && !!this._listener
            },
            isOnce: function() {
                return this._isOnce
            },
            getListener: function() {
                return this._listener
            },
            getSignal: function() {
                return this._signal
            },
            _destroy: function() {
                delete this._signal, delete this._listener, delete this.context
            },
            toString: function() {
                return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
            }
        }, i.SignalBinding.prototype.constructor = i.SignalBinding, i.Filter = function(t, e, o) {
            this.game = t, this.type = i.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new i.Point;
            var s = new Date;
            if (this.uniforms = {
                    resolution: {
                        type: "2f",
                        value: {
                            x: 256,
                            y: 256
                        }
                    },
                    time: {
                        type: "1f",
                        value: 0
                    },
                    mouse: {
                        type: "2f",
                        value: {
                            x: 0,
                            y: 0
                        }
                    },
                    date: {
                        type: "4fv",
                        value: [s.getFullYear(), s.getMonth(), s.getDate(), 60 * s.getHours() * 60 + 60 * s.getMinutes() + s.getSeconds()]
                    },
                    sampleRate: {
                        type: "1f",
                        value: 44100
                    },
                    iChannel0: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    },
                    iChannel1: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    },
                    iChannel2: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    },
                    iChannel3: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    }
                }, e)
                for (var n in e) this.uniforms[n] = e[n];
            this.fragmentSrc = o || ""
        }, i.Filter.prototype = {
            init: function() {},
            setResolution: function(t, e) {
                this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e
            },
            update: function(t) {
                if (void 0 !== t) {
                    var e = t.x / this.game.width,
                        i = 1 - t.y / this.game.height;
                    e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = i.toFixed(2), this.prevPoint.set(e, i))
                }
                this.uniforms.time.value = this.game.time.totalElapsedSeconds()
            },
            addToWorld: function(t, e, i, o, s, n) {
                void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 !== i && null !== i ? this.width = i : i = this.width, void 0 !== o && null !== o ? this.height = o : o = this.height;
                var r = this.game.add.image(t, e, "__default");
                return r.width = i, r.height = o, r.anchor.set(s, n), r.filters = [this], r
            },
            destroy: function() {
                this.game = null
            }
        }, i.Filter.prototype.constructor = i.Filter, Object.defineProperty(i.Filter.prototype, "width", {
            get: function() {
                return this.uniforms.resolution.value.x
            },
            set: function(t) {
                this.uniforms.resolution.value.x = t
            }
        }), Object.defineProperty(i.Filter.prototype, "height", {
            get: function() {
                return this.uniforms.resolution.value.y
            },
            set: function(t) {
                this.uniforms.resolution.value.y = t
            }
        }), i.Plugin = function(t, e) {
            void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
        }, i.Plugin.prototype = {
            preUpdate: function() {},
            update: function() {},
            render: function() {},
            postRender: function() {},
            destroy: function() {
                this.game = null, this.parent = null, this.active = !1, this.visible = !1
            }
        }, i.Plugin.prototype.constructor = i.Plugin, i.PluginManager = function(t) {
            this.game = t, this.plugins = [], this._len = 0, this._i = 0
        }, i.PluginManager.prototype = {
            add: function(t) {
                var e = Array.prototype.slice.call(arguments, 1),
                    i = !1;
                return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (t.hasPreUpdate = !0, i = !0), "function" == typeof t.update && (t.hasUpdate = !0, i = !0), "function" == typeof t.postUpdate && (t.hasPostUpdate = !0, i = !0), "function" == typeof t.render && (t.hasRender = !0, i = !0), "function" == typeof t.postRender && (t.hasPostRender = !0, i = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
            },
            remove: function(t, e) {
                for (void 0 === e && (e = !0), this._i = this._len; this._i--;)
                    if (this.plugins[this._i] === t) return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len--
            },
            removeAll: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                this.plugins.length = 0, this._len = 0
            },
            preUpdate: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
            },
            update: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
            },
            postUpdate: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
            },
            render: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
            },
            postRender: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
            },
            destroy: function() {
                this.removeAll(), this.game = null
            }
        }, i.PluginManager.prototype.constructor = i.PluginManager, i.Stage = function(t) {
            this.game = t, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new PIXI.Matrix, this.stage = this, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
                color: 0,
                rgba: "#000000"
            }, this.game.transparent || (this._bgColor.a = 1), t.config && this.parseConfig(t.config)
        }, i.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.Stage.prototype.constructor = i.Stage, i.Stage.prototype.parseConfig = function(t) {
            t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
        }, i.Stage.prototype.boot = function() {
            i.DOM.getOffset(this.game.canvas, this.offset), i.Canvas.setUserSelect(this.game.canvas, "none"), i.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
        }, i.Stage.prototype.preUpdate = function() {
            this.currentRenderOrderID = 0;
            for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate()
        }, i.Stage.prototype.update = function() {
            for (var t = this.children.length; t--;) this.children[t].update()
        }, i.Stage.prototype.postUpdate = function() {
            this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
            for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
            this.updateTransform()
        }, i.Stage.prototype.updateTransform = function() {
            this.worldAlpha = 1;
            for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
        }, i.Stage.prototype.checkVisibility = function() {
            void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
            var t = this;
            this._onChange = function(e) {
                return t.visibilityChange(e)
            }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
                i.Stage.prototype.visibilityChange.call(t, {
                    type: "pause"
                })
            }), CocoonJS.App.onActivated.addEventListener(function() {
                i.Stage.prototype.visibilityChange.call(t, {
                    type: "resume"
                })
            }))
        }, i.Stage.prototype.visibilityChange = function(t) {
            if ("pagehide" === t.type || "blur" === t.type || "pageshow" === t.type || "focus" === t.type) return void("pagehide" === t.type || "blur" === t.type ? this.game.focusLoss(t) : "pageshow" !== t.type && "focus" !== t.type || this.game.focusGain(t));
            this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t))
        }, i.Stage.prototype.setBackgroundColor = function(t) {
            this.game.transparent || (i.Color.valueToColor(t, this._bgColor), i.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
        }, i.Stage.prototype.destroy = function() {
            this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null
        }, Object.defineProperty(i.Stage.prototype, "backgroundColor", {
            get: function() {
                return this._bgColor.color
            },
            set: function(t) {
                this.setBackgroundColor(t)
            }
        }), Object.defineProperty(i.Stage.prototype, "smoothed", {
            get: function() {
                return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
            },
            set: function(t) {
                PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST
            }
        }), i.Group = function(t, e, o, s, n, r) {
            void 0 === s && (s = !1), void 0 === n && (n = !1), void 0 === r && (r = i.Physics.ARCADE), this.game = t, void 0 === e && (e = t.world), this.name = o || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), s ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : e && (e.addChild(this), this.z = e.children.length), this.type = i.GROUP, this.physicsType = i.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = i.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.onChildInputDown = new i.Signal, this.onChildInputUp = new i.Signal, this.onChildInputOver = new i.Signal, this.onChildInputOut = new i.Signal, this.enableBody = n, this.enableBodyDebug = !1, this.physicsBodyType = r, this.physicsSortDirection = null, this.onDestroy = new i.Signal, this.cursorIndex = 0, this.hash = [], this._sortProperty = "z"
        }, i.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.Group.prototype.constructor = i.Group, i.Group.RETURN_NONE = 0, i.Group.RETURN_TOTAL = 1, i.Group.RETURN_CHILD = 2, i.Group.RETURN_ALL = 3, i.Group.SORT_ASCENDING = -1, i.Group.SORT_DESCENDING = 1, i.Group.prototype.add = function(t, e, i) {
            return void 0 === e && (e = !1), t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t), t)
        }, i.Group.prototype.addAt = function(t, e, i) {
            this.add(t, i, e)
        }, i.Group.prototype.addToHash = function(t) {
            if (t.parent === this) {
                if (-1 === this.hash.indexOf(t)) return this.hash.push(t), !0
            }
            return !1
        }, i.Group.prototype.removeFromHash = function(t) {
            if (t) {
                var e = this.hash.indexOf(t);
                if (-1 !== e) return this.hash.splice(e, 1), !0
            }
            return !1
        }, i.Group.prototype.addMultiple = function(t, e) {
            if (t instanceof i.Group) t.moveAll(this, e);
            else if (Array.isArray(t))
                for (var o = 0; o < t.length; o++) this.add(t[o], e);
            return t
        }, i.Group.prototype.getAt = function(t) {
            return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
        }, i.Group.prototype.create = function(t, e, i, o, s, n) {
            void 0 === s && (s = !0);
            var r = new this.classType(this.game, t, e, i, o);
            return r.exists = s, r.visible = s, r.alive = s, this.add(r, !1, n)
        }, i.Group.prototype.createMultiple = function(t, e, i, o) {
            void 0 === i && (i = 0), void 0 === o && (o = !1), Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
            var s = this,
                n = [];
            return e.forEach(function(e) {
                i.forEach(function(i) {
                    for (var r = 0; r < t; r++) n.push(s.create(0, 0, e, i, o))
                })
            }), n
        }, i.Group.prototype.updateZ = function() {
            for (var t = this.children.length; t--;) this.children[t].z = t
        }, i.Group.prototype.align = function(t, e, o, s, n, r) {
            if (void 0 === n && (n = i.TOP_LEFT), void 0 === r && (r = 0), 0 === this.children.length || r > this.children.length || -1 === t && -1 === e) return !1;
            for (var a = new i.Rectangle(0, 0, o, s), h = t * o, l = e * s, d = r; d < this.children.length; d++) {
                var c = this.children[d];
                if (c.alignIn)
                    if (c.alignIn(a, n), -1 === t) a.y += s, a.y === l && (a.x += o, a.y = 0);
                    else if (-1 === e) a.x += o, a.x === h && (a.x = 0, a.y += s);
                else if (a.x += o, a.x === h && (a.x = 0, a.y += s, a.y === l)) return !0
            }
            return !0
        };
        i.Group.prototype.resetCursor = function(t) {
            if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor
        }, i.Group.prototype.next = function() {
            if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor
        }, i.Group.prototype.previous = function() {
            if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor
        }, i.Group.prototype.swap = function(t, e) {
            this.swapChildren(t, e), this.updateZ()
        }, i.Group.prototype.bringToTop = function(t) {
            return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t
        }, i.Group.prototype.sendToBack = function(t) {
            return t.parent === this && this.getIndex(t) > 0 && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t
        }, i.Group.prototype.moveUp = function(t) {
            if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
                var e = this.getIndex(t),
                    i = this.getAt(e + 1);
                i && this.swap(t, i)
            }
            return t
        }, i.Group.prototype.moveDown = function(t) {
            if (t.parent === this && this.getIndex(t) > 0) {
                var e = this.getIndex(t),
                    i = this.getAt(e - 1);
                i && this.swap(t, i)
            }
            return t
        }, i.Group.prototype.xy = function(t, e, i) {
            if (t < 0 || t > this.children.length) return -1;
            this.getChildAt(t).x = e, this.getChildAt(t).y = i
        }, i.Group.prototype.reverse = function() {
            this.children.reverse(), this.updateZ()
        }, i.Group.prototype.getIndex = function(t) {
            return this.children.indexOf(t)
        }, i.Group.prototype.getByName = function(t) {
            for (var e = 0; e < this.children.length; e++)
                if (this.children[e].name === t) return this.children[e];
            return null
        }, i.Group.prototype.replace = function(t, e) {
            var o = this.getIndex(t);
            if (-1 !== o) return e.parent && (e.parent instanceof i.Group ? e.parent.remove(e) : e.parent.removeChild(e)), this.remove(t), this.addAt(e, o), t
        }, i.Group.prototype.hasProperty = function(t, e) {
            var i = e.length;
            return 1 === i && e[0] in t || (2 === i && e[0] in t && e[1] in t[e[0]] || (3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]]))
        }, i.Group.prototype.setProperty = function(t, e, i, o, s) {
            if (void 0 === s && (s = !1), o = o || 0, !this.hasProperty(t, e) && (!s || o > 0)) return !1;
            var n = e.length;
            return 1 === n ? 0 === o ? t[e[0]] = i : 1 === o ? t[e[0]] += i : 2 === o ? t[e[0]] -= i : 3 === o ? t[e[0]] *= i : 4 === o && (t[e[0]] /= i) : 2 === n ? 0 === o ? t[e[0]][e[1]] = i : 1 === o ? t[e[0]][e[1]] += i : 2 === o ? t[e[0]][e[1]] -= i : 3 === o ? t[e[0]][e[1]] *= i : 4 === o && (t[e[0]][e[1]] /= i) : 3 === n ? 0 === o ? t[e[0]][e[1]][e[2]] = i : 1 === o ? t[e[0]][e[1]][e[2]] += i : 2 === o ? t[e[0]][e[1]][e[2]] -= i : 3 === o ? t[e[0]][e[1]][e[2]] *= i : 4 === o && (t[e[0]][e[1]][e[2]] /= i) : 4 === n && (0 === o ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === o ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === o ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === o ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === o && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0
        }, i.Group.prototype.checkProperty = function(t, e, o, s) {
            return void 0 === s && (s = !1), !(!i.Utils.getProperty(t, e) && s) && i.Utils.getProperty(t, e) === o
        }, i.Group.prototype.set = function(t, e, i, o, s, n, r) {
            if (void 0 === r && (r = !1), e = e.split("."), void 0 === o && (o = !1), void 0 === s && (s = !1), (!1 === o || o && t.alive) && (!1 === s || s && t.visible)) return this.setProperty(t, e, i, n, r)
        }, i.Group.prototype.setAll = function(t, e, i, o, s, n) {
            void 0 === i && (i = !1), void 0 === o && (o = !1), void 0 === n && (n = !1), t = t.split("."), s = s || 0;
            for (var r = 0; r < this.children.length; r++)(!i || i && this.children[r].alive) && (!o || o && this.children[r].visible) && this.setProperty(this.children[r], t, e, s, n)
        }, i.Group.prototype.setAllChildren = function(t, e, o, s, n, r) {
            void 0 === o && (o = !1), void 0 === s && (s = !1), void 0 === r && (r = !1), n = n || 0;
            for (var a = 0; a < this.children.length; a++)(!o || o && this.children[a].alive) && (!s || s && this.children[a].visible) && (this.children[a] instanceof i.Group ? this.children[a].setAllChildren(t, e, o, s, n, r) : this.setProperty(this.children[a], t.split("."), e, n, r))
        }, i.Group.prototype.checkAll = function(t, e, i, o, s) {
            void 0 === i && (i = !1), void 0 === o && (o = !1), void 0 === s && (s = !1);
            for (var n = 0; n < this.children.length; n++)
                if ((!i || i && this.children[n].alive) && (!o || o && this.children[n].visible) && !this.checkProperty(this.children[n], t, e, s)) return !1;
            return !0
        }, i.Group.prototype.addAll = function(t, e, i, o) {
            this.setAll(t, e, i, o, 1)
        }, i.Group.prototype.subAll = function(t, e, i, o) {
            this.setAll(t, e, i, o, 2)
        }, i.Group.prototype.multiplyAll = function(t, e, i, o) {
            this.setAll(t, e, i, o, 3)
        }, i.Group.prototype.divideAll = function(t, e, i, o) {
            this.setAll(t, e, i, o, 4)
        }, i.Group.prototype.callAllExists = function(t, e) {
            var i;
            if (arguments.length > 2) {
                i = [];
                for (var o = 2; o < arguments.length; o++) i.push(arguments[o])
            }
            for (var o = 0; o < this.children.length; o++) this.children[o].exists === e && this.children[o][t] && this.children[o][t].apply(this.children[o], i)
        }, i.Group.prototype.callbackFromArray = function(t, e, i) {
            if (1 === i) {
                if (t[e[0]]) return t[e[0]]
            } else if (2 === i) {
                if (t[e[0]][e[1]]) return t[e[0]][e[1]]
            } else if (3 === i) {
                if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]]
            } else if (4 === i) {
                if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]]
            } else if (t[e]) return t[e];
            return !1
        }, i.Group.prototype.callAll = function(t, e) {
            if (void 0 !== t) {
                t = t.split(".");
                var i = t.length;
                if (void 0 === e || null === e || "" === e) e = null;
                else if ("string" == typeof e) {
                    e = e.split(".");
                    var o = e.length
                }
                var s;
                if (arguments.length > 2) {
                    s = [];
                    for (var n = 2; n < arguments.length; n++) s.push(arguments[n])
                }
                for (var r = null, a = null, n = 0; n < this.children.length; n++) r = this.callbackFromArray(this.children[n], t, i), e && r ? (a = this.callbackFromArray(this.children[n], e, o), r && r.apply(a, s)) : r && r.apply(this.children[n], s)
            }
        }, i.Group.prototype.preUpdate = function() {
            if (this.pendingDestroy) return this.destroy(), !1;
            if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
            for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
            return !0
        }, i.Group.prototype.update = function() {
            for (var t = this.children.length; t--;) this.children[t].update()
        }, i.Group.prototype.postUpdate = function() {
            for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
        }, i.Group.prototype.filter = function(t, e) {
            for (var o = -1, s = this.children.length, n = []; ++o < s;) {
                var r = this.children[o];
                (!e || e && r.exists) && t(r, o, this.children) && n.push(r)
            }
            return new i.ArraySet(n)
        }, i.Group.prototype.forEach = function(t, e, i) {
            if (void 0 === i && (i = !1), arguments.length <= 3)
                for (var o = 0; o < this.children.length; o++)(!i || i && this.children[o].exists) && t.call(e, this.children[o]);
            else {
                for (var s = [null], o = 3; o < arguments.length; o++) s.push(arguments[o]);
                for (var o = 0; o < this.children.length; o++)(!i || i && this.children[o].exists) && (s[0] = this.children[o], t.apply(e, s))
            }
        }, i.Group.prototype.forEachExists = function(t, e) {
            var o;
            if (arguments.length > 2) {
                o = [null];
                for (var s = 2; s < arguments.length; s++) o.push(arguments[s])
            }
            this.iterate("exists", !0, i.Group.RETURN_TOTAL, t, e, o)
        }, i.Group.prototype.forEachAlive = function(t, e) {
            var o;
            if (arguments.length > 2) {
                o = [null];
                for (var s = 2; s < arguments.length; s++) o.push(arguments[s])
            }
            this.iterate("alive", !0, i.Group.RETURN_TOTAL, t, e, o)
        }, i.Group.prototype.forEachDead = function(t, e) {
            var o;
            if (arguments.length > 2) {
                o = [null];
                for (var s = 2; s < arguments.length; s++) o.push(arguments[s])
            }
            this.iterate("alive", !1, i.Group.RETURN_TOTAL, t, e, o)
        }, i.Group.prototype.sort = function(t, e) {
            this.children.length < 2 || (void 0 === t && (t = "z"), void 0 === e && (e = i.Group.SORT_ASCENDING), this._sortProperty = t, e === i.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
        }, i.Group.prototype.customSort = function(t, e) {
            this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
        }, i.Group.prototype.ascendingSortHandler = function(t, e) {
            return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
        }, i.Group.prototype.descendingSortHandler = function(t, e) {
            return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
        }, i.Group.prototype.iterate = function(t, e, o, s, n, r) {
            if (0 === this.children.length) {
                if (o === i.Group.RETURN_TOTAL) return 0;
                if (o === i.Group.RETURN_ALL) return []
            }
            var a = 0;
            if (o === i.Group.RETURN_ALL) var h = [];
            for (var l = 0; l < this.children.length; l++)
                if (this.children[l][t] === e) {
                    if (a++, s && (r ? (r[0] = this.children[l], s.apply(n, r)) : s.call(n, this.children[l])), o === i.Group.RETURN_CHILD) return this.children[l];
                    o === i.Group.RETURN_ALL && h.push(this.children[l])
                }
            return o === i.Group.RETURN_TOTAL ? a : o === i.Group.RETURN_ALL ? h : null
        }, i.Group.prototype.getFirstExists = function(t, e, o, s, n, r) {
            void 0 === e && (e = !1), "boolean" != typeof t && (t = !0);
            var a = this.iterate("exists", t, i.Group.RETURN_CHILD);
            return null === a && e ? this.create(o, s, n, r) : this.resetChild(a, o, s, n, r)
        }, i.Group.prototype.getFirstAlive = function(t, e, o, s, n) {
            void 0 === t && (t = !1);
            var r = this.iterate("alive", !0, i.Group.RETURN_CHILD);
            return null === r && t ? this.create(e, o, s, n) : this.resetChild(r, e, o, s, n)
        }, i.Group.prototype.getFirstDead = function(t, e, o, s, n) {
            void 0 === t && (t = !1);
            var r = this.iterate("alive", !1, i.Group.RETURN_CHILD);
            return null === r && t ? this.create(e, o, s, n) : this.resetChild(r, e, o, s, n)
        }, i.Group.prototype.resetChild = function(t, e, i, o, s) {
            return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== o && t.loadTexture(o, s), t)
        }, i.Group.prototype.getTop = function() {
            if (this.children.length > 0) return this.children[this.children.length - 1]
        }, i.Group.prototype.getBottom = function() {
            if (this.children.length > 0) return this.children[0]
        }, i.Group.prototype.getClosestTo = function(t, e, o) {
            for (var s = Number.MAX_VALUE, n = 0, r = null, a = 0; a < this.children.length; a++) {
                var h = this.children[a];
                h.exists && (n = Math.abs(i.Point.distance(t, h))) < s && (!e || e.call(o, h, n)) && (s = n, r = h)
            }
            return r
        }, i.Group.prototype.getFurthestFrom = function(t, e, o) {
            for (var s = 0, n = 0, r = null, a = 0; a < this.children.length; a++) {
                var h = this.children[a];
                h.exists && (n = Math.abs(i.Point.distance(t, h))) > s && (!e || e.call(o, h, n)) && (s = n, r = h)
            }
            return r
        }, i.Group.prototype.countLiving = function() {
            return this.iterate("alive", !0, i.Group.RETURN_TOTAL)
        }, i.Group.prototype.countDead = function() {
            return this.iterate("alive", !1, i.Group.RETURN_TOTAL)
        }, i.Group.prototype.getRandom = function(t, e) {
            return void 0 === t && (t = 0), void 0 === e && (e = this.children.length), 0 === e ? null : i.ArrayUtils.getRandomItem(this.children, t, e)
        }, i.Group.prototype.getRandomExists = function(t, e) {
            var i = this.getAll("exists", !0, t, e);
            return this.game.rnd.pick(i)
        }, i.Group.prototype.getAll = function(t, e, i, o) {
            void 0 === i && (i = 0), void 0 === o && (o = this.children.length);
            for (var s = [], n = i; n < o; n++) {
                var r = this.children[n];
                t && r[t] === e && s.push(r)
            }
            return s
        }, i.Group.prototype.remove = function(t, e, i) {
            if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
            i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
            var o = this.removeChild(t);
            return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && o && o.destroy(!0), !0
        }, i.Group.prototype.moveAll = function(t, e) {
            if (void 0 === e && (e = !1), this.children.length > 0 && t instanceof i.Group) {
                do {
                    t.add(this.children[0], e)
                } while (this.children.length > 0);
                this.hash = [], this.cursor = null
            }
            return t
        }, i.Group.prototype.removeAll = function(t, e, i) {
            if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
                do {
                    !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                    var o = this.removeChild(this.children[0]);
                    this.removeFromHash(o), t && o && o.destroy(!0, i)
                } while (this.children.length > 0);
                this.hash = [], this.cursor = null
            }
        }, i.Group.prototype.removeBetween = function(t, e, i, o) {
            if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === o && (o = !1), 0 !== this.children.length) {
                if (t > e || t < 0 || e > this.children.length) return !1;
                for (var s = e; s >= t;) {
                    !o && this.children[s].events && this.children[s].events.onRemovedFromGroup$dispatch(this.children[s], this);
                    var n = this.removeChild(this.children[s]);
                    this.removeFromHash(n), i && n && n.destroy(!0), this.cursor === this.children[s] && (this.cursor = null), s--
                }
                this.updateZ()
            }
        }, i.Group.prototype.destroy = function(t, e) {
            null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
        }, Object.defineProperty(i.Group.prototype, "total", {
            get: function() {
                return this.iterate("exists", !0, i.Group.RETURN_TOTAL)
            }
        }), Object.defineProperty(i.Group.prototype, "length", {
            get: function() {
                return this.children.length
            }
        }), Object.defineProperty(i.Group.prototype, "angle", {
            get: function() {
                return i.Math.radToDeg(this.rotation)
            },
            set: function(t) {
                this.rotation = i.Math.degToRad(t)
            }
        }), Object.defineProperty(i.Group.prototype, "centerX", {
            get: function() {
                return this.getBounds(this.parent).centerX
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.x - e.x;
                this.x = t + i - e.halfWidth
            }
        }), Object.defineProperty(i.Group.prototype, "centerY", {
            get: function() {
                return this.getBounds(this.parent).centerY
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.y - e.y;
                this.y = t + i - e.halfHeight
            }
        }), Object.defineProperty(i.Group.prototype, "left", {
            get: function() {
                return this.getBounds(this.parent).left
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.x - e.x;
                this.x = t + i
            }
        }), Object.defineProperty(i.Group.prototype, "right", {
            get: function() {
                return this.getBounds(this.parent).right
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.x - e.x;
                this.x = t + i - e.width
            }
        }), Object.defineProperty(i.Group.prototype, "top", {
            get: function() {
                return this.getBounds(this.parent).top
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.y - e.y;
                this.y = t + i
            }
        }), Object.defineProperty(i.Group.prototype, "bottom", {
            get: function() {
                return this.getBounds(this.parent).bottom
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.y - e.y;
                this.y = t + i - e.height
            }
        }), i.World = function(t) {
            i.Group.call(this, t, null, "__world", !1), this.bounds = new i.Rectangle(0, 0, t.width, t.height), this.camera = null, this._definedSize = !1, this._width = t.width, this._height = t.height, this.game.state.onStateChange.add(this.stateChange, this)
        }, i.World.prototype = Object.create(i.Group.prototype), i.World.prototype.constructor = i.World, i.World.prototype.boot = function() {
            this.camera = new i.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot()
        }, i.World.prototype.stateChange = function() {
            this.x = 0, this.y = 0, this.camera.reset()
        }, i.World.prototype.setBounds = function(t, e, i, o) {
            this._definedSize = !0, this._width = i, this._height = o, this.bounds.setTo(t, e, i, o), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(o, this.game.height)), this.game.physics.setBoundsToWorld()
        }, i.World.prototype.resize = function(t, e) {
            this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld()
        }, i.World.prototype.shutdown = function() {
            this.destroy(!0, !0)
        }, i.World.prototype.wrap = function(t, e, i, o, s) {
            void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === o && (o = !0), void 0 === s && (s = !0), i ? (t.getBounds(), o && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), s && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (o && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : o && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), s && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : s && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
        }, Object.defineProperty(i.World.prototype, "width", {
            get: function() {
                return this.bounds.width
            },
            set: function(t) {
                t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0
            }
        }), Object.defineProperty(i.World.prototype, "height", {
            get: function() {
                return this.bounds.height
            },
            set: function(t) {
                t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0
            }
        }), Object.defineProperty(i.World.prototype, "centerX", {
            get: function() {
                return this.bounds.halfWidth + this.bounds.x
            }
        }), Object.defineProperty(i.World.prototype, "centerY", {
            get: function() {
                return this.bounds.halfHeight + this.bounds.y
            }
        }), Object.defineProperty(i.World.prototype, "randomX", {
            get: function() {
                return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
            }
        }), Object.defineProperty(i.World.prototype, "randomY", {
            get: function() {
                return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
            }
        }), i.Game = function(t, e, o, s, n, r, a, h) {
            return this.id = i.GAMES.push(this) - 1, this.config = null, this.physicsConfig = h, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = i.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = i.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new i.Signal, this.forceSingleUpdate = !0, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
                enableDebug: !0
            }, void 0 !== t && (this._width = t), void 0 !== e && (this._height = e), void 0 !== o && (this.renderType = o), void 0 !== s && (this.parent = s), void 0 !== r && (this.transparent = r), void 0 !== a && (this.antialias = a), this.rnd = new i.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new i.StateManager(this, n)), this.device.whenReady(this.boot, this), this
        }, i.Game.prototype = {
            parseConfig: function(t) {
                this.config = t, void 0 === t.enableDebug && (this.config.enableDebug = !0), t.width && (this._width = t.width), t.height && (this._height = t.height), t.renderer && (this.renderType = t.renderer), t.parent && (this.parent = t.parent), void 0 !== t.transparent && (this.transparent = t.transparent), void 0 !== t.antialias && (this.antialias = t.antialias), t.resolution && (this.resolution = t.resolution), void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), t.physicsConfig && (this.physicsConfig = t.physicsConfig);
                var e = [(Date.now() * Math.random()).toString()];
                t.seed && (e = t.seed), this.rnd = new i.RandomDataGenerator(e);
                var o = null;
                t.state && (o = t.state), this.state = new i.StateManager(this, o)
            },
            boot: function() {
                this.isBooted || (this.onPause = new i.Signal, this.onResume = new i.Signal, this.onBlur = new i.Signal, this.onFocus = new i.Signal, this.isBooted = !0, PIXI.game = this, this.math = i.Math, this.scale = new i.ScaleManager(this, this._width, this._height), this.stage = new i.Stage(this), this.setUpRenderer(), this.world = new i.World(this), this.add = new i.GameObjectFactory(this), this.make = new i.GameObjectCreator(this), this.cache = new i.Cache(this), this.load = new i.Loader(this), this.time = new i.Time(this), this.tweens = new i.TweenManager(this), this.input = new i.Input(this), this.sound = new i.SoundManager(this), this.physics = new i.Physics(this, this.physicsConfig), this.particles = new i.Particles(this), this.create = new i.Create(this), this.plugins = new i.PluginManager(this), this.net = new i.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new i.Utils.Debug(this), this.debug.boot()) : this.debug = {
                    preUpdate: function() {},
                    update: function() {},
                    reset: function() {}
                }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new i.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new i.RequestAnimationFrame(this, !1), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.raf.start())
            },
            showDebugHeader: function() {
                if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                    var t = i.VERSION,
                        e = "Canvas",
                        o = "HTML Audio",
                        s = 1;
                    if (this.renderType === i.WEBGL ? (e = "WebGL", s++) : this.renderType === i.HEADLESS && (e = "Headless"), this.device.webAudio && (o = "WebAudio", s++), this.device.chrome) {
                        for (var n = ["%c %c %c Phaser v" + t + " | Pixi.js | " + e + " | " + o + "  %c %c %c http://phaser.io %c♥%c♥%c♥", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"], r = 0; r < 3; r++) r < s ? n.push("color: #ff2424; background: #fff") : n.push("color: #959595; background: #fff");
                        console.log.apply(console, n)
                    } else window.console && console.log("Phaser v" + t + " | Pixi.js " + PIXI.VERSION + " | " + e + " | " + o + " | http://phaser.io")
                }
            },
            setUpRenderer: function() {
                if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = i.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.renderType === i.HEADLESS || this.renderType === i.CANVAS || this.renderType === i.AUTO && !this.device.webGL) {
                    if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                    this.renderType = i.CANVAS, this.renderer = new PIXI.CanvasRenderer(this), this.context = this.renderer.context
                } else this.renderType = i.WEBGL, this.renderer = new PIXI.WebGLRenderer(this), this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
                this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === i.CANVAS), this.renderType !== i.HEADLESS && (this.stage.smoothed = this.antialias, i.Canvas.addToDOM(this.canvas, this.parent, !1), i.Canvas.setTouchAction(this.canvas))
            },
            contextLost: function(t) {
                t.preventDefault(), this.renderer.contextLost = !0
            },
            contextRestored: function() {
                this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1
            },
            update: function(t) {
                if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1);
                if (this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps);
                else {
                    var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                    this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                    var i = 0;
                    for (this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);) this.time.refresh();
                    i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.updateRender(this._deltaTime / e)
                }
            },
            updateLogic: function(t) {
                this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate())
            },
            updateRender: function(t) {
                this.lockRender || (this.state.preRender(t), this.renderType !== i.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(t), this.state.render(t)), this.plugins.postRender(t))
            },
            enableStep: function() {
                this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
            },
            disableStep: function() {
                this.stepping = !1, this.pendingStep = !1
            },
            step: function() {
                this.pendingStep = !1, this.stepCount++
            },
            destroy: function() {
                this.raf.stop(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), i.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, i.GAMES[this.id] = null
            },
            gamePaused: function(t) {
                this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0))
            },
            gameResumed: function(t) {
                this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1))
            },
            focusLoss: function(t) {
                this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t)
            },
            focusGain: function(t) {
                this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t)
            }
        }, i.Game.prototype.constructor = i.Game, Object.defineProperty(i.Game.prototype, "paused", {
            get: function() {
                return this._paused
            },
            set: function(t) {
                !0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1)
            }
        }), i.Input = function(t) {
            this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = i.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new i.ArraySet, this._localPoint = new i.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
        }, i.Input.MOUSE_OVERRIDES_TOUCH = 0, i.Input.TOUCH_OVERRIDES_MOUSE = 1, i.Input.MOUSE_TOUCH_COMBINE = 2, i.Input.MAX_POINTERS = 10, i.Input.prototype = {
            boot: function() {
                this.mousePointer = new i.Pointer(this.game, 0, i.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new i.Mouse(this.game), this.touch = new i.Touch(this.game), this.mspointer = new i.MSPointer(this.game), i.Keyboard && (this.keyboard = new i.Keyboard(this.game)), i.Gamepad && (this.gamepad = new i.Gamepad(this.game)), this.onDown = new i.Signal, this.onUp = new i.Signal, this.onTap = new i.Signal, this.onHold = new i.Signal, this.scale = new i.Point(1, 1), this.speed = new i.Point, this.position = new i.Point, this._oldPosition = new i.Point, this.circle = new i.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.mouse.start(), this.touch.start(), this.mspointer.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start();
                var t = this;
                this._onClickTrampoline = function(e) {
                    t.onClickTrampoline(e)
                }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
            },
            destroy: function() {
                this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], PIXI.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline)
            },
            setInteractiveCandidateHandler: function(t, e) {
                this.customCandidateHandler = t, this.customCandidateHandlerContext = e
            },
            addMoveCallback: function(t, e) {
                this.moveCallbacks.push({
                    callback: t,
                    context: e
                })
            },
            deleteMoveCallback: function(t, e) {
                for (var i = this.moveCallbacks.length; i--;)
                    if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1)
            },
            addPointer: function() {
                if (this.pointers.length >= i.Input.MAX_POINTERS) return console.warn("Phaser.Input.addPointer: Maximum limit of " + i.Input.MAX_POINTERS + " pointers reached."), null;
                var t = this.pointers.length + 1,
                    e = new i.Pointer(this.game, t, i.PointerMode.TOUCH);
                return this.pointers.push(e), this["pointer" + t] = e, e
            },
            update: function() {
                if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) return void this._pollCounter++;
                this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                this._pollCounter = 0
            },
            reset: function(t) {
                if (this.game.isBooted && !this.resetLocked) {
                    void 0 === t && (t = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(t), this.gamepad && this.gamepad.reset();
                    for (var e = 0; e < this.pointers.length; e++) this.pointers[e].reset();
                    "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new i.Signal, this.onUp = new i.Signal, this.onTap = new i.Signal, this.onHold = new i.Signal, this.moveCallbacks = []), this._pollCounter = 0
                }
            },
            resetSpeed: function(t, e) {
                this._oldPosition.setTo(t, e), this.speed.setTo(0, 0)
            },
            startPointer: function(t) {
                if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
                if (!this.pointer1.active) return this.pointer1.start(t);
                if (!this.pointer2.active) return this.pointer2.start(t);
                for (var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (!i.active) return i.start(t)
                }
                return null
            },
            updatePointer: function(t) {
                if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t);
                if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t);
                for (var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.active && i.identifier === t.identifier) return i.move(t)
                }
                return null
            },
            stopPointer: function(t) {
                if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t);
                if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t);
                for (var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.active && i.identifier === t.identifier) return i.stop(t)
                }
                return null
            },
            countActivePointers: function(t) {
                void 0 === t && (t = this.pointers.length);
                for (var e = t, i = 0; i < this.pointers.length && e > 0; i++) {
                    this.pointers[i].active && e--
                }
                return t - e
            },
            getPointer: function(t) {
                void 0 === t && (t = !1);
                for (var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.active === t) return i
                }
                return null
            },
            getPointerFromIdentifier: function(t) {
                for (var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.identifier === t) return i
                }
                return null
            },
            getPointerFromId: function(t) {
                for (var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.pointerId === t) return i
                }
                return null
            },
            getLocalPosition: function(t, e, o) {
                void 0 === o && (o = new i.Point);
                var s = t.worldTransform,
                    n = 1 / (s.a * s.d + s.c * -s.b);
                return o.setTo(s.d * n * e.x + -s.c * n * e.y + (s.ty * s.c - s.tx * s.d) * n, s.a * n * e.y + -s.b * n * e.x + (-s.ty * s.a + s.tx * s.b) * n)
            },
            hitTest: function(t, e, o) {
                if (!t.worldVisible) return !1;
                if (this.getLocalPosition(t, e, this._localPoint), o.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains) return t.hitArea.contains(this._localPoint.x, this._localPoint.y);
                if (t instanceof i.TileSprite) {
                    var s = t.width,
                        n = t.height,
                        r = -s * t.anchor.x;
                    if (this._localPoint.x >= r && this._localPoint.x < r + s) {
                        var a = -n * t.anchor.y;
                        if (this._localPoint.y >= a && this._localPoint.y < a + n) return !0
                    }
                } else if (t instanceof PIXI.Sprite) {
                    var s = t.texture.frame.width,
                        n = t.texture.frame.height,
                        r = -s * t.anchor.x;
                    if (this._localPoint.x >= r && this._localPoint.x < r + s) {
                        var a = -n * t.anchor.y;
                        if (this._localPoint.y >= a && this._localPoint.y < a + n) return !0
                    }
                } else if (t instanceof i.Graphics)
                    for (var h = 0; h < t.graphicsData.length; h++) {
                        var l = t.graphicsData[h];
                        if (l.fill && (l.shape && l.shape.contains(this._localPoint.x, this._localPoint.y))) return !0
                    }
                for (var h = 0; h < t.children.length; h++)
                    if (this.hitTest(t.children[h], e, o)) return !0;
                return !1
            },
            onClickTrampoline: function() {
                this.activePointer.processClickTrampolines()
            }
        }, i.Input.prototype.constructor = i.Input, Object.defineProperty(i.Input.prototype, "x", {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = Math.floor(t)
            }
        }), Object.defineProperty(i.Input.prototype, "y", {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = Math.floor(t)
            }
        }), Object.defineProperty(i.Input.prototype, "pollLocked", {
            get: function() {
                return this.pollRate > 0 && this._pollCounter < this.pollRate
            }
        }), Object.defineProperty(i.Input.prototype, "totalInactivePointers", {
            get: function() {
                return this.pointers.length - this.countActivePointers()
            }
        }), Object.defineProperty(i.Input.prototype, "totalActivePointers", {
            get: function() {
                return this.countActivePointers()
            }
        }), Object.defineProperty(i.Input.prototype, "worldX", {
            get: function() {
                return this.game.camera.view.x + this.x
            }
        }), Object.defineProperty(i.Input.prototype, "worldY", {
            get: function() {
                return this.game.camera.view.y + this.y
            }
        }), i.Mouse = function(t) {
            this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new i.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null
        }, i.Mouse.NO_BUTTON = -1, i.Mouse.LEFT_BUTTON = 0, i.Mouse.MIDDLE_BUTTON = 1, i.Mouse.RIGHT_BUTTON = 2, i.Mouse.BACK_BUTTON = 3, i.Mouse.FORWARD_BUTTON = 4, i.Mouse.WHEEL_UP = 1, i.Mouse.WHEEL_DOWN = -1, i.Mouse.prototype = {
            start: function() {
                if ((!this.game.device.android || !1 !== this.game.device.chrome) && null === this._onMouseDown) {
                    var e = this;
                    this._onMouseDown = function(t) {
                        return e.onMouseDown(t)
                    }, this._onMouseMove = function(t) {
                        return e.onMouseMove(t)
                    }, this._onMouseUp = function(t) {
                        return e.onMouseUp(t)
                    }, this._onMouseUpGlobal = function(t) {
                        return e.onMouseUpGlobal(t)
                    }, this._onMouseOutGlobal = function(t) {
                        return e.onMouseOutGlobal(t)
                    }, this._onMouseOut = function(t) {
                        return e.onMouseOut(t)
                    }, this._onMouseOver = function(t) {
                        return e.onMouseOver(t)
                    }, this._onMouseWheel = function(t) {
                        return e.onMouseWheel(t)
                    };
                    var i = this.game.canvas;
                    i.addEventListener("mousedown", this._onMouseDown, !0), i.addEventListener("mousemove", this._onMouseMove, !0), i.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), i.addEventListener("mouseover", this._onMouseOver, !0), i.addEventListener("mouseout", this._onMouseOut, !0));
                    var o = this.game.device.wheelEvent;
                    o && (i.addEventListener(o, this._onMouseWheel, !0), "mousewheel" === o ? this._wheelEvent = new t(-.025, 1) : "DOMMouseScroll" === o && (this._wheelEvent = new t(1, 1)))
                }
            },
            onMouseDown: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t))
            },
            onMouseMove: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t))
            },
            onMouseUp: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t))
            },
            onMouseUpGlobal: function(t) {
                this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t))
            },
            onMouseOutGlobal: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.leftButton.stop(t), this.input.mousePointer.rightButton.stop(t))
            },
            onMouseOut: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t))
            },
            onMouseOver: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t)
            },
            onMouseWheel: function(t) {
                this._wheelEvent && (t = this._wheelEvent.bindEvent(t)), this.event = t, this.capture && t.preventDefault(), this.wheelDelta = i.Math.clamp(-t.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, t)
            },
            requestPointerLock: function() {
                if (this.game.device.pointerLock) {
                    var t = this.game.canvas;
                    t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock();
                    var e = this;
                    this._pointerLockChange = function(t) {
                        return e.pointerLockChange(t)
                    }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                }
            },
            pointerLockChange: function(t) {
                var e = this.game.canvas;
                document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e ? (this.locked = !0, this.pointerLock.dispatch(!0, t)) : (this.locked = !1, this.pointerLock.dispatch(!1, t))
            },
            releasePointerLock: function() {
                document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
            },
            stop: function() {
                var t = this.game.canvas;
                t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0);
                var e = this.game.device.wheelEvent;
                e && t.removeEventListener(e, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
            }
        }, i.Mouse.prototype.constructor = i.Mouse, t.prototype = {}, t.prototype.constructor = t, t.prototype.bindEvent = function(e) {
            if (!t._stubsGenerated && e) {
                for (var i in e) i in t.prototype || Object.defineProperty(t.prototype, i, {
                    get: function(t) {
                        return function() {
                            var e = this.originalEvent[t];
                            return "function" != typeof e ? e : e.bind(this.originalEvent)
                        }
                    }(i)
                });
                t._stubsGenerated = !0
            }
            return this.originalEvent = e, this
        }, Object.defineProperties(t.prototype, {
            type: {
                value: "wheel"
            },
            deltaMode: {
                get: function() {
                    return this._deltaMode
                }
            },
            deltaY: {
                get: function() {
                    return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0
                }
            },
            deltaX: {
                get: function() {
                    return this._scaleFactor * this.originalEvent.wheelDeltaX || 0
                }
            },
            deltaZ: {
                value: 0
            }
        }), i.MSPointer = function(t) {
            this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null
        }, i.MSPointer.prototype = {
            start: function() {
                if (null === this._onMSPointerDown) {
                    var t = this;
                    if (this.game.device.mspointer) {
                        this._onMSPointerDown = function(e) {
                            return t.onPointerDown(e)
                        }, this._onMSPointerMove = function(e) {
                            return t.onPointerMove(e)
                        }, this._onMSPointerUp = function(e) {
                            return t.onPointerUp(e)
                        }, this._onMSPointerUpGlobal = function(e) {
                            return t.onPointerUpGlobal(e)
                        }, this._onMSPointerOut = function(e) {
                            return t.onPointerOut(e)
                        }, this._onMSPointerOver = function(e) {
                            return t.onPointerOver(e)
                        };
                        var e = this.game.canvas;
                        e.addEventListener("MSPointerDown", this._onMSPointerDown, !1), e.addEventListener("MSPointerMove", this._onMSPointerMove, !1), e.addEventListener("MSPointerUp", this._onMSPointerUp, !1), e.addEventListener("pointerdown", this._onMSPointerDown, !1), e.addEventListener("pointermove", this._onMSPointerMove, !1), e.addEventListener("pointerup", this._onMSPointerUp, !1), e.style["-ms-content-zooming"] = "none", e.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), e.addEventListener("MSPointerOver", this._onMSPointerOver, !0), e.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), e.addEventListener("pointerover", this._onMSPointerOver, !0), e.addEventListener("pointerout", this._onMSPointerOut, !0))
                    }
                }
            },
            onPointerDown: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t))
            },
            onPointerMove: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
            },
            onPointerUp: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
            },
            onPointerUpGlobal: function(t) {
                if ("mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) {
                    var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && e.withinGame && this.onPointerUp(t)
                } else this.onPointerUp(t)
            },
            onPointerOut: function(t) {
                if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !1;
                else {
                    var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && (e.withinGame = !1)
                }
                this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, t), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (t.identifier = 0, e ? e.stop(t) : this.input.mousePointer.stop(t))
            },
            onPointerOver: function(t) {
                if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !0;
                else {
                    var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && (e.withinGame = !0)
                }
                this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, t)
            },
            stop: function() {
                var t = this.game.canvas;
                t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0)
            }
        }, i.MSPointer.prototype.constructor = i.MSPointer, i.DeviceButton = function(t, e) {
            this.parent = t, this.game = t.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = e, this.onDown = new i.Signal, this.onUp = new i.Signal, this.onFloat = new i.Signal
        }, i.DeviceButton.prototype = {
            start: function(t, e) {
                this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e))
            },
            stop: function(t, e) {
                this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e))
            },
            padFloat: function(t) {
                this.value = t, this.onFloat.dispatch(this, t)
            },
            justPressed: function(t) {
                return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time
            },
            justReleased: function(t) {
                return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time
            },
            reset: function() {
                this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1
            },
            destroy: function() {
                this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null
            }
        }, i.DeviceButton.prototype.constructor = i.DeviceButton, Object.defineProperty(i.DeviceButton.prototype, "duration", {
            get: function() {
                return this.isUp ? -1 : this.game.time.time - this.timeDown
            }
        }), i.Pointer = function(t, e, o) {
            this.game = t, this.id = e, this.type = i.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = o || i.PointerMode.CURSOR | i.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new i.DeviceButton(this, i.Pointer.LEFT_BUTTON), this.middleButton = new i.DeviceButton(this, i.Pointer.MIDDLE_BUTTON), this.rightButton = new i.DeviceButton(this, i.Pointer.RIGHT_BUTTON), this.backButton = new i.DeviceButton(this, i.Pointer.BACK_BUTTON), this.forwardButton = new i.DeviceButton(this, i.Pointer.FORWARD_BUTTON), this.eraserButton = new i.DeviceButton(this, i.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === e, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new i.Point, this.positionDown = new i.Point, this.positionUp = new i.Point, this.circle = new i.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null
        }, i.Pointer.NO_BUTTON = 0, i.Pointer.LEFT_BUTTON = 1, i.Pointer.RIGHT_BUTTON = 2, i.Pointer.MIDDLE_BUTTON = 4, i.Pointer.BACK_BUTTON = 8, i.Pointer.FORWARD_BUTTON = 16, i.Pointer.ERASER_BUTTON = 32, i.Pointer.prototype = {
            resetButtons: function() {
                this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
            },
            processButtonsDown: function(t, e) {
                i.Pointer.LEFT_BUTTON & t && this.leftButton.start(e), i.Pointer.RIGHT_BUTTON & t && this.rightButton.start(e), i.Pointer.MIDDLE_BUTTON & t && this.middleButton.start(e), i.Pointer.BACK_BUTTON & t && this.backButton.start(e), i.Pointer.FORWARD_BUTTON & t && this.forwardButton.start(e), i.Pointer.ERASER_BUTTON & t && this.eraserButton.start(e)
            },
            processButtonsUp: function(t, e) {
                t === i.Mouse.LEFT_BUTTON && this.leftButton.stop(e), t === i.Mouse.RIGHT_BUTTON && this.rightButton.stop(e), t === i.Mouse.MIDDLE_BUTTON && this.middleButton.stop(e), t === i.Mouse.BACK_BUTTON && this.backButton.stop(e), t === i.Mouse.FORWARD_BUTTON && this.forwardButton.stop(e), 5 === t && this.eraserButton.stop(e)
            },
            updateButtons: function(t) {
                this.button = t.button;
                var e = "down" === t.type.toLowerCase().substr(-4);
                void 0 !== t.buttons ? e ? this.processButtonsDown(t.buttons, t) : this.processButtonsUp(t.button, t) : e ? this.leftButton.start(t) : (this.leftButton.stop(t), this.rightButton.stop(t)), 1 === t.buttons && t.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(t), this.rightButton.start(t)), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
            },
            start: function(t) {
                var e = this.game.input;
                return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.isMouse ? this.updateButtons(t) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (e.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.x = this.x, e.y = this.y, e.position.setTo(this.x, this.y), e.onDown.dispatch(this, t), e.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
            },
            update: function() {
                var t = this.game.input;
                this.active && (this.dirty && (t.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= t.holdRate && ((t.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this), this._holdSent = !0), t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate, this._history.push({
                    x: this.position.x,
                    y: this.position.y
                }), this._history.length > t.recordLimit && this._history.shift()))
            },
            move: function(t, e) {
                var o = this.game.input;
                if (!o.pollLocked) {
                    if (void 0 === e && (e = !1), void 0 !== t.button && (this.button = t.button), e && this.isMouse && this.updateButtons(t), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && o.mouse.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * o.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * o.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (o.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || o.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || o.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === o.totalActivePointers) && (o.activePointer = this, o.x = this.x, o.y = this.y, o.position.setTo(o.x, o.y), o.circle.x = o.x, o.circle.y = o.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY), this.game.paused) return this;
                    for (var s = o.moveCallbacks.length; s--;) o.moveCallbacks[s].callback.call(o.moveCallbacks[s].context, this, this.x, this.y, e);
                    return null !== this.targetObject && !0 === this.targetObject.isDragged ? !1 === this.targetObject.update(this) && (this.targetObject = null) : o.interactiveItems.total > 0 && this.processInteractiveObjects(e), this
                }
            },
            processInteractiveObjects: function(t) {
                var e = 0,
                    i = -1,
                    o = null,
                    s = this.game.input.interactiveItems.first;
                for (this.interactiveCandidates = []; s;) s.checked = !1, s.validForInput(i, e, !1) && (s.checked = !0, (t && s.checkPointerDown(this, !0) || !t && s.checkPointerOver(this, !0)) && (e = s.sprite.renderOrderID, i = s.priorityID, o = s, this.interactiveCandidates.push(s))), s = this.game.input.interactiveItems.next;
                for (s = this.game.input.interactiveItems.first; s;) !s.checked && s.validForInput(i, e, !0) && (t && s.checkPointerDown(this, !1) || !t && s.checkPointerOver(this, !1)) && (e = s.sprite.renderOrderID, i = s.priorityID, o = s, this.interactiveCandidates.push(s)), s = this.game.input.interactiveItems.next;
                return this.game.input.customCandidateHandler && (o = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, o)), this.swapTarget(o, !1), null !== this.targetObject
            },
            swapTarget: function(t, e) {
                void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t, t._pointerOverHandler(this, e)) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e))
            },
            leave: function(t) {
                this.withinGame = !1, this.move(t, !1)
            },
            stop: function(t) {
                var e = this.game.input;
                return this._stateReset && this.withinGame ? void t.preventDefault() : (this.timeUp = this.game.time.time, (e.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.onUp.dispatch(this, t), this.duration >= 0 && this.duration <= e.tapRate && (this.timeUp - this.previousTapTime < e.doubleTapRate ? e.onTap.dispatch(this, !0) : e.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(t) : (this.isDown = !1, this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && e.currentPointers--, e.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this)
            },
            justPressed: function(t) {
                return t = t || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + t > this.game.time.time
            },
            justReleased: function(t) {
                return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time
            },
            addClickTrampoline: function(t, e, i, o) {
                if (this.isDown) {
                    for (var s = this._clickTrampolines = this._clickTrampolines || [], n = 0; n < s.length; n++)
                        if (s[n].name === t) {
                            s.splice(n, 1);
                            break
                        }
                    s.push({
                        name: t,
                        targetObject: this.targetObject,
                        callback: e,
                        callbackContext: i,
                        callbackArgs: o
                    })
                }
            },
            processClickTrampolines: function() {
                var t = this._clickTrampolines;
                if (t) {
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e];
                        i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                    }
                    this._clickTrampolines = null, this._trampolineTargetObject = null
                }
            },
            reset: function() {
                !1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
            },
            resetMovement: function() {
                this.movementX = 0, this.movementY = 0
            }
        }, i.Pointer.prototype.constructor = i.Pointer, Object.defineProperty(i.Pointer.prototype, "duration", {
            get: function() {
                return this.isUp ? -1 : this.game.time.time - this.timeDown
            }
        }), Object.defineProperty(i.Pointer.prototype, "worldX", {
            get: function() {
                return this.game.world.camera.x + this.x
            }
        }), Object.defineProperty(i.Pointer.prototype, "worldY", {
            get: function() {
                return this.game.world.camera.y + this.y
            }
        }), i.PointerMode = {
            CURSOR: 1,
            CONTACT: 2
        }, i.Touch = function(t) {
            this.game = t, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
        }, i.Touch.prototype = {
            start: function() {
                if (null === this._onTouchStart) {
                    var t = this;
                    this.game.device.touch && (this._onTouchStart = function(e) {
                        return t.onTouchStart(e)
                    }, this._onTouchMove = function(e) {
                        return t.onTouchMove(e)
                    }, this._onTouchEnd = function(e) {
                        return t.onTouchEnd(e)
                    }, this._onTouchEnter = function(e) {
                        return t.onTouchEnter(e)
                    }, this._onTouchLeave = function(e) {
                        return t.onTouchLeave(e)
                    }, this._onTouchCancel = function(e) {
                        return t.onTouchCancel(e)
                    }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
                }
            },
            consumeDocumentTouches: function() {
                this._documentTouchMove = function(t) {
                    t.preventDefault()
                }, document.addEventListener("touchmove", this._documentTouchMove, !1)
            },
            addTouchLockCallback: function(t, e, i) {
                void 0 === i && (i = !1), this.touchLockCallbacks.push({
                    callback: t,
                    context: e,
                    onEnd: i
                })
            },
            removeTouchLockCallback: function(t, e) {
                for (var i = this.touchLockCallbacks.length; i--;)
                    if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1), !0;
                return !1
            },
            onTouchStart: function(t) {
                for (var e = this.touchLockCallbacks.length; e--;) {
                    var i = this.touchLockCallbacks[e];
                    !i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                }
                if (this.event = t, this.game.input.enabled && this.enabled) {
                    this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                    for (var e = 0; e < t.changedTouches.length; e++) this.game.input.startPointer(t.changedTouches[e])
                }
            },
            onTouchCancel: function(t) {
                if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) {
                    this.preventDefault && t.preventDefault();
                    for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                }
            },
            onTouchEnter: function(t) {
                this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
            },
            onTouchLeave: function(t) {
                this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault()
            },
            onTouchMove: function(t) {
                this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e])
            },
            onTouchEnd: function(t) {
                for (var e = this.touchLockCallbacks.length; e--;) {
                    var i = this.touchLockCallbacks[e];
                    i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                }
                this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
            },
            stop: function() {
                this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
            }
        }, i.Touch.prototype.constructor = i.Touch, i.InputHandler = function(t) {
            this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new i.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new i.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new i.Point, this.snapPoint = new i.Point, this._dragPoint = new i.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new i.Point, this._pointerData = [], this._pointerData.push({
                id: 0,
                x: 0,
                y: 0,
                camX: 0,
                camY: 0,
                isDown: !1,
                isUp: !1,
                isOver: !1,
                isOut: !1,
                timeOver: 0,
                timeOut: 0,
                timeDown: 0,
                timeUp: 0,
                downDuration: 0,
                isDragged: !1
            })
        }, i.InputHandler.prototype = {
            start: function(t, e) {
                if (t = t || 0, void 0 === e && (e = !1), !1 === this.enabled) {
                    this.game.input.interactiveItems.add(this), this.useHandCursor = e, this.priorityID = t;
                    for (var o = 0; o < 10; o++) this._pointerData[o] = {
                        id: o,
                        x: 0,
                        y: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    };
                    this.snapOffset = new i.Point, this.enabled = !0, this._wasEnabled = !0
                }
                return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
            },
            addedToGroup: function() {
                this._dragPhase || this._wasEnabled && !this.enabled && this.start()
            },
            removedFromGroup: function() {
                this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
            },
            reset: function() {
                this.enabled = !1;
                for (var t = 0; t < 10; t++) this._pointerData[t] = {
                    id: t,
                    x: 0,
                    y: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                }
            },
            stop: function() {
                !1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
            },
            destroy: function() {
                this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
            },
            validForInput: function(t, e, i) {
                return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!i && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
            },
            isPixelPerfect: function() {
                return this.pixelPerfectClick || this.pixelPerfectOver
            },
            pointerX: function(t) {
                return t = t || 0, this._pointerData[t].x
            },
            pointerY: function(t) {
                return t = t || 0, this._pointerData[t].y
            },
            pointerDown: function(t) {
                return t = t || 0, this._pointerData[t].isDown
            },
            pointerUp: function(t) {
                return t = t || 0, this._pointerData[t].isUp
            },
            pointerTimeDown: function(t) {
                return t = t || 0, this._pointerData[t].timeDown
            },
            pointerTimeUp: function(t) {
                return t = t || 0, this._pointerData[t].timeUp
            },
            pointerOver: function(t) {
                if (!this.enabled) return !1;
                if (void 0 === t) {
                    for (var e = 0; e < 10; e++)
                        if (this._pointerData[e].isOver) return !0;
                    return !1
                }
                return this._pointerData[t].isOver
            },
            pointerOut: function(t) {
                if (!this.enabled) return !1;
                if (void 0 !== t) return this._pointerData[t].isOut;
                for (var e = 0; e < 10; e++)
                    if (this._pointerData[e].isOut) return !0
            },
            pointerTimeOver: function(t) {
                return t = t || 0, this._pointerData[t].timeOver
            },
            pointerTimeOut: function(t) {
                return t = t || 0, this._pointerData[t].timeOut
            },
            pointerDragged: function(t) {
                return t = t || 0, this._pointerData[t].isDragged
            },
            checkPointerDown: function(t, e) {
                return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
            },
            checkPointerOver: function(t, e) {
                return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
            },
            checkPixel: function(t, e, i) {
                if (this.sprite.texture.baseTexture.source) {
                    if (null === t && null === e) {
                        this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                        var t = this._tempPoint.x,
                            e = this._tempPoint.y
                    }
                    if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t, this._dy = e, !1;
                    this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1);
                    if (this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return !0
                }
                return !1
            },
            update: function(t) {
                if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = i.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(t), !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.position.x, this._pointerData[t.id].y = t.y - this.sprite.position.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1)
            },
            _pointerOverHandler: function(t, e) {
                if (null !== this.sprite) {
                    var o = this._pointerData[t.id];
                    if (!1 === o.isOver || t.dirty) {
                        var s = !1 === o.isOver;
                        o.isOver = !0, o.isOut = !1, o.timeOver = this.game.time.time, o.x = t.x - this.sprite.position.x, o.y = t.y - this.sprite.position.y, this.useHandCursor && !1 === o.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && s && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                    }
                }
            },
            _pointerOutHandler: function(t, e) {
                if (null !== this.sprite) {
                    var o = this._pointerData[t.id];
                    o.isOver = !1, o.isOut = !0, o.timeOut = this.game.time.time, this.useHandCursor && !1 === o.isDragged && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
                }
            },
            _touchedHandler: function(t) {
                if (null !== this.sprite) {
                    var e = this._pointerData[t.id];
                    if (!e.isDown && e.isOver) {
                        if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return;
                        if (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite)) return;
                        this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                    }
                }
            },
            dragTimeElapsed: function(t) {
                this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
            },
            _releasedHandler: function(t) {
                if (null !== this.sprite) {
                    var e = this._pointerData[t.id];
                    if (e.isDown && t.isUp) {
                        e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown;
                        var o = this.checkPointerOver(t);
                        this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, o), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, o), o && (o = this.checkPointerOver(t))), e.isOver = o, !o && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                    }
                }
            },
            updateDrag: function(t, e) {
                if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t), !1;
                var i = this.globalToLocalX(t.x) + this._dragPoint.x + this.dragOffset.x,
                    o = this.globalToLocalY(t.y) + this._dragPoint.y + this.dragOffset.y,
                    s = this.game.camera.x - this._pointerData[t.id].camX,
                    n = this.game.camera.y - this._pointerData[t.id].camY;
                return this.allowHorizontalDrag && (this.sprite.x = i + s), this.allowVerticalDrag && (this.sprite.y = o + n), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y)), this.sprite.events.onDragUpdate.dispatch(this.sprite, t, i, o, this.snapPoint, e), !0
            },
            justOver: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e
            },
            justOut: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
            },
            justPressed: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e
            },
            justReleased: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
            },
            overDuration: function(t) {
                return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1
            },
            downDuration: function(t) {
                return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1
            },
            enableDrag: function(t, e, o, s, n, r) {
                void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === o && (o = !1), void 0 === s && (s = 255), void 0 === n && (n = null), void 0 === r && (r = null), this._dragPoint = new i.Point, this.draggable = !0, this.bringToTop = e, this.dragOffset = new i.Point, this.dragFromCenter = t, this.pixelPerfectClick = o, this.pixelPerfectAlpha = s, n && (this.boundsRect = n), r && (this.boundsSprite = r)
            },
            disableDrag: function() {
                if (this._pointerData)
                    for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
                this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
            },
            startDrag: function(t) {
                var e = this.sprite.x,
                    i = this.sprite.y;
                if (this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].camX = this.game.camera.x, this._pointerData[t.id].camY = this.game.camera.y, this._pointerData[t.id].isDragged = !0, this.dragFromCenter) {
                    var o = this.sprite.getBounds();
                    this.sprite.x = this.globalToLocalX(t.x) + (this.sprite.x - o.centerX), this.sprite.y = this.globalToLocalY(t.y) + (this.sprite.y - o.centerY)
                }
                this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(t.x), this.sprite.y - this.globalToLocalY(t.y)), this.updateDrag(t, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(e, i), this.sprite.events.onDragStart$dispatch(this.sprite, t, e, i), this._pendingDrag = !1
            },
            globalToLocalX: function(t) {
                return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t
            },
            globalToLocalY: function(t) {
                return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t
            },
            stopDrag: function(t) {
                this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY), this.sprite.events.onDragStop$dispatch(this.sprite, t), !1 === this.checkPointerOver(t) && this._pointerOutHandler(t)
            },
            setDragLock: function(t, e) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e
            },
            enableSnap: function(t, e, i, o, s, n) {
                void 0 === i && (i = !0), void 0 === o && (o = !1), void 0 === s && (s = 0), void 0 === n && (n = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = s, this.snapOffsetY = n, this.snapOnDrag = i, this.snapOnRelease = o
            },
            disableSnap: function() {
                this.snapOnDrag = !1, this.snapOnRelease = !1
            },
            checkBoundsRect: function() {
                this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY))
            },
            checkBoundsSprite: function() {
                this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY))
            }
        }, i.InputHandler.prototype.constructor = i.InputHandler, i.Gamepad = function(t) {
            this.game = t, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [new i.SinglePad(t, this), new i.SinglePad(t, this), new i.SinglePad(t, this), new i.SinglePad(t, this)]
        }, i.Gamepad.prototype = {
            addCallbacks: function(t, e) {
                void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
            },
            start: function() {
                if (!this._active) {
                    this._active = !0;
                    var t = this;
                    this._onGamepadConnected = function(e) {
                        return t.onGamepadConnected(e)
                    }, this._onGamepadDisconnected = function(e) {
                        return t.onGamepadDisconnected(e)
                    }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1)
                }
            },
            onGamepadConnected: function(t) {
                var e = t.gamepad;
                this._rawPads.push(e), this._gamepads[e.index].connect(e)
            },
            onGamepadDisconnected: function(t) {
                var e = t.gamepad;
                for (var i in this._rawPads) this._rawPads[i].index === e.index && this._rawPads.splice(i, 1);
                this._gamepads[e.index].disconnect()
            },
            update: function() {
                this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus()
            },
            _pollGamepads: function() {
                if (this._active) {
                    if (navigator.getGamepads) var t = navigator.getGamepads();
                    else if (navigator.webkitGetGamepads) var t = navigator.webkitGetGamepads();
                    else if (navigator.webkitGamepads) var t = navigator.webkitGamepads();
                    if (t) {
                        this._rawPads = [];
                        for (var e = !1, i = 0; i < t.length && (typeof t[i] !== this._prevRawGamepadTypes[i] && (e = !0, this._prevRawGamepadTypes[i] = typeof t[i]), t[i] && this._rawPads.push(t[i]), 3 !== i); i++);
                        for (var o = 0; o < this._gamepads.length; o++) this._gamepads[o]._rawPad = this._rawPads[o];
                        if (e) {
                            for (var s, n = {
                                    rawIndices: {},
                                    padIndices: {}
                                }, r = 0; r < this._gamepads.length; r++)
                                if (s = this._gamepads[r], s.connected)
                                    for (var a = 0; a < this._rawPads.length; a++) this._rawPads[a].index === s.index && (n.rawIndices[s.index] = !0, n.padIndices[r] = !0);
                            for (var h = 0; h < this._gamepads.length; h++)
                                if (s = this._gamepads[h], !n.padIndices[h]) {
                                    this._rawPads.length < 1 && s.disconnect();
                                    for (var l = 0; l < this._rawPads.length && !n.padIndices[h]; l++) {
                                        var d = this._rawPads[l];
                                        if (d) {
                                            if (n.rawIndices[d.index]) {
                                                s.disconnect();
                                                continue
                                            }
                                            s.connect(d), n.rawIndices[d.index] = !0, n.padIndices[h] = !0
                                        } else s.disconnect()
                                    }
                                }
                        }
                    }
                }
            },
            setDeadZones: function(t) {
                for (var e = 0; e < this._gamepads.length; e++) this._gamepads[e].deadZone = t
            },
            stop: function() {
                this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected)
            },
            reset: function() {
                this.update();
                for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].reset()
            },
            justPressed: function(t, e) {
                for (var i = 0; i < this._gamepads.length; i++)
                    if (!0 === this._gamepads[i].justPressed(t, e)) return !0;
                return !1
            },
            justReleased: function(t, e) {
                for (var i = 0; i < this._gamepads.length; i++)
                    if (!0 === this._gamepads[i].justReleased(t, e)) return !0;
                return !1
            },
            isDown: function(t) {
                for (var e = 0; e < this._gamepads.length; e++)
                    if (!0 === this._gamepads[e].isDown(t)) return !0;
                return !1
            },
            destroy: function() {
                this.stop();
                for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].destroy()
            }
        }, i.Gamepad.prototype.constructor = i.Gamepad, Object.defineProperty(i.Gamepad.prototype, "active", {
            get: function() {
                return this._active
            }
        }), Object.defineProperty(i.Gamepad.prototype, "supported", {
            get: function() {
                return this._gamepadSupportAvailable
            }
        }), Object.defineProperty(i.Gamepad.prototype, "padsConnected", {
            get: function() {
                return this._rawPads.length
            }
        }), Object.defineProperty(i.Gamepad.prototype, "pad1", {
            get: function() {
                return this._gamepads[0]
            }
        }), Object.defineProperty(i.Gamepad.prototype, "pad2", {
            get: function() {
                return this._gamepads[1]
            }
        }), Object.defineProperty(i.Gamepad.prototype, "pad3", {
            get: function() {
                return this._gamepads[2]
            }
        }), Object.defineProperty(i.Gamepad.prototype, "pad4", {
            get: function() {
                return this._gamepads[3]
            }
        }), i.Gamepad.BUTTON_0 = 0, i.Gamepad.BUTTON_1 = 1, i.Gamepad.BUTTON_2 = 2, i.Gamepad.BUTTON_3 = 3, i.Gamepad.BUTTON_4 = 4, i.Gamepad.BUTTON_5 = 5, i.Gamepad.BUTTON_6 = 6, i.Gamepad.BUTTON_7 = 7, i.Gamepad.BUTTON_8 = 8, i.Gamepad.BUTTON_9 = 9, i.Gamepad.BUTTON_10 = 10, i.Gamepad.BUTTON_11 = 11, i.Gamepad.BUTTON_12 = 12, i.Gamepad.BUTTON_13 = 13, i.Gamepad.BUTTON_14 = 14, i.Gamepad.BUTTON_15 = 15, i.Gamepad.AXIS_0 = 0, i.Gamepad.AXIS_1 = 1, i.Gamepad.AXIS_2 = 2, i.Gamepad.AXIS_3 = 3, i.Gamepad.AXIS_4 = 4, i.Gamepad.AXIS_5 = 5, i.Gamepad.AXIS_6 = 6, i.Gamepad.AXIS_7 = 7, i.Gamepad.AXIS_8 = 8, i.Gamepad.AXIS_9 = 9, i.Gamepad.XBOX360_A = 0, i.Gamepad.XBOX360_B = 1, i.Gamepad.XBOX360_X = 2, i.Gamepad.XBOX360_Y = 3, i.Gamepad.XBOX360_LEFT_BUMPER = 4, i.Gamepad.XBOX360_RIGHT_BUMPER = 5, i.Gamepad.XBOX360_LEFT_TRIGGER = 6, i.Gamepad.XBOX360_RIGHT_TRIGGER = 7, i.Gamepad.XBOX360_BACK = 8, i.Gamepad.XBOX360_START = 9, i.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, i.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, i.Gamepad.XBOX360_DPAD_LEFT = 14, i.Gamepad.XBOX360_DPAD_RIGHT = 15, i.Gamepad.XBOX360_DPAD_UP = 12, i.Gamepad.XBOX360_DPAD_DOWN = 13, i.Gamepad.XBOX360_STICK_LEFT_X = 0, i.Gamepad.XBOX360_STICK_LEFT_Y = 1, i.Gamepad.XBOX360_STICK_RIGHT_X = 2, i.Gamepad.XBOX360_STICK_RIGHT_Y = 3, i.Gamepad.PS3XC_X = 0, i.Gamepad.PS3XC_CIRCLE = 1;
        i.Gamepad.PS3XC_SQUARE = 2, i.Gamepad.PS3XC_TRIANGLE = 3, i.Gamepad.PS3XC_L1 = 4, i.Gamepad.PS3XC_R1 = 5, i.Gamepad.PS3XC_L2 = 6, i.Gamepad.PS3XC_R2 = 7, i.Gamepad.PS3XC_SELECT = 8, i.Gamepad.PS3XC_START = 9, i.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, i.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, i.Gamepad.PS3XC_DPAD_UP = 12, i.Gamepad.PS3XC_DPAD_DOWN = 13, i.Gamepad.PS3XC_DPAD_LEFT = 14, i.Gamepad.PS3XC_DPAD_RIGHT = 15, i.Gamepad.PS3XC_STICK_LEFT_X = 0, i.Gamepad.PS3XC_STICK_LEFT_Y = 1, i.Gamepad.PS3XC_STICK_RIGHT_X = 2, i.Gamepad.PS3XC_STICK_RIGHT_Y = 3, i.SinglePad = function(t, e) {
            this.game = t, this.index = null, this.connected = !1, this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = .26, this._padParent = e, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0
        }, i.SinglePad.prototype = {
            addCallbacks: function(t, e) {
                void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
            },
            getButton: function(t) {
                return this._buttons[t] ? this._buttons[t] : null
            },
            pollStatus: function() {
                if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                    for (var t = 0; t < this._buttonsLen; t++) {
                        var e = isNaN(this._rawPad.buttons[t]) ? this._rawPad.buttons[t].value : this._rawPad.buttons[t];
                        e !== this._buttons[t].value && (1 === e ? this.processButtonDown(t, e) : 0 === e ? this.processButtonUp(t, e) : this.processButtonFloat(t, e))
                    }
                    for (var i = 0; i < this._axesLen; i++) {
                        var o = this._rawPad.axes[i];
                        o > 0 && o > this.deadZone || o < 0 && o < -this.deadZone ? this.processAxisChange(i, o) : this.processAxisChange(i, 0)
                    }
                    this._prevTimestamp = this._rawPad.timestamp
                }
            },
            connect: function(t) {
                var e = !this.connected;
                this.connected = !0, this.index = t.index, this._rawPad = t, this._buttons = [], this._buttonsLen = t.buttons.length, this._axes = [], this._axesLen = t.axes.length;
                for (var o = 0; o < this._axesLen; o++) this._axes[o] = t.axes[o];
                for (var s in t.buttons) s = parseInt(s, 10), this._buttons[s] = new i.DeviceButton(this, s);
                e && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), e && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
            },
            disconnect: function() {
                var t = this.connected,
                    e = this.index;
                this.connected = !1, this.index = null, this._rawPad = void 0;
                for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
                this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, t && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, e), t && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
            },
            destroy: function() {
                this._rawPad = void 0;
                for (var t = 0; t < this._buttonsLen; t++) this._buttons[t].destroy();
                this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null
            },
            processAxisChange: function(t, e) {
                this._axes[t] !== e && (this._axes[t] = e, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, t, e), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, t, e))
            },
            processButtonDown: function(t, e) {
                this._buttons[t] && this._buttons[t].start(null, e), this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, t, e, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, t, e)
            },
            processButtonUp: function(t, e) {
                this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, t, e, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].stop(null, e)
            },
            processButtonFloat: function(t, e) {
                this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, t, e, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].padFloat(e)
            },
            axis: function(t) {
                return !!this._axes[t] && this._axes[t]
            },
            isDown: function(t) {
                return !!this._buttons[t] && this._buttons[t].isDown
            },
            isUp: function(t) {
                return !!this._buttons[t] && this._buttons[t].isUp
            },
            justReleased: function(t, e) {
                if (this._buttons[t]) return this._buttons[t].justReleased(e)
            },
            justPressed: function(t, e) {
                if (this._buttons[t]) return this._buttons[t].justPressed(e)
            },
            buttonValue: function(t) {
                return this._buttons[t] ? this._buttons[t].value : null
            },
            reset: function() {
                for (var t = 0; t < this._axes.length; t++) this._axes[t] = 0
            }
        }, i.SinglePad.prototype.constructor = i.SinglePad, i.Key = function(t, e) {
            this.game = t, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.repeats = 0, this.keyCode = e, this.onDown = new i.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new i.Signal, this._justDown = !1, this._justUp = !1
        }, i.Key.prototype = {
            update: function() {
                this._enabled && this.isDown && (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this))
            },
            processKeyDown: function(t) {
                this._enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)))
            },
            processKeyUp: function(t) {
                this._enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this._justUp = !0, this.onUp.dispatch(this)))
            },
            reset: function(t) {
                void 0 === t && (t = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this._enabled = !0, this._justDown = !1, this._justUp = !1, t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null)
            },
            downDuration: function(t) {
                return void 0 === t && (t = 50), this.isDown && this.duration < t
            },
            upDuration: function(t) {
                return void 0 === t && (t = 50), !this.isDown && this.game.time.time - this.timeUp < t
            }
        }, Object.defineProperty(i.Key.prototype, "justDown", {
            get: function() {
                var t = this._justDown;
                return this._justDown = !1, t
            }
        }), Object.defineProperty(i.Key.prototype, "justUp", {
            get: function() {
                var t = this._justUp;
                return this._justUp = !1, t
            }
        }), Object.defineProperty(i.Key.prototype, "enabled", {
            get: function() {
                return this._enabled
            },
            set: function(t) {
                (t = !!t) !== this._enabled && (t || this.reset(!1), this._enabled = t)
            }
        }), i.Key.prototype.constructor = i.Key, i.Keyboard = function(t) {
            this.game = t, this.enabled = !0, this.event = null, this.pressEvent = null, this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0
        }, i.Keyboard.prototype = {
            addCallbacks: function(t, e, i, o) {
                this.callbackContext = t, void 0 !== e && null !== e && (this.onDownCallback = e), void 0 !== i && null !== i && (this.onUpCallback = i), void 0 !== o && null !== o && (this.onPressCallback = o)
            },
            addKey: function(t) {
                return this._keys[t] || (this._keys[t] = new i.Key(this.game, t), this.addKeyCapture(t)), this._keys[t]
            },
            addKeys: function(t) {
                var e = {};
                for (var i in t) e[i] = this.addKey(t[i]);
                return e
            },
            removeKey: function(t) {
                this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t))
            },
            createCursorKeys: function() {
                return this.addKeys({
                    up: i.KeyCode.UP,
                    down: i.KeyCode.DOWN,
                    left: i.KeyCode.LEFT,
                    right: i.KeyCode.RIGHT
                })
            },
            start: function() {
                if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                    var t = this;
                    this._onKeyDown = function(e) {
                        return t.processKeyDown(e)
                    }, this._onKeyUp = function(e) {
                        return t.processKeyUp(e)
                    }, this._onKeyPress = function(e) {
                        return t.processKeyPress(e)
                    }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1)
                }
            },
            stop: function() {
                window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null
            },
            destroy: function() {
                this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0
            },
            addKeyCapture: function(t) {
                if ("object" == typeof t)
                    for (var e in t) this._capture[t[e]] = !0;
                else this._capture[t] = !0
            },
            removeKeyCapture: function(t) {
                delete this._capture[t]
            },
            clearCaptures: function() {
                this._capture = {}
            },
            update: function() {
                for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
            },
            processKeyDown: function(t) {
                if (this.event = t, this.game.input.enabled && this.enabled) {
                    var e = t.keyCode;
                    this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new i.Key(this.game, e)), this._keys[e].processKeyDown(t), this._k = e, this.onDownCallback && this.onDownCallback.call(this.callbackContext, t)
                }
            },
            processKeyPress: function(t) {
                this.pressEvent = t, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t)
            },
            processKeyUp: function(t) {
                if (this.event = t, this.game.input.enabled && this.enabled) {
                    var e = t.keyCode;
                    this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new i.Key(this.game, e)), this._keys[e].processKeyUp(t), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t)
                }
            },
            reset: function(t) {
                void 0 === t && (t = !0), this.event = null;
                for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t)
            },
            downDuration: function(t, e) {
                return this._keys[t] ? this._keys[t].downDuration(e) : null
            },
            upDuration: function(t, e) {
                return this._keys[t] ? this._keys[t].upDuration(e) : null
            },
            isDown: function(t) {
                return this._keys[t] ? this._keys[t].isDown : null
            }
        }, Object.defineProperty(i.Keyboard.prototype, "lastChar", {
            get: function() {
                return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode)
            }
        }), Object.defineProperty(i.Keyboard.prototype, "lastKey", {
            get: function() {
                return this._keys[this._k]
            }
        }), i.Keyboard.prototype.constructor = i.Keyboard, i.KeyCode = {
            A: "A".charCodeAt(0),
            B: "B".charCodeAt(0),
            C: "C".charCodeAt(0),
            D: "D".charCodeAt(0),
            E: "E".charCodeAt(0),
            F: "F".charCodeAt(0),
            G: "G".charCodeAt(0),
            H: "H".charCodeAt(0),
            I: "I".charCodeAt(0),
            J: "J".charCodeAt(0),
            K: "K".charCodeAt(0),
            L: "L".charCodeAt(0),
            M: "M".charCodeAt(0),
            N: "N".charCodeAt(0),
            O: "O".charCodeAt(0),
            P: "P".charCodeAt(0),
            Q: "Q".charCodeAt(0),
            R: "R".charCodeAt(0),
            S: "S".charCodeAt(0),
            T: "T".charCodeAt(0),
            U: "U".charCodeAt(0),
            V: "V".charCodeAt(0),
            W: "W".charCodeAt(0),
            X: "X".charCodeAt(0),
            Y: "Y".charCodeAt(0),
            Z: "Z".charCodeAt(0),
            ZERO: "0".charCodeAt(0),
            ONE: "1".charCodeAt(0),
            TWO: "2".charCodeAt(0),
            THREE: "3".charCodeAt(0),
            FOUR: "4".charCodeAt(0),
            FIVE: "5".charCodeAt(0),
            SIX: "6".charCodeAt(0),
            SEVEN: "7".charCodeAt(0),
            EIGHT: "8".charCodeAt(0),
            NINE: "9".charCodeAt(0),
            NUMPAD_0: 96,
            NUMPAD_1: 97,
            NUMPAD_2: 98,
            NUMPAD_3: 99,
            NUMPAD_4: 100,
            NUMPAD_5: 101,
            NUMPAD_6: 102,
            NUMPAD_7: 103,
            NUMPAD_8: 104,
            NUMPAD_9: 105,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_ADD: 107,
            NUMPAD_ENTER: 108,
            NUMPAD_SUBTRACT: 109,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            F1: 112,
            F2: 113,
            F3: 114,
            F4: 115,
            F5: 116,
            F6: 117,
            F7: 118,
            F8: 119,
            F9: 120,
            F10: 121,
            F11: 122,
            F12: 123,
            F13: 124,
            F14: 125,
            F15: 126,
            COLON: 186,
            EQUALS: 187,
            COMMA: 188,
            UNDERSCORE: 189,
            PERIOD: 190,
            QUESTION_MARK: 191,
            TILDE: 192,
            OPEN_BRACKET: 219,
            BACKWARD_SLASH: 220,
            CLOSED_BRACKET: 221,
            QUOTES: 222,
            BACKSPACE: 8,
            TAB: 9,
            CLEAR: 12,
            ENTER: 13,
            SHIFT: 16,
            CONTROL: 17,
            ALT: 18,
            CAPS_LOCK: 20,
            ESC: 27,
            SPACEBAR: 32,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            PLUS: 43,
            MINUS: 44,
            INSERT: 45,
            DELETE: 46,
            HELP: 47,
            NUM_LOCK: 144
        };
        for (var s in i.KeyCode) i.KeyCode.hasOwnProperty(s) && !s.match(/[a-z]/) && (i.Keyboard[s] = i.KeyCode[s]);
        i.Component = function() {}, i.Component.Angle = function() {}, i.Component.Angle.prototype = {
            angle: {
                get: function() {
                    return i.Math.wrapAngle(i.Math.radToDeg(this.rotation))
                },
                set: function(t) {
                    this.rotation = i.Math.degToRad(i.Math.wrapAngle(t))
                }
            }
        }, i.Component.Animation = function() {}, i.Component.Animation.prototype = {
            play: function(t, e, i, o) {
                if (this.animations) return this.animations.play(t, e, i, o)
            }
        }, i.Component.AutoCull = function() {}, i.Component.AutoCull.prototype = {
            autoCull: !1,
            inCamera: {
                get: function() {
                    return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds)
                }
            }
        }, i.Component.Bounds = function() {}, i.Component.Bounds.prototype = {
            offsetX: {
                get: function() {
                    return this.anchor.x * this.width
                }
            },
            offsetY: {
                get: function() {
                    return this.anchor.y * this.height
                }
            },
            centerX: {
                get: function() {
                    return this.x - this.offsetX + .5 * this.width
                },
                set: function(t) {
                    this.x = t + this.offsetX - .5 * this.width
                }
            },
            centerY: {
                get: function() {
                    return this.y - this.offsetY + .5 * this.height
                },
                set: function(t) {
                    this.y = t + this.offsetY - .5 * this.height
                }
            },
            left: {
                get: function() {
                    return this.x - this.offsetX
                },
                set: function(t) {
                    this.x = t + this.offsetX
                }
            },
            right: {
                get: function() {
                    return this.x + this.width - this.offsetX
                },
                set: function(t) {
                    this.x = t - this.width + this.offsetX
                }
            },
            top: {
                get: function() {
                    return this.y - this.offsetY
                },
                set: function(t) {
                    this.y = t + this.offsetY
                }
            },
            bottom: {
                get: function() {
                    return this.y + this.height - this.offsetY
                },
                set: function(t) {
                    this.y = t - this.height + this.offsetY
                }
            },
            alignIn: function(t, e, o, s) {
                switch (void 0 === o && (o = 0), void 0 === s && (s = 0), e) {
                    default:
                        case i.TOP_LEFT:
                        this.left = t.left - o,
                    this.top = t.top - s;
                    break;
                    case i.TOP_CENTER:
                            this.centerX = t.centerX + o,
                        this.top = t.top - s;
                        break;
                    case i.TOP_RIGHT:
                            this.right = t.right + o,
                        this.top = t.top - s;
                        break;
                    case i.LEFT_CENTER:
                            this.left = t.left - o,
                        this.centerY = t.centerY + s;
                        break;
                    case i.CENTER:
                            this.centerX = t.centerX + o,
                        this.centerY = t.centerY + s;
                        break;
                    case i.RIGHT_CENTER:
                            this.right = t.right + o,
                        this.centerY = t.centerY + s;
                        break;
                    case i.BOTTOM_LEFT:
                            this.left = t.left - o,
                        this.bottom = t.bottom + s;
                        break;
                    case i.BOTTOM_CENTER:
                            this.centerX = t.centerX + o,
                        this.bottom = t.bottom + s;
                        break;
                    case i.BOTTOM_RIGHT:
                            this.right = t.right + o,
                        this.bottom = t.bottom + s
                }
                return this
            },
            alignTo: function(t, e, o, s) {
                switch (void 0 === o && (o = 0),
                    void 0 === s && (s = 0), e) {
                    default:
                        case i.TOP_LEFT:
                        this.left = t.left - o,
                    this.bottom = t.top - s;
                    break;
                    case i.TOP_CENTER:
                            this.centerX = t.centerX + o,
                        this.bottom = t.top - s;
                        break;
                    case i.TOP_RIGHT:
                            this.right = t.right + o,
                        this.bottom = t.top - s;
                        break;
                    case i.LEFT_TOP:
                            this.right = t.left - o,
                        this.top = t.top - s;
                        break;
                    case i.LEFT_CENTER:
                            this.right = t.left - o,
                        this.centerY = t.centerY + s;
                        break;
                    case i.LEFT_BOTTOM:
                            this.right = t.left - o,
                        this.bottom = t.bottom + s;
                        break;
                    case i.RIGHT_TOP:
                            this.left = t.right + o,
                        this.top = t.top - s;
                        break;
                    case i.RIGHT_CENTER:
                            this.left = t.right + o,
                        this.centerY = t.centerY + s;
                        break;
                    case i.RIGHT_BOTTOM:
                            this.left = t.right + o,
                        this.bottom = t.bottom + s;
                        break;
                    case i.BOTTOM_LEFT:
                            this.left = t.left - o,
                        this.top = t.bottom + s;
                        break;
                    case i.BOTTOM_CENTER:
                            this.centerX = t.centerX + o,
                        this.top = t.bottom + s;
                        break;
                    case i.BOTTOM_RIGHT:
                            this.right = t.right + o,
                        this.top = t.bottom + s
                }
                return this
            }
        }, i.Group.prototype.alignIn = i.Component.Bounds.prototype.alignIn, i.Group.prototype.alignTo = i.Component.Bounds.prototype.alignTo, i.Component.BringToTop = function() {}, i.Component.BringToTop.prototype.bringToTop = function() {
            return this.parent && this.parent.bringToTop(this), this
        }, i.Component.BringToTop.prototype.sendToBack = function() {
            return this.parent && this.parent.sendToBack(this), this
        }, i.Component.BringToTop.prototype.moveUp = function() {
            return this.parent && this.parent.moveUp(this), this
        }, i.Component.BringToTop.prototype.moveDown = function() {
            return this.parent && this.parent.moveDown(this), this
        }, i.Component.Core = function() {}, i.Component.Core.install = function(t) {
            i.Utils.mixinPrototype(this, i.Component.Core.prototype), this.components = {};
            for (var e = 0; e < t.length; e++) {
                var o = t[e],
                    s = !1;
                "Destroy" === o && (s = !0), i.Utils.mixinPrototype(this, i.Component[o].prototype, s), this.components[o] = !0
            }
        }, i.Component.Core.init = function(t, e, o, s, n) {
            this.game = t, this.key = s, this.data = {}, this.position.set(e, o), this.world = new i.Point(e, o), this.previousPosition = new i.Point(e, o), this.events = new i.Events(this), this._bounds = new i.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new i.AnimationManager(this)), this.components.LoadTexture && null !== s && this.loadTexture(s, n)
        }, i.Component.Core.preUpdate = function() {
            if (this.pendingDestroy) return void this.destroy();
            if (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
            this.world.setTo(this.game.camera.view.x + this.worldTransform.tx, this.game.camera.view.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate();
            for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
            return !0
        }, i.Component.Core.prototype = {
            game: null,
            name: "",
            data: {},
            components: {},
            z: 0,
            events: void 0,
            animations: void 0,
            key: "",
            world: null,
            debug: !1,
            previousPosition: null,
            previousRotation: 0,
            renderOrderID: 0,
            fresh: !0,
            pendingDestroy: !1,
            _bounds: null,
            _exists: !0,
            exists: {
                get: function() {
                    return this._exists
                },
                set: function(t) {
                    t ? (this._exists = !0, this.body && this.body.type === i.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === i.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1)
                }
            },
            update: function() {},
            postUpdate: function() {
                this.customRender && this.key.render(), this.components.PhysicsBody && i.Component.PhysicsBody.postUpdate.call(this);
                for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
            }
        }, i.Component.Crop = function() {}, i.Component.Crop.prototype = {
            cropRect: null,
            _crop: null,
            crop: function(t, e) {
                void 0 === e && (e = !1), t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : e && null === this.cropRect ? this.cropRect = new i.Rectangle(t.x, t.y, t.width, t.height) : this.cropRect = t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
            },
            updateCrop: function() {
                if (this.cropRect) {
                    var t = this.texture.crop.x,
                        e = this.texture.crop.y,
                        o = this.texture.crop.width,
                        s = this.texture.crop.height;
                    this._crop = i.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                    var n = Math.max(this._frame.x, this._crop.x),
                        r = Math.max(this._frame.y, this._crop.y),
                        a = Math.min(this._frame.right, this._crop.right) - n,
                        h = Math.min(this._frame.bottom, this._crop.bottom) - r;
                    this.texture.crop.x = n, this.texture.crop.y = r, this.texture.crop.width = a, this.texture.crop.height = h, this.texture.frame.width = Math.min(a, this.cropRect.width), this.texture.frame.height = Math.min(h, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || t === n && e === r && o === a && s === h || (this.texture.requiresReTint = !0)
                }
            }
        }, i.Component.Delta = function() {}, i.Component.Delta.prototype = {
            deltaX: {
                get: function() {
                    return this.world.x - this.previousPosition.x
                }
            },
            deltaY: {
                get: function() {
                    return this.world.y - this.previousPosition.y
                }
            },
            deltaZ: {
                get: function() {
                    return this.rotation - this.previousRotation
                }
            }
        }, i.Component.Destroy = function() {}, i.Component.Destroy.prototype = {
            destroyPhase: !1,
            destroy: function(t, e) {
                if (null !== this.game && !this.destroyPhase) {
                    void 0 === t && (t = !0), void 0 === e && (e = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof i.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                    var o = this.children.length;
                    if (t)
                        for (; o--;) this.children[o].destroy(t);
                    else
                        for (; o--;) this.removeChild(this.children[o]);
                    this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), i.Video && this.key instanceof i.Video && this.key.onChangeSource.remove(this.resizeFrame, this), i.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), e && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                }
            }
        }, i.Events = function(t) {
            this.parent = t
        }, i.Events.prototype = {
            destroy: function() {
                this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose()
            },
            onAddedToGroup: null,
            onRemovedFromGroup: null,
            onRemovedFromWorld: null,
            onDestroy: null,
            onKilled: null,
            onRevived: null,
            onOutOfBounds: null,
            onEnterBounds: null,
            onInputOver: null,
            onInputOut: null,
            onInputDown: null,
            onInputUp: null,
            onDragStart: null,
            onDragUpdate: null,
            onDragStop: null,
            onAnimationStart: null,
            onAnimationComplete: null,
            onAnimationLoop: null
        }, i.Events.prototype.constructor = i.Events;
        for (var n in i.Events.prototype) i.Events.prototype.hasOwnProperty(n) && 0 === n.indexOf("on") && null === i.Events.prototype[n] && function(t, e) {
            "use strict";
            Object.defineProperty(i.Events.prototype, t, {
                get: function() {
                    return this[e] || (this[e] = new i.Signal)
                }
            }), i.Events.prototype[t + "$dispatch"] = function() {
                return this[e] ? this[e].dispatch.apply(this[e], arguments) : null
            }
        }(n, "_" + n);
        i.Component.Health = function() {}, i.Component.Health.prototype = {
            health: 1,
            maxHealth: 100,
            damage: function(t) {
                return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this
            },
            setHealth: function(t) {
                return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this
            },
            heal: function(t) {
                return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this
            }
        }, i.Component.InCamera = function() {}, i.Component.InCamera.prototype = {
            inCamera: {
                get: function() {
                    return this.game.world.camera.view.intersects(this._bounds)
                }
            }
        }, i.Component.InputEnabled = function() {}, i.Component.InputEnabled.prototype = {
            input: null,
            inputEnabled: {
                get: function() {
                    return this.input && this.input.enabled
                },
                set: function(t) {
                    t ? null === this.input ? (this.input = new i.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                }
            }
        }, i.Component.InWorld = function() {}, i.Component.InWorld.preUpdate = function() {
            if (this.autoCull || this.checkWorldBounds) {
                if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                    if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                    else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
                if (this.checkWorldBounds)
                    if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                    else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
            }
            return !0
        }, i.Component.InWorld.prototype = {
            checkWorldBounds: !1,
            outOfBoundsKill: !1,
            outOfCameraBoundsKill: !1,
            _outOfBoundsFired: !1,
            inWorld: {
                get: function() {
                    return this.game.world.bounds.intersects(this.getBounds())
                }
            }
        }, i.Component.LifeSpan = function() {}, i.Component.LifeSpan.preUpdate = function() {
            return !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) || (this.kill(), !1)
        }, i.Component.LifeSpan.prototype = {
            alive: !0,
            lifespan: 0,
            revive: function(t) {
                return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this
            },
            kill: function() {
                return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this
            }
        }, i.Component.LoadTexture = function() {}, i.Component.LoadTexture.prototype = {
            customRender: !1,
            _frame: null,
            loadTexture: function(t, e, o) {
                t === i.PENDING_ATLAS ? (t = e, e = 0) : e = e || 0, (o || void 0 === o) && this.animations && this.animations.stop(), this.key = t, this.customRender = !1;
                var s = this.game.cache,
                    n = !0,
                    r = !this.texture.baseTexture.scaleMode;
                if (i.RenderTexture && t instanceof i.RenderTexture) this.key = t.key, this.setTexture(t);
                else if (i.BitmapData && t instanceof i.BitmapData) this.customRender = !0, this.setTexture(t.texture), n = s.hasFrameData(t.key, i.Cache.BITMAPDATA) ? !this.animations.loadFrameData(s.getFrameData(t.key, i.Cache.BITMAPDATA), e) : !this.animations.loadFrameData(t.frameData, 0);
                else if (i.Video && t instanceof i.Video) {
                    this.customRender = !0;
                    var a = t.texture.valid;
                    this.setTexture(t.texture), this.setFrame(t.texture.frame.clone()), t.onChangeSource.add(this.resizeFrame, this), this.texture.valid = a
                } else if (i.Tilemap && t instanceof i.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(t.canvas));
                else if (t instanceof PIXI.Texture) this.setTexture(t);
                else {
                    var h = s.getImage(t, !0);
                    this.key = h.key, this.setTexture(new PIXI.Texture(h.base)), this.texture.baseTexture.skipRender = "__default" === t, n = !this.animations.loadFrameData(h.frameData, e)
                }
                n && (this._frame = i.Rectangle.clone(this.texture.frame)), r || (this.texture.baseTexture.scaleMode = 1)
            },
            setFrame: function(t) {
                this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                    x: t.spriteSourceSizeX,
                    y: t.spriteSourceSizeY,
                    width: t.sourceSizeW,
                    height: t.sourceSizeH
                }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0)
            },
            resizeFrame: function(t, e, i) {
                this.texture.frame.resize(e, i), this.texture.setFrame(this.texture.frame)
            },
            resetFrame: function() {
                this._frame && this.setFrame(this._frame)
            },
            frame: {
                get: function() {
                    return this.animations.frame
                },
                set: function(t) {
                    this.animations.frame = t
                }
            },
            frameName: {
                get: function() {
                    return this.animations.frameName
                },
                set: function(t) {
                    this.animations.frameName = t
                }
            }
        }, i.Component.Overlap = function() {}, i.Component.Overlap.prototype = {
            overlap: function(t) {
                return i.Rectangle.intersects(this.getBounds(), t.getBounds())
            }
        }, i.Component.PhysicsBody = function() {}, i.Component.PhysicsBody.preUpdate = function() {
            return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1))
        }, i.Component.PhysicsBody.postUpdate = function() {
            this.exists && this.body && this.body.postUpdate()
        }, i.Component.PhysicsBody.prototype = {
            body: null,
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            }
        }, i.Component.Reset = function() {}, i.Component.Reset.prototype.reset = function(t, e, i) {
            return void 0 === i && (i = 1), this.world.set(t, e), this.position.set(t, e), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = i), this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1), this
        }, i.Component.ScaleMinMax = function() {}, i.Component.ScaleMinMax.prototype = {
            transformCallback: null,
            transformCallbackContext: this,
            scaleMin: null,
            scaleMax: null,
            checkTransform: function(t) {
                this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)), this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
            },
            setScaleMinMax: function(t, e, o, s) {
                void 0 === e ? e = o = s = t : void 0 === o && (o = s = e, e = t), null === t ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(t, e) : this.scaleMin = new i.Point(t, e), null === o ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(o, s) : this.scaleMax = new i.Point(o, s), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
            }
        }, i.Component.Smoothed = function() {}, i.Component.Smoothed.prototype = {
            smoothed: {
                get: function() {
                    return !this.texture.baseTexture.scaleMode
                },
                set: function(t) {
                    t ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
                }
            }
        }, i.GameObjectFactory = function(t) {
            this.game = t, this.world = this.game.world
        }, i.GameObjectFactory.prototype = {
            existing: function(t) {
                return this.world.add(t)
            },
            weapon: function(t, e, o, s) {
                var n = this.game.plugins.add(i.Weapon);
                return n.createBullets(t, e, o, s), n
            },
            image: function(t, e, o, s, n) {
                return void 0 === n && (n = this.world), n.add(new i.Image(this.game, t, e, o, s))
            },
            sprite: function(t, e, i, o, s) {
                return void 0 === s && (s = this.world), s.create(t, e, i, o)
            },
            creature: function(t, e, o, s, n) {
                void 0 === n && (n = this.world);
                var r = new i.Creature(this.game, t, e, o, s);
                return n.add(r), r
            },
            tween: function(t) {
                return this.game.tweens.create(t)
            },
            group: function(t, e, o, s, n) {
                return new i.Group(this.game, t, e, o, s, n)
            },
            physicsGroup: function(t, e, o, s) {
                return new i.Group(this.game, e, o, s, !0, t)
            },
            spriteBatch: function(t, e, o) {
                return void 0 === t && (t = null), void 0 === e && (e = "group"), void 0 === o && (o = !1), new i.SpriteBatch(this.game, t, e, o)
            },
            audio: function(t, e, i, o) {
                return this.game.sound.add(t, e, i, o)
            },
            sound: function(t, e, i, o) {
                return this.game.sound.add(t, e, i, o)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            tileSprite: function(t, e, o, s, n, r, a) {
                return void 0 === a && (a = this.world), a.add(new i.TileSprite(this.game, t, e, o, s, n, r))
            },
            rope: function(t, e, o, s, n, r) {
                return void 0 === r && (r = this.world), r.add(new i.Rope(this.game, t, e, o, s, n))
            },
            text: function(t, e, o, s, n) {
                return void 0 === n && (n = this.world), n.add(new i.Text(this.game, t, e, o, s))
            },
            button: function(t, e, o, s, n, r, a, h, l, d) {
                return void 0 === d && (d = this.world), d.add(new i.Button(this.game, t, e, o, s, n, r, a, h, l))
            },
            graphics: function(t, e, o) {
                return void 0 === o && (o = this.world), o.add(new i.Graphics(this.game, t, e))
            },
            emitter: function(t, e, o) {
                return this.game.particles.add(new i.Particles.Arcade.Emitter(this.game, t, e, o))
            },
            retroFont: function(t, e, o, s, n, r, a, h, l) {
                return new i.RetroFont(this.game, t, e, o, s, n, r, a, h, l)
            },
            bitmapText: function(t, e, o, s, n, r) {
                return void 0 === r && (r = this.world), r.add(new i.BitmapText(this.game, t, e, o, s, n))
            },
            tilemap: function(t, e, o, s, n) {
                return new i.Tilemap(this.game, t, e, o, s, n)
            },
            renderTexture: function(t, e, o, s) {
                void 0 !== o && "" !== o || (o = this.game.rnd.uuid()), void 0 === s && (s = !1);
                var n = new i.RenderTexture(this.game, t, e, o);
                return s && this.game.cache.addRenderTexture(o, n), n
            },
            video: function(t, e) {
                return new i.Video(this.game, t, e)
            },
            bitmapData: function(t, e, o, s) {
                void 0 === s && (s = !1), void 0 !== o && "" !== o || (o = this.game.rnd.uuid());
                var n = new i.BitmapData(this.game, o, t, e);
                return s && this.game.cache.addBitmapData(o, n), n
            },
            filter: function(t) {
                var e = Array.prototype.slice.call(arguments, 1),
                    t = new i.Filter[t](this.game);
                return t.init.apply(t, e), t
            },
            plugin: function(t) {
                return this.game.plugins.add(t)
            }
        }, i.GameObjectFactory.prototype.constructor = i.GameObjectFactory, i.GameObjectCreator = function(t) {
            this.game = t, this.world = this.game.world
        }, i.GameObjectCreator.prototype = {
            image: function(t, e, o, s) {
                return new i.Image(this.game, t, e, o, s)
            },
            sprite: function(t, e, o, s) {
                return new i.Sprite(this.game, t, e, o, s)
            },
            tween: function(t) {
                return new i.Tween(t, this.game, this.game.tweens)
            },
            group: function(t, e, o, s, n) {
                return new i.Group(this.game, t, e, o, s, n)
            },
            spriteBatch: function(t, e, o) {
                return void 0 === e && (e = "group"), void 0 === o && (o = !1), new i.SpriteBatch(this.game, t, e, o)
            },
            audio: function(t, e, i, o) {
                return this.game.sound.add(t, e, i, o)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            sound: function(t, e, i, o) {
                return this.game.sound.add(t, e, i, o)
            },
            tileSprite: function(t, e, o, s, n, r) {
                return new i.TileSprite(this.game, t, e, o, s, n, r)
            },
            rope: function(t, e, o, s, n) {
                return new i.Rope(this.game, t, e, o, s, n)
            },
            text: function(t, e, o, s) {
                return new i.Text(this.game, t, e, o, s)
            },
            button: function(t, e, o, s, n, r, a, h, l) {
                return new i.Button(this.game, t, e, o, s, n, r, a, h, l)
            },
            graphics: function(t, e) {
                return new i.Graphics(this.game, t, e)
            },
            emitter: function(t, e, o) {
                return new i.Particles.Arcade.Emitter(this.game, t, e, o)
            },
            retroFont: function(t, e, o, s, n, r, a, h, l) {
                return new i.RetroFont(this.game, t, e, o, s, n, r, a, h, l)
            },
            bitmapText: function(t, e, o, s, n, r) {
                return new i.BitmapText(this.game, t, e, o, s, n, r)
            },
            tilemap: function(t, e, o, s, n) {
                return new i.Tilemap(this.game, t, e, o, s, n)
            },
            renderTexture: function(t, e, o, s) {
                void 0 !== o && "" !== o || (o = this.game.rnd.uuid()), void 0 === s && (s = !1);
                var n = new i.RenderTexture(this.game, t, e, o);
                return s && this.game.cache.addRenderTexture(o, n), n
            },
            bitmapData: function(t, e, o, s) {
                void 0 === s && (s = !1), void 0 !== o && "" !== o || (o = this.game.rnd.uuid());
                var n = new i.BitmapData(this.game, o, t, e);
                return s && this.game.cache.addBitmapData(o, n), n
            },
            filter: function(t) {
                var e = Array.prototype.slice.call(arguments, 1),
                    t = new i.Filter[t](this.game);
                return t.init.apply(t, e), t
            }
        }, i.GameObjectCreator.prototype.constructor = i.GameObjectCreator, i.Sprite = function(t, e, o, s, n) {
            e = e || 0, o = o || 0, s = s || null, n = n || null, this.type = i.SPRITE, this.physicsType = i.SPRITE, PIXI.Sprite.call(this, i.Cache.DEFAULT), i.Component.Core.init.call(this, t, e, o, s, n)
        }, i.Sprite.prototype = Object.create(PIXI.Sprite.prototype), i.Sprite.prototype.constructor = i.Sprite, i.Component.Core.install.call(i.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), i.Sprite.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Sprite.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Sprite.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Sprite.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Sprite.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Image = function(t, e, o, s, n) {
            e = e || 0, o = o || 0, s = s || null, n = n || null, this.type = i.IMAGE, PIXI.Sprite.call(this, i.Cache.DEFAULT), i.Component.Core.init.call(this, t, e, o, s, n)
        }, i.Image.prototype = Object.create(PIXI.Sprite.prototype), i.Image.prototype.constructor = i.Image, i.Component.Core.install.call(i.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), i.Image.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Image.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Image.prototype.preUpdate = i.Component.Core.preUpdate, i.Button = function(t, e, o, s, n, r, a, h, l, d) {
            e = e || 0, o = o || 0, s = s || null, n = n || null, r = r || this, i.Image.call(this, t, e, o, s, h), this.type = i.BUTTON, this.physicsType = i.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new i.Signal, this.onInputOut = new i.Signal, this.onInputDown = new i.Signal, this.onInputUp = new i.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = i.PointerMode.TOUCH, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(a, h, l, d), null !== n && this.onInputUp.add(n, r), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this)
        }, i.Button.prototype = Object.create(i.Image.prototype), i.Button.prototype.constructor = i.Button;
        i.Button.prototype.clearFrames = function() {
            this.setFrames(null, null, null, null)
        }, i.Button.prototype.removedFromWorld = function() {
            this.inputEnabled = !1
        }, i.Button.prototype.setStateFrame = function(t, e, i) {
            var o = "_on" + t + "Frame";
            null !== e ? (this[o] = e, i && this.changeStateFrame(t)) : this[o] = null
        }, i.Button.prototype.changeStateFrame = function(t) {
            if (this.freezeFrames) return !1;
            var e = "_on" + t + "Frame",
                i = this[e];
            return "string" == typeof i ? (this.frameName = i, !0) : "number" == typeof i && (this.frame = i, !0)
        }, i.Button.prototype.setFrames = function(t, e, i, o) {
            this.setStateFrame("Over", t, this.input.pointerOver()), this.setStateFrame("Out", e, !this.input.pointerOver()), this.setStateFrame("Down", i, this.input.pointerDown()), this.setStateFrame("Up", o, this.input.pointerUp())
        }, i.Button.prototype.setStateSound = function(t, e, o) {
            var s = "on" + t + "Sound",
                n = "on" + t + "SoundMarker";
            e instanceof i.Sound || e instanceof i.AudioSprite ? (this[s] = e, this[n] = "string" == typeof o ? o : "") : (this[s] = null, this[n] = "")
        }, i.Button.prototype.playStateSound = function(t) {
            var e = "on" + t + "Sound",
                i = this[e];
            if (i) {
                var o = "on" + t + "SoundMarker",
                    s = this[o];
                return i.play(s), !0
            }
            return !1
        }, i.Button.prototype.setSounds = function(t, e, i, o, s, n, r, a) {
            this.setStateSound("Over", t, e), this.setStateSound("Out", s, n), this.setStateSound("Down", i, o), this.setStateSound("Up", r, a)
        }, i.Button.prototype.setOverSound = function(t, e) {
            this.setStateSound("Over", t, e)
        }, i.Button.prototype.setOutSound = function(t, e) {
            this.setStateSound("Out", t, e)
        }, i.Button.prototype.setDownSound = function(t, e) {
            this.setStateSound("Down", t, e)
        }, i.Button.prototype.setUpSound = function(t, e) {
            this.setStateSound("Up", t, e)
        }, i.Button.prototype.onInputOverHandler = function(t, e) {
            e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame("Over"), this.onOverMouseOnly && !e.isMouse || (this.playStateSound("Over"), this.onInputOver && this.onInputOver.dispatch(this, e)))
        }, i.Button.prototype.onInputOutHandler = function(t, e) {
            this.changeStateFrame("Out"), this.playStateSound("Out"), this.onInputOut && this.onInputOut.dispatch(this, e)
        }, i.Button.prototype.onInputDownHandler = function(t, e) {
            this.changeStateFrame("Down"), this.playStateSound("Down"), this.onInputDown && this.onInputDown.dispatch(this, e)
        }, i.Button.prototype.onInputUpHandler = function(t, e, i) {
            if (this.playStateSound("Up"), this.onInputUp && this.onInputUp.dispatch(this, e, i), !this.freezeFrames)
                if (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode) this.changeStateFrame("Out");
                else {
                    var o = this.changeStateFrame("Up");
                    o || (i ? this.changeStateFrame("Over") : this.changeStateFrame("Out"))
                }
        }, i.SpriteBatch = function(t, e, o, s) {
            void 0 !== e && null !== e || (e = t.world), PIXI.SpriteBatch.call(this), i.Group.call(this, t, e, o, s), this.type = i.SPRITEBATCH
        }, i.SpriteBatch.prototype = i.Utils.extend(!0, i.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, i.Group.prototype), i.SpriteBatch.prototype.constructor = i.SpriteBatch, i.BitmapData = function(t, e, o, s, n) {
            void 0 !== o && 0 !== o || (o = 256), void 0 !== s && 0 !== s || (s = 256), void 0 === n && (n = !1), this.game = t, this.key = e, this.width = o, this.height = s, this.canvas = i.Canvas.create(this, o, s, null, n), this.context = this.canvas.getContext("2d", {
                alpha: !0
            }), this.ctx = this.context, this.smoothProperty = t.renderType === i.CANVAS ? t.renderer.renderSession.smoothProperty : i.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, o, s), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new i.FrameData, this.textureFrame = this.frameData.addFrame(new i.Frame(0, 0, 0, o, s, "bitmapData")), this.texture.frame = this.textureFrame, this.type = i.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new i.Point, this._size = new i.Point, this._scale = new i.Point, this._rotate = 0, this._alpha = {
                prev: 1,
                current: 1
            }, this._anchor = new i.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new i.Circle, this._swapCanvas = void 0
        }, i.BitmapData.prototype = {
            move: function(t, e, i) {
                return 0 !== t && this.moveH(t, i), 0 !== e && this.moveV(e, i), this
            },
            moveH: function(t, e) {
                void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                var i = this._swapCanvas,
                    o = i.getContext("2d"),
                    s = this.height,
                    n = this.canvas;
                if (o.clearRect(0, 0, this.width, this.height), t < 0) {
                    t = Math.abs(t);
                    var r = this.width - t;
                    e && o.drawImage(n, 0, 0, t, s, r, 0, t, s), o.drawImage(n, t, 0, r, s, 0, 0, r, s)
                } else {
                    var r = this.width - t;
                    e && o.drawImage(n, r, 0, t, s, 0, 0, t, s), o.drawImage(n, 0, 0, r, s, t, 0, r, s)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            moveV: function(t, e) {
                void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                var i = this._swapCanvas,
                    o = i.getContext("2d"),
                    s = this.width,
                    n = this.canvas;
                if (o.clearRect(0, 0, this.width, this.height), t < 0) {
                    t = Math.abs(t);
                    var r = this.height - t;
                    e && o.drawImage(n, 0, 0, s, t, 0, r, s, t), o.drawImage(n, 0, t, s, r, 0, 0, s, r)
                } else {
                    var r = this.height - t;
                    e && o.drawImage(n, 0, r, s, t, 0, 0, s, t), o.drawImage(n, 0, 0, s, r, 0, t, s, r)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            add: function(t) {
                if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                else t.loadTexture(this);
                return this
            },
            load: function(t) {
                if ("string" == typeof t && (t = this.game.cache.getImage(t)), t) return this.resize(t.width, t.height), this.cls(), this.draw(t), this.update(), this
            },
            clear: function(t, e, i, o) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === o && (o = this.height), this.context.clearRect(t, e, i, o), this.dirty = !0, this
            },
            fill: function(t, e, i, o) {
                return void 0 === o && (o = 1), this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + o + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this
            },
            generateTexture: function(t) {
                var e = new Image;
                e.src = this.canvas.toDataURL("image/png");
                var i = this.game.cache.addImage(t, "", e);
                return new PIXI.Texture(i.base)
            },
            resize: function(t, e) {
                return t === this.width && e === this.height || (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, void 0 !== this._swapCanvas && (this._swapCanvas.width = t, this._swapCanvas.height = e), this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.update(), this.dirty = !0), this
            },
            update: function(t, e, i, o) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = Math.max(1, this.width)), void 0 === o && (o = Math.max(1, this.height)), this.imageData = this.context.getImageData(t, e, i, o), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this
            },
            processPixelRGB: function(t, e, o, s, n, r) {
                void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = this.width), void 0 === r && (r = this.height);
                for (var a = o + n, h = s + r, l = i.Color.createColor(), d = {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0
                    }, c = !1, p = s; p < h; p++)
                    for (var u = o; u < a; u++) i.Color.unpackPixel(this.getPixel32(u, p), l), !1 !== (d = t.call(e, l, u, p)) && null !== d && void 0 !== d && (this.setPixel32(u, p, d.r, d.g, d.b, d.a, !1), c = !0);
                return c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            processPixel: function(t, e, i, o, s, n) {
                void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = this.width), void 0 === n && (n = this.height);
                for (var r = i + s, a = o + n, h = 0, l = 0, d = !1, c = o; c < a; c++)
                    for (var p = i; p < r; p++) h = this.getPixel32(p, c), (l = t.call(e, h, p, c)) !== h && (this.pixels[c * this.width + p] = l, d = !0);
                return d && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            replaceRGB: function(t, e, o, s, n, r, a, h, l) {
                var d = 0,
                    c = 0,
                    p = this.width,
                    u = this.height,
                    b = i.Color.packPixel(t, e, o, s);
                void 0 !== l && l instanceof i.Rectangle && (d = l.x, c = l.y, p = l.width, u = l.height);
                for (var m = 0; m < u; m++)
                    for (var y = 0; y < p; y++) this.getPixel32(d + y, c + m) === b && this.setPixel32(d + y, c + m, n, r, a, h, !1);
                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
            },
            setHSL: function(t, e, o, s) {
                var n = t || 0 === t,
                    r = e || 0 === e,
                    a = o || 0 === o;
                if (n || r || a) {
                    void 0 === s && (s = new i.Rectangle(0, 0, this.width, this.height));
                    for (var h = i.Color.createColor(), l = s.y; l < s.bottom; l++)
                        for (var d = s.x; d < s.right; d++) i.Color.unpackPixel(this.getPixel32(d, l), h, !0), n && (h.h = t), r && (h.s = e), a && (h.l = o), i.Color.HSLtoRGB(h.h, h.s, h.l, h), this.setPixel32(d, l, h.r, h.g, h.b, h.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            shiftHSL: function(t, e, o, s) {
                if (void 0 !== t && null !== t || (t = !1), void 0 !== e && null !== e || (e = !1), void 0 !== o && null !== o || (o = !1), t || e || o) {
                    void 0 === s && (s = new i.Rectangle(0, 0, this.width, this.height));
                    for (var n = i.Color.createColor(), r = s.y; r < s.bottom; r++)
                        for (var a = s.x; a < s.right; a++) i.Color.unpackPixel(this.getPixel32(a, r), n, !0), t && (n.h = this.game.math.wrap(n.h + t, 0, 1)), e && (n.s = this.game.math.clamp(n.s + e, 0, 1)),
                            o && (n.l = this.game.math.clamp(n.l + o, 0, 1)), i.Color.HSLtoRGB(n.h, n.s, n.l, n), this.setPixel32(a, r, n.r, n.g, n.b, n.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            setPixel32: function(t, e, o, s, n, r, a) {
                return void 0 === a && (a = !0), t >= 0 && t <= this.width && e >= 0 && e <= this.height && (i.Device.LITTLE_ENDIAN ? this.pixels[e * this.width + t] = r << 24 | n << 16 | s << 8 | o : this.pixels[e * this.width + t] = o << 24 | s << 16 | n << 8 | r, a && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this
            },
            setPixel: function(t, e, i, o, s, n) {
                return this.setPixel32(t, e, i, o, s, 255, n)
            },
            getPixel: function(t, e, o) {
                o || (o = i.Color.createColor());
                var s = ~~(t + e * this.width);
                return s *= 4, o.r = this.data[s], o.g = this.data[++s], o.b = this.data[++s], o.a = this.data[++s], o
            },
            getPixel32: function(t, e) {
                if (t >= 0 && t <= this.width && e >= 0 && e <= this.height) return this.pixels[e * this.width + t]
            },
            getPixelRGB: function(t, e, o, s, n) {
                return i.Color.unpackPixel(this.getPixel32(t, e), o, s, n)
            },
            getPixels: function(t) {
                return this.context.getImageData(t.x, t.y, t.width, t.height)
            },
            getFirstPixel: function(t) {
                void 0 === t && (t = 0);
                var e = i.Color.createColor(),
                    o = 0,
                    s = 0,
                    n = 1,
                    r = !1;
                1 === t ? (n = -1, s = this.height) : 3 === t && (n = -1, o = this.width);
                do {
                    i.Color.unpackPixel(this.getPixel32(o, s), e), 0 === t || 1 === t ? ++o === this.width && (o = 0, ((s += n) >= this.height || s <= 0) && (r = !0)) : 2 !== t && 3 !== t || ++s === this.height && (s = 0, ((o += n) >= this.width || o <= 0) && (r = !0))
                } while (0 === e.a && !r);
                return e.x = o, e.y = s, e
            },
            getBounds: function(t) {
                return void 0 === t && (t = new i.Rectangle), t.x = this.getFirstPixel(2).x, t.x === this.width ? t.setTo(0, 0, 0, 0) : (t.y = this.getFirstPixel(0).y, t.width = this.getFirstPixel(3).x - t.x + 1, t.height = this.getFirstPixel(1).y - t.y + 1, t)
            },
            addToWorld: function(t, e, i, o, s, n) {
                s = s || 1, n = n || 1;
                var r = this.game.add.image(t, e, this);
                return r.anchor.set(i, o), r.scale.set(s, n), r
            },
            copy: function(t, e, o, s, n, r, a, h, l, d, c, p, u, b, m, y, f) {
                if (void 0 !== t && null !== t || (t = this), (t instanceof i.RenderTexture || t instanceof PIXI.RenderTexture) && (t = t.getCanvas()), this._image = t, t instanceof i.Sprite || t instanceof i.Image || t instanceof i.Text || t instanceof PIXI.Sprite) this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), this._scale.set(t.scale.x, t.scale.y), this._anchor.set(t.anchor.x, t.anchor.y), this._rotate = t.rotation, this._alpha.current = t.alpha, t.texture instanceof i.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source, void 0 !== r && null !== r || (r = t.x), void 0 !== a && null !== a || (a = t.y), t.texture.trim && (r += t.texture.trim.x - t.anchor.x * t.texture.trim.width, a += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0));
                else {
                    if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, t instanceof i.BitmapData) this._image = t.canvas;
                    else if ("string" == typeof t) {
                        if (null === (t = this.game.cache.getImage(t))) return;
                        this._image = t
                    }
                    this._size.set(this._image.width, this._image.height)
                }
                if (void 0 !== e && null !== e || (e = 0), void 0 !== o && null !== o || (o = 0), s && (this._size.x = s), n && (this._size.y = n), void 0 !== r && null !== r || (r = e), void 0 !== a && null !== a || (a = o), void 0 !== h && null !== h || (h = this._size.x), void 0 !== l && null !== l || (l = this._size.y), "number" == typeof d && (this._rotate = d), "number" == typeof c && (this._anchor.x = c), "number" == typeof p && (this._anchor.y = p), "number" == typeof u && (this._scale.x = u), "number" == typeof b && (this._scale.y = b), "number" == typeof m && (this._alpha.current = m), void 0 === y && (y = null), void 0 === f && (f = !1), !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
                    var g = this.context;
                    return this._alpha.prev = g.globalAlpha, g.save(), g.globalAlpha = this._alpha.current, y && (this.op = y), f && (r |= 0, a |= 0), g.translate(r, a), g.scale(this._scale.x, this._scale.y), g.rotate(this._rotate), g.drawImage(this._image, this._pos.x + e, this._pos.y + o, this._size.x, this._size.y, -h * this._anchor.x, -l * this._anchor.y, h, l), g.restore(), g.globalAlpha = this._alpha.prev, this.dirty = !0, this
                }
            },
            copyTransform: function(t, e, o) {
                if (void 0 === e && (e = null), void 0 === o && (o = !1), !t.hasOwnProperty("worldTransform") || !t.worldVisible || 0 === t.worldAlpha) return this;
                var s = t.worldTransform;
                if (this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), 0 === s.a || 0 === s.d || 0 === this._size.x || 0 === this._size.y) return this;
                t.texture instanceof i.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source;
                var n = s.tx,
                    r = s.ty;
                t.texture.trim && (n += t.texture.trim.x - t.anchor.x * t.texture.trim.width, r += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0)), o && (n |= 0, r |= 0);
                var a = this.context;
                return this._alpha.prev = a.globalAlpha, a.save(), a.globalAlpha = this._alpha.current, e && (this.op = e), a[this.smoothProperty] = t.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, a.setTransform(s.a, s.b, s.c, s.d, n, r), a.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * t.anchor.x, -this._size.y * t.anchor.y, this._size.x, this._size.y), a.restore(), a.globalAlpha = this._alpha.prev, this.dirty = !0, this
            },
            copyRect: function(t, e, i, o, s, n, r) {
                return this.copy(t, e.x, e.y, e.width, e.height, i, o, e.width, e.height, 0, 0, 0, 1, 1, s, n, r)
            },
            draw: function(t, e, i, o, s, n, r) {
                return this.copy(t, null, null, null, null, e, i, o, s, null, null, null, null, null, null, n, r)
            },
            drawGroup: function(t, e, i) {
                return t.total > 0 && t.forEachExists(this.drawGroupProxy, this, e, i), this
            },
            drawGroupProxy: function(t, e, o) {
                if (t.hasOwnProperty("texture") && this.copyTransform(t, e, o), t.type === i.GROUP && t.exists) this.drawGroup(t, e, o);
                else if (t.hasOwnProperty("children") && t.children.length > 0)
                    for (var s = 0; s < t.children.length; s++) t.children[s].exists && this.copyTransform(t.children[s], e, o)
            },
            drawFull: function(t, e, o) {
                if (!1 === t.worldVisible || 0 === t.worldAlpha || t.hasOwnProperty("exists") && !1 === t.exists) return this;
                if (t.type !== i.GROUP && t.type !== i.EMITTER && t.type !== i.BITMAPTEXT)
                    if (t.type === i.GRAPHICS) {
                        var s = t.getBounds();
                        this.ctx.save(), this.ctx.translate(s.x, s.y), PIXI.CanvasGraphics.renderGraphics(t, this.ctx), this.ctx.restore()
                    } else this.copy(t, null, null, null, null, t.worldPosition.x, t.worldPosition.y, null, null, t.worldRotation, null, null, t.worldScale.x, t.worldScale.y, t.worldAlpha, e, o);
                if (t.children)
                    for (var n = 0; n < t.children.length; n++) this.drawFull(t.children[n], e, o);
                return this
            },
            shadow: function(t, e, i, o) {
                var s = this.context;
                return void 0 === t || null === t ? s.shadowColor = "rgba(0,0,0,0)" : (s.shadowColor = t, s.shadowBlur = e || 5, s.shadowOffsetX = i || 10, s.shadowOffsetY = o || 10), this
            },
            alphaMask: function(t, e, i, o) {
                return void 0 === o || null === o ? this.draw(e).blendSourceAtop() : this.draw(e, o.x, o.y, o.width, o.height).blendSourceAtop(), void 0 === i || null === i ? this.draw(t).blendReset() : this.draw(t, i.x, i.y, i.width, i.height).blendReset(), this
            },
            extract: function(t, e, i, o, s, n, r, a, h) {
                return void 0 === s && (s = 255), void 0 === n && (n = !1), void 0 === r && (r = e), void 0 === a && (a = i), void 0 === h && (h = o), n && t.resize(this.width, this.height), this.processPixelRGB(function(n, l, d) {
                    return n.r === e && n.g === i && n.b === o && t.setPixel32(l, d, r, a, h, s, !1), !1
                }, this), t.context.putImageData(t.imageData, 0, 0), t.dirty = !0, t
            },
            rect: function(t, e, i, o, s) {
                return void 0 !== s && (this.context.fillStyle = s), this.context.fillRect(t, e, i, o), this
            },
            text: function(t, e, i, o, s, n) {
                void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = "14px Courier"), void 0 === s && (s = "rgb(255,255,255)"), void 0 === n && (n = !0);
                var r = this.context,
                    a = r.font;
                return r.font = o, n && (r.fillStyle = "rgb(0,0,0)", r.fillText(t, e + 1, i + 1)), r.fillStyle = s, r.fillText(t, e, i), r.font = a, this
            },
            circle: function(t, e, i, o) {
                var s = this.context;
                return void 0 !== o && (s.fillStyle = o), s.beginPath(), s.arc(t, e, i, 0, 2 * Math.PI, !1), s.closePath(), s.fill(), this
            },
            line: function(t, e, i, o, s, n) {
                void 0 === s && (s = "#fff"), void 0 === n && (n = 1);
                var r = this.context;
                return r.beginPath(), r.moveTo(t, e), r.lineTo(i, o), r.lineWidth = n, r.strokeStyle = s, r.stroke(), r.closePath(), this
            },
            textureLine: function(t, e, o) {
                if (void 0 === o && (o = "repeat-x"), "string" != typeof e || (e = this.game.cache.getImage(e))) {
                    var s = t.length;
                    "no-repeat" === o && s > e.width && (s = e.width);
                    var n = this.context;
                    return n.fillStyle = n.createPattern(e, o), this._circle = new i.Circle(t.start.x, t.start.y, e.height), this._circle.circumferencePoint(t.angle - 1.5707963267948966, !1, this._pos), n.save(), n.translate(this._pos.x, this._pos.y), n.rotate(t.angle), n.fillRect(0, 0, s, e.height), n.restore(), this.dirty = !0, this
                }
            },
            render: function() {
                return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this
            },
            destroy: function() {
                this.frameData.destroy(), this.texture.destroy(!0), PIXI.CanvasPool.remove(this)
            },
            blendReset: function() {
                return this.op = "source-over", this
            },
            blendSourceOver: function() {
                return this.op = "source-over", this
            },
            blendSourceIn: function() {
                return this.op = "source-in", this
            },
            blendSourceOut: function() {
                return this.op = "source-out", this
            },
            blendSourceAtop: function() {
                return this.op = "source-atop", this
            },
            blendDestinationOver: function() {
                return this.op = "destination-over", this
            },
            blendDestinationIn: function() {
                return this.op = "destination-in", this
            },
            blendDestinationOut: function() {
                return this.op = "destination-out", this
            },
            blendDestinationAtop: function() {
                return this.op = "destination-atop", this
            },
            blendXor: function() {
                return this.op = "xor", this
            },
            blendAdd: function() {
                return this.op = "lighter", this
            },
            blendMultiply: function() {
                return this.op = "multiply", this
            },
            blendScreen: function() {
                return this.op = "screen", this
            },
            blendOverlay: function() {
                return this.op = "overlay", this
            },
            blendDarken: function() {
                return this.op = "darken", this
            },
            blendLighten: function() {
                return this.op = "lighten", this
            },
            blendColorDodge: function() {
                return this.op = "color-dodge", this
            },
            blendColorBurn: function() {
                return this.op = "color-burn", this
            },
            blendHardLight: function() {
                return this.op = "hard-light", this
            },
            blendSoftLight: function() {
                return this.op = "soft-light", this
            },
            blendDifference: function() {
                return this.op = "difference", this
            },
            blendExclusion: function() {
                return this.op = "exclusion", this
            },
            blendHue: function() {
                return this.op = "hue", this
            },
            blendSaturation: function() {
                return this.op = "saturation", this
            },
            blendColor: function() {
                return this.op = "color", this
            },
            blendLuminosity: function() {
                return this.op = "luminosity", this
            }
        }, Object.defineProperty(i.BitmapData.prototype, "smoothed", {
            get: function() {
                i.Canvas.getSmoothingEnabled(this.context)
            },
            set: function(t) {
                i.Canvas.setSmoothingEnabled(this.context, t)
            }
        }), Object.defineProperty(i.BitmapData.prototype, "op", {
            get: function() {
                return this.context.globalCompositeOperation
            },
            set: function(t) {
                this.context.globalCompositeOperation = t
            }
        }), i.BitmapData.getTransform = function(t, e, i, o, s, n) {
            return "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), "number" != typeof i && (i = 1), "number" != typeof o && (o = 1), "number" != typeof s && (s = 0), "number" != typeof n && (n = 0), {
                sx: i,
                sy: o,
                scaleX: i,
                scaleY: o,
                skewX: s,
                skewY: n,
                translateX: t,
                translateY: e,
                tx: t,
                ty: e
            }
        }, i.BitmapData.prototype.constructor = i.BitmapData, PIXI.Graphics = function() {
            PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new PIXI.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1
        }, PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), PIXI.Graphics.prototype.constructor = PIXI.Graphics, PIXI.Graphics.prototype.lineStyle = function(t, e, i) {
            return this.lineWidth = t || 0, this.lineColor = e || 0, this.lineAlpha = void 0 === i ? 1 : i, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
        }, PIXI.Graphics.prototype.moveTo = function(t, e) {
            return this.drawShape(new PIXI.Polygon([t, e])), this
        }, PIXI.Graphics.prototype.lineTo = function(t, e) {
            return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(t, e), this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.quadraticCurveTo = function(t, e, i, o) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            var s, n, r = this.currentPath.shape.points;
            0 === r.length && this.moveTo(0, 0);
            for (var a = r[r.length - 2], h = r[r.length - 1], l = 0, d = 1; d <= 20; ++d) l = d / 20, s = a + (t - a) * l, n = h + (e - h) * l, r.push(s + (t + (i - t) * l - s) * l, n + (e + (o - e) * l - n) * l);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.bezierCurveTo = function(t, e, i, o, s, n) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            for (var r, a, h, l, d, c = this.currentPath.shape.points, p = c[c.length - 2], u = c[c.length - 1], b = 0, m = 1; m <= 20; ++m) b = m / 20, r = 1 - b, a = r * r, h = a * r, l = b * b, d = l * b, c.push(h * p + 3 * a * b * t + 3 * r * l * i + d * s, h * u + 3 * a * b * e + 3 * r * l * o + d * n);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.arcTo = function(t, e, i, o, s) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
            var n = this.currentPath.shape.points,
                r = n[n.length - 2],
                a = n[n.length - 1],
                h = a - e,
                l = r - t,
                d = o - e,
                c = i - t,
                p = Math.abs(h * c - l * d);
            if (p < 1e-8 || 0 === s) n[n.length - 2] === t && n[n.length - 1] === e || n.push(t, e);
            else {
                var u = h * h + l * l,
                    b = d * d + c * c,
                    m = h * d + l * c,
                    y = s * Math.sqrt(u) / p,
                    f = s * Math.sqrt(b) / p,
                    g = y * m / u,
                    x = f * m / b,
                    _ = y * c + f * l,
                    v = y * d + f * h,
                    w = l * (f + g),
                    C = h * (f + g),
                    S = c * (y + x),
                    A = d * (y + x),
                    T = Math.atan2(C - v, w - _),
                    P = Math.atan2(A - v, S - _);
                this.arc(_ + t, v + e, s, T, P, l * d > c * h)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.arc = function(t, e, i, o, s, n, r) {
            if (o === s) return this;
            void 0 === n && (n = !1), void 0 === r && (r = 40), !n && s <= o ? s += 2 * Math.PI : n && o <= s && (o += 2 * Math.PI);
            var a = n ? -1 * (o - s) : s - o,
                h = Math.ceil(Math.abs(a) / (2 * Math.PI)) * r;
            if (0 === a) return this;
            var l = t + Math.cos(o) * i,
                d = e + Math.sin(o) * i;
            n && this.filling ? this.moveTo(t, e) : this.moveTo(l, d);
            for (var c = this.currentPath.shape.points, p = a / (2 * h), u = 2 * p, b = Math.cos(p), m = Math.sin(p), y = h - 1, f = y % 1 / y, g = 0; g <= y; g++) {
                var x = g + f * g,
                    _ = p + o + u * x,
                    v = Math.cos(_),
                    w = -Math.sin(_);
                c.push((b * v + m * w) * i + t, (b * -w + m * v) * i + e)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.beginFill = function(t, e) {
            return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
        }, PIXI.Graphics.prototype.endFill = function() {
            return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
        }, PIXI.Graphics.prototype.drawRect = function(t, e, i, o) {
            return this.drawShape(new PIXI.Rectangle(t, e, i, o)), this
        }, PIXI.Graphics.prototype.drawRoundedRect = function(t, e, i, o, s) {
            return this.drawShape(new PIXI.RoundedRectangle(t, e, i, o, s)), this
        }, PIXI.Graphics.prototype.drawCircle = function(t, e, i) {
            return this.drawShape(new PIXI.Circle(t, e, i)), this
        }, PIXI.Graphics.prototype.drawEllipse = function(t, e, i, o) {
            return this.drawShape(new PIXI.Ellipse(t, e, i, o)), this
        }, PIXI.Graphics.prototype.drawPolygon = function(t) {
            (t instanceof i.Polygon || t instanceof PIXI.Polygon) && (t = t.points);
            var e = t;
            if (!Array.isArray(e)) {
                e = new Array(arguments.length);
                for (var o = 0; o < e.length; ++o) e[o] = arguments[o]
            }
            return this.drawShape(new i.Polygon(e)), this
        }, PIXI.Graphics.prototype.clear = function() {
            return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this
        }, PIXI.Graphics.prototype.generateTexture = function(t, e, i) {
            void 0 === t && (t = 1), void 0 === e && (e = PIXI.scaleModes.DEFAULT), void 0 === i && (i = 0);
            var o = this.getBounds();
            o.width += i, o.height += i;
            var s = new PIXI.CanvasBuffer(o.width * t, o.height * t),
                n = PIXI.Texture.fromCanvas(s.canvas, e);
            return n.baseTexture.resolution = t, s.context.scale(t, t), s.context.translate(-o.x, -o.y), PIXI.CanvasGraphics.renderGraphics(this, s.context), n
        }, PIXI.Graphics.prototype._renderWebGL = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
                if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode) {
                    t.spriteBatch.currentBlendMode = this.blendMode;
                    var e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode];
                    t.spriteBatch.gl.blendFunc(e[0], e[1])
                }
                if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, t), this.children.length) {
                    t.spriteBatch.start();
                    for (var i = 0; i < this.children.length; i++) this.children[i]._renderWebGL(t);
                    t.spriteBatch.stop()
                }
                this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this.mask, t), t.drawCount++, t.spriteBatch.start()
            }
        }, PIXI.Graphics.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
                var e = t.context,
                    i = this.worldTransform;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t);
                var o = t.resolution,
                    s = i.tx * t.resolution + t.shakeX,
                    n = i.ty * t.resolution + t.shakeY;
                e.setTransform(i.a * o, i.b * o, i.c * o, i.d * o, s, n), PIXI.CanvasGraphics.renderGraphics(this, e);
                for (var r = 0; r < this.children.length; r++) this.children[r]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, PIXI.Graphics.prototype.getBounds = function(t) {
            if (!this._currentBounds) {
                if (!this.renderable) return PIXI.EmptyRectangle;
                this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
                var e = this._localBounds,
                    i = e.x,
                    o = e.width + e.x,
                    s = e.y,
                    n = e.height + e.y,
                    r = t || this.worldTransform,
                    a = r.a,
                    h = r.b,
                    l = r.c,
                    d = r.d,
                    c = r.tx,
                    p = r.ty,
                    u = a * o + l * n + c,
                    b = d * n + h * o + p,
                    m = a * i + l * n + c,
                    y = d * n + h * i + p,
                    f = a * i + l * s + c,
                    g = d * s + h * i + p,
                    x = a * o + l * s + c,
                    _ = d * s + h * o + p,
                    v = u,
                    w = b,
                    C = u,
                    S = b;
                C = m < C ? m : C, C = f < C ? f : C, C = x < C ? x : C, S = y < S ? y : S, S = g < S ? g : S, S = _ < S ? _ : S, v = m > v ? m : v, v = f > v ? f : v, v = x > v ? x : v, w = y > w ? y : w, w = g > w ? g : w, w = _ > w ? _ : w, this._bounds.x = C, this._bounds.width = v - C, this._bounds.y = S, this._bounds.height = w - S, this._currentBounds = this._bounds
            }
            return this._currentBounds
        }, PIXI.Graphics.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = PIXI.identityMatrix;
            for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            var i = this.getBounds();
            for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            return i
        }, PIXI.Graphics.prototype.containsPoint = function(t) {
            this.worldTransform.applyInverse(t, tempPoint);
            for (var e = this.graphicsData, i = 0; i < e.length; i++) {
                var o = e[i];
                if (o.fill && (o.shape && o.shape.contains(tempPoint.x, tempPoint.y))) return !0
            }
            return !1
        }, PIXI.Graphics.prototype.updateLocalBounds = function() {
            var t = 1 / 0,
                e = -1 / 0,
                o = 1 / 0,
                s = -1 / 0;
            if (this.graphicsData.length)
                for (var n, r, a, h, l, d, c = 0; c < this.graphicsData.length; c++) {
                    var p = this.graphicsData[c],
                        u = p.type,
                        b = p.lineWidth;
                    if (n = p.shape, u === PIXI.Graphics.RECT || u === PIXI.Graphics.RREC) a = n.x - b / 2, h = n.y - b / 2, l = n.width + b, d = n.height + b, t = a < t ? a : t, e = a + l > e ? a + l : e, o = h < o ? h : o, s = h + d > s ? h + d : s;
                    else if (u === PIXI.Graphics.CIRC) a = n.x, h = n.y, l = n.radius + b / 2, d = n.radius + b / 2, t = a - l < t ? a - l : t, e = a + l > e ? a + l : e, o = h - d < o ? h - d : o, s = h + d > s ? h + d : s;
                    else if (u === PIXI.Graphics.ELIP) a = n.x, h = n.y, l = n.width + b / 2, d = n.height + b / 2, t = a - l < t ? a - l : t, e = a + l > e ? a + l : e, o = h - d < o ? h - d : o, s = h + d > s ? h + d : s;
                    else {
                        r = n.points;
                        for (var m = 0; m < r.length; m++) r[m] instanceof i.Point ? (a = r[m].x, h = r[m].y) : (a = r[m], h = r[m + 1], m < r.length - 1 && m++), t = a - b < t ? a - b : t, e = a + b > e ? a + b : e, o = h - b < o ? h - b : o, s = h + b > s ? h + b : s
                    }
                } else t = 0, e = 0, o = 0, s = 0;
            var y = this.boundsPadding;
            this._localBounds.x = t - y, this._localBounds.width = e - t + 2 * y, this._localBounds.y = o - y, this._localBounds.height = s - o + 2 * y
        }, PIXI.Graphics.prototype._generateCachedSprite = function() {
            var t = this.getLocalBounds();
            if (this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height);
            else {
                var e = new PIXI.CanvasBuffer(t.width, t.height),
                    i = PIXI.Texture.fromCanvas(e.canvas);
                this._cachedSprite = new PIXI.Sprite(i), this._cachedSprite.buffer = e, this._cachedSprite.worldTransform = this.worldTransform
            }
            this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._cachedSprite.buffer.context.translate(-t.x, -t.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
        }, PIXI.Graphics.prototype.updateCachedSpriteTexture = function() {
            var t = this._cachedSprite,
                e = t.texture,
                i = t.buffer.canvas;
            e.baseTexture.width = i.width, e.baseTexture.height = i.height, e.crop.width = e.frame.width = i.width, e.crop.height = e.frame.height = i.height, t._width = i.width, t._height = i.height, e.baseTexture.dirty()
        }, PIXI.Graphics.prototype.destroyCachedSprite = function() {
            this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
        }, PIXI.Graphics.prototype.drawShape = function(t) {
            this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, t instanceof i.Polygon && (t = t.clone(), t.flatten());
            var e = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, t);
            return this.graphicsData.push(e), e.type === PIXI.Graphics.POLY && (e.shape.closed = this.filling, this.currentPath = e), this.dirty = !0, this._boundsDirty = !0, e
        }, Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(t) {
                this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0
            }
        }), PIXI.GraphicsData = function(t, e, i, o, s, n, r) {
            this.lineWidth = t, this.lineColor = e, this.lineAlpha = i, this._lineTint = e, this.fillColor = o, this.fillAlpha = s, this._fillTint = o, this.fill = n, this.shape = r, this.type = r.type
        }, PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData, PIXI.GraphicsData.prototype.clone = function() {
            return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
        }, PIXI.EarCut = {}, PIXI.EarCut.Triangulate = function(t, e, i) {
            i = i || 2;
            var o = e && e.length,
                s = o ? e[0] * i : t.length,
                n = PIXI.EarCut.linkedList(t, 0, s, i, !0),
                r = [];
            if (!n) return r;
            var a, h, l, d, c, p, u;
            if (o && (n = PIXI.EarCut.eliminateHoles(t, e, n, i)), t.length > 80 * i) {
                a = l = t[0], h = d = t[1];
                for (var b = i; b < s; b += i) c = t[b], p = t[b + 1], c < a && (a = c), p < h && (h = p), c > l && (l = c), p > d && (d = p);
                u = Math.max(l - a, d - h)
            }
            return PIXI.EarCut.earcutLinked(n, r, i, a, h, u), r
        }, PIXI.EarCut.linkedList = function(t, e, i, o, s) {
            var n, r, a, h = 0;
            for (n = e, r = i - o; n < i; n += o) h += (t[r] - t[n]) * (t[n + 1] + t[r + 1]), r = n;
            if (s === h > 0)
                for (n = e; n < i; n += o) a = PIXI.EarCut.insertNode(n, t[n], t[n + 1], a);
            else
                for (n = i - o; n >= e; n -= o) a = PIXI.EarCut.insertNode(n, t[n], t[n + 1], a);
            return a
        }, PIXI.EarCut.filterPoints = function(t, e) {
            if (!t) return t;
            e || (e = t);
            var i, o = t;
            do {
                if (i = !1, o.steiner || !PIXI.EarCut.equals(o, o.next) && 0 !== PIXI.EarCut.area(o.prev, o, o.next)) o = o.next;
                else {
                    if (PIXI.EarCut.removeNode(o), (o = e = o.prev) === o.next) return null;
                    i = !0
                }
            } while (i || o !== e);
            return e
        }, PIXI.EarCut.earcutLinked = function(t, e, i, o, s, n, r) {
            if (t) {
                !r && n && PIXI.EarCut.indexCurve(t, o, s, n);
                for (var a, h, l = t; t.prev !== t.next;)
                    if (a = t.prev, h = t.next, n ? PIXI.EarCut.isEarHashed(t, o, s, n) : PIXI.EarCut.isEar(t)) e.push(a.i / i), e.push(t.i / i), e.push(h.i / i), PIXI.EarCut.removeNode(t), t = h.next, l = h.next;
                    else if ((t = h) === l) {
                    r ? 1 === r ? (t = PIXI.EarCut.cureLocalIntersections(t, e, i), PIXI.EarCut.earcutLinked(t, e, i, o, s, n, 2)) : 2 === r && PIXI.EarCut.splitEarcut(t, e, i, o, s, n) : PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(t), e, i, o, s, n, 1);
                    break
                }
            }
        }, PIXI.EarCut.isEar = function(t) {
            var e = t.prev,
                i = t,
                o = t.next;
            if (PIXI.EarCut.area(e, i, o) >= 0) return !1;
            for (var s = t.next.next; s !== t.prev;) {
                if (PIXI.EarCut.pointInTriangle(e.x, e.y, i.x, i.y, o.x, o.y, s.x, s.y) && PIXI.EarCut.area(s.prev, s, s.next) >= 0) return !1;
                s = s.next
            }
            return !0
        }, PIXI.EarCut.isEarHashed = function(t, e, i, o) {
            var s = t.prev,
                n = t,
                r = t.next;
            if (PIXI.EarCut.area(s, n, r) >= 0) return !1;
            for (var a = s.x < n.x ? s.x < r.x ? s.x : r.x : n.x < r.x ? n.x : r.x, h = s.y < n.y ? s.y < r.y ? s.y : r.y : n.y < r.y ? n.y : r.y, l = s.x > n.x ? s.x > r.x ? s.x : r.x : n.x > r.x ? n.x : r.x, d = s.y > n.y ? s.y > r.y ? s.y : r.y : n.y > r.y ? n.y : r.y, c = PIXI.EarCut.zOrder(a, h, e, i, o), p = PIXI.EarCut.zOrder(l, d, e, i, o), u = t.nextZ; u && u.z <= p;) {
                if (u !== t.prev && u !== t.next && PIXI.EarCut.pointInTriangle(s.x, s.y, n.x, n.y, r.x, r.y, u.x, u.y) && PIXI.EarCut.area(u.prev, u, u.next) >= 0) return !1;
                u = u.nextZ
            }
            for (u = t.prevZ; u && u.z >= c;) {
                if (u !== t.prev && u !== t.next && PIXI.EarCut.pointInTriangle(s.x, s.y, n.x, n.y, r.x, r.y, u.x, u.y) && PIXI.EarCut.area(u.prev, u, u.next) >= 0) return !1;
                u = u.prevZ
            }
            return !0
        }, PIXI.EarCut.cureLocalIntersections = function(t, e, i) {
            var o = t;
            do {
                var s = o.prev,
                    n = o.next.next;
                PIXI.EarCut.intersects(s, o, o.next, n) && PIXI.EarCut.locallyInside(s, n) && PIXI.EarCut.locallyInside(n, s) && (e.push(s.i / i), e.push(o.i / i), e.push(n.i / i), PIXI.EarCut.removeNode(o), PIXI.EarCut.removeNode(o.next), o = t = n), o = o.next
            } while (o !== t);
            return o
        }, PIXI.EarCut.splitEarcut = function(t, e, i, o, s, n) {
            var r = t;
            do {
                for (var a = r.next.next; a !== r.prev;) {
                    if (r.i !== a.i && PIXI.EarCut.isValidDiagonal(r, a)) {
                        var h = PIXI.EarCut.splitPolygon(r, a);
                        return r = PIXI.EarCut.filterPoints(r, r.next), h = PIXI.EarCut.filterPoints(h, h.next), PIXI.EarCut.earcutLinked(r, e, i, o, s, n), void PIXI.EarCut.earcutLinked(h, e, i, o, s, n)
                    }
                    a = a.next
                }
                r = r.next
            } while (r !== t)
        }, PIXI.EarCut.eliminateHoles = function(t, e, i, o) {
            var s, n, r, a, h, l = [];
            for (s = 0, n = e.length; s < n; s++) r = e[s] * o, a = s < n - 1 ? e[s + 1] * o : t.length, h = PIXI.EarCut.linkedList(t, r, a, o, !1), h === h.next && (h.steiner = !0), l.push(PIXI.EarCut.getLeftmost(h));
            for (l.sort(compareX), s = 0; s < l.length; s++) PIXI.EarCut.eliminateHole(l[s], i), i = PIXI.EarCut.filterPoints(i, i.next);
            return i
        }, PIXI.EarCut.compareX = function(t, e) {
            return t.x - e.x
        }, PIXI.EarCut.eliminateHole = function(t, e) {
            if (e = PIXI.EarCut.findHoleBridge(t, e)) {
                var i = PIXI.EarCut.splitPolygon(e, t);
                PIXI.EarCut.filterPoints(i, i.next)
            }
        }, PIXI.EarCut.findHoleBridge = function(t, e) {
            var i, o = e,
                s = t.x,
                n = t.y,
                r = -1 / 0;
            do {
                if (n <= o.y && n >= o.next.y) {
                    var a = o.x + (n - o.y) * (o.next.x - o.x) / (o.next.y - o.y);
                    a <= s && a > r && (r = a, i = o.x < o.next.x ? o : o.next)
                }
                o = o.next
            } while (o !== e);
            if (!i) return null;
            if (t.x === i.x) return i.prev;
            var h, l = i,
                d = 1 / 0;
            for (o = i.next; o !== l;) s >= o.x && o.x >= i.x && PIXI.EarCut.pointInTriangle(n < i.y ? s : r, n, i.x, i.y, n < i.y ? r : s, n, o.x, o.y) && ((h = Math.abs(n - o.y) / (s - o.x)) < d || h === d && o.x > i.x) && PIXI.EarCut.locallyInside(o, t) && (i = o, d = h), o = o.next;
            return i
        }, PIXI.EarCut.indexCurve = function(t, e, i, o) {
            var s = t;
            do {
                null === s.z && (s.z = PIXI.EarCut.zOrder(s.x, s.y, e, i, o)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next
            } while (s !== t);
            s.prevZ.nextZ = null, s.prevZ = null, PIXI.EarCut.sortLinked(s)
        }, PIXI.EarCut.sortLinked = function(t) {
            var e, i, o, s, n, r, a, h, l = 1;
            do {
                for (i = t, t = null, n = null, r = 0; i;) {
                    for (r++, o = i, a = 0, e = 0; e < l && (a++, o = o.nextZ); e++);
                    for (h = l; a > 0 || h > 0 && o;) 0 === a ? (s = o, o = o.nextZ, h--) : 0 !== h && o ? i.z <= o.z ? (s = i, i = i.nextZ, a--) : (s = o, o = o.nextZ, h--) : (s = i, i = i.nextZ, a--), n ? n.nextZ = s : t = s, s.prevZ = n, n = s;
                    i = o
                }
                n.nextZ = null, l *= 2
            } while (r > 1);
            return t
        }, PIXI.EarCut.zOrder = function(t, e, i, o, s) {
            return t = 32767 * (t - i) / s, e = 32767 * (e - o) / s, t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t | e << 1
        }, PIXI.EarCut.getLeftmost = function(t) {
            var e = t,
                i = t;
            do {
                e.x < i.x && (i = e), e = e.next
            } while (e !== t);
            return i
        }, PIXI.EarCut.pointInTriangle = function(t, e, i, o, s, n, r, a) {
            return (s - r) * (e - a) - (t - r) * (n - a) >= 0 && (t - r) * (o - a) - (i - r) * (e - a) >= 0 && (i - r) * (n - a) - (s - r) * (o - a) >= 0
        }, PIXI.EarCut.isValidDiagonal = function(t, e) {
            return PIXI.EarCut.equals(t, e) || t.next.i !== e.i && t.prev.i !== e.i && !PIXI.EarCut.intersectsPolygon(t, e) && PIXI.EarCut.locallyInside(t, e) && PIXI.EarCut.locallyInside(e, t) && PIXI.EarCut.middleInside(t, e)
        }, PIXI.EarCut.area = function(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }, PIXI.EarCut.equals = function(t, e) {
            return t.x === e.x && t.y === e.y
        }, PIXI.EarCut.intersects = function(t, e, i, o) {
            return PIXI.EarCut.area(t, e, i) > 0 != PIXI.EarCut.area(t, e, o) > 0 && PIXI.EarCut.area(i, o, t) > 0 != PIXI.EarCut.area(i, o, e) > 0
        }, PIXI.EarCut.intersectsPolygon = function(t, e) {
            var i = t;
            do {
                if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && PIXI.EarCut.intersects(i, i.next, t, e)) return !0;
                i = i.next
            } while (i !== t);
            return !1
        }, PIXI.EarCut.locallyInside = function(t, e) {
            return PIXI.EarCut.area(t.prev, t, t.next) < 0 ? PIXI.EarCut.area(t, e, t.next) >= 0 && PIXI.EarCut.area(t, t.prev, e) >= 0 : PIXI.EarCut.area(t, e, t.prev) < 0 || PIXI.EarCut.area(t, t.next, e) < 0
        }, PIXI.EarCut.middleInside = function(t, e) {
            var i = t,
                o = !1,
                s = (t.x + e.x) / 2,
                n = (t.y + e.y) / 2;
            do {
                i.y > n != i.next.y > n && s < (i.next.x - i.x) * (n - i.y) / (i.next.y - i.y) + i.x && (o = !o), i = i.next
            } while (i !== t);
            return o
        }, PIXI.EarCut.splitPolygon = function(t, e) {
            var i = new PIXI.EarCut.Node(t.i, t.x, t.y),
                o = new PIXI.EarCut.Node(e.i, e.x, e.y),
                s = t.next,
                n = e.prev;
            return t.next = e, e.prev = t, i.next = s, s.prev = i, o.next = i, i.prev = o, n.next = o, o.prev = n, o
        }, PIXI.EarCut.insertNode = function(t, e, i, o) {
            var s = new PIXI.EarCut.Node(t, e, i);
            return o ? (s.next = o.next, s.prev = o, o.next.prev = s, o.next = s) : (s.prev = s, s.next = s), s
        }, PIXI.EarCut.removeNode = function(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }, PIXI.EarCut.Node = function(t, e, i) {
            this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(t, e) {
            var i, o = e.gl,
                s = e.projection,
                n = e.offset,
                r = e.shaderManager.primitiveShader;
            t.dirty && PIXI.WebGLGraphics.updateGraphics(t, o);
            for (var a = t._webGL[o.id], h = 0; h < a.data.length; h++) 1 === a.data[h].mode ? (i = a.data[h], e.stencilManager.pushStencil(t, i, e), o.drawElements(o.TRIANGLE_FAN, 4, o.UNSIGNED_SHORT, 2 * (i.indices.length - 4)), e.stencilManager.popStencil(t, i, e)) : (i = a.data[h], e.shaderManager.setShader(r), r = e.shaderManager.primitiveShader, o.uniformMatrix3fv(r.translationMatrix, !1, t.worldTransform.toArray(!0)), o.uniform1f(r.flipY, 1), o.uniform2f(r.projectionVector, s.x, -s.y), o.uniform2f(r.offsetVector, -n.x, -n.y), o.uniform3fv(r.tintColor, PIXI.hex2rgb(t.tint)), o.uniform1f(r.alpha, t.worldAlpha), o.bindBuffer(o.ARRAY_BUFFER, i.buffer), o.vertexAttribPointer(r.aVertexPosition, 2, o.FLOAT, !1, 24, 0), o.vertexAttribPointer(r.colorAttribute, 4, o.FLOAT, !1, 24, 8), o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, i.indexBuffer), o.drawElements(o.TRIANGLE_STRIP, i.indices.length, o.UNSIGNED_SHORT, 0))
        }, PIXI.WebGLGraphics.updateGraphics = function(t, e) {
            var i = t._webGL[e.id];
            i || (i = t._webGL[e.id] = {
                lastIndex: 0,
                data: [],
                gl: e
            }), t.dirty = !1;
            var o;
            if (t.clearDirty) {
                for (t.clearDirty = !1, o = 0; o < i.data.length; o++) {
                    var s = i.data[o];
                    s.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(s)
                }
                i.data = [], i.lastIndex = 0
            }
            var n;
            for (o = i.lastIndex; o < t.graphicsData.length; o++) {
                var r = t.graphicsData[o];
                if (r.type === PIXI.Graphics.POLY) {
                    if (r.points = r.shape.points.slice(), r.shape.closed && (r.points[0] === r.points[r.points.length - 2] && r.points[1] === r.points[r.points.length - 1] || r.points.push(r.points[0], r.points[1])), r.fill && r.points.length >= PIXI.WebGLGraphics.stencilBufferLimit)
                        if (r.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit) {
                            n = PIXI.WebGLGraphics.switchMode(i, 0);
                            var a = PIXI.WebGLGraphics.buildPoly(r, n);
                            a || (n = PIXI.WebGLGraphics.switchMode(i, 1), PIXI.WebGLGraphics.buildComplexPoly(r, n))
                        } else n = PIXI.WebGLGraphics.switchMode(i, 1), PIXI.WebGLGraphics.buildComplexPoly(r, n);
                    r.lineWidth > 0 && (n = PIXI.WebGLGraphics.switchMode(i, 0), PIXI.WebGLGraphics.buildLine(r, n))
                } else n = PIXI.WebGLGraphics.switchMode(i, 0), r.type === PIXI.Graphics.RECT ? PIXI.WebGLGraphics.buildRectangle(r, n) : r.type === PIXI.Graphics.CIRC || r.type === PIXI.Graphics.ELIP ? PIXI.WebGLGraphics.buildCircle(r, n) : r.type === PIXI.Graphics.RREC && PIXI.WebGLGraphics.buildRoundedRectangle(r, n);
                i.lastIndex++
            }
            for (o = 0; o < i.data.length; o++) n = i.data[o], n.dirty && n.upload()
        }, PIXI.WebGLGraphics.switchMode = function(t, e) {
            var i;
            return t.data.length ? (i = t.data[t.data.length - 1],
                i.mode === e && 1 !== e || (i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl), i.mode = e, t.data.push(i))) : (i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl), i.mode = e, t.data.push(i)), i.dirty = !0, i
        }, PIXI.WebGLGraphics.buildRectangle = function(t, e) {
            var i = t.shape,
                o = i.x,
                s = i.y,
                n = i.width,
                r = i.height;
            if (t.fill) {
                var a = PIXI.hex2rgb(t.fillColor),
                    h = t.fillAlpha,
                    l = a[0] * h,
                    d = a[1] * h,
                    c = a[2] * h,
                    p = e.points,
                    u = e.indices,
                    b = p.length / 6;
                p.push(o, s), p.push(l, d, c, h), p.push(o + n, s), p.push(l, d, c, h), p.push(o, s + r), p.push(l, d, c, h), p.push(o + n, s + r), p.push(l, d, c, h), u.push(b, b, b + 1, b + 2, b + 3, b + 3)
            }
            if (t.lineWidth) {
                var m = t.points;
                t.points = [o, s, o + n, s, o + n, s + r, o, s + r, o, s], PIXI.WebGLGraphics.buildLine(t, e), t.points = m
            }
        }, PIXI.WebGLGraphics.buildRoundedRectangle = function(t, e) {
            var i = t.shape,
                o = i.x,
                s = i.y,
                n = i.width,
                r = i.height,
                a = i.radius,
                h = [];
            if (h.push(o, s + a), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(o, s + r - a, o, s + r, o + a, s + r)), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(o + n - a, s + r, o + n, s + r, o + n, s + r - a)), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(o + n, s + a, o + n, s, o + n - a, s)), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(o + a, s, o, s, o, s + a)), t.fill) {
                var l = PIXI.hex2rgb(t.fillColor),
                    d = t.fillAlpha,
                    c = l[0] * d,
                    p = l[1] * d,
                    u = l[2] * d,
                    b = e.points,
                    m = e.indices,
                    y = b.length / 6,
                    f = PIXI.EarCut.Triangulate(h, null, 2),
                    g = 0;
                for (g = 0; g < f.length; g += 3) m.push(f[g] + y), m.push(f[g] + y), m.push(f[g + 1] + y), m.push(f[g + 2] + y), m.push(f[g + 2] + y);
                for (g = 0; g < h.length; g++) b.push(h[g], h[++g], c, p, u, d)
            }
            if (t.lineWidth) {
                var x = t.points;
                t.points = h, PIXI.WebGLGraphics.buildLine(t, e), t.points = x
            }
        }, PIXI.WebGLGraphics.quadraticBezierCurve = function(t, e, i, o, s, n) {
            function r(t, e, i) {
                return t + (e - t) * i
            }
            for (var a, h, l, d, c, p, u = [], b = 0, m = 0; m <= 20; m++) b = m / 20, a = r(t, i, b), h = r(e, o, b), l = r(i, s, b), d = r(o, n, b), c = r(a, l, b), p = r(h, d, b), u.push(c, p);
            return u
        }, PIXI.WebGLGraphics.buildCircle = function(t, e) {
            var i, o, s = t.shape,
                n = s.x,
                r = s.y;
            t.type === PIXI.Graphics.CIRC ? (i = s.radius, o = s.radius) : (i = s.width, o = s.height);
            var a = 2 * Math.PI / 40,
                h = 0;
            if (t.fill) {
                var l = PIXI.hex2rgb(t.fillColor),
                    d = t.fillAlpha,
                    c = l[0] * d,
                    p = l[1] * d,
                    u = l[2] * d,
                    b = e.points,
                    m = e.indices,
                    y = b.length / 6;
                for (m.push(y), h = 0; h < 41; h++) b.push(n, r, c, p, u, d), b.push(n + Math.sin(a * h) * i, r + Math.cos(a * h) * o, c, p, u, d), m.push(y++, y++);
                m.push(y - 1)
            }
            if (t.lineWidth) {
                var f = t.points;
                for (t.points = [], h = 0; h < 41; h++) t.points.push(n + Math.sin(a * h) * i, r + Math.cos(a * h) * o);
                PIXI.WebGLGraphics.buildLine(t, e), t.points = f
            }
        }, PIXI.WebGLGraphics.buildLine = function(t, e) {
            var i = 0,
                o = t.points;
            if (0 !== o.length) {
                if (t.lineWidth % 2)
                    for (i = 0; i < o.length; i++) o[i] += .5;
                var s = new PIXI.Point(o[0], o[1]),
                    n = new PIXI.Point(o[o.length - 2], o[o.length - 1]);
                if (s.x === n.x && s.y === n.y) {
                    o = o.slice(), o.pop(), o.pop(), n = new PIXI.Point(o[o.length - 2], o[o.length - 1]);
                    var r = n.x + .5 * (s.x - n.x),
                        a = n.y + .5 * (s.y - n.y);
                    o.unshift(r, a), o.push(r, a)
                }
                var h, l, d, c, p, u, b, m, y, f, g, x, _, v, w, C, S, A, T, P, B, M, I, R = e.points,
                    D = e.indices,
                    k = o.length / 2,
                    V = o.length,
                    E = R.length / 6,
                    L = t.lineWidth / 2,
                    F = PIXI.hex2rgb(t.lineColor),
                    O = t.lineAlpha,
                    G = F[0] * O,
                    U = F[1] * O,
                    N = F[2] * O;
                for (d = o[0], c = o[1], p = o[2], u = o[3], y = -(c - u), f = d - p, I = Math.sqrt(y * y + f * f), y /= I, f /= I, y *= L, f *= L, R.push(d - y, c - f, G, U, N, O), R.push(d + y, c + f, G, U, N, O), i = 1; i < k - 1; i++) d = o[2 * (i - 1)], c = o[2 * (i - 1) + 1], p = o[2 * i], u = o[2 * i + 1], b = o[2 * (i + 1)], m = o[2 * (i + 1) + 1], y = -(c - u), f = d - p, I = Math.sqrt(y * y + f * f), y /= I, f /= I, y *= L, f *= L, g = -(u - m), x = p - b, I = Math.sqrt(g * g + x * x), g /= I, x /= I, g *= L, x *= L, w = -f + c - (-f + u), C = -y + p - (-y + d), S = (-y + d) * (-f + u) - (-y + p) * (-f + c), A = -x + m - (-x + u), T = -g + p - (-g + b), P = (-g + b) * (-x + u) - (-g + p) * (-x + m), B = w * T - A * C, Math.abs(B) < .1 ? (B += 10.1, R.push(p - y, u - f, G, U, N, O), R.push(p + y, u + f, G, U, N, O)) : (h = (C * P - T * S) / B, l = (A * S - w * P) / B, M = (h - p) * (h - p) + (l - u) + (l - u), M > 19600 ? (_ = y - g, v = f - x, I = Math.sqrt(_ * _ + v * v), _ /= I, v /= I, _ *= L, v *= L, R.push(p - _, u - v), R.push(G, U, N, O), R.push(p + _, u + v), R.push(G, U, N, O), R.push(p - _, u - v), R.push(G, U, N, O), V++) : (R.push(h, l), R.push(G, U, N, O), R.push(p - (h - p), u - (l - u)), R.push(G, U, N, O)));
                for (d = o[2 * (k - 2)], c = o[2 * (k - 2) + 1], p = o[2 * (k - 1)], u = o[2 * (k - 1) + 1], y = -(c - u), f = d - p, I = Math.sqrt(y * y + f * f), y /= I, f /= I, y *= L, f *= L, R.push(p - y, u - f), R.push(G, U, N, O), R.push(p + y, u + f), R.push(G, U, N, O), D.push(E), i = 0; i < V; i++) D.push(E++);
                D.push(E - 1)
            }
        }, PIXI.WebGLGraphics.buildComplexPoly = function(t, e) {
            var i = t.points.slice();
            if (!(i.length < 6)) {
                var o = e.indices;
                e.points = i, e.alpha = t.fillAlpha, e.color = PIXI.hex2rgb(t.fillColor);
                for (var s, n, r = 1 / 0, a = -1 / 0, h = 1 / 0, l = -1 / 0, d = 0; d < i.length; d += 2) s = i[d], n = i[d + 1], r = s < r ? s : r, a = s > a ? s : a, h = n < h ? n : h, l = n > l ? n : l;
                i.push(r, h, a, h, a, l, r, l);
                var c = i.length / 2;
                for (d = 0; d < c; d++) o.push(d)
            }
        }, PIXI.WebGLGraphics.buildPoly = function(t, e) {
            var i = t.points;
            if (!(i.length < 6)) {
                var o = e.points,
                    s = e.indices,
                    n = i.length / 2,
                    r = PIXI.hex2rgb(t.fillColor),
                    a = t.fillAlpha,
                    h = r[0] * a,
                    l = r[1] * a,
                    d = r[2] * a,
                    c = PIXI.EarCut.Triangulate(i, null, 2);
                if (!c) return !1;
                var p = o.length / 6,
                    u = 0;
                for (u = 0; u < c.length; u += 3) s.push(c[u] + p), s.push(c[u] + p), s.push(c[u + 1] + p), s.push(c[u + 2] + p), s.push(c[u + 2] + p);
                for (u = 0; u < n; u++) o.push(i[2 * u], i[2 * u + 1], h, l, d, a);
                return !0
            }
        }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(t) {
            this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0
        }, PIXI.WebGLGraphicsData.prototype.reset = function() {
            this.points = [], this.indices = []
        }, PIXI.WebGLGraphicsData.prototype.upload = function() {
            var t = this.gl;
            this.glPoints = new PIXI.Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndicies = new PIXI.Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW), this.dirty = !1
        }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(t, e) {
            var i = t.worldAlpha;
            t.dirty && (this.updateGraphicsTint(t), t.dirty = !1);
            for (var o = 0; o < t.graphicsData.length; o++) {
                var s = t.graphicsData[o],
                    n = s.shape,
                    r = s._fillTint,
                    a = s._lineTint;
                if (e.lineWidth = s.lineWidth, s.type === PIXI.Graphics.POLY) {
                    e.beginPath();
                    var h = n.points;
                    e.moveTo(h[0], h[1]);
                    for (var l = 1; l < h.length / 2; l++) e.lineTo(h[2 * l], h[2 * l + 1]);
                    n.closed && e.lineTo(h[0], h[1]), h[0] === h[h.length - 2] && h[1] === h[h.length - 1] && e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
                } else if (s.type === PIXI.Graphics.RECT)(s.fillColor || 0 === s.fillColor) && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fillRect(n.x, n.y, n.width, n.height)), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.strokeRect(n.x, n.y, n.width, n.height));
                else if (s.type === PIXI.Graphics.CIRC) e.beginPath(), e.arc(n.x, n.y, n.radius, 0, 2 * Math.PI), e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke());
                else if (s.type === PIXI.Graphics.ELIP) {
                    var d = 2 * n.width,
                        c = 2 * n.height,
                        p = n.x - d / 2,
                        u = n.y - c / 2;
                    e.beginPath();
                    var b = d / 2 * .5522848,
                        m = c / 2 * .5522848,
                        y = p + d,
                        f = u + c,
                        g = p + d / 2,
                        x = u + c / 2;
                    e.moveTo(p, x), e.bezierCurveTo(p, x - m, g - b, u, g, u), e.bezierCurveTo(g + b, u, y, x - m, y, x), e.bezierCurveTo(y, x + m, g + b, f, g, f), e.bezierCurveTo(g - b, f, p, x + m, p, x), e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
                } else if (s.type === PIXI.Graphics.RREC) {
                    var _ = n.x,
                        v = n.y,
                        w = n.width,
                        C = n.height,
                        S = n.radius,
                        A = Math.min(w, C) / 2 | 0;
                    S = S > A ? A : S, e.beginPath(), e.moveTo(_, v + S), e.lineTo(_, v + C - S), e.quadraticCurveTo(_, v + C, _ + S, v + C), e.lineTo(_ + w - S, v + C), e.quadraticCurveTo(_ + w, v + C, _ + w, v + C - S), e.lineTo(_ + w, v + S), e.quadraticCurveTo(_ + w, v, _ + w - S, v), e.lineTo(_ + S, v), e.quadraticCurveTo(_, v, _, v + S), e.closePath(), (s.fillColor || 0 === s.fillColor) && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
                }
            }
        }, PIXI.CanvasGraphics.renderGraphicsMask = function(t, e) {
            var i = t.graphicsData.length;
            if (0 !== i) {
                e.beginPath();
                for (var o = 0; o < i; o++) {
                    var s = t.graphicsData[o],
                        n = s.shape;
                    if (s.type === PIXI.Graphics.POLY) {
                        var r = n.points;
                        e.moveTo(r[0], r[1]);
                        for (var a = 1; a < r.length / 2; a++) e.lineTo(r[2 * a], r[2 * a + 1]);
                        r[0] === r[r.length - 2] && r[1] === r[r.length - 1] && e.closePath()
                    } else if (s.type === PIXI.Graphics.RECT) e.rect(n.x, n.y, n.width, n.height), e.closePath();
                    else if (s.type === PIXI.Graphics.CIRC) e.arc(n.x, n.y, n.radius, 0, 2 * Math.PI), e.closePath();
                    else if (s.type === PIXI.Graphics.ELIP) {
                        var h = 2 * n.width,
                            l = 2 * n.height,
                            d = n.x - h / 2,
                            c = n.y - l / 2,
                            p = h / 2 * .5522848,
                            u = l / 2 * .5522848,
                            b = d + h,
                            m = c + l,
                            y = d + h / 2,
                            f = c + l / 2;
                        e.moveTo(d, f), e.bezierCurveTo(d, f - u, y - p, c, y, c), e.bezierCurveTo(y + p, c, b, f - u, b, f), e.bezierCurveTo(b, f + u, y + p, m, y, m), e.bezierCurveTo(y - p, m, d, f + u, d, f), e.closePath()
                    } else if (s.type === PIXI.Graphics.RREC) {
                        var g = n.x,
                            x = n.y,
                            _ = n.width,
                            v = n.height,
                            w = n.radius,
                            C = Math.min(_, v) / 2 | 0;
                        w = w > C ? C : w, e.moveTo(g, x + w), e.lineTo(g, x + v - w), e.quadraticCurveTo(g, x + v, g + w, x + v), e.lineTo(g + _ - w, x + v), e.quadraticCurveTo(g + _, x + v, g + _, x + v - w), e.lineTo(g + _, x + w), e.quadraticCurveTo(g + _, x, g + _ - w, x), e.lineTo(g + w, x), e.quadraticCurveTo(g, x, g, x + w), e.closePath()
                    }
                }
            }
        }, PIXI.CanvasGraphics.updateGraphicsTint = function(t) {
            if (16777215 !== t.tint)
                for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, o = (255 & t.tint) / 255, s = 0; s < t.graphicsData.length; s++) {
                    var n = t.graphicsData[s],
                        r = 0 | n.fillColor,
                        a = 0 | n.lineColor;
                    n._fillTint = ((r >> 16 & 255) / 255 * e * 255 << 16) + ((r >> 8 & 255) / 255 * i * 255 << 8) + (255 & r) / 255 * o * 255, n._lineTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * i * 255 << 8) + (255 & a) / 255 * o * 255
                }
        }, i.Graphics = function(t, e, o) {
            void 0 === e && (e = 0), void 0 === o && (o = 0), this.type = i.GRAPHICS, this.physicsType = i.SPRITE, this.anchor = new i.Point, PIXI.Graphics.call(this), i.Component.Core.init.call(this, t, e, o, "", null)
        }, i.Graphics.prototype = Object.create(PIXI.Graphics.prototype), i.Graphics.prototype.constructor = i.Graphics, i.Component.Core.install.call(i.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), i.Graphics.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Graphics.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Graphics.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Graphics.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Graphics.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Graphics.prototype.postUpdate = function() {
            i.Component.PhysicsBody.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
            for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
        }, i.Graphics.prototype.destroy = function(t) {
            this.clear(), i.Component.Destroy.prototype.destroy.call(this, t)
        }, i.Graphics.prototype.drawTriangle = function(t, e) {
            void 0 === e && (e = !1);
            var o = new i.Polygon(t);
            if (e) {
                var s = new i.Point(this.game.camera.x - t[0].x, this.game.camera.y - t[0].y),
                    n = new i.Point(t[1].x - t[0].x, t[1].y - t[0].y),
                    r = new i.Point(t[1].x - t[2].x, t[1].y - t[2].y),
                    a = r.cross(n);
                s.dot(a) > 0 && this.drawPolygon(o)
            } else this.drawPolygon(o)
        }, i.Graphics.prototype.drawTriangles = function(t, e, o) {
            void 0 === o && (o = !1);
            var s, n = new i.Point,
                r = new i.Point,
                a = new i.Point,
                h = [];
            if (e)
                if (t[0] instanceof i.Point)
                    for (s = 0; s < e.length / 3; s++) h.push(t[e[3 * s]]), h.push(t[e[3 * s + 1]]), h.push(t[e[3 * s + 2]]), 3 === h.length && (this.drawTriangle(h, o), h = []);
                else
                    for (s = 0; s < e.length; s++) n.x = t[2 * e[s]], n.y = t[2 * e[s] + 1], h.push(n.copyTo({})), 3 === h.length && (this.drawTriangle(h, o), h = []);
            else if (t[0] instanceof i.Point)
                for (s = 0; s < t.length / 3; s++) this.drawTriangle([t[3 * s], t[3 * s + 1], t[3 * s + 2]], o);
            else
                for (s = 0; s < t.length / 6; s++) n.x = t[6 * s + 0], n.y = t[6 * s + 1], r.x = t[6 * s + 2], r.y = t[6 * s + 3], a.x = t[6 * s + 4], a.y = t[6 * s + 5], this.drawTriangle([n, r, a], o)
        }, i.RenderTexture = function(t, e, o, s, n, r) {
            void 0 === s && (s = ""), void 0 === n && (n = i.scaleModes.DEFAULT), void 0 === r && (r = 1), this.game = t, this.key = s, this.type = i.RENDERTEXTURE, this._tempMatrix = new PIXI.Matrix, PIXI.RenderTexture.call(this, e, o, this.game.renderer, n, r), this.render = i.RenderTexture.prototype.render
        }, i.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype), i.RenderTexture.prototype.constructor = i.RenderTexture, i.RenderTexture.prototype.renderXY = function(t, e, i, o) {
            t.updateTransform(), this._tempMatrix.copyFrom(t.worldTransform), this._tempMatrix.tx = e, this._tempMatrix.ty = i, this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, o) : this.renderCanvas(t, this._tempMatrix, o)
        }, i.RenderTexture.prototype.renderRawXY = function(t, e, i, o) {
            this._tempMatrix.identity().translate(e, i), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, o) : this.renderCanvas(t, this._tempMatrix, o)
        }, i.RenderTexture.prototype.render = function(t, e, i) {
            void 0 === e || null === e ? this._tempMatrix.copyFrom(t.worldTransform) : this._tempMatrix.copyFrom(e), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, i) : this.renderCanvas(t, this._tempMatrix, i)
        }, i.Text = function(t, e, o, s, n) {
            e = e || 0, o = o || 0, s = void 0 === s || null === s ? "" : s.toString(), n = i.Utils.extend({}, n), this.type = i.TEXT, this.physicsType = i.SPRITE, this.padding = new i.Point, this.textBounds = null, this.canvas = PIXI.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this._res = t.renderer.resolution, this._text = s, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, i.Sprite.call(this, t, e, o, PIXI.Texture.fromCanvas(this.canvas)), this.setStyle(n), "" !== s && this.updateText()
        }, i.Text.prototype = Object.create(i.Sprite.prototype), i.Text.prototype.constructor = i.Text, i.Text.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Text.prototype.update = function() {}, i.Text.prototype.destroy = function(t) {
            this.texture.destroy(!0), i.Component.Destroy.prototype.destroy.call(this, t)
        }, i.Text.prototype.setShadow = function(t, e, i, o, s, n) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "rgba(0, 0, 0, 1)"), void 0 === o && (o = 0), void 0 === s && (s = !0), void 0 === n && (n = !0), this.style.shadowOffsetX = t, this.style.shadowOffsetY = e, this.style.shadowColor = i, this.style.shadowBlur = o, this.style.shadowStroke = s, this.style.shadowFill = n, this.dirty = !0, this
        }, i.Text.prototype.setStyle = function(t, e) {
            void 0 === e && (e = !1), t = t || {}, t.font = t.font || "bold 20pt Arial", t.backgroundColor = t.backgroundColor || null, t.fill = t.fill || "black", t.align = t.align || "left", t.boundsAlignH = t.boundsAlignH || "left", t.boundsAlignV = t.boundsAlignV || "top", t.stroke = t.stroke || "black", t.strokeThickness = t.strokeThickness || 0, t.wordWrap = t.wordWrap || !1, t.wordWrapWidth = t.wordWrapWidth || 100, t.maxLines = t.maxLines || 0, t.shadowOffsetX = t.shadowOffsetX || 0, t.shadowOffsetY = t.shadowOffsetY || 0, t.shadowColor = t.shadowColor || "rgba(0,0,0,0)", t.shadowBlur = t.shadowBlur || 0, t.tabs = t.tabs || 0;
            var i = this.fontToComponents(t.font);
            return t.fontStyle && (i.fontStyle = t.fontStyle), t.fontVariant && (i.fontVariant = t.fontVariant), t.fontWeight && (i.fontWeight = t.fontWeight), t.fontSize && ("number" == typeof t.fontSize && (t.fontSize = t.fontSize + "px"), i.fontSize = t.fontSize), this._fontComponents = i, t.font = this.componentsToFont(this._fontComponents), this.style = t, this.dirty = !0, e && this.updateText(), this
        }, i.Text.prototype.updateText = function() {
            this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
            var t = this.text;
            this.style.wordWrap && (t = this.runWordWrap(this.text));
            var e = t.split(/(?:\r\n|\r|\n)/),
                i = this.style.tabs,
                o = [],
                s = 0,
                n = this.determineFontProperties(this.style.font),
                r = e.length;
            this.style.maxLines > 0 && this.style.maxLines < e.length && (r = this.style.maxLines), this._charCount = 0;
            for (var a = 0; a < r; a++) {
                if (0 === i) {
                    var h = this.style.strokeThickness + this.padding.x;
                    this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? h += this.measureLine(e[a]) : h += this.context.measureText(e[a]).width, this.style.wordWrap && (h -= this.context.measureText(" ").width)
                } else {
                    var l = e[a].split(/(?:\t)/),
                        h = this.padding.x + this.style.strokeThickness;
                    if (Array.isArray(i))
                        for (var d = 0, c = 0; c < l.length; c++) {
                            var p = 0;
                            p = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(l[c]) : Math.ceil(this.context.measureText(l[c]).width), c > 0 && (d += i[c - 1]), h = d + p
                        } else
                            for (var c = 0; c < l.length; c++) {
                                this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? h += this.measureLine(l[c]) : h += Math.ceil(this.context.measureText(l[c]).width);
                                var u = this.game.math.snapToCeil(h, i) - h;
                                h += u
                            }
                }
                o[a] = Math.ceil(h), s = Math.max(s, o[a])
            }
            this.canvas.width = s * this._res;
            var b = n.fontSize + this.style.strokeThickness + this.padding.y,
                m = b * r,
                y = this._lineSpacing;
            y < 0 && Math.abs(y) > b && (y = -b), 0 !== y && (m += y > 0 ? y * e.length : y * (e.length - 1)), this.canvas.height = m * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round";
            var f, g;
            for (this._charCount = 0, a = 0; a < r; a++) f = this.style.strokeThickness / 2, g = this.style.strokeThickness / 2 + a * b + n.ascent, a > 0 && (g += y * a), "right" === this.style.align ? f += s - o[a] : "center" === this.style.align && (f += (s - o[a]) / 2), this.autoRound && (f = Math.round(f), g = Math.round(g)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(e[a], f, g) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[a], f, g) : this.renderTabLine(e[a], f, g, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[a], f, g) : this.renderTabLine(e[a], f, g, !0)));
            this.updateTexture(), this.dirty = !1
        }, i.Text.prototype.renderTabLine = function(t, e, i, o) {
            var s = t.split(/(?:\t)/),
                n = this.style.tabs,
                r = 0;
            if (Array.isArray(n))
                for (var a = 0, h = 0; h < s.length; h++) h > 0 && (a += n[h - 1]), r = e + a, o ? this.context.fillText(s[h], r, i) : this.context.strokeText(s[h], r, i);
            else
                for (var h = 0; h < s.length; h++) {
                    var l = Math.ceil(this.context.measureText(s[h]).width);
                    r = this.game.math.snapToCeil(e, n), o ? this.context.fillText(s[h], r, i) : this.context.strokeText(s[h], r, i), e = r + l
                }
        }, i.Text.prototype.updateShadow = function(t) {
            t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0)
        }, i.Text.prototype.measureLine = function(t) {
            for (var e = 0, i = 0; i < t.length; i++) {
                var o = t[i];
                if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var s = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (s.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (s.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(s)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), e += this.context.measureText(o).width, this._charCount++
            }
            return Math.ceil(e)
        }, i.Text.prototype.updateLine = function(t, e, i) {
            for (var o = 0; o < t.length; o++) {
                var s = t[o];
                if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var n = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (n.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (n.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(n)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(s, e, i)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(s, e, i)), e += this.context.measureText(s).width, this._charCount++
            }
        }, i.Text.prototype.clearColors = function() {
            return this.colors = [], this.strokeColors = [], this.dirty = !0, this
        }, i.Text.prototype.clearFontValues = function() {
            return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this
        }, i.Text.prototype.addColor = function(t, e) {
            return this.colors[e] = t, this.dirty = !0, this
        }, i.Text.prototype.addStrokeColor = function(t, e) {
            return this.strokeColors[e] = t, this.dirty = !0, this
        }, i.Text.prototype.addFontStyle = function(t, e) {
            return this.fontStyles[e] = t, this.dirty = !0, this
        }, i.Text.prototype.addFontWeight = function(t, e) {
            return this.fontWeights[e] = t, this.dirty = !0, this
        }, i.Text.prototype.precalculateWordWrap = function(t) {
            return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(t).split(/(?:\r\n|\r|\n)/)
        }, i.Text.prototype.runWordWrap = function(t) {
            return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
        }, i.Text.prototype.advancedWordWrap = function(t) {
            for (var e = this.context, i = this.style.wordWrapWidth, o = "", s = t.replace(/ +/gi, " ").split(/\r?\n/gi), n = s.length, r = 0; r < n; r++) {
                var a = s[r],
                    h = "";
                a = a.replace(/^ *|\s*$/gi, "");
                if (e.measureText(a).width < i) o += a + "\n";
                else {
                    for (var l = i, d = a.split(" "), c = 0; c < d.length; c++) {
                        var p = d[c],
                            u = p + " ",
                            b = e.measureText(u).width;
                        if (b > l) {
                            if (0 === c) {
                                for (var m = u; m.length && (m = m.slice(0, -1), !((b = e.measureText(m).width) <= l)););
                                if (!m.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                var y = p.substr(m.length);
                                d[c] = y, h += m
                            }
                            var f = d[c].length ? c : c + 1,
                                g = d.slice(f).join(" ").replace(/[ \n]*$/gi, "");
                            s[r + 1] = g + " " + (s[r + 1] || ""), n = s.length;
                            break
                        }
                        h += u, l -= b
                    }
                    o += h.replace(/[ \n]*$/gi, "") + "\n"
                }
            }
            return o = o.replace(/[\s|\n]*$/gi, "")
        }, i.Text.prototype.basicWordWrap = function(t) {
            for (var e = "", i = t.split("\n"), o = 0; o < i.length; o++) {
                for (var s = this.style.wordWrapWidth, n = i[o].split(" "), r = 0; r < n.length; r++) {
                    var a = this.context.measureText(n[r]).width,
                        h = a + this.context.measureText(" ").width;
                    h > s ? (r > 0 && (e += "\n"), e += n[r] + " ", s = this.style.wordWrapWidth - a) : (s -= h, e += n[r] + " ")
                }
                o < i.length - 1 && (e += "\n")
            }
            return e
        }, i.Text.prototype.updateFont = function(t) {
            var e = this.componentsToFont(t);
            this.style.font !== e && (this.style.font = e, this.dirty = !0, this.parent && this.updateTransform())
        }, i.Text.prototype.fontToComponents = function(t) {
            var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
            if (e) {
                var i = e[5].trim();
                return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"), {
                    font: t,
                    fontStyle: e[1] || "normal",
                    fontVariant: e[2] || "normal",
                    fontWeight: e[3] || "normal",
                    fontSize: e[4] || "medium",
                    fontFamily: i
                }
            }
            return console.warn("Phaser.Text - unparsable CSS font: " + t), {
                font: t
            }
        }, i.Text.prototype.componentsToFont = function(t) {
            var e, i = [];
            return e = t.fontStyle, e && "normal" !== e && i.push(e), e = t.fontVariant, e && "normal" !== e && i.push(e), e = t.fontWeight, e && "normal" !== e && i.push(e), e = t.fontSize, e && "medium" !== e && i.push(e), e = t.fontFamily, e && i.push(e), i.length || i.push(t.font), i.join(" ")
        }, i.Text.prototype.setText = function(t, e) {
            return void 0 === e && (e = !1), this.text = t.toString() || "", e ? this.updateText() : this.dirty = !0, this
        }, i.Text.prototype.parseList = function(t) {
            if (!Array.isArray(t)) return this;
            for (var e = "", i = 0; i < t.length; i++) Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t"));
            return this.text = e, this.dirty = !0, this
        }, i.Text.prototype.setTextBounds = function(t, e, o, s) {
            return void 0 === t ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(t, e, o, s) : this.textBounds = new i.Rectangle(t, e, o, s), this.style.wordWrapWidth > o && (this.style.wordWrapWidth = o)), this.updateTexture(), this
        }, i.Text.prototype.updateTexture = function() {
            var t = this.texture.baseTexture,
                e = this.texture.crop,
                i = this.texture.frame,
                o = this.canvas.width,
                s = this.canvas.height;
            if (t.width = o, t.height = s, e.width = o, e.height = s, i.width = o, i.height = s, this.texture.width = o, this.texture.height = s, this._width = o, this._height = s, this.textBounds) {
                var n = this.textBounds.x,
                    r = this.textBounds.y;
                "right" === this.style.boundsAlignH ? n += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (n += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? r += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (r += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -n, this.pivot.y = -r
            }
            this.renderable = 0 !== o && 0 !== s, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
        }, i.Text.prototype._renderWebGL = function(t) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, t)
        }, i.Text.prototype._renderCanvas = function(t) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, t)
        }, i.Text.prototype.determineFontProperties = function(t) {
            var e = i.Text.fontPropertiesCache[t];
            if (!e) {
                e = {};
                var o = i.Text.fontPropertiesCanvas,
                    s = i.Text.fontPropertiesContext;
                s.font = t;
                var n = Math.ceil(s.measureText("|MÉq").width),
                    r = Math.ceil(s.measureText("|MÉq").width),
                    a = 2 * r;
                if (r = 1.4 * r | 0, o.width = n, o.height = a, s.fillStyle = "#f00", s.fillRect(0, 0, n, a), s.font = t, s.textBaseline = "alphabetic", s.fillStyle = "#000", s.fillText("|MÉq", 0, r), !s.getImageData(0, 0, n, a)) return e.ascent = r, e.descent = r + 6, e.fontSize = e.ascent + e.descent, i.Text.fontPropertiesCache[t] = e, e;
                var h, l, d = s.getImageData(0, 0, n, a).data,
                    c = d.length,
                    p = 4 * n,
                    u = 0,
                    b = !1;
                for (h = 0; h < r; h++) {
                    for (l = 0; l < p; l += 4)
                        if (255 !== d[u + l]) {
                            b = !0;
                            break
                        }
                    if (b) break;
                    u += p
                }
                for (e.ascent = r - h, u = c - p, b = !1, h = a; h > r; h--) {
                    for (l = 0; l < p; l += 4)
                        if (255 !== d[u + l]) {
                            b = !0;
                            break
                        }
                    if (b) break;
                    u -= p
                }
                e.descent = h - r, e.descent += 6, e.fontSize = e.ascent + e.descent, i.Text.fontPropertiesCache[t] = e
            }
            return e
        }, i.Text.prototype.getBounds = function(t) {
            return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, t)
        }, Object.defineProperty(i.Text.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(i.Text.prototype, "cssFont", {
            get: function() {
                return this.componentsToFont(this._fontComponents)
            },
            set: function(t) {
                t = t || "bold 20pt Arial", this._fontComponents = this.fontToComponents(t), this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "font", {
            get: function() {
                return this._fontComponents.fontFamily
            },
            set: function(t) {
                t = t || "Arial", t = t.trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"), this._fontComponents.fontFamily = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fontSize", {
            get: function() {
                var t = this._fontComponents.fontSize;
                return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
            },
            set: function(t) {
                t = t || "0", "number" == typeof t && (t += "px"), this._fontComponents.fontSize = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fontWeight", {
            get: function() {
                return this._fontComponents.fontWeight || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontWeight = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fontStyle", {
            get: function() {
                return this._fontComponents.fontStyle || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontStyle = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fontVariant", {
            get: function() {
                return this._fontComponents.fontVariant || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontVariant = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fill", {
            get: function() {
                return this.style.fill
            },
            set: function(t) {
                t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "align", {
            get: function() {
                return this.style.align
            },
            set: function(t) {
                t !== this.style.align && (this.style.align = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "resolution", {
            get: function() {
                return this._res
            },
            set: function(t) {
                t !== this._res && (this._res = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "tabs", {
            get: function() {
                return this.style.tabs
            },
            set: function(t) {
                t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "boundsAlignH", {
            get: function() {
                return this.style.boundsAlignH
            },
            set: function(t) {
                t !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "boundsAlignV", {
            get: function() {
                return this.style.boundsAlignV
            },
            set: function(t) {
                t !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "stroke", {
            get: function() {
                return this.style.stroke
            },
            set: function(t) {
                t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "strokeThickness", {
            get: function() {
                return this.style.strokeThickness
            },
            set: function(t) {
                t !== this.style.strokeThickness && (this.style.strokeThickness = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "wordWrap", {
            get: function() {
                return this.style.wordWrap
            },
            set: function(t) {
                t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "wordWrapWidth", {
            get: function() {
                return this.style.wordWrapWidth
            },
            set: function(t) {
                t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "lineSpacing", {
            get: function() {
                return this._lineSpacing
            },
            set: function(t) {
                t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(i.Text.prototype, "shadowOffsetX", {
            get: function() {
                return this.style.shadowOffsetX
            },
            set: function(t) {
                t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowOffsetY", {
            get: function() {
                return this.style.shadowOffsetY
            },
            set: function(t) {
                t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowColor", {
            get: function() {
                return this.style.shadowColor
            },
            set: function(t) {
                t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowBlur", {
            get: function() {
                return this.style.shadowBlur
            },
            set: function(t) {
                t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowStroke", {
            get: function() {
                return this.style.shadowStroke
            },
            set: function(t) {
                t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowFill", {
            get: function() {
                return this.style.shadowFill
            },
            set: function(t) {
                t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "width", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width, this._width = t
            }
        }), Object.defineProperty(i.Text.prototype, "height", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height, this._height = t
            }
        }), i.Text.fontPropertiesCache = {}, i.Text.fontPropertiesCanvas = document.createElement("canvas"), i.Text.fontPropertiesContext = i.Text.fontPropertiesCanvas.getContext("2d"), i.BitmapText = function(t, e, o, s, n, r, a) {
            e = e || 0,
                o = o || 0, s = s || "", n = n || "", r = r || 32, a = a || "left", PIXI.DisplayObjectContainer.call(this), this.type = i.BITMAPTEXT, this.physicsType = i.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new i.Point, this._prevAnchor = new i.Point, this._glyphs = [], this._maxWidth = 0, this._text = n.toString() || "", this._data = t.cache.getBitmapFont(s), this._font = s, this._fontSize = r, this._align = a, this._tint = 16777215, this.updateText(), this.dirty = !1, i.Component.Core.init.call(this, t, e, o, "", null)
        }, i.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.BitmapText.prototype.constructor = i.BitmapText, i.Component.Core.install.call(i.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), i.BitmapText.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.BitmapText.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.BitmapText.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.BitmapText.prototype.preUpdateCore = i.Component.Core.preUpdate, i.BitmapText.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.BitmapText.prototype.postUpdate = function() {
            i.Component.PhysicsBody.postUpdate.call(this), this.body && this.body.type === i.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
        }, i.BitmapText.prototype.setText = function(t) {
            this.text = t
        };
        i.BitmapText.prototype.scanLine = function(t, e, i) {
            for (var o = 0, s = 0, n = -1, r = 0, a = null, h = this._maxWidth > 0 ? this._maxWidth : null, l = [], d = 0; d < i.length; d++) {
                var c = d === i.length - 1;
                if (/(?:\r\n|\r|\n)/.test(i.charAt(d))) return {
                    width: s,
                    text: i.substr(0, d),
                    end: c,
                    chars: l
                };
                var p = i.charCodeAt(d),
                    u = t.chars[p],
                    b = 0;
                void 0 === u && (p = 32, u = t.chars[p]);
                var m = a && u.kerning[a] ? u.kerning[a] : 0;
                if (/(\s)/.test(i.charAt(d)) && (n = d, r = s), b = (m + u.texture.width + u.xOffset) * e, h && s + b >= h && n > -1) return {
                    width: r || s,
                    text: i.substr(0, d - (d - n)),
                    end: c,
                    chars: l
                };
                s += (u.xAdvance + m) * e, l.push(o + (u.xOffset + m) * e), o += (u.xAdvance + m) * e, a = p
            }
            return {
                width: s,
                text: i,
                end: c,
                chars: l
            }
        }, i.BitmapText.prototype.cleanText = function(t, e) {
            void 0 === e && (e = "");
            var i = this._data.font;
            if (!i) return "";
            for (var o = /\r\n|\n\r|\n|\r/g, s = t.replace(o, "\n").split("\n"), n = 0; n < s.length; n++) {
                for (var r = "", a = s[n], h = 0; h < a.length; h++) r = i.chars[a.charCodeAt(h)] ? r.concat(a[h]) : r.concat(e);
                s[n] = r
            }
            return s.join("\n")
        }, i.BitmapText.prototype.updateText = function() {
            var t = this._data.font;
            if (t) {
                var e = this.text,
                    i = this._fontSize / t.size,
                    o = [],
                    s = 0;
                this.textWidth = 0;
                do {
                    var n = this.scanLine(t, i, e);
                    n.y = s, o.push(n), n.width > this.textWidth && (this.textWidth = n.width), s += t.lineHeight * i, e = e.substr(n.text.length + 1)
                } while (!1 === n.end);
                this.textHeight = s;
                for (var r = 0, a = 0, h = this.textWidth * this.anchor.x, l = this.textHeight * this.anchor.y, d = 0; d < o.length; d++) {
                    var n = o[d];
                    "right" === this._align ? a = this.textWidth - n.width : "center" === this._align && (a = (this.textWidth - n.width) / 2);
                    for (var c = 0; c < n.text.length; c++) {
                        var p = n.text.charCodeAt(c),
                            u = t.chars[p];
                        void 0 === u && (p = 32, u = t.chars[p]);
                        var b = this._glyphs[r];
                        b ? b.texture = u.texture : (b = new PIXI.Sprite(u.texture), b.name = n.text[c], this._glyphs.push(b)), b.position.x = n.chars[c] + a - h, b.position.y = n.y + u.yOffset * i - l, b.scale.set(i), b.tint = this.tint, b.texture.requiresReTint = !0, b.parent || this.addChild(b), r++
                    }
                }
                for (d = r; d < this._glyphs.length; d++) this.removeChild(this._glyphs[d])
            }
        }, i.BitmapText.prototype.purgeGlyphs = function() {
            for (var t = this._glyphs.length, e = [], i = 0; i < this._glyphs.length; i++) this._glyphs[i].parent !== this ? this._glyphs[i].destroy() : e.push(this._glyphs[i]);
            return this._glyphs = [], this._glyphs = e, this.updateText(), t - e.length
        }, i.BitmapText.prototype.updateTransform = function() {
            !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
        }, Object.defineProperty(i.BitmapText.prototype, "align", {
            get: function() {
                return this._align
            },
            set: function(t) {
                t === this._align || "left" !== t && "center" !== t && "right" !== t || (this._align = t, this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "tint", {
            get: function() {
                return this._tint
            },
            set: function(t) {
                t !== this._tint && (this._tint = t, this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "font", {
            get: function() {
                return this._font
            },
            set: function(t) {
                t !== this._font && (this._font = t.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "fontSize", {
            get: function() {
                return this._fontSize
            },
            set: function(t) {
                (t = parseInt(t, 10)) !== this._fontSize && t > 0 && (this._fontSize = t, this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "", this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "maxWidth", {
            get: function() {
                return this._maxWidth
            },
            set: function(t) {
                t !== this._maxWidth && (this._maxWidth = t, this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "smoothed", {
            get: function() {
                return !this._data.base.scaleMode
            },
            set: function(t) {
                this._data.base.scaleMode = t ? 0 : 1
            }
        }), i.RetroFont = function(t, e, o, s, n, r, a, h, l, d) {
            if (!t.cache.checkImageKey(e)) return !1;
            void 0 !== r && null !== r || (r = t.cache.getImage(e).width / o), this.characterWidth = o, this.characterHeight = s, this.characterSpacingX = a || 0, this.characterSpacingY = h || 0, this.characterPerRow = r, this.offsetX = l || 0, this.offsetY = d || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = t.cache.getImage(e), this._text = "", this.grabData = [], this.frameData = new i.FrameData;
            for (var c = this.offsetX, p = this.offsetY, u = 0, b = 0; b < n.length; b++) {
                var m = this.frameData.addFrame(new i.Frame(b, c, p, this.characterWidth, this.characterHeight));
                this.grabData[n.charCodeAt(b)] = m.index, u++, u === this.characterPerRow ? (u = 0, c = this.offsetX, p += this.characterHeight + this.characterSpacingY) : c += this.characterWidth + this.characterSpacingX
            }
            t.cache.updateFrameData(e, this.frameData), this.stamp = new i.Image(t, 0, 0, e, 0), i.RenderTexture.call(this, t, 100, 100, "", i.scaleModes.NEAREST), this.type = i.RETROFONT
        }, i.RetroFont.prototype = Object.create(i.RenderTexture.prototype), i.RetroFont.prototype.constructor = i.RetroFont, i.RetroFont.ALIGN_LEFT = "left", i.RetroFont.ALIGN_RIGHT = "right", i.RetroFont.ALIGN_CENTER = "center", i.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", i.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", i.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", i.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", i.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", i.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", i.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", i.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", i.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", i.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", i.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", i.RetroFont.prototype.setFixedWidth = function(t, e) {
            void 0 === e && (e = "left"), this.fixedWidth = t, this.align = e
        }, i.RetroFont.prototype.setText = function(t, e, i, o, s, n) {
            this.multiLine = e || !1, this.customSpacingX = i || 0, this.customSpacingY = o || 0, this.align = s || "left", this.autoUpperCase = !n, t.length > 0 && (this.text = t)
        }, i.RetroFont.prototype.buildRetroFontText = function() {
            var t = 0,
                e = 0;
            if (this.clear(), this.multiLine) {
                var o = this._text.split("\n");
                this.fixedWidth > 0 ? this.resize(this.fixedWidth, o.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), o.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
                for (var s = 0; s < o.length; s++) t = 0, this.align === i.RetroFont.ALIGN_RIGHT ? t = this.width - o[s].length * (this.characterWidth + this.customSpacingX) : this.align === i.RetroFont.ALIGN_CENTER && (t = this.width / 2 - o[s].length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(o[s], t, e, this.customSpacingX), e += this.characterHeight + this.customSpacingY
            } else this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), t = 0, this.align === i.RetroFont.ALIGN_RIGHT ? t = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === i.RetroFont.ALIGN_CENTER && (t = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(this._text, t, 0, this.customSpacingX);
            this.requiresReTint = !0
        }, i.RetroFont.prototype.pasteLine = function(t, e, i, o) {
            for (var s = 0; s < t.length; s++)
                if (" " === t.charAt(s)) e += this.characterWidth + o;
                else if (this.grabData[t.charCodeAt(s)] >= 0 && (this.stamp.frame = this.grabData[t.charCodeAt(s)], this.renderXY(this.stamp, e, i, !1), (e += this.characterWidth + o) > this.width)) break
        }, i.RetroFont.prototype.getLongestLine = function() {
            var t = 0;
            if (this._text.length > 0)
                for (var e = this._text.split("\n"), i = 0; i < e.length; i++) e[i].length > t && (t = e[i].length);
            return t
        }, i.RetroFont.prototype.removeUnsupportedCharacters = function(t) {
            for (var e = "", i = 0; i < this._text.length; i++) {
                var o = this._text[i],
                    s = o.charCodeAt(0);
                (this.grabData[s] >= 0 || !t && "\n" === o) && (e = e.concat(o))
            }
            return e
        }, i.RetroFont.prototype.updateOffset = function(t, e) {
            if (this.offsetX !== t || this.offsetY !== e) {
                for (var i = t - this.offsetX, o = e - this.offsetY, s = this.game.cache.getFrameData(this.stamp.key).getFrames(), n = s.length; n--;) s[n].x += i, s[n].y += o;
                this.buildRetroFontText()
            }
        }, Object.defineProperty(i.RetroFont.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                var e;
                (e = this.autoUpperCase ? t.toUpperCase() : t) !== this._text && (this._text = e, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText())
            }
        }), Object.defineProperty(i.RetroFont.prototype, "smoothed", {
            get: function() {
                return this.stamp.smoothed
            },
            set: function(t) {
                this.stamp.smoothed = t, this.buildRetroFontText()
            }
        }), i.Rope = function(t, e, o, s, n, r) {
            this.points = [], this.points = r, this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, e = e || 0, o = o || 0, s = s || null, n = n || null, this.type = i.ROPE, PIXI.Rope.call(this, i.Cache.DEFAULT, this.points), i.Component.Core.init.call(this, t, e, o, s, n)
        }, i.Rope.prototype = Object.create(PIXI.Rope.prototype), i.Rope.prototype.constructor = i.Rope, i.Component.Core.install.call(i.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), i.Rope.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Rope.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Rope.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Rope.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Rope.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Rope.prototype.update = function() {
            this._hasUpdateAnimation && this.updateAnimation.call(this)
        }, i.Rope.prototype.reset = function(t, e) {
            return i.Component.Reset.prototype.reset.call(this, t, e), this
        }, Object.defineProperty(i.Rope.prototype, "updateAnimation", {
            get: function() {
                return this._updateAnimation
            },
            set: function(t) {
                t && "function" == typeof t ? (this._hasUpdateAnimation = !0, this._updateAnimation = t) : (this._hasUpdateAnimation = !1, this._updateAnimation = null)
            }
        }), Object.defineProperty(i.Rope.prototype, "segments", {
            get: function() {
                for (var t, e, o, s, n, r, a, h, l = [], d = 0; d < this.points.length; d++) t = 4 * d, e = this.vertices[t] * this.scale.x, o = this.vertices[t + 1] * this.scale.y, s = this.vertices[t + 4] * this.scale.x, n = this.vertices[t + 3] * this.scale.y, r = i.Math.difference(e, s), a = i.Math.difference(o, n), e += this.world.x, o += this.world.y, h = new i.Rectangle(e, o, r, a), l.push(h);
                return l
            }
        }), i.TileSprite = function(t, e, o, s, n, r, a) {
            e = e || 0, o = o || 0, s = s || 256, n = n || 256, r = r || null, a = a || null, this.type = i.TILESPRITE, this.physicsType = i.SPRITE, this._scroll = new i.Point;
            var h = t.cache.getImage("__default", !0);
            PIXI.TilingSprite.call(this, new PIXI.Texture(h.base), s, n), i.Component.Core.init.call(this, t, e, o, r, a)
        }, i.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype), i.TileSprite.prototype.constructor = i.TileSprite, i.Component.Core.install.call(i.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]), i.TileSprite.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.TileSprite.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.TileSprite.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.TileSprite.prototype.preUpdateCore = i.Component.Core.preUpdate, i.TileSprite.prototype.preUpdate = function() {
            return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.TileSprite.prototype.autoScroll = function(t, e) {
            this._scroll.set(t, e)
        }, i.TileSprite.prototype.stopScroll = function() {
            this._scroll.set(0, 0)
        }, i.TileSprite.prototype.destroy = function(t) {
            i.Component.Destroy.prototype.destroy.call(this, t), PIXI.TilingSprite.prototype.destroy.call(this)
        }, i.TileSprite.prototype.reset = function(t, e) {
            return i.Component.Reset.prototype.reset.call(this, t, e), this.tilePosition.x = 0, this.tilePosition.y = 0, this
        }, i.Device = function() {
            this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1
        }, i.Device = new i.Device, i.Device.onInitialized = new i.Signal, i.Device.whenReady = function(t, e, i) {
            var o = this._readyCheck;
            if (this.deviceReadyAt || !o) t.call(e, this);
            else if (o._monitor || i) o._queue = o._queue || [], o._queue.push([t, e]);
            else {
                o._monitor = o.bind(this), o._queue = o._queue || [], o._queue.push([t, e]);
                var s = void 0 !== window.cordova,
                    n = navigator.isCocoonJS;
                "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(o._monitor, 0) : s && !n ? document.addEventListener("deviceready", o._monitor, !1) : (document.addEventListener("DOMContentLoaded", o._monitor, !1), window.addEventListener("load", o._monitor, !1))
            }
        }, i.Device._readyCheck = function() {
            var t = this._readyCheck;
            if (document.body) {
                if (!this.deviceReadyAt) {
                    this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", t._monitor), document.removeEventListener("DOMContentLoaded", t._monitor), window.removeEventListener("load", t._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this);
                    for (var e; e = t._queue.shift();) {
                        var i = e[0],
                            o = e[1];
                        i.call(o, this)
                    }
                    this._readyCheck = null, this._initialize = null, this.onInitialized = null
                }
            } else window.setTimeout(t._monitor, 20)
        }, i.Device._initialize = function() {
            function t() {
                var t = new ArrayBuffer(4),
                    e = new Uint8Array(t),
                    i = new Uint32Array(t);
                return e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === i[0] || 2712847316 !== i[0] && null
            }

            function e() {
                if (void 0 === Uint8ClampedArray) return !1;
                var t = PIXI.CanvasPool.create(this, 1, 1),
                    e = t.getContext("2d");
                if (!e) return !1;
                var i = e.createImageData(1, 1);
                return PIXI.CanvasPool.remove(this), i.data instanceof Uint8ClampedArray
            }
            var i = this;
            ! function() {
                var t = navigator.userAgent;
                /Playstation Vita/.test(t) ? i.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? i.kindle = !0 : /Android/.test(t) ? i.android = !0 : /CrOS/.test(t) ? i.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (i.iOS = !0, navigator.appVersion.match(/OS (\d+)/), i.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? i.linux = !0 : /Mac OS/.test(t) ? i.macOS = !0 : /Windows/.test(t) && (i.windows = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (i.android = !1, i.iOS = !1, i.macOS = !1, i.windows = !0, i.windowsPhone = !0);
                var e = /Silk/.test(t);
                (i.windows || i.macOS || i.linux && !e || i.chromeOS) && (i.desktop = !0), (i.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (i.desktop = !1)
            }(),
            function() {
                var t = navigator.userAgent;
                if (/Arora/.test(t) ? i.arora = !0 : /Edge\/\d+/.test(t) ? i.edge = !0 : /Chrome\/(\d+)/.test(t) && !i.windowsPhone ? (i.chrome = !0, i.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? i.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (i.firefox = !0, i.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && i.iOS ? i.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (i.ie = !0, i.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? i.midori = !0 : /Opera/.test(t) ? i.opera = !0 : /Safari\/(\d+)/.test(t) && !i.windowsPhone ? (i.safari = !0, /Version\/(\d+)\./.test(t) && (i.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (i.ie = !0, i.trident = !0, i.tridentVersion = parseInt(RegExp.$1, 10), i.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (i.silk = !0), navigator.standalone && (i.webApp = !0), void 0 !== window.cordova && (i.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (i.node = !0), i.node && "object" == typeof process.versions && (i.nodeWebkit = !!process.versions["node-webkit"], i.electron = !!process.versions.electron), navigator.isCocoonJS && (i.cocoonJS = !0), i.cocoonJS) try {
                    i.cocoonJSApp = "undefined" != typeof CocoonJS
                } catch (t) {
                    i.cocoonJSApp = !1
                }
                void 0 !== window.ejecta && (i.ejecta = !0), /Crosswalk/.test(t) && (i.crosswalk = !0)
            }(),
            function() {
                i.audioData = !!window.Audio, i.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                var t = document.createElement("audio");
                try {
                    if (t.canPlayType && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (i.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || t.canPlayType("audio/opus;").replace(/^no$/, "")) && (i.opus = !0), t.canPlayType("audio/mpeg;").replace(/^no$/, "") && (i.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (i.wav = !0), (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;").replace(/^no$/, "")) && (i.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (i.webm = !0), "" !== t.canPlayType('audio/mp4;codecs="ec-3"')))
                        if (i.edge) i.dolby = !0;
                        else if (i.safari && i.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                        var e = parseInt(RegExp.$1, 10),
                            o = parseInt(RegExp.$2, 10);
                        (10 === e && o >= 11 || e > 10) && (i.dolby = !0)
                    }
                } catch (t) {}
            }(),
            function() {
                var t = document.createElement("video");
                try {
                    !!t.canPlayType && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (i.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (i.h264Video = !0, i.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (i.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (i.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (i.hlsVideo = !0))
                } catch (t) {}
            }(),
            function() {
                var t, e = document.createElement("p"),
                    o = {
                        webkitTransform: "-webkit-transform",
                        OTransform: "-o-transform",
                        msTransform: "-ms-transform",
                        MozTransform: "-moz-transform",
                        transform: "transform"
                    };
                document.body.insertBefore(e, null);
                for (var s in o) void 0 !== e.style[s] && (e.style[s] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(e).getPropertyValue(o[s]));
                document.body.removeChild(e), i.css3D = void 0 !== t && t.length > 0 && "none" !== t
            }(),
            function() {
                i.pixelRatio = window.devicePixelRatio || 1, i.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"), i.iPhone4 = 2 === i.pixelRatio && i.iPhone, i.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"), "undefined" != typeof Int8Array ? i.typedArray = !0 : i.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (i.littleEndian = t(), i.LITTLE_ENDIAN = i.littleEndian), i.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== i.littleEndian && e(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (i.vibration = !0)
            }(),
            function() {
                i.canvas = !!window.CanvasRenderingContext2D || i.cocoonJS;
                try {
                    i.localStorage = !!localStorage.getItem
                } catch (t) {
                    i.localStorage = !1
                }
                i.file = !!(window.File && window.FileReader && window.FileList && window.Blob), i.fileSystem = !!window.requestFileSystem, i.webGL = function() {
                    try {
                        var t = document.createElement("canvas");
                        return t.screencanvas = !1, !!window.WebGLRenderingContext && (t.getContext("webgl") || t.getContext("experimental-webgl"))
                    } catch (t) {
                        return !1
                    }
                }(), i.webGL = !!i.webGL, i.worker = !!window.Worker, i.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, i.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, i.getUserMedia = i.getUserMedia && !!navigator.getUserMedia && !!window.URL, i.firefox && i.firefoxVersion < 21 && (i.getUserMedia = !1), !i.iOS && (i.ie || i.firefox || i.chrome) && (i.canvasBitBltShift = !0), (i.safari || i.mobileSafari) && (i.canvasBitBltShift = !1)
            }(),
            function() {
                for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], e = document.createElement("div"), o = 0; o < t.length; o++)
                    if (e[t[o]]) {
                        i.fullscreen = !0, i.requestFullscreen = t[o];
                        break
                    }
                var s = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                if (i.fullscreen)
                    for (var o = 0; o < s.length; o++)
                        if (document[s[o]]) {
                            i.cancelFullscreen = s[o];
                            break
                        }
                window.Element && Element.ALLOW_KEYBOARD_INPUT && (i.fullscreenKeyboard = !0)
            }(),
            function() {
                ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (i.touch = !0), (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (i.mspointer = !0), i.cocoonJS || ("onwheel" in window || i.ie && "WheelEvent" in window ? i.wheelEvent = "wheel" : "onmousewheel" in window ? i.wheelEvent = "mousewheel" : i.firefox && "MouseScrollEvent" in window && (i.wheelEvent = "DOMMouseScroll"))
            }()
        }, i.Device.canPlayAudio = function(t) {
            return !("mp3" !== t || !this.mp3) || (!("ogg" !== t || !this.ogg && !this.opus) || (!("m4a" !== t || !this.m4a) || (!("opus" !== t || !this.opus) || (!("wav" !== t || !this.wav) || (!("webm" !== t || !this.webm) || !("mp4" !== t || !this.dolby))))))
        }, i.Device.canPlayVideo = function(t) {
            return !("webm" !== t || !this.webmVideo && !this.vp9Video) || (!("mp4" !== t || !this.mp4Video && !this.h264Video) || (!("ogg" !== t && "ogv" !== t || !this.oggVideo) || !("mpeg" !== t || !this.hlsVideo)))
        }, i.Device.isConsoleOpen = function() {
            return !(!window.console || !window.console.firebug) || !(!window.console || (console.profile(), console.profileEnd(), console.clear && console.clear(), !console.profiles)) && console.profiles.length > 0
        }, i.Device.isAndroidStockBrowser = function() {
            var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
            return t && t[1] < 537
        }, i.Canvas = {
            create: function(t, e, i, o, s) {
                e = e || 256, i = i || 256;
                var n = s ? document.createElement("canvas") : PIXI.CanvasPool.create(t, e, i);
                return "string" == typeof o && "" !== o && (n.id = o), n.width = e, n.height = i, n.style.display = "block", n
            },
            setBackgroundColor: function(t, e) {
                return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t
            },
            setTouchAction: function(t, e) {
                return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
            },
            setUserSelect: function(t, e) {
                return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
            },
            addToDOM: function(t, e, i) {
                var o;
                return void 0 === i && (i = !0), e && ("string" == typeof e ? o = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (o = e)), o || (o = document.body), i && o.style && (o.style.overflow = "hidden"), o.appendChild(t), t
            },
            removeFromDOM: function(t) {
                t.parentNode && t.parentNode.removeChild(t)
            },
            setTransform: function(t, e, i, o, s, n, r) {
                return t.setTransform(o, n, r, s, e, i), t
            },
            setSmoothingEnabled: function(t, e) {
                var o = i.Canvas.getSmoothingPrefix(t);
                return o && (t[o] = e), t
            },
            getSmoothingPrefix: function(t) {
                var e = ["i", "webkitI", "msI", "mozI", "oI"];
                for (var i in e) {
                    var o = e[i] + "mageSmoothingEnabled";
                    if (o in t) return o
                }
                return null
            },
            getSmoothingEnabled: function(t) {
                var e = i.Canvas.getSmoothingPrefix(t);
                if (e) return t[e]
            },
            setImageRenderingCrisp: function(t) {
                for (var e = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"], i = 0; i < e.length; i++) t.style["image-rendering"] = e[i];
                return t.style.msInterpolationMode = "nearest-neighbor", t
            },
            setImageRenderingBicubic: function(t) {
                return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
            }
        }, i.RequestAnimationFrame = function(t, e) {
            void 0 === e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e;
            for (var i = ["ms", "moz", "webkit", "o"], o = 0; o < i.length && !window.requestAnimationFrame; o++) window.requestAnimationFrame = window[i[o] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[o] + "CancelAnimationFrame"];
            this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
        }, i.RequestAnimationFrame.prototype = {
            start: function() {
                this.isRunning = !0;
                var t = this;
                !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                    return t.updateSetTimeout()
                }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(e) {
                    return t.updateRAF(e)
                }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateRAF: function(t) {
                this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateSetTimeout: function() {
                this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
            },
            stop: function() {
                this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
            },
            isSetTimeOut: function() {
                return this._isSetTimeOut
            },
            isRAF: function() {
                return !1 === this._isSetTimeOut
            }
        }, i.RequestAnimationFrame.prototype.constructor = i.RequestAnimationFrame, i.Math = {
            PI2: 2 * Math.PI,
            between: function(t, e) {
                return Math.floor(Math.random() * (e - t + 1) + t)
            },
            fuzzyEqual: function(t, e, i) {
                return void 0 === i && (i = 1e-4), Math.abs(t - e) < i
            },
            fuzzyLessThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), t < e + i
            },
            fuzzyGreaterThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), t > e - i
            },
            fuzzyCeil: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.ceil(t - e)
            },
            fuzzyFloor: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.floor(t + e)
            },
            average: function() {
                for (var t = 0, e = arguments.length, i = 0; i < e; i++) t += +arguments[i];
                return t / e
            },
            shear: function(t) {
                return t % 1
            },
            snapTo: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.round(t / e), i + t)
            },
            snapToFloor: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.floor(t / e), i + t)
            },
            snapToCeil: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.ceil(t / e), i + t)
            },
            roundTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var o = Math.pow(i, -e);
                return Math.round(t * o) / o
            },
            floorTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var o = Math.pow(i, -e);
                return Math.floor(t * o) / o
            },
            ceilTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var o = Math.pow(i, -e);
                return Math.ceil(t * o) / o
            },
            rotateToAngle: function(t, e, o) {
                return void 0 === o && (o = .05), t === e ? t : (Math.abs(e - t) <= o || Math.abs(e - t) >= i.Math.PI2 - o ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += i.Math.PI2 : e -= i.Math.PI2), e > t ? t += o : e < t && (t -= o)), t)
            },
            getShortestAngle: function(t, e) {
                var i = e - t;
                return 0 === i ? 0 : i - 360 * Math.floor((i - -180) / 360)
            },
            angleBetween: function(t, e, i, o) {
                return Math.atan2(o - e, i - t)
            },
            angleBetweenY: function(t, e, i, o) {
                return Math.atan2(i - t, o - e)
            },
            angleBetweenPoints: function(t, e) {
                return Math.atan2(e.y - t.y, e.x - t.x)
            },
            angleBetweenPointsY: function(t, e) {
                return Math.atan2(e.x - t.x, e.y - t.y)
            },
            reverseAngle: function(t) {
                return this.normalizeAngle(t + Math.PI, !0)
            },
            normalizeAngle: function(t) {
                return t %= 2 * Math.PI, t >= 0 ? t : t + 2 * Math.PI
            },
            maxAdd: function(t, e, i) {
                return Math.min(t + e, i)
            },
            minSub: function(t, e, i) {
                return Math.max(t - e, i)
            },
            wrap: function(t, e, i) {
                var o = i - e;
                if (o <= 0) return 0;
                var s = (t - e) % o;
                return s < 0 && (s += o), s + e
            },
            wrapValue: function(t, e, i) {
                return t = Math.abs(t), e = Math.abs(e), i = Math.abs(i), (t + e) % i
            },
            isOdd: function(t) {
                return !!(1 & t)
            },
            isEven: function(t) {
                return !(1 & t)
            },
            min: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0];
                else var t = arguments;
                for (var e = 1, i = 0, o = t.length; e < o; e++) t[e] < t[i] && (i = e);
                return t[i]
            },
            max: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0];
                else var t = arguments;
                for (var e = 1, i = 0, o = t.length; e < o; e++) t[e] > t[i] && (i = e);
                return t[i]
            },
            minProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1];
                else var e = arguments.slice(1);
                for (var i = 1, o = 0, s = e.length; i < s; i++) e[i][t] < e[o][t] && (o = i);
                return e[o][t]
            },
            maxProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1];
                else var e = arguments.slice(1);
                for (var i = 1, o = 0, s = e.length; i < s; i++) e[i][t] > e[o][t] && (o = i);
                return e[o][t]
            },
            wrapAngle: function(t, e) {
                return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
            },
            linearInterpolation: function(t, e) {
                var i = t.length - 1,
                    o = i * e,
                    s = Math.floor(o);
                return e < 0 ? this.linear(t[0], t[1], o) : e > 1 ? this.linear(t[i], t[i - 1], i - o) : this.linear(t[s], t[s + 1 > i ? i : s + 1], o - s)
            },
            bezierInterpolation: function(t, e) {
                for (var i = 0, o = t.length - 1, s = 0; s <= o; s++) i += Math.pow(1 - e, o - s) * Math.pow(e, s) * t[s] * this.bernstein(o, s);
                return i
            },
            catmullRomInterpolation: function(t, e) {
                var i = t.length - 1,
                    o = i * e,
                    s = Math.floor(o);
                return t[0] === t[i] ? (e < 0 && (s = Math.floor(o = i * (1 + e))), this.catmullRom(t[(s - 1 + i) % i], t[s], t[(s + 1) % i], t[(s + 2) % i], o - s)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -o) - t[0]) : e > 1 ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], o - i) - t[i]) : this.catmullRom(t[s ? s - 1 : 0], t[s], t[i < s + 1 ? i : s + 1], t[i < s + 2 ? i : s + 2], o - s)
            },
            linear: function(t, e, i) {
                return (e - t) * i + t
            },
            bernstein: function(t, e) {
                return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
            },
            factorial: function(t) {
                if (0 === t) return 1;
                for (var e = t; --t;) e *= t;
                return e
            },
            catmullRom: function(t, e, i, o, s) {
                var n = .5 * (i - t),
                    r = .5 * (o - e),
                    a = s * s;
                return (2 * e - 2 * i + n + r) * (s * a) + (-3 * e + 3 * i - 2 * n - r) * a + n * s + e
            },
            difference: function(t, e) {
                return Math.abs(t - e)
            },
            roundAwayFromZero: function(t) {
                return t > 0 ? Math.ceil(t) : Math.floor(t)
            },
            sinCosGenerator: function(t, e, i, o) {
                void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === o && (o = 1);
                for (var s = e, n = i, r = o * Math.PI / t, a = [], h = [], l = 0; l < t; l++) n -= s * r, s += n * r, a[l] = n, h[l] = s;
                return {
                    sin: h,
                    cos: a,
                    length: t
                }
            },
            distance: function(t, e, i, o) {
                var s = t - i,
                    n = e - o;
                return Math.sqrt(s * s + n * n)
            },
            distanceSq: function(t, e, i, o) {
                var s = t - i,
                    n = e - o;
                return s * s + n * n
            },
            distancePow: function(t, e, i, o, s) {
                return void 0 === s && (s = 2), Math.sqrt(Math.pow(i - t, s) + Math.pow(o - e, s))
            },
            clamp: function(t, e, i) {
                return t < e ? e : i < t ? i : t
            },
            clampBottom: function(t, e) {
                return t < e ? e : t
            },
            within: function(t, e, i) {
                return Math.abs(t - e) <= i
            },
            mapLinear: function(t, e, i, o, s) {
                return o + (t - e) * (s - o) / (i - e)
            },
            smoothstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
            },
            sign: function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : 0
            },
            percent: function(t, e, i) {
                return void 0 === i && (i = 0), t > e || i > e ? 1 : t < i || i > t ? 0 : (t - i) / e
            }
        };
        var r = Math.PI / 180,
            a = 180 / Math.PI;
        return i.Math.degToRad = function(t) {
                return t * r
            }, i.Math.radToDeg = function(t) {
                return t * a
            }, i.RandomDataGenerator = function(t) {
                void 0 === t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof t ? this.state(t) : this.sow(t)
            }, i.RandomDataGenerator.prototype = {
                rnd: function() {
                    var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                    return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
                },
                sow: function(t) {
                    if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t)
                        for (var e = 0; e < t.length && null != t[e]; e++) {
                            var i = t[e];
                            this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0)
                        }
                },
                hash: function(t) {
                    var e, i, o;
                    for (o = 4022871197, t = t.toString(), i = 0; i < t.length; i++) o += t.charCodeAt(i), e = .02519603282416938 * o, o = e >>> 0, e -= o, e *= o, o = e >>> 0, e -= o, o += 4294967296 * e;
                    return 2.3283064365386963e-10 * (o >>> 0)
                },
                integer: function() {
                    return 4294967296 * this.rnd.apply(this)
                },
                frac: function() {
                    return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0)
                },
                real: function() {
                    return this.integer() + this.frac()
                },
                integerInRange: function(t, e) {
                    return Math.floor(this.realInRange(0, e - t + 1) + t)
                },
                between: function(t, e) {
                    return this.integerInRange(t, e)
                },
                realInRange: function(t, e) {
                    return this.frac() * (e - t) + t
                },
                normal: function() {
                    return 1 - 2 * this.frac()
                },
                uuid: function() {
                    var t = "",
                        e = "";
                    for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-");
                    return e
                },
                pick: function(t) {
                    return t[this.integerInRange(0, t.length - 1)]
                },
                sign: function() {
                    return this.pick([-1, 1])
                },
                weightedPick: function(t) {
                    return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
                },
                timestamp: function(t, e) {
                    return this.realInRange(t || 9466848e5, e || 1577862e6)
                },
                angle: function() {
                    return this.integerInRange(-180, 180)
                },
                state: function(t) {
                    return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
                }
            }, i.RandomDataGenerator.prototype.constructor = i.RandomDataGenerator, i.QuadTree = function(t, e, i, o, s, n, r) {
                this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, o, s, n, r)
            }, i.QuadTree.prototype = {
                reset: function(t, e, i, o, s, n, r) {
                    this.maxObjects = s || 10, this.maxLevels = n || 4, this.level = r || 0, this.bounds = {
                        x: Math.round(t),
                        y: Math.round(e),
                        width: i,
                        height: o,
                        subWidth: Math.floor(i / 2),
                        subHeight: Math.floor(o / 2),
                        right: Math.round(t) + Math.floor(i / 2),
                        bottom: Math.round(e) + Math.floor(o / 2)
                    }, this.objects.length = 0, this.nodes.length = 0
                },
                populate: function(t) {
                    t.forEach(this.populateHandler, this, !0)
                },
                populateHandler: function(t) {
                    t.body && t.exists && this.insert(t.body)
                },
                split: function() {
                    this.nodes[0] = new i.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new i.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new i.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new i.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
                },
                insert: function(t) {
                    var e, i = 0;
                    if (null != this.nodes[0] && -1 !== (e = this.getIndex(t))) return void this.nodes[e].insert(t);
                    if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                        for (null == this.nodes[0] && this.split(); i < this.objects.length;) e = this.getIndex(this.objects[i]), -1 !== e ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
                },
                getIndex: function(t) {
                    var e = -1;
                    return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e
                },
                retrieve: function(t) {
                    if (t instanceof i.Rectangle) var e = this.objects,
                        o = this.getIndex(t);
                    else {
                        if (!t.body) return this._empty;
                        var e = this.objects,
                            o = this.getIndex(t.body)
                    }
                    return this.nodes[0] && (-1 !== o ? e = e.concat(this.nodes[o].retrieve(t)) : (e = e.concat(this.nodes[0].retrieve(t)), e = e.concat(this.nodes[1].retrieve(t)), e = e.concat(this.nodes[2].retrieve(t)), e = e.concat(this.nodes[3].retrieve(t)))), e
                },
                clear: function() {
                    this.objects.length = 0;
                    for (var t = this.nodes.length; t--;) this.nodes[t].clear(), this.nodes.splice(t, 1);
                    this.nodes.length = 0
                }
            }, i.QuadTree.prototype.constructor = i.QuadTree, i.Net = function(t) {
                this.game = t
            }, i.Net.prototype = {
                getHostName: function() {
                    return window.location && window.location.hostname ? window.location.hostname : null
                },
                checkDomainName: function(t) {
                    return -1 !== window.location.hostname.indexOf(t)
                },
                updateQueryString: function(t, e, i, o) {
                    void 0 === i && (i = !1), void 0 !== o && "" !== o || (o = window.location.href);
                    var s = "",
                        n = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi");
                    if (n.test(o)) s = void 0 !== e && null !== e ? o.replace(n, "$1" + t + "=" + e + "$2$3") : o.replace(n, "$1$3").replace(/(&|\?)$/, "");
                    else if (void 0 !== e && null !== e) {
                        var r = -1 !== o.indexOf("?") ? "&" : "?",
                            a = o.split("#");
                        o = a[0] + r + t + "=" + e, a[1] && (o += "#" + a[1]), s = o
                    } else s = o;
                    if (!i) return s;
                    window.location.href = s
                },
                getQueryString: function(t) {
                    void 0 === t && (t = "");
                    var e = {},
                        i = location.search.substring(1).split("&");
                    for (var o in i) {
                        var s = i[o].split("=");
                        if (s.length > 1) {
                            if (t && t === this.decodeURI(s[0])) return this.decodeURI(s[1]);
                            e[this.decodeURI(s[0])] = this.decodeURI(s[1])
                        }
                    }
                    return e
                },
                decodeURI: function(t) {
                    return decodeURIComponent(t.replace(/\+/g, " "))
                }
            }, i.Net.prototype.constructor = i.Net, i.TweenManager = function(t) {
                this.game = t, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
                    Power0: i.Easing.Power0,
                    Power1: i.Easing.Power1,
                    Power2: i.Easing.Power2,
                    Power3: i.Easing.Power3,
                    Power4: i.Easing.Power4,
                    Linear: i.Easing.Linear.None,
                    Quad: i.Easing.Quadratic.Out,
                    Cubic: i.Easing.Cubic.Out,
                    Quart: i.Easing.Quartic.Out,
                    Quint: i.Easing.Quintic.Out,
                    Sine: i.Easing.Sinusoidal.Out,
                    Expo: i.Easing.Exponential.Out,
                    Circ: i.Easing.Circular.Out,
                    Elastic: i.Easing.Elastic.Out,
                    Back: i.Easing.Back.Out,
                    Bounce: i.Easing.Bounce.Out,
                    "Quad.easeIn": i.Easing.Quadratic.In,
                    "Cubic.easeIn": i.Easing.Cubic.In,
                    "Quart.easeIn": i.Easing.Quartic.In,
                    "Quint.easeIn": i.Easing.Quintic.In,
                    "Sine.easeIn": i.Easing.Sinusoidal.In,
                    "Expo.easeIn": i.Easing.Exponential.In,
                    "Circ.easeIn": i.Easing.Circular.In,
                    "Elastic.easeIn": i.Easing.Elastic.In,
                    "Back.easeIn": i.Easing.Back.In,
                    "Bounce.easeIn": i.Easing.Bounce.In,
                    "Quad.easeOut": i.Easing.Quadratic.Out,
                    "Cubic.easeOut": i.Easing.Cubic.Out,
                    "Quart.easeOut": i.Easing.Quartic.Out,
                    "Quint.easeOut": i.Easing.Quintic.Out,
                    "Sine.easeOut": i.Easing.Sinusoidal.Out,
                    "Expo.easeOut": i.Easing.Exponential.Out,
                    "Circ.easeOut": i.Easing.Circular.Out,
                    "Elastic.easeOut": i.Easing.Elastic.Out,
                    "Back.easeOut": i.Easing.Back.Out,
                    "Bounce.easeOut": i.Easing.Bounce.Out,
                    "Quad.easeInOut": i.Easing.Quadratic.InOut,
                    "Cubic.easeInOut": i.Easing.Cubic.InOut,
                    "Quart.easeInOut": i.Easing.Quartic.InOut,
                    "Quint.easeInOut": i.Easing.Quintic.InOut,
                    "Sine.easeInOut": i.Easing.Sinusoidal.InOut,
                    "Expo.easeInOut": i.Easing.Exponential.InOut,
                    "Circ.easeInOut": i.Easing.Circular.InOut,
                    "Elastic.easeInOut": i.Easing.Elastic.InOut,
                    "Back.easeInOut": i.Easing.Back.InOut,
                    "Bounce.easeInOut": i.Easing.Bounce.InOut
                }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
            }, i.TweenManager.prototype = {
                getAll: function() {
                    return this._tweens
                },
                removeAll: function() {
                    for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
                    this._add = []
                },
                removeFrom: function(t, e) {
                    void 0 === e && (e = !0);
                    var o, s;
                    if (Array.isArray(t))
                        for (o = 0, s = t.length; o < s; o++) this.removeFrom(t[o]);
                    else if (t.type === i.GROUP && e)
                        for (var o = 0, s = t.children.length; o < s; o++) this.removeFrom(t.children[o]);
                    else {
                        for (o = 0, s = this._tweens.length; o < s; o++) t === this._tweens[o].target && this.remove(this._tweens[o]);
                        for (o = 0, s = this._add.length; o < s; o++) t === this._add[o].target && this.remove(this._add[o])
                    }
                },
                add: function(t) {
                    t._manager = this, this._add.push(t)
                },
                create: function(t) {
                    return new i.Tween(t, this.game, this)
                },
                remove: function(t) {
                    var e = this._tweens.indexOf(t); - 1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0)
                },
                update: function() {
                    var t = this._add.length,
                        e = this._tweens.length;
                    if (0 === e && 0 === t) return !1;
                    for (var i = 0; i < e;) this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1), e--);
                    return t > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
                },
                isTweening: function(t) {
                    return this._tweens.some(function(e) {
                        return e.target === t
                    })
                },
                _pauseAll: function() {
                    for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._pause()
                },
                _resumeAll: function() {
                    for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._resume()
                },
                pauseAll: function() {
                    for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].pause()
                },
                resumeAll: function() {
                    for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].resume(!0)
                }
            }, i.TweenManager.prototype.constructor = i.TweenManager, i.Tween = function(t, e, o) {
                this.game = e, this.target = t, this.manager = o, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new i.Signal, this.onLoop = new i.Signal, this.onRepeat = new i.Signal, this.onChildComplete = new i.Signal, this.onComplete = new i.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = o.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1
            }, i.Tween.prototype = {
                to: function(t, e, o, s, n, r, a) {
                    return (void 0 === e || e <= 0) && (e = 1e3), void 0 !== o && null !== o || (o = i.Easing.Default), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = !1), "string" == typeof o && this.manager.easeMap[o] && (o = this.manager.easeMap[o]), this.isRunning ? (console.warn("Phaser.Tween.to cannot be called after Tween.start"), this) : (this.timeline.push(new i.TweenData(this).to(t, e, o, n, r, a)), s && this.start(), this)
                },
                from: function(t, e, o, s, n, r, a) {
                    return void 0 === e && (e = 1e3), void 0 !== o && null !== o || (o = i.Easing.Default), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = !1), "string" == typeof o && this.manager.easeMap[o] && (o = this.manager.easeMap[o]), this.isRunning ? (console.warn("Phaser.Tween.from cannot be called after Tween.start"), this) : (this.timeline.push(new i.TweenData(this).from(t, e, o, n, r, a)), s && this.start(), this)
                },
                start: function(t) {
                    if (void 0 === t && (t = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
                    for (var e = 0; e < this.timeline.length; e++)
                        for (var i in this.timeline[e].vEnd) this.properties[i] = this.target[i] || 0, Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
                    for (var e = 0; e < this.timeline.length; e++) this.timeline[e].loadValues();
                    return this.manager.add(this), this.isRunning = !0, (t < 0 || t > this.timeline.length - 1) && (t = 0), this.current = t, this.timeline[this.current].start(), this
                },
                stop: function(t) {
                    return void 0 === t && (t = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this
                },
                updateTweenData: function(t, e, i) {
                    if (0 === this.timeline.length) return this;
                    if (void 0 === i && (i = 0), -1 === i)
                        for (var o = 0; o < this.timeline.length; o++) this.timeline[o][t] = e;
                    else this.timeline[i][t] = e;
                    return this
                },
                delay: function(t, e) {
                    return this.updateTweenData("delay", t, e)
                },
                repeat: function(t, e, i) {
                    return void 0 === e && (e = 0), this.updateTweenData("repeatCounter", t, i), this.updateTweenData("repeatDelay", e, i)
                },
                repeatDelay: function(t, e) {
                    return this.updateTweenData("repeatDelay", t, e)
                },
                yoyo: function(t, e, i) {
                    return void 0 === e && (e = 0), this.updateTweenData("yoyo", t, i), this.updateTweenData("yoyoDelay", e, i)
                },
                yoyoDelay: function(t, e) {
                    return this.updateTweenData("yoyoDelay", t, e)
                },
                easing: function(t, e) {
                    return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]), this.updateTweenData("easingFunction", t, e)
                },
                interpolation: function(t, e, o) {
                    return void 0 === e && (e = i.Math), this.updateTweenData("interpolationFunction", t, o), this.updateTweenData("interpolationContext", e, o)
                },
                repeatAll: function(t) {
                    return void 0 === t && (t = 0), this.repeatCounter = t, this
                },
                chain: function() {
                    for (var t = arguments.length; t--;) t > 0 ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
                    return this
                },
                loop: function(t) {
                    return void 0 === t && (t = !0), this.repeatCounter = t ? -1 : 0, this
                },
                onUpdateCallback: function(t, e) {
                    return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this
                },
                pause: function() {
                    this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time
                },
                _pause: function() {
                    this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time)
                },
                resume: function() {
                    if (this.isPaused) {
                        this.isPaused = !1, this._codePaused = !1;
                        for (var t = 0; t < this.timeline.length; t++) this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime)
                    }
                },
                _resume: function() {
                    this._codePaused || this.resume()
                },
                update: function(t) {
                    if (this.pendingDelete || !this.target) return !1;
                    if (this.isPaused) return !0;
                    var e = this.timeline[this.current].update(t);
                    if (e === i.TweenData.PENDING) return !0;
                    if (e === i.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
                    if (e === i.TweenData.LOOPED) return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
                    if (e === i.TweenData.COMPLETE) {
                        var o = !1;
                        return this.reverse ? --this.current < 0 && (this.current = this.timeline.length - 1, o = !0) : ++this.current === this.timeline.length && (this.current = 0, o = !0), o ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
                    }
                },
                generateData: function(t, e) {
                    if (null === this.game || null === this.target) return null;
                    void 0 === t && (t = 60), void 0 === e && (e = []);
                    for (var i = 0; i < this.timeline.length; i++)
                        for (var o in this.timeline[i].vEnd) this.properties[o] = this.target[o] || 0, Array.isArray(this.properties[o]) || (this.properties[o] *= 1);
                    for (var i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
                    for (var i = 0; i < this.timeline.length; i++) e = e.concat(this.timeline[i].generateData(t));
                    return e
                }
            }, Object.defineProperty(i.Tween.prototype, "totalDuration", {
                get: function() {
                    for (var t = 0, e = 0; e < this.timeline.length; e++) t += this.timeline[e].duration;
                    return t
                }
            }), i.Tween.prototype.constructor = i.Tween, i.TweenData = function(t) {
                this.parent = t, this.game = t.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = i.Easing.Default, this.interpolationFunction = i.Math.linearInterpolation, this.interpolationContext = i.Math, this.isRunning = !1, this.isFrom = !1
            }, i.TweenData.PENDING = 0, i.TweenData.RUNNING = 1, i.TweenData.LOOPED = 2, i.TweenData.COMPLETE = 3, i.TweenData.prototype = {
                to: function(t, e, i, o, s, n) {
                    return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = o, this.repeatTotal = s, this.yoyo = n, this.isFrom = !1, this
                },
                from: function(t, e, i, o, s, n) {
                    return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = o, this.repeatTotal = s, this.yoyo = n, this.isFrom = !0, this
                },
                start: function() {
                    if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)
                        for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t], this.parent.target[t] = this.vStart[t];
                    return this.value = 0, this.yoyoCounter = 0, this.repeatCounter = this.repeatTotal, this
                },
                loadValues: function() {
                    for (var t in this.parent.properties) {
                        if (this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) {
                            if (0 === this.vEnd[t].length) continue;
                            0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                        }
                        void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t], 10)), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t], this.vStartCache[t] = this.vStart[t], this.vEndCache[t] = this.vEnd[t]
                    }
                    return this
                },
                update: function(t) {
                    if (this.isRunning) {
                        if (t < this.startTime) return i.TweenData.RUNNING
                    } else {
                        if (!(t >= this.startTime)) return i.TweenData.PENDING;
                        this.isRunning = !0
                    }
                    var e = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                    this.parent.reverse ? (this.dt -= e * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += e * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                    for (var o in this.vEnd) {
                        var s = this.vStart[o],
                            n = this.vEnd[o];
                        Array.isArray(n) ? this.parent.target[o] = this.interpolationFunction.call(this.interpolationContext, n, this.value) : this.parent.target[o] = s + (n - s) * this.value
                    }
                    return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : i.TweenData.RUNNING
                },
                generateData: function(t) {
                    this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                    var e = [],
                        i = !1,
                        o = 1 / t * 1e3;
                    do {
                        this.parent.reverse ? (this.dt -= o, this.dt = Math.max(this.dt, 0)) : (this.dt += o, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                        var s = {};
                        for (var n in this.vEnd) {
                            var r = this.vStart[n],
                                a = this.vEnd[n];
                            Array.isArray(a) ? s[n] = this.interpolationFunction(a, this.value) : s[n] = r + (a - r) * this.value
                        }
                        e.push(s), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0)
                    } while (!i);
                    if (this.yoyo) {
                        var h = e.slice();
                        h.reverse(), e = e.concat(h)
                    }
                    return e
                },
                repeat: function() {
                    if (this.yoyo) {
                        if (this.inReverse && 0 === this.repeatCounter) {
                            for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                            return this.inReverse = !1, i.TweenData.COMPLETE
                        }
                        this.inReverse = !this.inReverse
                    } else if (0 === this.repeatCounter) return i.TweenData.COMPLETE;
                    if (this.inReverse)
                        for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t];
                    else {
                        for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                        this.repeatCounter > 0 && this.repeatCounter--
                    }
                    return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, i.TweenData.LOOPED
                }
            }, i.TweenData.prototype.constructor = i.TweenData, i.Easing = {
                Linear: {
                    None: function(t) {
                        return t
                    }
                },
                Quadratic: {
                    In: function(t) {
                        return t * t
                    },
                    Out: function(t) {
                        return t * (2 - t)
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                    }
                },
                Cubic: {
                    In: function(t) {
                        return t * t * t
                    },
                    Out: function(t) {
                        return --t * t * t + 1
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                    }
                },
                Quartic: {
                    In: function(t) {
                        return t * t * t * t
                    },
                    Out: function(t) {
                        return 1 - --t * t * t * t
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                    }
                },
                Quintic: {
                    In: function(t) {
                        return t * t * t * t * t
                    },
                    Out: function(t) {
                        return --t * t * t * t * t + 1
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                    }
                },
                Sinusoidal: {
                    In: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
                    },
                    Out: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
                    },
                    InOut: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
                    }
                },
                Exponential: {
                    In: function(t) {
                        return 0 === t ? 0 : Math.pow(1024, t - 1)
                    },
                    Out: function(t) {
                        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                    },
                    InOut: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                    }
                },
                Circular: {
                    In: function(t) {
                        return 1 - Math.sqrt(1 - t * t)
                    },
                    Out: function(t) {
                        return Math.sqrt(1 - --t * t)
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                    }
                },
                Elastic: {
                    In: function(t) {
                        var e, i = .1;
                        return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4))
                    },
                    Out: function(t) {
                        var e, i = .1;
                        return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1)
                    },
                    InOut: function(t) {
                        var e, i = .1;
                        return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1)
                    }
                },
                Back: {
                    In: function(t) {
                        var e = 1.70158;
                        return t * t * ((e + 1) * t - e)
                    },
                    Out: function(t) {
                        var e = 1.70158;
                        return --t * t * ((e + 1) * t + e) + 1
                    },
                    InOut: function(t) {
                        var e = 2.5949095;
                        return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                    }
                },
                Bounce: {
                    In: function(t) {
                        return 1 - i.Easing.Bounce.Out(1 - t)
                    },
                    Out: function(t) {
                        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                    },
                    InOut: function(t) {
                        return t < .5 ? .5 * i.Easing.Bounce.In(2 * t) : .5 * i.Easing.Bounce.Out(2 * t - 1) + .5
                    }
                }
            }, i.Easing.Default = i.Easing.Linear.None, i.Easing.Power0 = i.Easing.Linear.None, i.Easing.Power1 = i.Easing.Quadratic.Out, i.Easing.Power2 = i.Easing.Cubic.Out, i.Easing.Power3 = i.Easing.Quartic.Out, i.Easing.Power4 = i.Easing.Quintic.Out, i.Time = function(t) {
                this.game = t, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new i.Timer(this.game, !1), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = []
            }, i.Time.prototype = {
                boot: function() {
                    this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time
                },
                add: function(t) {
                    return this._timers.push(t), t
                },
                create: function(t) {
                    void 0 === t && (t = !0);
                    var e = new i.Timer(this.game, t);
                    return this._timers.push(e), e
                },
                removeAll: function() {
                    for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
                    this._timers = [], this.events.removeAll()
                },
                refresh: function() {
                    var t = this.time;
                    this.time = Date.now(), this.elapsedMS = this.time - t
                },
                update: function(t) {
                    var e = this.time;
                    this.time = Date.now(), this.elapsedMS = this.time - e, this.prevTime = this.now, this.now = t, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))), this.timeExpected = t + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
                },
                updateTimers: function() {
                    for (var t = 0, e = this._timers.length; t < e;) this._timers[t].update(this.time) ? t++ : (this._timers.splice(t, 1), e--)
                },
                updateAdvancedTiming: function() {
                    this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0)
                },
                gamePaused: function() {
                    this._pauseStarted = Date.now(), this.events.pause();
                    for (var t = this._timers.length; t--;) this._timers[t]._pause()
                },
                gameResumed: function() {
                    this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
                    for (var t = this._timers.length; t--;) this._timers[t]._resume()
                },
                totalElapsedSeconds: function() {
                    return .001 * (this.time - this._started)
                },
                elapsedSince: function(t) {
                    return this.time - t
                },
                elapsedSecondsSince: function(t) {
                    return .001 * (this.time - t)
                },
                reset: function() {
                    this._started = this.time, this.removeAll()
                }
            }, Object.defineProperty(i.Time.prototype, "desiredFps", {
                get: function() {
                    return this._desiredFps
                },
                set: function(t) {
                    this._desiredFps = t, this.physicsElapsed = 1 / t, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / t
                }
            }), i.Time.prototype.constructor = i.Time, i.Timer = function(t, e) {
                void 0 === e && (e = !0), this.game = t, this.running = !1, this.autoDestroy = e, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new i.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
            }, i.Timer.MINUTE = 6e4, i.Timer.SECOND = 1e3, i.Timer.HALF = 500, i.Timer.QUARTER = 250, i.Timer.prototype = {
                create: function(t, e, o, s, n, r) {
                    t = Math.round(t);
                    var a = t;
                    0 === this._now ? a += this.game.time.time : a += this._now;
                    var h = new i.TimerEvent(this, t, a, o, e, s, n, r);
                    return this.events.push(h), this.order(), this.expired = !1, h
                },
                add: function(t, e, i) {
                    return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
                },
                repeat: function(t, e, i, o) {
                    return this.create(t, !1, e, i, o, Array.prototype.slice.call(arguments, 4))
                },
                loop: function(t, e, i) {
                    return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
                },
                start: function(t) {
                    if (!this.running) {
                        this._started = this.game.time.time + (t || 0), this.running = !0;
                        for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started
                    }
                },
                stop: function(t) {
                    this.running = !1, void 0 === t && (t = !0), t && (this.events.length = 0)
                },
                remove: function(t) {
                    for (var e = 0; e < this.events.length; e++)
                        if (this.events[e] === t) return this.events[e].pendingDelete = !0, !0;
                    return !1
                },
                order: function() {
                    this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
                },
                sortHandler: function(t, e) {
                    return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
                },
                clearPendingEvents: function() {
                    for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                    this._len = this.events.length, this._i = 0
                },
                update: function(t) {
                    if (this.paused) return !0;
                    if (this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                        for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete;) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), !0 === this.events[this._i].loop ? (this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : this.events[this._i].repeatCount > 0 ? (this.events[this._i].repeatCount--, this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : (this._marked++, this.events[this._i].pendingDelete = !0, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)), this._i++;
                        this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                    }
                    return !this.expired || !this.autoDestroy
                },
                pause: function() {
                    this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0))
                },
                _pause: function() {
                    !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0)
                },
                adjustEvents: function(t) {
                    for (var e = 0; e < this.events.length; e++)
                        if (!this.events[e].pendingDelete) {
                            var i = this.events[e].tick - t;
                            i < 0 && (i = 0), this.events[e].tick = this._now + i
                        }
                    var o = this.nextTick - t;
                    this.nextTick = o < 0 ? this._now : this._now + o
                },
                resume: function() {
                    if (this.paused) {
                        var t = this.game.time.time;
                        this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
                    }
                },
                _resume: function() {
                    this._codePaused || this.resume()
                },
                removeAll: function() {
                    this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
                },
                destroy: function() {
                    this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, this._i = 0
                }
            }, Object.defineProperty(i.Timer.prototype, "next", {
                get: function() {
                    return this.nextTick
                }
            }), Object.defineProperty(i.Timer.prototype, "duration", {
                get: function() {
                    return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
                }
            }), Object.defineProperty(i.Timer.prototype, "length", {
                get: function() {
                    return this.events.length
                }
            }), Object.defineProperty(i.Timer.prototype, "ms", {
                get: function() {
                    return this.running ? this._now - this._started - this._pauseTotal : 0
                }
            }), Object.defineProperty(i.Timer.prototype, "seconds", {
                get: function() {
                    return this.running ? .001 * this.ms : 0
                }
            }), i.Timer.prototype.constructor = i.Timer, i.TimerEvent = function(t, e, i, o, s, n, r, a) {
                this.timer = t, this.delay = e, this.tick = i, this.repeatCount = o - 1, this.loop = s, this.callback = n, this.callbackContext = r, this.args = a, this.pendingDelete = !1
            }, i.TimerEvent.prototype.constructor = i.TimerEvent, i.AnimationManager = function(t) {
                this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
            }, i.AnimationManager.prototype = {
                loadFrameData: function(t, e) {
                    if (void 0 === t) return !1;
                    if (this.isLoaded)
                        for (var i in this._anims) this._anims[i].updateFrameData(t);
                    return this._frameData = t, void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
                },
                copyFrameData: function(t, e) {
                    if (this._frameData = t.clone(), this.isLoaded)
                        for (var i in this._anims) this._anims[i].updateFrameData(this._frameData);
                    return void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
                },
                add: function(t, e, o, s, n) {
                    return e = e || [], o = o || 60, void 0 === s && (s = !1), void 0 === n && (n = !(!e || "number" != typeof e[0])), this._outputFrames = [], this._frameData.getFrameIndexes(e, n, this._outputFrames), this._anims[t] = new i.Animation(this.game, this.sprite, t, this._frameData, this._outputFrames, o, s), this.currentAnim = this._anims[t], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[t]
                },
                validateFrames: function(t, e) {
                    void 0 === e && (e = !0);
                    for (var i = 0; i < t.length; i++)
                        if (!0 === e) {
                            if (t[i] > this._frameData.total) return !1
                        } else if (!1 === this._frameData.checkFrameName(t[i])) return !1;
                    return !0
                },
                play: function(t, e, i, o) {
                    if (this._anims[t]) return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, o)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, o))
                },
                stop: function(t, e) {
                    void 0 === e && (e = !1), !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
                },
                update: function() {
                    return !(this.updateIfVisible && !this.sprite.visible) && (!(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame, !0))
                },
                next: function(t) {
                    this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
                },
                previous: function(t) {
                    this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
                },
                getAnimation: function(t) {
                    return "string" == typeof t && this._anims[t] ? this._anims[t] : null
                },
                refreshFrame: function() {},
                destroy: function() {
                    var t = null;
                    for (var t in this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                    this._anims = {}, this._outputFrames = [],
                        this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
                }
            }, i.AnimationManager.prototype.constructor = i.AnimationManager, Object.defineProperty(i.AnimationManager.prototype, "frameData", {
                get: function() {
                    return this._frameData
                }
            }), Object.defineProperty(i.AnimationManager.prototype, "frameTotal", {
                get: function() {
                    return this._frameData.total
                }
            }), Object.defineProperty(i.AnimationManager.prototype, "paused", {
                get: function() {
                    return this.currentAnim.isPaused
                },
                set: function(t) {
                    this.currentAnim.paused = t
                }
            }), Object.defineProperty(i.AnimationManager.prototype, "name", {
                get: function() {
                    if (this.currentAnim) return this.currentAnim.name
                }
            }), Object.defineProperty(i.AnimationManager.prototype, "frame", {
                get: function() {
                    if (this.currentFrame) return this.currentFrame.index
                },
                set: function(t) {
                    "number" == typeof t && this._frameData && null !== this._frameData.getFrame(t) && (this.currentFrame = this._frameData.getFrame(t), this.currentFrame && this.sprite.setFrame(this.currentFrame))
                }
            }), Object.defineProperty(i.AnimationManager.prototype, "frameName", {
                get: function() {
                    if (this.currentFrame) return this.currentFrame.name
                },
                set: function(t) {
                    "string" == typeof t && this._frameData && null !== this._frameData.getFrameByName(t) ? (this.currentFrame = this._frameData.getFrameByName(t), this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame))) : console.warn("Cannot set frameName: " + t)
                }
            }), i.Animation = function(t, e, o, s, n, r, a) {
                void 0 === a && (a = !1), this.game = t, this._parent = e, this._frameData = s, this.name = o, this._frames = [], this._frames = this._frames.concat(n), this.delay = 1e3 / r, this.loop = a, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new i.Signal, this.onUpdate = null, this.onComplete = new i.Signal, this.onLoop = new i.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
            }, i.Animation.prototype = {
                play: function(t, e, i) {
                    return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), void 0 !== i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this
                },
                restart: function() {
                    this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this)
                },
                reverse: function() {
                    return this.reversed = !this.reversed, this
                },
                reverseOnce: function() {
                    return this.onComplete.addOnce(this.reverse, this), this.reverse()
                },
                setFrame: function(t, e) {
                    var i;
                    if (void 0 === e && (e = !1), "string" == typeof t)
                        for (var o = 0; o < this._frames.length; o++) this._frameData.getFrame(this._frames[o]).name === t && (i = o);
                    else if ("number" == typeof t)
                        if (e) i = t;
                        else
                            for (var o = 0; o < this._frames.length; o++) this._frames[o] === t && (i = o);
                    i && (this._frameIndex = i - 1, this._timeNextFrame = this.game.time.time, this.update())
                },
                stop: function(t, e) {
                    void 0 === t && (t = !1), void 0 === e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
                },
                onPause: function() {
                    this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
                },
                onResume: function() {
                    this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
                },
                update: function() {
                    return !this.isPaused && (!!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0)))
                },
                updateCurrentFrame: function(t, e) {
                    if (void 0 === e && (e = !1), !this._frameData) return !1;
                    var i = this.currentFrame.index;
                    return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (e || !e && i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
                },
                next: function(t) {
                    void 0 === t && (t = 1);
                    var e = this._frameIndex + t;
                    e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
                },
                previous: function(t) {
                    void 0 === t && (t = 1);
                    var e = this._frameIndex - t;
                    e < 0 && (this.loop ? e = this._frames.length + e : e++), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
                },
                updateFrameData: function(t) {
                    this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
                },
                destroy: function() {
                    this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
                },
                complete: function() {
                    this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
                }
            }, i.Animation.prototype.constructor = i.Animation, Object.defineProperty(i.Animation.prototype, "paused", {
                get: function() {
                    return this.isPaused
                },
                set: function(t) {
                    this.isPaused = t, t ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
                }
            }), Object.defineProperty(i.Animation.prototype, "reversed", {
                get: function() {
                    return this.isReversed
                },
                set: function(t) {
                    this.isReversed = t
                }
            }), Object.defineProperty(i.Animation.prototype, "frameTotal", {
                get: function() {
                    return this._frames.length
                }
            }), Object.defineProperty(i.Animation.prototype, "frame", {
                get: function() {
                    return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
                },
                set: function(t) {
                    this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
                }
            }), Object.defineProperty(i.Animation.prototype, "speed", {
                get: function() {
                    return 1e3 / this.delay
                },
                set: function(t) {
                    t > 0 && (this.delay = 1e3 / t)
                }
            }), Object.defineProperty(i.Animation.prototype, "enableUpdate", {
                get: function() {
                    return null !== this.onUpdate
                },
                set: function(t) {
                    t && null === this.onUpdate ? this.onUpdate = new i.Signal : t || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
                }
            }), i.Animation.generateFrameNames = function(t, e, o, s, n) {
                void 0 === s && (s = "");
                var r = [],
                    a = "";
                if (e < o)
                    for (var h = e; h <= o; h++) a = "number" == typeof n ? i.Utils.pad(h.toString(), n, "0", 1) : h.toString(), a = t + a + s, r.push(a);
                else
                    for (var h = e; h >= o; h--) a = "number" == typeof n ? i.Utils.pad(h.toString(), n, "0", 1) : h.toString(), a = t + a + s, r.push(a);
                return r
            }, i.Frame = function(t, e, o, s, n, r) {
                this.index = t, this.x = e, this.y = o, this.width = s, this.height = n, this.name = r, this.centerX = Math.floor(s / 2), this.centerY = Math.floor(n / 2), this.distance = i.Math.distance(0, 0, s, n), this.rotated = !1, this.rotationDirection = "cw", this.trimmed = !1, this.sourceSizeW = s, this.sourceSizeH = n, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
            }, i.Frame.prototype = {
                resize: function(t, e) {
                    this.width = t, this.height = e, this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2), this.distance = i.Math.distance(0, 0, t, e), this.sourceSizeW = t, this.sourceSizeH = e, this.right = this.x + t, this.bottom = this.y + e
                },
                setTrim: function(t, e, i, o, s, n, r) {
                    this.trimmed = t, t && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = o, this.spriteSourceSizeY = s, this.spriteSourceSizeW = n, this.spriteSourceSizeH = r)
                },
                clone: function() {
                    var t = new i.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
                    for (var e in this) this.hasOwnProperty(e) && (t[e] = this[e]);
                    return t
                },
                getRect: function(t) {
                    return void 0 === t ? t = new i.Rectangle(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
                }
            }, i.Frame.prototype.constructor = i.Frame, i.FrameData = function() {
                this._frames = [], this._frameNames = []
            }, i.FrameData.prototype = {
                addFrame: function(t) {
                    return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t
                },
                getFrame: function(t) {
                    return t >= this._frames.length && (t = 0), this._frames[t]
                },
                getFrameByName: function(t) {
                    return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
                },
                checkFrameName: function(t) {
                    return null != this._frameNames[t]
                },
                clone: function() {
                    for (var t = new i.FrameData, e = 0; e < this._frames.length; e++) t._frames.push(this._frames[e].clone());
                    for (var o in this._frameNames) this._frameNames.hasOwnProperty(o) && t._frameNames.push(this._frameNames[o]);
                    return t
                },
                getFrameRange: function(t, e, i) {
                    void 0 === i && (i = []);
                    for (var o = t; o <= e; o++) i.push(this._frames[o]);
                    return i
                },
                getFrames: function(t, e, i) {
                    if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                        for (var o = 0; o < this._frames.length; o++) i.push(this._frames[o]);
                    else
                        for (var o = 0; o < t.length; o++) e ? i.push(this.getFrame(t[o])) : i.push(this.getFrameByName(t[o]));
                    return i
                },
                getFrameIndexes: function(t, e, i) {
                    if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                        for (var o = 0; o < this._frames.length; o++) i.push(this._frames[o].index);
                    else
                        for (var o = 0; o < t.length; o++) e && this._frames[t[o]] ? i.push(this._frames[t[o]].index) : this.getFrameByName(t[o]) && i.push(this.getFrameByName(t[o]).index);
                    return i
                },
                destroy: function() {
                    this._frames = null, this._frameNames = null
                }
            }, i.FrameData.prototype.constructor = i.FrameData, Object.defineProperty(i.FrameData.prototype, "total", {
                get: function() {
                    return this._frames.length
                }
            }), i.AnimationParser = {
                spriteSheet: function(t, e, o, s, n, r, a) {
                    var h = e;
                    if ("string" == typeof e && (h = t.cache.getImage(e)), null === h) return null;
                    var l = h.width,
                        d = h.height;
                    o <= 0 && (o = Math.floor(-l / Math.min(-1, o))), s <= 0 && (s = Math.floor(-d / Math.min(-1, s)));
                    var c = Math.floor((l - r) / (o + a)),
                        p = Math.floor((d - r) / (s + a)),
                        u = c * p;
                    if (-1 !== n && (u = n), 0 === l || 0 === d || l < o || d < s || 0 === u) return console.warn("Phaser.AnimationParser.spriteSheet: '" + e + "'s width/height zero or width/height < given frameWidth/frameHeight"), null;
                    for (var b = new i.FrameData, m = r, y = r, f = 0; f < u; f++) b.addFrame(new i.Frame(f, m, y, o, s, "")), (m += o + a) + o > l && (m = r, y += s + a);
                    return b
                },
                JSONData: function(t, e) {
                    if (!e.frames) return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"), void console.log(e);
                    for (var o, s = new i.FrameData, n = e.frames, r = 0; r < n.length; r++) o = s.addFrame(new i.Frame(r, n[r].frame.x, n[r].frame.y, n[r].frame.w, n[r].frame.h, n[r].filename)), n[r].trimmed && o.setTrim(n[r].trimmed, n[r].sourceSize.w, n[r].sourceSize.h, n[r].spriteSourceSize.x, n[r].spriteSourceSize.y, n[r].spriteSourceSize.w, n[r].spriteSourceSize.h);
                    return s
                },
                JSONDataPyxel: function(t, e) {
                    if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(t) {
                            if (!e[t]) return console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + t + '" key.'), void console.log(e)
                        }), 1 !== e.layers.length) return console.warn("Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps."), void console.log(e);
                    for (var o, s = new i.FrameData, n = e.tileheight, r = e.tilewidth, a = e.layers[0].tiles, h = 0; h < a.length; h++) o = s.addFrame(new i.Frame(h, a[h].x, a[h].y, r, n, "frame_" + h)), o.setTrim(!1);
                    return s
                },
                JSONDataHash: function(t, e) {
                    if (!e.frames) return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"), void console.log(e);
                    var o, s = new i.FrameData,
                        n = e.frames,
                        r = 0;
                    for (var a in n) o = s.addFrame(new i.Frame(r, n[a].frame.x, n[a].frame.y, n[a].frame.w, n[a].frame.h, a)), n[a].trimmed && o.setTrim(n[a].trimmed, n[a].sourceSize.w, n[a].sourceSize.h, n[a].spriteSourceSize.x, n[a].spriteSourceSize.y, n[a].spriteSourceSize.w, n[a].spriteSourceSize.h), r++;
                    return s
                },
                XMLData: function(t, e) {
                    if (!e.getElementsByTagName("TextureAtlas")) return void console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
                    for (var o, s, n, r, a, h, l, d, c, p, u, b = new i.FrameData, m = e.getElementsByTagName("SubTexture"), y = 0; y < m.length; y++) n = m[y].attributes, s = n.name.value, r = parseInt(n.x.value, 10), a = parseInt(n.y.value, 10), h = parseInt(n.width.value, 10), l = parseInt(n.height.value, 10), d = null, c = null, n.frameX && (d = Math.abs(parseInt(n.frameX.value, 10)), c = Math.abs(parseInt(n.frameY.value, 10)), p = parseInt(n.frameWidth.value, 10), u = parseInt(n.frameHeight.value, 10)), o = b.addFrame(new i.Frame(y, r, a, h, l, s)), null === d && null === c || o.setTrim(!0, h, l, d, c, p, u);
                    return b
                }
            }, i.Cache = function(t) {
                this.game = t, this.autoResolveURL = !1, this._cache = {
                    canvas: {},
                    image: {},
                    texture: {},
                    sound: {},
                    video: {},
                    text: {},
                    json: {},
                    xml: {},
                    physics: {},
                    tilemap: {},
                    binary: {},
                    bitmapData: {},
                    bitmapFont: {},
                    shader: {},
                    renderTexture: {}
                }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new i.Signal, this._cacheMap = [], this._cacheMap[i.Cache.CANVAS] = this._cache.canvas, this._cacheMap[i.Cache.IMAGE] = this._cache.image, this._cacheMap[i.Cache.TEXTURE] = this._cache.texture, this._cacheMap[i.Cache.SOUND] = this._cache.sound, this._cacheMap[i.Cache.TEXT] = this._cache.text, this._cacheMap[i.Cache.PHYSICS] = this._cache.physics, this._cacheMap[i.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[i.Cache.BINARY] = this._cache.binary, this._cacheMap[i.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[i.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[i.Cache.JSON] = this._cache.json, this._cacheMap[i.Cache.XML] = this._cache.xml, this._cacheMap[i.Cache.VIDEO] = this._cache.video, this._cacheMap[i.Cache.SHADER] = this._cache.shader, this._cacheMap[i.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this.addDefaultImage(), this.addMissingImage()
            }, i.Cache.CANVAS = 1, i.Cache.IMAGE = 2, i.Cache.TEXTURE = 3, i.Cache.SOUND = 4, i.Cache.TEXT = 5, i.Cache.PHYSICS = 6, i.Cache.TILEMAP = 7, i.Cache.BINARY = 8, i.Cache.BITMAPDATA = 9, i.Cache.BITMAPFONT = 10, i.Cache.JSON = 11, i.Cache.XML = 12, i.Cache.VIDEO = 13, i.Cache.SHADER = 14, i.Cache.RENDER_TEXTURE = 15, i.Cache.DEFAULT = null, i.Cache.MISSING = null, i.Cache.prototype = {
                addCanvas: function(t, e, i) {
                    void 0 === i && (i = e.getContext("2d")), this._cache.canvas[t] = {
                        canvas: e,
                        context: i
                    }
                },
                addImage: function(t, e, o) {
                    this.checkImageKey(t) && this.removeImage(t);
                    var s = {
                        key: t,
                        url: e,
                        data: o,
                        base: new PIXI.BaseTexture(o),
                        frame: new i.Frame(0, 0, 0, o.width, o.height, t),
                        frameData: new i.FrameData
                    };
                    return s.frameData.addFrame(new i.Frame(0, 0, 0, o.width, o.height, e)), this._cache.image[t] = s, this._resolveURL(e, s), "__default" === t ? i.Cache.DEFAULT = new PIXI.Texture(s.base) : "__missing" === t && (i.Cache.MISSING = new PIXI.Texture(s.base)), s
                },
                addDefaultImage: function() {
                    var t = new Image;
                    t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
                    var e = this.addImage("__default", null, t);
                    e.base.skipRender = !0, i.Cache.DEFAULT = new PIXI.Texture(e.base)
                },
                addMissingImage: function() {
                    var t = new Image;
                    t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
                    var e = this.addImage("__missing", null, t);
                    i.Cache.MISSING = new PIXI.Texture(e.base)
                },
                addSound: function(t, e, i, o, s) {
                    void 0 === o && (o = !0, s = !1), void 0 === s && (o = !1, s = !0);
                    var n = !1;
                    s && (n = !0), this._cache.sound[t] = {
                        url: e,
                        data: i,
                        isDecoding: !1,
                        decoded: n,
                        webAudio: o,
                        audioTag: s,
                        locked: this.game.sound.touchLocked
                    }, this._resolveURL(e, this._cache.sound[t])
                },
                addText: function(t, e, i) {
                    this._cache.text[t] = {
                        url: e,
                        data: i
                    }, this._resolveURL(e, this._cache.text[t])
                },
                addPhysicsData: function(t, e, i, o) {
                    this._cache.physics[t] = {
                        url: e,
                        data: i,
                        format: o
                    }, this._resolveURL(e, this._cache.physics[t])
                },
                addTilemap: function(t, e, i, o) {
                    this._cache.tilemap[t] = {
                        url: e,
                        data: i,
                        format: o
                    }, this._resolveURL(e, this._cache.tilemap[t])
                },
                addBinary: function(t, e) {
                    this._cache.binary[t] = e
                },
                addBitmapData: function(t, e, o) {
                    return e.key = t, void 0 === o && (o = new i.FrameData, o.addFrame(e.textureFrame)), this._cache.bitmapData[t] = {
                        data: e,
                        frameData: o
                    }, e
                },
                addBitmapFont: function(t, e, o, s, n, r, a) {
                    var h = {
                        url: e,
                        data: o,
                        font: null,
                        base: new PIXI.BaseTexture(o)
                    };
                    void 0 === r && (r = 0), void 0 === a && (a = 0), h.font = "json" === n ? i.LoaderParser.jsonBitmapFont(s, h.base, r, a) : i.LoaderParser.xmlBitmapFont(s, h.base, r, a), this._cache.bitmapFont[t] = h, this._resolveURL(e, h)
                },
                addJSON: function(t, e, i) {
                    this._cache.json[t] = {
                        url: e,
                        data: i
                    }, this._resolveURL(e, this._cache.json[t])
                },
                addXML: function(t, e, i) {
                    this._cache.xml[t] = {
                        url: e,
                        data: i
                    }, this._resolveURL(e, this._cache.xml[t])
                },
                addVideo: function(t, e, i, o) {
                    this._cache.video[t] = {
                        url: e,
                        data: i,
                        isBlob: o,
                        locked: !0
                    }, this._resolveURL(e, this._cache.video[t])
                },
                addShader: function(t, e, i) {
                    this._cache.shader[t] = {
                        url: e,
                        data: i
                    }, this._resolveURL(e, this._cache.shader[t])
                },
                addRenderTexture: function(t, e) {
                    this._cache.renderTexture[t] = {
                        texture: e,
                        frame: new i.Frame(0, 0, 0, e.width, e.height, "", "")
                    }
                },
                addSpriteSheet: function(t, e, o, s, n, r, a, h) {
                    void 0 === r && (r = -1), void 0 === a && (a = 0), void 0 === h && (h = 0);
                    var l = {
                        key: t,
                        url: e,
                        data: o,
                        frameWidth: s,
                        frameHeight: n,
                        margin: a,
                        spacing: h,
                        base: new PIXI.BaseTexture(o),
                        frameData: i.AnimationParser.spriteSheet(this.game, o, s, n, r, a, h)
                    };
                    this._cache.image[t] = l, this._resolveURL(e, l)
                },
                addTextureAtlas: function(t, e, o, s, n) {
                    var r = {
                        key: t,
                        url: e,
                        data: o,
                        base: new PIXI.BaseTexture(o)
                    };
                    n === i.Loader.TEXTURE_ATLAS_XML_STARLING ? r.frameData = i.AnimationParser.XMLData(this.game, s, t) : n === i.Loader.TEXTURE_ATLAS_JSON_PYXEL ? r.frameData = i.AnimationParser.JSONDataPyxel(this.game, s, t) : Array.isArray(s.frames) ? r.frameData = i.AnimationParser.JSONData(this.game, s, t) : r.frameData = i.AnimationParser.JSONDataHash(this.game, s, t), this._cache.image[t] = r, this._resolveURL(e, r)
                },
                reloadSound: function(t) {
                    var e = this,
                        i = this.getSound(t);
                    i && (i.data.src = i.url, i.data.addEventListener("canplaythrough", function() {
                        return e.reloadSoundComplete(t)
                    }, !1), i.data.load())
                },
                reloadSoundComplete: function(t) {
                    var e = this.getSound(t);
                    e && (e.locked = !1, this.onSoundUnlock.dispatch(t))
                },
                updateSound: function(t, e, i) {
                    var o = this.getSound(t);
                    o && (o[e] = i)
                },
                decodedSound: function(t, e) {
                    var i = this.getSound(t);
                    i.data = e, i.decoded = !0, i.isDecoding = !1
                },
                isSoundDecoded: function(t) {
                    var e = this.getItem(t, i.Cache.SOUND, "isSoundDecoded");
                    if (e) return e.decoded
                },
                isSoundReady: function(t) {
                    var e = this.getItem(t, i.Cache.SOUND, "isSoundDecoded");
                    if (e) return e.decoded && !this.game.sound.touchLocked
                },
                checkKey: function(t, e) {
                    return !!this._cacheMap[t][e]
                },
                checkURL: function(t) {
                    return !!this._urlMap[this._resolveURL(t)]
                },
                checkCanvasKey: function(t) {
                    return this.checkKey(i.Cache.CANVAS, t)
                },
                checkImageKey: function(t) {
                    return this.checkKey(i.Cache.IMAGE, t)
                },
                checkTextureKey: function(t) {
                    return this.checkKey(i.Cache.TEXTURE, t)
                },
                checkSoundKey: function(t) {
                    return this.checkKey(i.Cache.SOUND, t)
                },
                checkTextKey: function(t) {
                    return this.checkKey(i.Cache.TEXT, t)
                },
                checkPhysicsKey: function(t) {
                    return this.checkKey(i.Cache.PHYSICS, t)
                },
                checkTilemapKey: function(t) {
                    return this.checkKey(i.Cache.TILEMAP, t)
                },
                checkBinaryKey: function(t) {
                    return this.checkKey(i.Cache.BINARY, t)
                },
                checkBitmapDataKey: function(t) {
                    return this.checkKey(i.Cache.BITMAPDATA, t)
                },
                checkBitmapFontKey: function(t) {
                    return this.checkKey(i.Cache.BITMAPFONT, t)
                },
                checkJSONKey: function(t) {
                    return this.checkKey(i.Cache.JSON, t)
                },
                checkXMLKey: function(t) {
                    return this.checkKey(i.Cache.XML, t)
                },
                checkVideoKey: function(t) {
                    return this.checkKey(i.Cache.VIDEO, t)
                },
                checkShaderKey: function(t) {
                    return this.checkKey(i.Cache.SHADER, t)
                },
                checkRenderTextureKey: function(t) {
                    return this.checkKey(i.Cache.RENDER_TEXTURE, t)
                },
                getItem: function(t, e, i, o) {
                    return this.checkKey(e, t) ? void 0 === o ? this._cacheMap[e][t] : this._cacheMap[e][t][o] : (i && console.warn("Phaser.Cache." + i + ': Key "' + t + '" not found in Cache.'), null)
                },
                getCanvas: function(t) {
                    return this.getItem(t, i.Cache.CANVAS, "getCanvas", "canvas")
                },
                getImage: function(t, e) {
                    void 0 !== t && null !== t || (t = "__default"), void 0 === e && (e = !1);
                    var o = this.getItem(t, i.Cache.IMAGE, "getImage");
                    return null === o && (o = this.getItem("__missing", i.Cache.IMAGE, "getImage")), e ? o : o.data
                },
                getTextureFrame: function(t) {
                    return this.getItem(t, i.Cache.TEXTURE, "getTextureFrame", "frame")
                },
                getSound: function(t) {
                    return this.getItem(t, i.Cache.SOUND, "getSound")
                },
                getSoundData: function(t) {
                    return this.getItem(t, i.Cache.SOUND, "getSoundData", "data")
                },
                getText: function(t) {
                    return this.getItem(t, i.Cache.TEXT, "getText", "data")
                },
                getPhysicsData: function(t, e, o) {
                    var s = this.getItem(t, i.Cache.PHYSICS, "getPhysicsData", "data");
                    if (null === s || void 0 === e || null === e) return s;
                    if (s[e]) {
                        var n = s[e];
                        if (!n || !o) return n;
                        for (var r in n)
                            if (r = n[r], r.fixtureKey === o) return r;
                        console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + o + " in " + t + '"')
                    } else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + t + " / " + e + '"');
                    return null
                },
                getTilemapData: function(t) {
                    return this.getItem(t, i.Cache.TILEMAP, "getTilemapData")
                },
                getBinary: function(t) {
                    return this.getItem(t, i.Cache.BINARY, "getBinary")
                },
                getBitmapData: function(t) {
                    return this.getItem(t, i.Cache.BITMAPDATA, "getBitmapData", "data")
                },
                getBitmapFont: function(t) {
                    return this.getItem(t, i.Cache.BITMAPFONT, "getBitmapFont")
                },
                getJSON: function(t, e) {
                    var o = this.getItem(t, i.Cache.JSON, "getJSON", "data");
                    return o ? e ? i.Utils.extend(!0, Array.isArray(o) ? [] : {}, o) : o : null
                },
                getXML: function(t) {
                    return this.getItem(t, i.Cache.XML, "getXML", "data")
                },
                getVideo: function(t) {
                    return this.getItem(t, i.Cache.VIDEO, "getVideo")
                },
                getShader: function(t) {
                    return this.getItem(t, i.Cache.SHADER, "getShader", "data")
                },
                getRenderTexture: function(t) {
                    return this.getItem(t, i.Cache.RENDER_TEXTURE, "getRenderTexture")
                },
                getBaseTexture: function(t, e) {
                    return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getBaseTexture", "base")
                },
                getFrame: function(t, e) {
                    return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getFrame", "frame")
                },
                getFrameCount: function(t, e) {
                    var i = this.getFrameData(t, e);
                    return i ? i.total : 0
                },
                getFrameData: function(t, e) {
                    return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getFrameData", "frameData")
                },
                hasFrameData: function(t, e) {
                    return void 0 === e && (e = i.Cache.IMAGE), null !== this.getItem(t, e, "", "frameData")
                },
                updateFrameData: function(t, e, o) {
                    void 0 === o && (o = i.Cache.IMAGE), this._cacheMap[o][t] && (this._cacheMap[o][t].frameData = e)
                },
                getFrameByIndex: function(t, e, i) {
                    var o = this.getFrameData(t, i);
                    return o ? o.getFrame(e) : null
                },
                getFrameByName: function(t, e, i) {
                    var o = this.getFrameData(t, i);
                    return o ? o.getFrameByName(e) : null
                },
                getURL: function(t) {
                    var t = this._resolveURL(t);
                    return t ? this._urlMap[t] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + t + '" or Cache.autoResolveURL was false'), null)
                },
                getKeys: function(t) {
                    void 0 === t && (t = i.Cache.IMAGE);
                    var e = [];
                    if (this._cacheMap[t])
                        for (var o in this._cacheMap[t]) "__default" !== o && "__missing" !== o && e.push(o);
                    return e
                },
                removeCanvas: function(t) {
                    delete this._cache.canvas[t]
                },
                removeImage: function(t, e) {
                    void 0 === e && (e = !0);
                    var i = this.getImage(t, !0);
                    e && i.base && i.base.destroy(), delete this._cache.image[t]
                },
                removeSound: function(t) {
                    delete this._cache.sound[t]
                },
                removeText: function(t) {
                    delete this._cache.text[t]
                },
                removePhysics: function(t) {
                    delete this._cache.physics[t]
                },
                removeTilemap: function(t) {
                    delete this._cache.tilemap[t]
                },
                removeBinary: function(t) {
                    delete this._cache.binary[t]
                },
                removeBitmapData: function(t) {
                    delete this._cache.bitmapData[t]
                },
                removeBitmapFont: function(t) {
                    delete this._cache.bitmapFont[t]
                },
                removeJSON: function(t) {
                    delete this._cache.json[t]
                },
                removeXML: function(t) {
                    delete this._cache.xml[t]
                },
                removeVideo: function(t) {
                    delete this._cache.video[t]
                },
                removeShader: function(t) {
                    delete this._cache.shader[t]
                },
                removeRenderTexture: function(t) {
                    delete this._cache.renderTexture[t]
                },
                removeSpriteSheet: function(t) {
                    delete this._cache.spriteSheet[t]
                },
                removeTextureAtlas: function(t) {
                    delete this._cache.atlas[t]
                },
                clearGLTextures: function() {
                    for (var t in this._cache.image) this._cache.image[t].base._glTextures = []
                },
                _resolveURL: function(t, e) {
                    return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null
                },
                destroy: function() {
                    for (var t = 0; t < this._cacheMap.length; t++) {
                        var e = this._cacheMap[t];
                        for (var i in e) "__default" !== i && "__missing" !== i && (e[i].destroy && e[i].destroy(), delete e[i])
                    }
                    this._urlMap = null, this._urlResolver = null, this._urlTemp = null
                }
            }, i.Cache.prototype.constructor = i.Cache, i.Loader = function(t) {
                this.game = t, this.cache = t.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
                    requestedWith: !1,
                    json: "application/json",
                    xml: "application/xml"
                }, this.onLoadStart = new i.Signal, this.onLoadComplete = new i.Signal, this.onPackComplete = new i.Signal, this.onFileStart = new i.Signal, this.onFileComplete = new i.Signal, this.onFileError = new i.Signal, this.useXDomainRequest = !1, this._warnedAboutXDomainRequest = !1, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0
            }, i.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, i.Loader.TEXTURE_ATLAS_JSON_HASH = 1, i.Loader.TEXTURE_ATLAS_XML_STARLING = 2, i.Loader.PHYSICS_LIME_CORONA_JSON = 3, i.Loader.PHYSICS_PHASER_JSON = 4, i.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, i.Loader.prototype = {
                setPreloadSprite: function(t, e) {
                    e = e || 0, this.preloadSprite = {
                        sprite: t,
                        direction: e,
                        width: t.width,
                        height: t.height,
                        rect: null
                    }, this.preloadSprite.rect = 0 === e ? new i.Rectangle(0, 0, 1, t.height) : new i.Rectangle(0, 0, t.width, 1), t.crop(this.preloadSprite.rect), t.visible = !0
                },
                resize: function() {
                    this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
                },
                checkKeyExists: function(t, e) {
                    return this.getAssetIndex(t, e) > -1
                },
                getAssetIndex: function(t, e) {
                    for (var i = -1, o = 0; o < this._fileList.length; o++) {
                        var s = this._fileList[o];
                        if (s.type === t && s.key === e && (i = o, !s.loaded && !s.loading)) break
                    }
                    return i
                },
                getAsset: function(t, e) {
                    var i = this.getAssetIndex(t, e);
                    return i > -1 && {
                        index: i,
                        file: this._fileList[i]
                    }
                },
                reset: function(t, e) {
                    void 0 === e && (e = !1), this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
                },
                addToFileList: function(t, e, i, o, s, n) {
                    if (void 0 === s && (s = !1), void 0 === e || "" === e) return console.warn("Phaser.Loader: Invalid or no key given of type " + t), this;
                    if (void 0 === i || null === i) {
                        if (!n) return console.warn("Phaser.Loader: No URL given for file type: " + t + " key: " + e), this;
                        i = e + n
                    }
                    var r = {
                        type: t,
                        key: e,
                        path: this.path,
                        url: i,
                        syncPoint: this._withSyncPointDepth > 0,
                        data: null,
                        loading: !1,
                        loaded: !1,
                        error: !1
                    };
                    if (o)
                        for (var a in o) r[a] = o[a];
                    var h = this.getAssetIndex(t, e);
                    if (s && h > -1) {
                        var l = this._fileList[h];
                        l.loading || l.loaded ? (this._fileList.push(r), this._totalFileCount++) : this._fileList[h] = r
                    } else -1 === h && (this._fileList.push(r), this._totalFileCount++);
                    return this
                },
                replaceInFileList: function(t, e, i, o) {
                    return this.addToFileList(t, e, i, o, !0)
                },
                pack: function(t, e, i, o) {
                    if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === o && (o = null), !e && !i) return console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."), this;
                    var s = {
                        type: "packfile",
                        key: t,
                        url: e,
                        path: this.path,
                        syncPoint: !0,
                        data: null,
                        loading: !1,
                        loaded: !1,
                        error: !1,
                        callbackContext: o
                    };
                    i && ("string" == typeof i && (i = JSON.parse(i)), s.data = i || {}, s.loaded = !0);
                    for (var n = 0; n < this._fileList.length + 1; n++) {
                        var r = this._fileList[n];
                        if (!r || !r.loaded && !r.loading && "packfile" !== r.type) {
                            this._fileList.splice(n, 0, s), this._totalPackCount++;
                            break
                        }
                    }
                    return this
                },
                image: function(t, e, i) {
                    return this.addToFileList("image", t, e, void 0, i, ".png")
                },
                images: function(t, e) {
                    if (Array.isArray(e))
                        for (var i = 0; i < t.length; i++) this.image(t[i], e[i]);
                    else
                        for (var i = 0; i < t.length; i++) this.image(t[i]);
                    return this
                },
                text: function(t, e, i) {
                    return this.addToFileList("text", t, e, void 0, i, ".txt")
                },
                json: function(t, e, i) {
                    return this.addToFileList("json", t, e, void 0, i, ".json")
                },
                shader: function(t, e, i) {
                    return this.addToFileList("shader", t, e, void 0, i, ".frag")
                },
                xml: function(t, e, i) {
                    return this.addToFileList("xml", t, e, void 0, i, ".xml")
                },
                script: function(t, e, i, o) {
                    return void 0 === i && (i = !1), !1 !== i && void 0 === o && (o = this), this.addToFileList("script", t, e, {
                        syncPoint: !0,
                        callback: i,
                        callbackContext: o
                    }, !1, ".js")
                },
                binary: function(t, e, i, o) {
                    return void 0 === i && (i = !1), !1 !== i && void 0 === o && (o = i), this.addToFileList("binary", t, e, {
                        callback: i,
                        callbackContext: o
                    }, !1, ".bin")
                },
                spritesheet: function(t, e, i, o, s, n, r) {
                    return void 0 === s && (s = -1), void 0 === n && (n = 0), void 0 === r && (r = 0), this.addToFileList("spritesheet", t, e, {
                        frameWidth: i,
                        frameHeight: o,
                        frameMax: s,
                        margin: n,
                        spacing: r
                    }, !1, ".png")
                },
                audio: function(t, e, i) {
                    return this.game.sound.noAudio ? this : (void 0 === i && (i = !0), "string" == typeof e && (e = [e]), this.addToFileList("audio", t, e, {
                        buffer: null,
                        autoDecode: i
                    }))
                },
                audioSprite: function(t, e, i, o, s) {
                    return this.game.sound.noAudio ? this : (void 0 === i && (i = null), void 0 === o && (o = null), void 0 === s && (s = !0), this.audio(t, e, s), i ? this.json(t + "-audioatlas", i) : o ? ("string" == typeof o && (o = JSON.parse(o)), this.cache.addJSON(t + "-audioatlas", "", o)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object"), this)
                },
                audiosprite: function(t, e, i, o, s) {
                    return this.audioSprite(t, e, i, o, s)
                },
                video: function(t, e, i, o) {
                    return void 0 === i && (i = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === o && (o = !1), "string" == typeof e && (e = [e]), this.addToFileList("video", t, e, {
                        buffer: null,
                        asBlob: o,
                        loadEvent: i
                    })
                },
                tilemap: function(t, e, o, s) {
                    if (void 0 === e && (e = null), void 0 === o && (o = null), void 0 === s && (s = i.Tilemap.CSV), e || o || (e = s === i.Tilemap.CSV ? t + ".csv" : t + ".json"), o) {
                        switch (s) {
                            case i.Tilemap.CSV:
                                break;
                            case i.Tilemap.TILED_JSON:
                                "string" == typeof o && (o = JSON.parse(o))
                        }
                        this.cache.addTilemap(t, null, o, s)
                    } else this.addToFileList("tilemap", t, e, {
                        format: s
                    });
                    return this
                },
                physics: function(t, e, o, s) {
                    return void 0 === e && (e = null), void 0 === o && (o = null), void 0 === s && (s = i.Physics.LIME_CORONA_JSON), e || o || (e = t + ".json"),
                        o ? ("string" == typeof o && (o = JSON.parse(o)), this.cache.addPhysicsData(t, null, o, s)) : this.addToFileList("physics", t, e, {
                            format: s
                        }), this
                },
                bitmapFont: function(t, e, i, o, s, n) {
                    if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === i && (i = null), void 0 === o && (o = null), null === i && null === o && (i = t + ".xml"), void 0 === s && (s = 0), void 0 === n && (n = 0), i) this.addToFileList("bitmapfont", t, e, {
                        atlasURL: i,
                        xSpacing: s,
                        ySpacing: n
                    });
                    else if ("string" == typeof o) {
                        var r, a;
                        try {
                            r = JSON.parse(o)
                        } catch (t) {
                            a = this.parseXml(o)
                        }
                        if (!a && !r) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                        this.addToFileList("bitmapfont", t, e, {
                            atlasURL: null,
                            atlasData: r || a,
                            atlasType: r ? "json" : "xml",
                            xSpacing: s,
                            ySpacing: n
                        })
                    }
                    return this
                },
                atlasJSONArray: function(t, e, o, s) {
                    return this.atlas(t, e, o, s, i.Loader.TEXTURE_ATLAS_JSON_ARRAY)
                },
                atlasJSONHash: function(t, e, o, s) {
                    return this.atlas(t, e, o, s, i.Loader.TEXTURE_ATLAS_JSON_HASH)
                },
                atlasXML: function(t, e, o, s) {
                    return void 0 === o && (o = null), void 0 === s && (s = null), o || s || (o = t + ".xml"), this.atlas(t, e, o, s, i.Loader.TEXTURE_ATLAS_XML_STARLING)
                },
                atlas: function(t, e, o, s, n) {
                    if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === o && (o = null), void 0 === s && (s = null), void 0 === n && (n = i.Loader.TEXTURE_ATLAS_JSON_ARRAY), o || s || (o = n === i.Loader.TEXTURE_ATLAS_XML_STARLING ? t + ".xml" : t + ".json"), o) this.addToFileList("textureatlas", t, e, {
                        atlasURL: o,
                        format: n
                    });
                    else {
                        switch (n) {
                            case i.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                                "string" == typeof s && (s = JSON.parse(s));
                                break;
                            case i.Loader.TEXTURE_ATLAS_XML_STARLING:
                                if ("string" == typeof s) {
                                    var r = this.parseXml(s);
                                    if (!r) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                    s = r
                                }
                        }
                        this.addToFileList("textureatlas", t, e, {
                            atlasURL: null,
                            atlasData: s,
                            format: n
                        })
                    }
                    return this
                },
                withSyncPoint: function(t, e) {
                    this._withSyncPointDepth++;
                    try {
                        t.call(e || this, this)
                    } finally {
                        this._withSyncPointDepth--
                    }
                    return this
                },
                addSyncPoint: function(t, e) {
                    var i = this.getAsset(t, e);
                    return i && (i.file.syncPoint = !0), this
                },
                removeFile: function(t, e) {
                    var i = this.getAsset(t, e);
                    i && (i.loaded || i.loading || this._fileList.splice(i.index, 1))
                },
                removeAll: function() {
                    this._fileList.length = 0, this._flightQueue.length = 0
                },
                start: function() {
                    this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
                },
                processLoadQueue: function() {
                    if (!this.isLoading) return console.warn("Phaser.Loader - active loading canceled / reset"), void this.finishedLoading(!0);
                    for (var t = 0; t < this._flightQueue.length; t++) {
                        var e = this._flightQueue[t];
                        (e.loaded || e.error) && (this._flightQueue.splice(t, 1), t--, e.loading = !1, e.requestUrl = null, e.requestObject = null, e.error && this.onFileError.dispatch(e.key, e), "packfile" !== e.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, e.key, !e.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === e.type && e.error && (this._loadedPackCount++, this.onPackComplete.dispatch(e.key, !e.error, this._loadedPackCount, this._totalPackCount)))
                    }
                    for (var o = !1, s = this.enableParallel ? i.Math.clamp(this.maxParallelDownloads, 1, 12) : 1, t = this._processingHead; t < this._fileList.length; t++) {
                        var e = this._fileList[t];
                        if ("packfile" === e.type && !e.error && e.loaded && t === this._processingHead && (this.processPack(e), this._loadedPackCount++, this.onPackComplete.dispatch(e.key, !e.error, this._loadedPackCount, this._totalPackCount)), e.loaded || e.error ? t === this._processingHead && (this._processingHead = t + 1) : !e.loading && this._flightQueue.length < s && ("packfile" !== e.type || e.data ? o || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(e), e.loading = !0, this.onFileStart.dispatch(this.progress, e.key, e.url), this.loadFile(e)) : (this._flightQueue.push(e), e.loading = !0, this.loadFile(e))), !e.loaded && e.syncPoint && (o = !0), this._flightQueue.length >= s || o && this._loadedPackCount === this._totalPackCount) break
                    }
                    if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
                    else if (!this._flightQueue.length) {
                        console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                        var n = this;
                        setTimeout(function() {
                            n.finishedLoading(!0)
                        }, 2e3)
                    }
                },
                finishedLoading: function(t) {
                    this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.onLoadComplete.dispatch(), this.game.state.loadComplete(), this.reset())
                },
                asyncComplete: function(t, e) {
                    void 0 === e && (e = ""), t.loaded = !0, t.error = !!e, e && (t.errorMessage = e, console.warn("Phaser.Loader - " + t.type + "[" + t.key + "]: " + e)), this.processLoadQueue()
                },
                processPack: function(t) {
                    var e = t.data[t.key];
                    if (!e) return void console.warn("Phaser.Loader - " + t.key + ": pack has data, but not for pack key");
                    for (var o = 0; o < e.length; o++) {
                        var s = e[o];
                        switch (s.type) {
                            case "image":
                                this.image(s.key, s.url, s.overwrite);
                                break;
                            case "text":
                                this.text(s.key, s.url, s.overwrite);
                                break;
                            case "json":
                                this.json(s.key, s.url, s.overwrite);
                                break;
                            case "xml":
                                this.xml(s.key, s.url, s.overwrite);
                                break;
                            case "script":
                                this.script(s.key, s.url, s.callback, t.callbackContext || this);
                                break;
                            case "binary":
                                this.binary(s.key, s.url, s.callback, t.callbackContext || this);
                                break;
                            case "spritesheet":
                                this.spritesheet(s.key, s.url, s.frameWidth, s.frameHeight, s.frameMax, s.margin, s.spacing);
                                break;
                            case "video":
                                this.video(s.key, s.urls);
                                break;
                            case "audio":
                                this.audio(s.key, s.urls, s.autoDecode);
                                break;
                            case "audiosprite":
                                this.audiosprite(s.key, s.urls, s.jsonURL, s.jsonData, s.autoDecode);
                                break;
                            case "tilemap":
                                this.tilemap(s.key, s.url, s.data, i.Tilemap[s.format]);
                                break;
                            case "physics":
                                this.physics(s.key, s.url, s.data, i.Loader[s.format]);
                                break;
                            case "bitmapFont":
                                this.bitmapFont(s.key, s.textureURL, s.atlasURL, s.atlasData, s.xSpacing, s.ySpacing);
                                break;
                            case "atlasJSONArray":
                                this.atlasJSONArray(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                break;
                            case "atlasJSONHash":
                                this.atlasJSONHash(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                break;
                            case "atlasXML":
                                this.atlasXML(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                break;
                            case "atlas":
                                this.atlas(s.key, s.textureURL, s.atlasURL, s.atlasData, i.Loader[s.format]);
                                break;
                            case "shader":
                                this.shader(s.key, s.url, s.overwrite)
                        }
                    }
                },
                transformUrl: function(t, e) {
                    return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t)
                },
                loadFile: function(t) {
                    switch (t.type) {
                        case "packfile":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                            break;
                        case "image":
                        case "spritesheet":
                        case "textureatlas":
                        case "bitmapfont":
                            this.loadImageTag(t);
                            break;
                        case "audio":
                            t.url = this.getAudioURL(t.url), t.url ? this.game.sound.usingWebAudio ? this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(t) : this.fileError(t, null, "No supported audio URL specified or device does not have audio playback support");
                            break;
                        case "video":
                            t.url = this.getVideoURL(t.url), t.url ? t.asBlob ? this.xhrLoad(t, this.transformUrl(t.url, t), "blob", this.fileComplete) : this.loadVideoTag(t) : this.fileError(t, null, "No supported video URL specified or device does not have video playback support");
                            break;
                        case "json":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete);
                            break;
                        case "xml":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.xmlLoadComplete);
                            break;
                        case "tilemap":
                            t.format === i.Tilemap.TILED_JSON ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete) : t.format === i.Tilemap.CSV ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.csvLoadComplete) : this.asyncComplete(t, "invalid Tilemap format: " + t.format);
                            break;
                        case "text":
                        case "script":
                        case "shader":
                        case "physics":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                            break;
                        case "binary":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete)
                    }
                },
                loadImageTag: function(t) {
                    var e = this;
                    t.data = new Image, t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function() {
                        t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t))
                    }, t.data.onerror = function() {
                        t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t))
                    }, t.data.src = this.transformUrl(t.url, t), t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
                },
                loadVideoTag: function(t) {
                    var e = this;
                    t.data = document.createElement("video"), t.data.name = t.key, t.data.controls = !1, t.data.autoplay = !1;
                    var o = function() {
                        t.data.removeEventListener(t.loadEvent, o, !1), t.data.onerror = null, t.data.canplay = !0, i.GAMES[e.game.id].load.fileComplete(t)
                    };
                    t.data.onerror = function() {
                        t.data.removeEventListener(t.loadEvent, o, !1), t.data.onerror = null, t.data.canplay = !1, e.fileError(t)
                    }, t.data.addEventListener(t.loadEvent, o, !1), t.data.src = this.transformUrl(t.url, t), t.data.load()
                },
                loadAudioTag: function(t) {
                    var e = this;
                    if (this.game.sound.touchLocked) t.data = new Audio, t.data.name = t.key, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), this.fileComplete(t);
                    else {
                        t.data = new Audio, t.data.name = t.key;
                        var i = function() {
                            t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileComplete(t)
                        };
                        t.data.onerror = function() {
                            t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileError(t)
                        }, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), t.data.addEventListener("canplaythrough", i, !1), t.data.load()
                    }
                },
                xhrLoad: function(t, e, i, o, s) {
                    if (this.useXDomainRequest && window.XDomainRequest) return void this.xhrLoadWithXDR(t, e, i, o, s);
                    var n = new XMLHttpRequest;
                    n.open("GET", e, !0), n.responseType = i, !1 !== this.headers.requestedWith && n.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[t.type] && n.setRequestHeader("Accept", this.headers[t.type]), s = s || this.fileError;
                    var r = this;
                    n.onload = function() {
                        try {
                            return 4 === n.readyState && n.status >= 400 && n.status <= 599 ? s.call(r, t, n) : o.call(r, t, n)
                        } catch (e) {
                            r.hasLoaded ? window.console && console.error(e) : r.asyncComplete(t, e.message || "Exception")
                        }
                    }, n.onerror = function() {
                        try {
                            return s.call(r, t, n)
                        } catch (e) {
                            r.hasLoaded ? window.console && console.error(e) : r.asyncComplete(t, e.message || "Exception")
                        }
                    }, t.requestObject = n, t.requestUrl = e, n.send()
                },
                xhrLoadWithXDR: function(t, e, i, o, s) {
                    this._warnedAboutXDomainRequest || this.game.device.ie && !(this.game.device.ieVersion >= 10) || (this._warnedAboutXDomainRequest = !0, console.warn("Phaser.Loader - using XDomainRequest outside of IE 9"));
                    var n = new window.XDomainRequest;
                    n.open("GET", e, !0), n.responseType = i, n.timeout = 3e3, s = s || this.fileError;
                    var r = this;
                    n.onerror = function() {
                        try {
                            return s.call(r, t, n)
                        } catch (e) {
                            r.asyncComplete(t, e.message || "Exception")
                        }
                    }, n.ontimeout = function() {
                        try {
                            return s.call(r, t, n)
                        } catch (e) {
                            r.asyncComplete(t, e.message || "Exception")
                        }
                    }, n.onprogress = function() {}, n.onload = function() {
                        try {
                            return 4 === n.readyState && n.status >= 400 && n.status <= 599 ? s.call(r, t, n) : o.call(r, t, n)
                        } catch (e) {
                            r.asyncComplete(t, e.message || "Exception")
                        }
                    }, t.requestObject = n, t.requestUrl = e, setTimeout(function() {
                        n.send()
                    }, 0)
                },
                getVideoURL: function(t) {
                    for (var e = 0; e < t.length; e++) {
                        var i, o = t[e];
                        if (o.uri) {
                            if (i = o.type, o = o.uri, this.game.device.canPlayVideo(i)) return o
                        } else {
                            if (0 === o.indexOf("blob:") || 0 === o.indexOf("data:")) return o;
                            o.indexOf("?") >= 0 && (o = o.substr(0, o.indexOf("?")));
                            if (i = o.substr((Math.max(0, o.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(i)) return t[e]
                        }
                    }
                    return null
                },
                getAudioURL: function(t) {
                    if (this.game.sound.noAudio) return null;
                    for (var e = 0; e < t.length; e++) {
                        var i, o = t[e];
                        if (o.uri) {
                            if (i = o.type, o = o.uri, this.game.device.canPlayAudio(i)) return o
                        } else {
                            if (0 === o.indexOf("blob:") || 0 === o.indexOf("data:")) return o;
                            o.indexOf("?") >= 0 && (o = o.substr(0, o.indexOf("?")));
                            if (i = o.substr((Math.max(0, o.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(i)) return t[e]
                        }
                    }
                    return null
                },
                fileError: function(t, e, i) {
                    var o = t.requestUrl || this.transformUrl(t.url, t),
                        s = "error loading asset from URL " + o;
                    !i && e && (i = e.status), i && (s = s + " (" + i + ")"), this.asyncComplete(t, s)
                },
                fileComplete: function(t, e) {
                    var o = !0;
                    switch (t.type) {
                        case "packfile":
                            var s = JSON.parse(e.responseText);
                            t.data = s || {};
                            break;
                        case "image":
                            this.cache.addImage(t.key, t.url, t.data);
                            break;
                        case "spritesheet":
                            this.cache.addSpriteSheet(t.key, t.url, t.data, t.frameWidth, t.frameHeight, t.frameMax, t.margin, t.spacing);
                            break;
                        case "textureatlas":
                            if (null == t.atlasURL) this.cache.addTextureAtlas(t.key, t.url, t.data, t.atlasData, t.format);
                            else if (o = !1, t.format === i.Loader.TEXTURE_ATLAS_JSON_ARRAY || t.format === i.Loader.TEXTURE_ATLAS_JSON_HASH || t.format === i.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.jsonLoadComplete);
                            else {
                                if (t.format !== i.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + t.format);
                                this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.xmlLoadComplete)
                            }
                            break;
                        case "bitmapfont":
                            t.atlasURL ? (o = !1, this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", function(t, e) {
                                var i;
                                try {
                                    i = JSON.parse(e.responseText)
                                } catch (t) {}
                                i ? (t.atlasType = "json", this.jsonLoadComplete(t, e)) : (t.atlasType = "xml", this.xmlLoadComplete(t, e))
                            })) : this.cache.addBitmapFont(t.key, t.url, t.data, t.atlasData, t.atlasType, t.xSpacing, t.ySpacing);
                            break;
                        case "video":
                            if (t.asBlob) try {
                                t.data = e.response
                            } catch (e) {
                                throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + t.key)
                            }
                            this.cache.addVideo(t.key, t.url, t.data, t.asBlob);
                            break;
                        case "audio":
                            this.game.sound.usingWebAudio ? (t.data = e.response, this.cache.addSound(t.key, t.url, t.data, !0, !1), t.autoDecode && this.game.sound.decode(t.key)) : this.cache.addSound(t.key, t.url, t.data, !1, !0);
                            break;
                        case "text":
                            t.data = e.responseText, this.cache.addText(t.key, t.url, t.data);
                            break;
                        case "shader":
                            t.data = e.responseText, this.cache.addShader(t.key, t.url, t.data);
                            break;
                        case "physics":
                            var s = JSON.parse(e.responseText);
                            this.cache.addPhysicsData(t.key, t.url, s, t.format);
                            break;
                        case "script":
                            t.data = document.createElement("script"), t.data.language = "javascript", t.data.type = "text/javascript", t.data.defer = !1, t.data.text = e.responseText, document.head.appendChild(t.data), t.callback && (t.data = t.callback.call(t.callbackContext, t.key, e.responseText));
                            break;
                        case "binary":
                            t.callback ? t.data = t.callback.call(t.callbackContext, t.key, e.response) : t.data = e.response, this.cache.addBinary(t.key, t.data)
                    }
                    o && this.asyncComplete(t)
                },
                jsonLoadComplete: function(t, e) {
                    var i = JSON.parse(e.responseText);
                    "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format), this.asyncComplete(t)
                },
                csvLoadComplete: function(t, e) {
                    var i = e.responseText;
                    this.cache.addTilemap(t.key, t.url, i, t.format), this.asyncComplete(t)
                },
                xmlLoadComplete: function(t, e) {
                    var i = e.responseText,
                        o = this.parseXml(i);
                    if (!o) {
                        var s = e.responseType || e.contentType;
                        return console.warn("Phaser.Loader - " + t.key + ": invalid XML (" + s + ")"), void this.asyncComplete(t, "invalid XML")
                    }
                    "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, o, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, o, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, o), this.asyncComplete(t)
                },
                parseXml: function(t) {
                    var e;
                    try {
                        if (window.DOMParser) {
                            var i = new DOMParser;
                            e = i.parseFromString(t, "text/xml")
                        } else e = new ActiveXObject("Microsoft.XMLDOM"), e.async = "false", e.loadXML(t)
                    } catch (t) {
                        e = null
                    }
                    return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null
                },
                updateProgress: function() {
                    this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
                },
                totalLoadedFiles: function() {
                    return this._loadedFileCount
                },
                totalQueuedFiles: function() {
                    return this._totalFileCount - this._loadedFileCount
                },
                totalLoadedPacks: function() {
                    return this._totalPackCount
                },
                totalQueuedPacks: function() {
                    return this._totalPackCount - this._loadedPackCount
                }
            }, Object.defineProperty(i.Loader.prototype, "progressFloat", {
                get: function() {
                    var t = this._loadedFileCount / this._totalFileCount * 100;
                    return i.Math.clamp(t || 0, 0, 100)
                }
            }), Object.defineProperty(i.Loader.prototype, "progress", {
                get: function() {
                    return Math.round(this.progressFloat)
                }
            }), i.Loader.prototype.constructor = i.Loader, i.LoaderParser = {
                bitmapFont: function(t, e, i, o) {
                    return this.xmlBitmapFont(t, e, i, o)
                },
                xmlBitmapFont: function(t, e, i, o) {
                    var s = {},
                        n = t.getElementsByTagName("info")[0],
                        r = t.getElementsByTagName("common")[0];
                    s.font = n.getAttribute("face"), s.size = parseInt(n.getAttribute("size"), 10), s.lineHeight = parseInt(r.getAttribute("lineHeight"), 10) + o, s.chars = {};
                    for (var a = t.getElementsByTagName("char"), h = 0; h < a.length; h++) {
                        var l = parseInt(a[h].getAttribute("id"), 10);
                        s.chars[l] = {
                            x: parseInt(a[h].getAttribute("x"), 10),
                            y: parseInt(a[h].getAttribute("y"), 10),
                            width: parseInt(a[h].getAttribute("width"), 10),
                            height: parseInt(a[h].getAttribute("height"), 10),
                            xOffset: parseInt(a[h].getAttribute("xoffset"), 10),
                            yOffset: parseInt(a[h].getAttribute("yoffset"), 10),
                            xAdvance: parseInt(a[h].getAttribute("xadvance"), 10) + i,
                            kerning: {}
                        }
                    }
                    var d = t.getElementsByTagName("kerning");
                    for (h = 0; h < d.length; h++) {
                        var c = parseInt(d[h].getAttribute("first"), 10),
                            p = parseInt(d[h].getAttribute("second"), 10),
                            u = parseInt(d[h].getAttribute("amount"), 10);
                        s.chars[p].kerning[c] = u
                    }
                    return this.finalizeBitmapFont(e, s)
                },
                jsonBitmapFont: function(t, e, i, o) {
                    var s = {
                        font: t.font.info._face,
                        size: parseInt(t.font.info._size, 10),
                        lineHeight: parseInt(t.font.common._lineHeight, 10) + o,
                        chars: {}
                    };
                    return t.font.chars.char.forEach(function(t) {
                        var e = parseInt(t._id, 10);
                        s.chars[e] = {
                            x: parseInt(t._x, 10),
                            y: parseInt(t._y, 10),
                            width: parseInt(t._width, 10),
                            height: parseInt(t._height, 10),
                            xOffset: parseInt(t._xoffset, 10),
                            yOffset: parseInt(t._yoffset, 10),
                            xAdvance: parseInt(t._xadvance, 10) + i,
                            kerning: {}
                        }
                    }), t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function(t) {
                        s.chars[t._second].kerning[t._first] = parseInt(t._amount, 10)
                    }), this.finalizeBitmapFont(e, s)
                },
                finalizeBitmapFont: function(t, e) {
                    return Object.keys(e.chars).forEach(function(o) {
                        var s = e.chars[o];
                        s.texture = new PIXI.Texture(t, new i.Rectangle(s.x, s.y, s.width, s.height))
                    }), e
                }
            }, i.AudioSprite = function(t, e) {
                this.game = t, this.key = e, this.config = this.game.cache.getJSON(e + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {};
                for (var i in this.config.spritemap) {
                    var o = this.config.spritemap[i],
                        s = this.game.add.sound(this.key);
                    s.addMarker(i, o.start, o.end - o.start, null, o.loop), this.sounds[i] = s
                }
                this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
            }, i.AudioSprite.prototype = {
                play: function(t, e) {
                    return void 0 === e && (e = 1), this.sounds[t].play(t, null, e)
                },
                stop: function(t) {
                    if (t) this.sounds[t].stop();
                    else
                        for (var e in this.sounds) this.sounds[e].stop()
                },
                get: function(t) {
                    return this.sounds[t]
                }
            }, i.AudioSprite.prototype.constructor = i.AudioSprite, i.Sound = function(t, e, o, s, n) {
                void 0 === o && (o = 1), void 0 === s && (s = !1), void 0 === n && (n = t.sound.connectToMaster), this.game = t, this.name = e, this.key = e, this.loop = s, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = o * this.game.sound.volume, n && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(e) && this.game.cache.isSoundReady(e) ? (this._sound = this.game.cache.getSoundData(e), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new i.Signal, this.onPlay = new i.Signal, this.onPause = new i.Signal, this.onResume = new i.Signal, this.onLoop = new i.Signal, this.onStop = new i.Signal, this.onMute = new i.Signal, this.onMarkerComplete = new i.Signal, this.onFadeComplete = new i.Signal, this._volume = o, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1
            }, i.Sound.prototype = {
                soundHasUnlocked: function(t) {
                    t === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
                },
                addMarker: function(t, e, i, o, s) {
                    void 0 !== i && null !== i || (i = 1), void 0 !== o && null !== o || (o = 1), void 0 === s && (s = !1), this.markers[t] = {
                        name: t,
                        start: e,
                        stop: e + i,
                        volume: o,
                        duration: i,
                        durationMS: 1e3 * i,
                        loop: s
                    }
                },
                removeMarker: function(t) {
                    delete this.markers[t]
                },
                onEndedHandler: function() {
                    this._sound.onended = null, this.isPlaying = !1, this.currentTime = this.durationMS, this.stop()
                },
                update: function() {
                    if (!this.game.cache.checkSoundKey(this.key)) return void this.destroy();
                    this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = this.game.time.time), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))
                },
                loopFull: function(t) {
                    return this.play(null, 0, t, !0)
                },
                play: function(t, e, i, o, s) {
                    if (void 0 !== t && !1 !== t && null !== t || (t = ""), void 0 === s && (s = !0), this.isPlaying && !this.allowMultiple && !s && !this.override) return this;
                    if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || s)) {
                        if (this.usingWebAudio) {
                            if (void 0 === this._sound.stop) this._sound.noteOff(0);
                            else try {
                                this._sound.stop(0)
                            } catch (t) {}
                            this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                        } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                        this.isPlaying = !1
                    }
                    if ("" === t && Object.keys(this.markers).length > 0) return this;
                    if ("" !== t) {
                        if (!this.markers[t]) return console.warn("Phaser.Sound.play: audio marker " + t + " doesn't exist"), this;
                        this.currentMarker = t, this.position = this.markers[t].start, this.volume = this.markers[t].volume, this.loop = this.markers[t].loop, this.duration = this.markers[t].duration, this.durationMS = this.markers[t].durationMS, void 0 !== i && (this.volume = i), void 0 !== o && (this.loop = o), this._tempMarker = t, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
                    } else e = e || 0, void 0 === i && (i = this._volume), void 0 === o && (o = this.loop), this.position = Math.max(0, e), this.volume = i, this.loop = o, this.duration = 0, this.durationMS = 0, this._tempMarker = t, this._tempPosition = e, this._tempVolume = i, this._tempLoop = o;
                    return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this.loop && "" === t && (this._sound.loop = !0), this.loop || "" !== t || (this._sound.onended = this.onEndedHandler.bind(this)), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === t ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume, this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this
                },
                restart: function(t, e, i, o) {
                    t = t || "", e = e || 0, i = i || 1, void 0 === o && (o = !1), this.play(t, e, i, o, !0)
                },
                pause: function() {
                    this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop())
                },
                resume: function() {
                    if (this.paused && this._sound) {
                        if (this.usingWebAudio) {
                            var t = Math.max(0, this.position + this.pausedPosition / 1e3);
                            this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this.loop && (this._sound.loop = !0), this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
                            var e = this.duration - this.pausedPosition / 1e3;
                            void 0 === this._sound.start ? this._sound.noteGrainOn(0, t, e) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, t) : this._sound.start(0, t, e)
                        } else this._sound.currentTime = this._tempPause, this._sound.play();
                        this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this)
                    }
                },
                stop: function() {
                    if (this.isPlaying && this._sound)
                        if (this.usingWebAudio) {
                            if (void 0 === this._sound.stop) this._sound.noteOff(0);
                            else try {
                                this._sound.stop(0)
                            } catch (t) {}
                            this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                        } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                    if (this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) {
                        var t = this.currentMarker;
                        "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, t)
                    }
                },
                fadeIn: function(t, e, i) {
                    void 0 === e && (e = !1), void 0 === i && (i = this.currentMarker), this.paused || (this.play(i, 0, 0, e), this.fadeTo(t, 1))
                },
                fadeOut: function(t) {
                    this.fadeTo(t, 0)
                },
                fadeTo: function(t, e) {
                    if (this.isPlaying && !this.paused && e !== this.volume) {
                        if (void 0 === t && (t = 1e3), void 0 === e) return void console.warn("Phaser.Sound.fadeTo: No Volume Specified.");
                        this.fadeTween = this.game.add.tween(this).to({
                            volume: e
                        }, t, i.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this)
                    }
                },
                fadeComplete: function() {
                    this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop()
                },
                updateGlobalVolume: function(t) {
                    this.usingAudioTag && this._sound && (this._sound.volume = t * this._volume)
                },
                destroy: function(t) {
                    void 0 === t && (t = !0), this.stop(), t ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
                }
            }, i.Sound.prototype.constructor = i.Sound, Object.defineProperty(i.Sound.prototype, "isDecoding", {
                get: function() {
                    return this.game.cache.getSound(this.key).isDecoding
                }
            }), Object.defineProperty(i.Sound.prototype, "isDecoded", {
                get: function() {
                    return this.game.cache.isSoundDecoded(this.key)
                }
            }), Object.defineProperty(i.Sound.prototype, "mute", {
                get: function() {
                    return this._muted || this.game.sound.mute
                },
                set: function(t) {
                    (t = t || !1) !== this._muted && (t ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this))
                }
            }), Object.defineProperty(i.Sound.prototype, "volume", {
                get: function() {
                    return this._volume
                },
                set: function(t) {
                    if (this.game.device.firefox && this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)), this._muted) return void(this._muteVolume = t);
                    this._tempVolume = t, this._volume = t, this.usingWebAudio ? this.gainNode.gain.value = t : this.usingAudioTag && this._sound && (this._sound.volume = t)
                }
            }), i.SoundManager = function(t) {
                this.game = t, this.onSoundDecode = new i.Signal, this.onVolumeChange = new i.Signal, this.onMute = new i.Signal, this.onUnMute = new i.Signal, this.context = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new i.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null
            }, i.SoundManager.prototype = {
                boot: function() {
                    if (this.game.device.iOS && !1 === this.game.device.webAudio && (this.channels = 1), window.PhaserGlobal) {
                        if (!0 === window.PhaserGlobal.disableAudio) return this.noAudio = !0, void(this.touchLocked = !1);
                        if (!0 === window.PhaserGlobal.disableWebAudio) return this.usingAudioTag = !0, void(this.touchLocked = !1)
                    }
                    if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext;
                    else if (window.AudioContext) try {
                        this.context = new window.AudioContext
                    } catch (t) {
                        this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                    } else if (window.webkitAudioContext) try {
                        this.context = new window.webkitAudioContext
                    } catch (t) {
                        this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                    }
                    if (null === this.context) {
                        if (void 0 === window.Audio) return void(this.noAudio = !0);
                        this.usingAudioTag = !0
                    } else this.usingWebAudio = !0, void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination);
                    this.noAudio || (!this.game.device.cocoonJS && this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock()
                },
                setTouchLock: function() {
                    this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (this.game.device.iOSVersion > 8 ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0)
                },
                unlock: function() {
                    if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
                    if (this.usingAudioTag) this.touchLocked = !1, this._unlockSource = null;
                    else if (this.usingWebAudio) {
                        var t = this.context.createBuffer(1, 1, 22050);
                        this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = t, this._unlockSource.connect(this.context.destination), void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0)
                    }
                    return !0
                },
                stopAll: function() {
                    if (!this.noAudio)
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop()
                },
                pauseAll: function() {
                    if (!this.noAudio)
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause()
                },
                resumeAll: function() {
                    if (!this.noAudio)
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume()
                },
                decode: function(t, e) {
                    e = e || null;
                    var i = this.game.cache.getSoundData(t);
                    if (i && !1 === this.game.cache.isSoundDecoded(t)) {
                        this.game.cache.updateSound(t, "isDecoding", !0);
                        var o = this;
                        try {
                            this.context.decodeAudioData(i, function(i) {
                                i && (o.game.cache.decodedSound(t, i), o.onSoundDecode.dispatch(t, e))
                            })
                        } catch (t) {}
                    }
                },
                setDecodedCallback: function(t, e, o) {
                    "string" == typeof t && (t = [t]), this._watchList.reset();
                    for (var s = 0; s < t.length; s++) t[s] instanceof i.Sound ? this.game.cache.isSoundDecoded(t[s].key) || this._watchList.add(t[s].key) : this.game.cache.isSoundDecoded(t[s]) || this._watchList.add(t[s]);
                    0 === this._watchList.total ? (this._watching = !1, e.call(o)) : (this._watching = !0, this._watchCallback = e, this._watchContext = o)
                },
                update: function() {
                    if (!this.noAudio) {
                        !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1, this._unlockSource = null);
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update();
                        if (this._watching) {
                            for (var e = this._watchList.first; e;) this.game.cache.isSoundDecoded(e) && this._watchList.remove(e), e = this._watchList.next;
                            0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                        }
                    }
                },
                add: function(t, e, o, s) {
                    void 0 === e && (e = 1), void 0 === o && (o = !1), void 0 === s && (s = this.connectToMaster);
                    var n = new i.Sound(this.game, t, e, o, s);
                    return this._sounds.push(n), n
                },
                addSprite: function(t) {
                    return new i.AudioSprite(this.game, t)
                },
                remove: function(t) {
                    for (var e = this._sounds.length; e--;)
                        if (this._sounds[e] === t) return this._sounds[e].destroy(!1), this._sounds.splice(e, 1), !0;
                    return !1
                },
                removeByKey: function(t) {
                    for (var e = this._sounds.length, i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++);
                    return i
                },
                play: function(t, e, i) {
                    if (!this.noAudio) {
                        var o = this.add(t, e, i);
                        return o.play(), o
                    }
                },
                setMute: function() {
                    if (!this._muted) {
                        this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                        this.onMute.dispatch()
                    }
                },
                unsetMute: function() {
                    if (this._muted && !this._codeMuted) {
                        this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                        this.onUnMute.dispatch()
                    }
                },
                destroy: function() {
                    this.stopAll();
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].destroy();
                    this._sounds = [], this.onSoundDecode.dispose(), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
                }
            }, i.SoundManager.prototype.constructor = i.SoundManager, Object.defineProperty(i.SoundManager.prototype, "mute", {
                get: function() {
                    return this._muted
                },
                set: function(t) {
                    if (t = t || !1) {
                        if (this._muted) return;
                        this._codeMuted = !0, this.setMute()
                    } else {
                        if (!this._muted) return;
                        this._codeMuted = !1, this.unsetMute()
                    }
                }
            }), Object.defineProperty(i.SoundManager.prototype, "volume", {
                get: function() {
                    return this._volume
                },
                set: function(t) {
                    if (t < 0 ? t = 0 : t > 1 && (t = 1), this._volume !== t) {
                        if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t;
                        else
                            for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                        this.onVolumeChange.dispatch(t)
                    }
                }
            }), i.ScaleManager = function(t, e, o) {
                this.game = t, this.dom = i.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new i.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new i.Signal, this.enterIncorrectOrientation = new i.Signal, this.leaveIncorrectOrientation = new i.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new i.Signal, this.onFullScreenChange = new i.Signal, this.onFullScreenError = new i.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new i.Point(1, 1), this.scaleFactorInversed = new i.Point(1, 1), this.margin = {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0,
                    x: 0,
                    y: 0
                }, this.bounds = new i.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
                    right: "layout",
                    bottom: ""
                }, this.compatibility = {
                    supportsFullScreen: !1,
                    orientationFallback: null,
                    noMargins: !1,
                    scrollTo: null,
                    forceMinimumDocumentHeight: !1,
                    canExpandParent: !0,
                    clickTrampoline: ""
                }, this._scaleMode = i.ScaleManager.NO_SCALE, this._fullScreenScaleMode = i.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new i.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new i.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new i.Rectangle, this._userScaleFactor = new i.Point(1, 1), this._userScaleTrim = new i.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new i.Rectangle, this._tempBounds = new i.Rectangle, this._lastReportedCanvasSize = new i.Rectangle, this._lastReportedGameSize = new i.Rectangle, this._booted = !1, t.config && this.parseConfig(t.config), this.setupScale(e, o)
            }, i.ScaleManager.EXACT_FIT = 0, i.ScaleManager.NO_SCALE = 1, i.ScaleManager.SHOW_ALL = 2, i.ScaleManager.RESIZE = 3, i.ScaleManager.USER_SCALE = 4, i.ScaleManager.prototype = {
                boot: function() {
                    var t = this.compatibility;
                    t.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? t.scrollTo = new i.Point(0, 1) : t.scrollTo = new i.Point(0, 0)), this.game.device.desktop ? (t.orientationFallback = "screen", t.clickTrampoline = "when-not-mouse") : (t.orientationFallback = "", t.clickTrampoline = "");
                    var e = this;
                    this._orientationChange = function(t) {
                        return e.orientationChange(t)
                    }, this._windowResize = function(t) {
                        return e.windowResize(t)
                    }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) {
                        return e.fullScreenChange(t)
                    }, this._fullScreenError = function(t) {
                        return e.fullScreenError(t)
                    }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), i.FlexGrid && (this.grid = new i.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
                },
                parseConfig: function(t) {
                    void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode), void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget)
                },
                setupScale: function(t, e) {
                    var o, s = new i.Rectangle;
                    "" !== this.game.parent && ("string" == typeof this.game.parent ? o = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (o = this.game.parent)), o ? (this.parentNode = o, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), s.width = this._parentBounds.width, s.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, s.width = this.dom.visualBounds.width, s.height = this.dom.visualBounds.height, this.offset.set(0, 0));
                    var n = 0,
                        r = 0;
                    "number" == typeof t ? n = t : (this.parentScaleFactor.x = parseInt(t, 10) / 100, n = s.width * this.parentScaleFactor.x), "number" == typeof e ? r = e : (this.parentScaleFactor.y = parseInt(e, 10) / 100, r = s.height * this.parentScaleFactor.y), n = Math.floor(n), r = Math.floor(r), this._gameSize.setTo(0, 0, n, r), this.updateDimensions(n, r, !1)
                },
                _gameResumed: function() {
                    this.queueUpdate(!0)
                },
                setGameSize: function(t, e) {
                    this._gameSize.setTo(0, 0, t, e), this.currentScaleMode !== i.ScaleManager.RESIZE && this.updateDimensions(t, e, !0), this.queueUpdate(!0)
                },
                setUserScale: function(t, e, i, o) {
                    this._userScaleFactor.setTo(t, e), this._userScaleTrim.setTo(0 | i, 0 | o), this.queueUpdate(!0)
                },
                setResizeCallback: function(t, e) {
                    this.onResize = t, this.onResizeContext = e
                },
                signalSizeChange: function() {
                    if (!i.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !i.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                        var t = this.width,
                            e = this.height;
                        this._lastReportedCanvasSize.setTo(0, 0, t, e), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(t, e), this.onSizeChange.dispatch(this, t, e), this.currentScaleMode === i.ScaleManager.RESIZE && (this.game.state.resize(t, e), this.game.load.resize(t, e))
                    }
                },
                setMinMax: function(t, e, i, o) {
                    this.minWidth = t, this.minHeight = e, void 0 !== i && (this.maxWidth = i), void 0 !== o && (this.maxHeight = o)
                },
                preUpdate: function() {
                    if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                        var t = this._updateThrottle;
                        this._updateThrottleReset = t >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                        var e = this._parentBounds.width,
                            o = this._parentBounds.height,
                            s = this.getParentBounds(this._parentBounds),
                            n = s.width !== e || s.height !== o,
                            r = this.updateOrientationState();
                        (n || r) && (this.onResize && this.onResize.call(this.onResizeContext, this, s), this.updateLayout(), this.signalSizeChange());
                        var a = 2 * this._updateThrottle;
                        this._updateThrottle < t && (a = Math.min(t, this._updateThrottleReset)), this._updateThrottle = i.Math.clamp(a, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time
                    }
                },
                pauseUpdate: function() {
                    this.preUpdate(), this._updateThrottle = this.trackParentInterval
                },
                updateDimensions: function(t, e, i) {
                    this.width = t * this.parentScaleFactor.x, this.height = e * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
                },
                updateScalingAndBounds: function() {
                    this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
                },
                forceOrientation: function(t, e) {
                    void 0 === e && (e = !1), this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0)
                },
                classifyOrientation: function(t) {
                    return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null
                },
                updateOrientationState: function() {
                    var t = this.screenOrientation,
                        e = this.incorrectOrientation;
                    this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                    var i = t !== this.screenOrientation,
                        o = e !== this.incorrectOrientation;
                    return o && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (i || o) && this.onOrientationChange.dispatch(this, t, e), i || o
                },
                orientationChange: function(t) {
                    this.event = t, this.queueUpdate(!0)
                },
                windowResize: function(t) {
                    this.event = t, this.queueUpdate(!0)
                },
                scrollTop: function() {
                    var t = this.compatibility.scrollTo;
                    t && window.scrollTo(t.x, t.y)
                },
                refresh: function() {
                    this.scrollTop(), this.queueUpdate(!0)
                },
                updateLayout: function() {
                    var t = this.currentScaleMode;
                    if (t === i.ScaleManager.RESIZE) return void this.reflowGame();
                    if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : t === i.ScaleManager.EXACT_FIT ? this.setExactFit() : t === i.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : t === i.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : t === i.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (t === i.ScaleManager.SHOW_ALL || t === i.ScaleManager.USER_SCALE)) {
                        var e = this.getParentBounds(this._tempBounds);
                        this.width = Math.min(this.width, e.width), this.height = Math.min(this.height, e.height)
                    }
                    this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()
                },
                getParentBounds: function(t) {
                    var e = t || new i.Rectangle,
                        o = this.boundingParent,
                        s = this.dom.visualBounds,
                        n = this.dom.layoutBounds;
                    if (o) {
                        var r = o.getBoundingClientRect(),
                            a = o.offsetParent ? o.offsetParent.getBoundingClientRect() : o.getBoundingClientRect();
                        e.setTo(r.left - a.left, r.top - a.top, r.width, r.height);
                        var h = this.windowConstraints;
                        if (h.right) {
                            var l = "layout" === h.right ? n : s;
                            e.right = Math.min(e.right, l.width)
                        }
                        if (h.bottom) {
                            var l = "layout" === h.bottom ? n : s;
                            e.bottom = Math.min(e.bottom, l.height)
                        }
                    } else e.setTo(0, 0, s.width, s.height);
                    return e.setTo(Math.round(e.x), Math.round(e.y), Math.round(e.width), Math.round(e.height)), e
                },
                alignCanvas: function(t, e) {
                    var i = this.getParentBounds(this._tempBounds),
                        o = this.game.canvas,
                        s = this.margin;
                    if (t) {
                        s.left = s.right = 0;
                        var n = o.getBoundingClientRect();
                        if (this.width < i.width && !this.incorrectOrientation) {
                            var r = n.left - i.x,
                                a = i.width / 2 - this.width / 2;
                            a = Math.max(a, 0);
                            var h = a - r;
                            s.left = Math.round(h)
                        }
                        o.style.marginLeft = s.left + "px", 0 !== s.left && (s.right = -(i.width - n.width - s.left), o.style.marginRight = s.right + "px")
                    }
                    if (e) {
                        s.top = s.bottom = 0;
                        var n = o.getBoundingClientRect();
                        if (this.height < i.height && !this.incorrectOrientation) {
                            var r = n.top - i.y,
                                a = i.height / 2 - this.height / 2;
                            a = Math.max(a, 0);
                            var h = a - r;
                            s.top = Math.round(h)
                        }
                        o.style.marginTop = s.top + "px", 0 !== s.top && (s.bottom = -(i.height - n.height - s.top), o.style.marginBottom = s.bottom + "px")
                    }
                    s.x = s.left, s.y = s.top
                },
                reflowGame: function() {
                    this.resetCanvas("", "");
                    var t = this.getParentBounds(this._tempBounds);
                    this.updateDimensions(t.width, t.height, !0)
                },
                reflowCanvas: function() {
                    this.incorrectOrientation || (this.width = i.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = i.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds()
                },
                resetCanvas: function(t, e) {
                    void 0 === t && (t = this.width + "px"), void 0 === e && (e = this.height + "px");
                    var i = this.game.canvas;
                    this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""), i.style.width = t, i.style.height = e
                },
                queueUpdate: function(t) {
                    t && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset
                },
                reset: function(t) {
                    t && this.grid && this.grid.reset()
                },
                setMaximum: function() {
                    this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height
                },
                setShowAll: function(t) {
                    var e, i = this.getParentBounds(this._tempBounds),
                        o = i.width,
                        s = i.height;
                    e = t ? Math.max(s / this.game.height, o / this.game.width) : Math.min(s / this.game.height, o / this.game.width), this.width = Math.round(this.game.width * e), this.height = Math.round(this.game.height * e)
                },
                setExactFit: function() {
                    var t = this.getParentBounds(this._tempBounds);
                    this.width = t.width, this.height = t.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
                },
                createFullScreenTarget: function() {
                    var t = document.createElement("div");
                    return t.style.margin = "0", t.style.padding = "0", t.style.background = "#000", t
                },
                startFullScreen: function(t, e) {
                    if (this.isFullScreen) return !1;
                    if (!this.compatibility.supportsFullScreen) {
                        var o = this;
                        return void setTimeout(function() {
                            o.fullScreenError()
                        }, 10)
                    }
                    if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                        var s = this.game.input;
                        if (s.activePointer && s.activePointer !== s.mousePointer && (e || !1 !== e)) return void s.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [t, !1])
                    }
                    void 0 !== t && this.game.renderType === i.CANVAS && (this.game.stage.smoothed = t);
                    var n = this.fullScreenTarget;
                    n || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), n = this._createdFullScreenTarget);
                    var r = {
                        targetElement: n
                    };
                    if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, r), this._createdFullScreenTarget) {
                        var a = this.game.canvas;
                        a.parentNode.insertBefore(n, a), n.appendChild(a)
                    }
                    return this.game.device.fullscreenKeyboard ? n[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : n[this.game.device.requestFullscreen](), !0
                },
                stopFullScreen: function() {
                    return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), !0)
                },
                cleanupCreatedTarget: function() {
                    var t = this._createdFullScreenTarget;
                    if (t && t.parentNode) {
                        var e = t.parentNode;
                        e.insertBefore(this.game.canvas, t), e.removeChild(t)
                    }
                    this._createdFullScreenTarget = null
                },
                prepScreenMode: function(t) {
                    var e = !!this._createdFullScreenTarget,
                        o = this._createdFullScreenTarget || this.fullScreenTarget;
                    t ? (e || this.fullScreenScaleMode === i.ScaleManager.EXACT_FIT) && o !== this.game.canvas && (this._fullScreenRestore = {
                        targetWidth: o.style.width,
                        targetHeight: o.style.height
                    }, o.style.width = "100%", o.style.height = "100%") : (this._fullScreenRestore && (o.style.width = this._fullScreenRestore.targetWidth, o.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
                },
                fullScreenChange: function(t) {
                    this.event = t, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height)
                },
                fullScreenError: function(t) {
                    this.event = t, this.cleanupCreatedTarget(), console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"), this.onFullScreenError.dispatch(this)
                },
                scaleSprite: function(t, e, i, o) {
                    if (void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === o && (o = !1), !t || !t.scale) return t;
                    if (t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0) return t;
                    var s = e,
                        n = t.height * e / t.width,
                        r = t.width * i / t.height,
                        a = i,
                        h = r > e;
                    return h = h ? o : !o, h ? (t.width = Math.floor(s), t.height = Math.floor(n)) : (t.width = Math.floor(r), t.height = Math.floor(a)), t
                },
                destroy: function() {
                    this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
                }
            }, i.ScaleManager.prototype.constructor = i.ScaleManager, Object.defineProperty(i.ScaleManager.prototype, "boundingParent", {
                get: function() {
                    return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null
                }
            }), Object.defineProperty(i.ScaleManager.prototype, "scaleMode", {
                get: function() {
                    return this._scaleMode
                },
                set: function(t) {
                    return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t), this._scaleMode
                }
            }), Object.defineProperty(i.ScaleManager.prototype, "fullScreenScaleMode", {
                get: function() {
                    return this._fullScreenScaleMode
                },
                set: function(t) {
                    return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t), this._fullScreenScaleMode
                }
            }), Object.defineProperty(i.ScaleManager.prototype, "currentScaleMode", {
                get: function() {
                    return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
                }
            }), Object.defineProperty(i.ScaleManager.prototype, "pageAlignHorizontally", {
                get: function() {
                    return this._pageAlignHorizontally
                },
                set: function(t) {
                    t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0))
                }
            }), Object.defineProperty(i.ScaleManager.prototype, "pageAlignVertically", {
                get: function() {
                    return this._pageAlignVertically
                },
                set: function(t) {
                    t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0))
                }
            }), Object.defineProperty(i.ScaleManager.prototype, "isFullScreen", {
                get: function() {
                    return !1
                }
            }), Object.defineProperty(i.ScaleManager.prototype, "isPortrait", {
                get: function() {
                    return "portrait" === this.classifyOrientation(this.screenOrientation)
                }
            }), Object.defineProperty(i.ScaleManager.prototype, "isLandscape", {
                get: function() {
                    return "landscape" === this.classifyOrientation(this.screenOrientation)
                }
            }), Object.defineProperty(i.ScaleManager.prototype, "isGamePortrait", {
                get: function() {
                    return this.height > this.width
                }
            }), Object.defineProperty(i.ScaleManager.prototype, "isGameLandscape", {
                get: function() {
                    return this.width > this.height
                }
            }), i.Utils.Debug = function(t) {
                this.game = t, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.renderShadow = !0, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1
            }, i.Utils.Debug.prototype = {
                boot: function() {
                    this.game.renderType === i.CANVAS ? this.context = this.game.context : (this.bmd = new i.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d"))
                },
                resize: function(t, e, i) {
                    this.bmd.resize(e, i), this.canvas.width = e, this.canvas.height = i
                },
                preUpdate: function() {
                    this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
                },
                reset: function() {
                    this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear()
                },
                start: function(t, e, i, o) {
                    "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), i = i || "rgb(255,255,255)", void 0 === o && (o = 0), this.currentX = t, this.currentY = e, this.currentColor = i, this.columnWidth = o, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = i, this.context.fillStyle = i, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha
                },
                stop: function() {
                    this.context.restore()
                },
                line: function() {
                    for (var t = this.currentX, e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[e], t, this.currentY), t += this.columnWidth;
                    this.currentY += this.lineHeight
                },
                soundInfo: function(t, e, i, o) {
                    this.start(e, i, o), this.line("Sound: " + t.key + " Locked: " + t.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + " Pending Playback: " + t.pendingPlayback), this.line("Decoded: " + t.isDecoded + " Decoding: " + t.isDecoding), this.line("Total Duration: " + t.totalDuration + " Playing: " + t.isPlaying), this.line("Time: " + t.currentTime), this.line("Volume: " + t.volume + " Muted: " + t.mute), this.line("WebAudio: " + t.usingWebAudio + " Audio: " + t.usingAudioTag), "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + " Duration: " + t.duration + " (ms: " + t.durationMS + ")"), this.line("Start: " + t.markers[t.currentMarker].start + " Stop: " + t.markers[t.currentMarker].stop), this.line("Position: " + t.position)), this.stop()
                },
                cameraInfo: function(t, e, i, o) {
                    this.start(e, i, o), this.line("Camera (" + t.width + " x " + t.height + ")"), this.line("X: " + t.x + " Y: " + t.y), t.bounds && this.line("Bounds x: " + t.bounds.x + " Y: " + t.bounds.y + " w: " + t.bounds.width + " h: " + t.bounds.height), this.line("View x: " + t.view.x + " Y: " + t.view.y + " w: " + t.view.width + " h: " + t.view.height), this.line("Total in view: " + t.totalInView), this.stop()
                },
                timer: function(t, e, i, o) {
                    this.start(e, i, o), this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"), this.line("Next Tick: " + t.next + " Duration: " + t.duration), this.line("Paused: " + t.paused + " Length: " + t.length), this.stop()
                },
                pointer: function(t, e, i, o, s) {
                    null != t && (void 0 === e && (e = !1), i = i || "rgba(0,255,0,0.5)", o = o || "rgba(255,0,0,0.5)", !0 === e && !0 === t.isUp || (this.start(t.x, t.y - 100, s), this.context.beginPath(), this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI), t.active ? this.context.fillStyle = i : this.context.fillStyle = o, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(t.positionDown.x, t.positionDown.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + t.id + " Active: " + t.active), this.line("World X: " + t.worldX + " World Y: " + t.worldY), this.line("Screen X: " + t.x + " Screen Y: " + t.y + " In: " + t.withinGame), this.line("Duration: " + t.duration + " ms"), this.line("is Down: " + t.isDown + " is Up: " + t.isUp), this.stop()))
                },
                spriteInputInfo: function(t, e, i, o) {
                    this.start(e, i, o), this.line("Sprite Input: (" + t.width + " x " + t.height + ")"), this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)), this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)), this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)), this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()), this.stop()
                },
                key: function(t, e, i, o) {
                    this.start(e, i, o, 150), this.line("Key:", t.keyCode, "isDown:", t.isDown), this.line("justDown:", t.justDown, "justUp:", t.justUp), this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)), this.stop()
                },
                inputInfo: function(t, e, i) {
                    this.start(t, e, i), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop()
                },
                spriteBounds: function(t, e, i) {
                    var o = t.getBounds();
                    o.x += this.game.camera.x, o.y += this.game.camera.y, this.rectangle(o, e, i)
                },
                ropeSegments: function(t, e, i) {
                    var o = this;
                    t.segments.forEach(function(t) {
                        o.rectangle(t, e, i)
                    }, this)
                },
                spriteInfo: function(t, e, i, o) {
                    this.start(e, i, o), this.line("Sprite:  (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y), this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)), this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)), this.line("visible: " + t.visible + " in camera: " + t.inCamera), this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)), this.stop()
                },
                spriteCoords: function(t, e, i, o) {
                    this.start(e, i, o, 100), t.name && this.line(t.name), this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)), this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)), this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)), this.stop()
                },
                lineInfo: function(t, e, i, o) {
                    this.start(e, i, o, 80), this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)), this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)), this.line("length:", t.length.toFixed(2), "angle:", t.angle), this.stop()
                },
                pixel: function(t, e, i, o) {
                    o = o || 2, this.start(), this.context.fillStyle = i, this.context.fillRect(t, e, o, o), this.stop()
                },
                geom: function(t, e, o, s) {
                    void 0 === o && (o = !0), void 0 === s && (s = 0), e = e || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = e, this.context.strokeStyle = e, t instanceof i.Rectangle || 1 === s ? o ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : t instanceof i.Circle || 2 === s ? (this.context.beginPath(), this.context.arc(t.x - this.game.camera.x, t.y - this.game.camera.y, t.radius, 0, 2 * Math.PI, !1), this.context.closePath(), o ? this.context.fill() : this.context.stroke()) : t instanceof i.Point || 3 === s ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, 4, 4) : (t instanceof i.Line || 4 === s) && (this.context.lineWidth = 1, this.context.beginPath(), this.context.moveTo(t.start.x + .5 - this.game.camera.x, t.start.y + .5 - this.game.camera.y), this.context.lineTo(t.end.x + .5 - this.game.camera.x, t.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()), this.stop()
                },
                rectangle: function(t, e, i) {
                    void 0 === i && (i = !0), e = e || "rgba(0, 255, 0, 0.4)", this.start(), i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)), this.stop()
                },
                text: function(t, e, i, o, s) {
                    o = o || "rgb(255,255,255)", s = s || "16px Courier", this.start(), this.context.font = s, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)), this.context.fillStyle = o, this.context.fillText(t, e, i), this.stop()
                },
                quadTree: function(t, e) {
                    e = e || "rgba(255,0,0,0.3)", this.start();
                    var i = t.bounds;
                    if (0 === t.nodes.length) {
                        this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)";
                        for (var o = 0; o < t.objects.length; o++) this.context.strokeRect(t.objects[o].x, t.objects[o].y, t.objects[o].width, t.objects[o].height)
                    } else
                        for (var o = 0; o < t.nodes.length; o++) this.quadTree(t.nodes[o]);
                    this.stop()
                },
                body: function(t, e, o) {
                    t.body && (this.start(), t.body.type === i.Physics.ARCADE ? i.Physics.Arcade.Body.render(this.context, t.body, e, o) : t.body.type === i.Physics.NINJA ? i.Physics.Ninja.Body.render(this.context, t.body, e, o) : t.body.type === i.Physics.BOX2D && i.Physics.Box2D.renderBody(this.context, t.body, e), this.stop())
                },
                bodyInfo: function(t, e, o, s) {
                    t.body && (this.start(e, o, s, 210), t.body.type === i.Physics.ARCADE ? i.Physics.Arcade.Body.renderBodyInfo(this, t.body) : t.body.type === i.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, t.body), this.stop())
                },
                box2dWorld: function() {
                    this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0);
                    var t = this.game.state.getCurrentState().root;
                    if (t) {
                        var e = 52 * t.scale.x / 50;
                        this.context.scale(e, e)
                    }
                    this.game.physics.box2d.renderDebugDraw(this.context), this.stop()
                },
                box2dBody: function(t, e) {
                    this.start(), i.Physics.Box2D.renderBody(this.context, t, e), this.stop()
                },
                displayList: function(t) {
                    if (void 0 === t && (t = this.game.world), t.hasOwnProperty("renderOrderID") ? console.log("[" + t.renderOrderID + "]", t) : console.log("[]", t), t.children && t.children.length > 0)
                        for (var e = 0; e < t.children.length; e++) this.game.debug.displayList(t.children[e])
                },
                destroy: function() {
                    PIXI.CanvasPool.remove(this)
                }
            }, i.Utils.Debug.prototype.constructor = i.Utils.Debug, i.DOM = {
                getOffset: function(t, e) {
                    e = e || new i.Point;
                    var o = t.getBoundingClientRect(),
                        s = i.DOM.scrollY,
                        n = i.DOM.scrollX,
                        r = document.documentElement.clientTop,
                        a = document.documentElement.clientLeft;
                    return e.x = o.left + n - a, e.y = o.top + s - r, e
                },
                getBounds: function(t, e) {
                    return void 0 === e && (e = 0), !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
                },
                calibrate: function(t, e) {
                    e = +e || 0;
                    var i = {
                        width: 0,
                        height: 0,
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    };
                    return i.width = (i.right = t.right + e) - (i.left = t.left - e), i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e), i
                },
                getAspectRatio: function(t) {
                    t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t;
                    var e = t.width,
                        i = t.height;
                    return "function" == typeof e && (e = e.call(t)), "function" == typeof i && (i = i.call(t)), e / i
                },
                inLayoutViewport: function(t, e) {
                    var i = this.getBounds(t, e);
                    return !!i && i.bottom >= 0 && i.right >= 0 && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height
                },
                getScreenOrientation: function(t) {
                    var e = window.screen,
                        i = e.orientation || e.mozOrientation || e.msOrientation;
                    if (i && "string" == typeof i.type) return i.type;
                    if ("string" == typeof i) return i;
                    var o = "portrait-primary",
                        s = "landscape-primary";
                    if ("screen" === t) return e.height > e.width ? o : s;
                    if ("viewport" === t) return this.visualBounds.height > this.visualBounds.width ? o : s;
                    if ("window.orientation" === t && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? o : s;
                    if (window.matchMedia) {
                        if (window.matchMedia("(orientation: portrait)").matches) return o;
                        if (window.matchMedia("(orientation: landscape)").matches) return s
                    }
                    return this.visualBounds.height > this.visualBounds.width ? o : s
                },
                visualBounds: new i.Rectangle,
                layoutBounds: new i.Rectangle,
                documentBounds: new i.Rectangle
            }, i.Device.whenReady(function(t) {
                var e = window && "pageXOffset" in window ? function() {
                        return window.pageXOffset
                    } : function() {
                        return document.documentElement.scrollLeft
                    },
                    o = window && "pageYOffset" in window ? function() {
                        return window.pageYOffset
                    } : function() {
                        return document.documentElement.scrollTop
                    };
                if (Object.defineProperty(i.DOM, "scrollX", {
                        get: e
                    }), Object.defineProperty(i.DOM, "scrollY", {
                        get: o
                    }), Object.defineProperty(i.DOM.visualBounds, "x", {
                        get: e
                    }), Object.defineProperty(i.DOM.visualBounds, "y", {
                        get: o
                    }), Object.defineProperty(i.DOM.layoutBounds, "x", {
                        value: 0
                    }), Object.defineProperty(i.DOM.layoutBounds, "y", {
                        value: 0
                    }), t.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
                    var s = function() {
                            return Math.max(window.innerWidth, document.documentElement.clientWidth)
                        },
                        n = function() {
                            return Math.max(window.innerHeight, document.documentElement.clientHeight)
                        };
                    Object.defineProperty(i.DOM.visualBounds, "width", {
                        get: s
                    }), Object.defineProperty(i.DOM.visualBounds, "height", {
                        get: n
                    }), Object.defineProperty(i.DOM.layoutBounds, "width", {
                        get: s
                    }), Object.defineProperty(i.DOM.layoutBounds, "height", {
                        get: n
                    })
                } else Object.defineProperty(i.DOM.visualBounds, "width", {
                    get: function() {
                        return window.innerWidth
                    }
                }), Object.defineProperty(i.DOM.visualBounds, "height", {
                    get: function() {
                        return window.innerHeight
                    }
                }), Object.defineProperty(i.DOM.layoutBounds, "width", {
                    get: function() {
                        var t = document.documentElement.clientWidth,
                            e = window.innerWidth;
                        return t < e ? e : t
                    }
                }), Object.defineProperty(i.DOM.layoutBounds, "height", {
                    get: function() {
                        var t = document.documentElement.clientHeight,
                            e = window.innerHeight;
                        return t < e ? e : t
                    }
                });
                Object.defineProperty(i.DOM.documentBounds, "x", {
                    value: 0
                }), Object.defineProperty(i.DOM.documentBounds, "y", {
                    value: 0
                }), Object.defineProperty(i.DOM.documentBounds, "width", {
                    get: function() {
                        var t = document.documentElement;
                        return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
                    }
                }), Object.defineProperty(i.DOM.documentBounds, "height", {
                    get: function() {
                        var t = document.documentElement;
                        return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
                    }
                })
            }, null, !0), i.ArraySet = function(t) {
                this.position = 0, this.list = t || []
            }, i.ArraySet.prototype = {
                add: function(t) {
                    return this.exists(t) || this.list.push(t), t
                },
                getIndex: function(t) {
                    return this.list.indexOf(t)
                },
                getByKey: function(t, e) {
                    for (var i = this.list.length; i--;)
                        if (this.list[i][t] === e) return this.list[i];
                    return null
                },
                exists: function(t) {
                    return this.list.indexOf(t) > -1
                },
                reset: function() {
                    this.list.length = 0
                },
                remove: function(t) {
                    var e = this.list.indexOf(t);
                    if (e > -1) return this.list.splice(e, 1), t
                },
                setAll: function(t, e) {
                    for (var i = this.list.length; i--;) this.list[i] && (this.list[i][t] = e)
                },
                callAll: function(t) {
                    for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
                },
                removeAll: function(t) {
                    void 0 === t && (t = !1);
                    for (var e = this.list.length; e--;)
                        if (this.list[e]) {
                            var i = this.remove(this.list[e]);
                            t && i.destroy()
                        }
                    this.position = 0, this.list = []
                }
            }, Object.defineProperty(i.ArraySet.prototype, "total", {
                get: function() {
                    return this.list.length
                }
            }), Object.defineProperty(i.ArraySet.prototype, "first", {
                get: function() {
                    return this.position = 0, this.list.length > 0 ? this.list[0] : null
                }
            }), Object.defineProperty(i.ArraySet.prototype, "next", {
                get: function() {
                    return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
                }
            }), i.ArraySet.prototype.constructor = i.ArraySet, i.ArrayUtils = {
                getRandomItem: function(t, e, i) {
                    if (null === t) return null;
                    void 0 === e && (e = 0), void 0 === i && (i = t.length);
                    var o = e + Math.floor(Math.random() * i);
                    return void 0 === t[o] ? null : t[o]
                },
                removeRandomItem: function(t, e, i) {
                    if (null == t) return null;
                    void 0 === e && (e = 0), void 0 === i && (i = t.length);
                    var o = e + Math.floor(Math.random() * i);
                    if (o < t.length) {
                        var s = t.splice(o, 1);
                        return void 0 === s[0] ? null : s[0]
                    }
                    return null
                },
                shuffle: function(t) {
                    for (var e = t.length - 1; e > 0; e--) {
                        var i = Math.floor(Math.random() * (e + 1)),
                            o = t[e];
                        t[e] = t[i], t[i] = o
                    }
                    return t
                },
                transposeMatrix: function(t) {
                    for (var e = t.length, i = t[0].length, o = new Array(i), s = 0; s < i; s++) {
                        o[s] = new Array(e);
                        for (var n = e - 1; n > -1; n--) o[s][n] = t[n][s]
                    }
                    return o
                },
                rotateMatrix: function(t, e) {
                    if ("string" != typeof e && (e = (e % 360 + 360) % 360), 90 === e || -270 === e || "rotateLeft" === e) t = i.ArrayUtils.transposeMatrix(t), t = t.reverse();
                    else if (-90 === e || 270 === e || "rotateRight" === e) t = t.reverse(), t = i.ArrayUtils.transposeMatrix(t);
                    else if (180 === Math.abs(e) || "rotate180" === e) {
                        for (var o = 0; o < t.length; o++) t[o].reverse();
                        t = t.reverse()
                    }
                    return t
                },
                findClosest: function(t, e) {
                    if (!e.length) return NaN;
                    if (1 === e.length || t < e[0]) return e[0];
                    for (var i = 1; e[i] < t;) i++;
                    var o = e[i - 1],
                        s = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
                    return s - t <= t - o ? s : o
                },
                rotateRight: function(t) {
                    var e = t.pop();
                    return t.unshift(e), e
                },
                rotateLeft: function(t) {
                    var e = t.shift();
                    return t.push(e), e
                },
                rotate: function(t) {
                    var e = t.shift();
                    return t.push(e), e
                },
                numberArray: function(t, e) {
                    for (var i = [], o = t; o <= e; o++) i.push(o);
                    return i
                },
                numberArrayStep: function(t, e, o) {
                    void 0 !== t && null !== t || (t = 0), void 0 !== e && null !== e || (e = t, t = 0), void 0 === o && (o = 1);
                    for (var s = [], n = Math.max(i.Math.roundAwayFromZero((e - t) / (o || 1)), 0), r = 0; r < n; r++) s.push(t), t += o;
                    return s
                }
            }, i.LinkedList = function() {
                this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
            }, i.LinkedList.prototype = {
                add: function(t) {
                    return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, this.next = t, t.prev = this, this.total++, t) : (this.last.next = t, t.prev = this.last, this.last = t, this.total++, t)
                },
                reset: function() {
                    this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
                },
                remove: function(t) {
                    if (1 === this.total) return this.reset(), void(t.next = t.prev = null);
                    t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.next = t.prev = null, null === this.first && (this.last = null), this.total--
                },
                callAll: function(t) {
                    if (this.first && this.last) {
                        var e = this.first;
                        do {
                            e && e[t] && e[t].call(e), e = e.next
                        } while (e !== this.last.next)
                    }
                }
            }, i.LinkedList.prototype.constructor = i.LinkedList, i.Create = function(t) {
                this.game = t, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{
                    0: "#000",
                    1: "#9D9D9D",
                    2: "#FFF",
                    3: "#BE2633",
                    4: "#E06F8B",
                    5: "#493C2B",
                    6: "#A46422",
                    7: "#EB8931",
                    8: "#F7E26B",
                    9: "#2F484E",
                    A: "#44891A",
                    B: "#A3CE27",
                    C: "#1B2632",
                    D: "#005784",
                    E: "#31A2F2",
                    F: "#B2DCEF"
                }, {
                    0: "#000",
                    1: "#191028",
                    2: "#46af45",
                    3: "#a1d685",
                    4: "#453e78",
                    5: "#7664fe",
                    6: "#833129",
                    7: "#9ec2e8",
                    8: "#dc534b",
                    9: "#e18d79",
                    A: "#d6b97b",
                    B: "#e9d8a1",
                    C: "#216c4b",
                    D: "#d365c8",
                    E: "#afaab9",
                    F: "#f5f4eb"
                }, {
                    0: "#000",
                    1: "#2234d1",
                    2: "#0c7e45",
                    3: "#44aacc",
                    4: "#8a3622",
                    5: "#5c2e78",
                    6: "#aa5c3d",
                    7: "#b5b5b5",
                    8: "#5e606e",
                    9: "#4c81fb",
                    A: "#6cd947",
                    B: "#7be2f9",
                    C: "#eb8a60",
                    D: "#e23d69",
                    E: "#ffd93f",
                    F: "#fff"
                }, {
                    0: "#000",
                    1: "#fff",
                    2: "#8b4131",
                    3: "#7bbdc5",
                    4: "#8b41ac",
                    5: "#6aac41",
                    6: "#3931a4",
                    7: "#d5de73",
                    8: "#945a20",
                    9: "#5a4100",
                    A: "#bd736a",
                    B: "#525252",
                    C: "#838383",
                    D: "#acee8b",
                    E: "#7b73de",
                    F: "#acacac"
                }, {
                    0: "#000",
                    1: "#191028",
                    2: "#46af45",
                    3: "#a1d685",
                    4: "#453e78",
                    5: "#7664fe",
                    6: "#833129",
                    7: "#9ec2e8",
                    8: "#dc534b",
                    9: "#e18d79",
                    A: "#d6b97b",
                    B: "#e9d8a1",
                    C: "#216c4b",
                    D: "#d365c8",
                    E: "#afaab9",
                    F: "#fff"
                }]
            }, i.Create.PALETTE_ARNE = 0, i.Create.PALETTE_JMP = 1, i.Create.PALETTE_CGA = 2, i.Create.PALETTE_C64 = 3, i.Create.PALETTE_JAPANESE_MACHINE = 4, i.Create.prototype = {
                texture: function(t, e, i, o, s) {
                    void 0 === i && (i = 8), void 0 === o && (o = i), void 0 === s && (s = 0);
                    var n = e[0].length * i,
                        r = e.length * o;
                    null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(n, r), this.bmd.clear();
                    for (var a = 0; a < e.length; a++)
                        for (var h = e[a], l = 0; l < h.length; l++) {
                            var d = h[l];
                            "." !== d && " " !== d && (this.ctx.fillStyle = this.palettes[s][d], this.ctx.fillRect(l * i, a * o, i, o))
                        }
                    return this.bmd.generateTexture(t)
                },
                grid: function(t, e, i, o, s, n) {
                    null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(e, i), this.ctx.fillStyle = n;
                    for (var r = 0; r < i; r += s) this.ctx.fillRect(0, r, e, 1);
                    for (var a = 0; a < e; a += o) this.ctx.fillRect(a, 0, 1, i);
                    return this.bmd.generateTexture(t)
                }
            }, i.Create.prototype.constructor = i.Create, i.FlexGrid = function(t, e, o) {
                this.game = t.game, this.manager = t, this.width = e, this.height = o, this.boundsCustom = new i.Rectangle(0, 0, e, o), this.boundsFluid = new i.Rectangle(0, 0, e, o), this.boundsFull = new i.Rectangle(0, 0, e, o), this.boundsNone = new i.Rectangle(0, 0, e, o), this.positionCustom = new i.Point(0, 0), this.positionFluid = new i.Point(0, 0), this.positionFull = new i.Point(0, 0), this.positionNone = new i.Point(0, 0), this.scaleCustom = new i.Point(1, 1), this.scaleFluid = new i.Point(1, 1), this.scaleFluidInversed = new i.Point(1, 1), this.scaleFull = new i.Point(1, 1), this.scaleNone = new i.Point(1, 1), this.customWidth = 0, this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = e / o, this.ratioV = o / e, this.multiplier = 0, this.layers = []
            }, i.FlexGrid.prototype = {
                setSize: function(t, e) {
                    this.width = t, this.height = e, this.ratioH = t / e, this.ratioV = e / t, this.scaleNone = new i.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh()
                },
                createCustomLayer: function(t, e, o, s) {
                    void 0 === s && (s = !0), this.customWidth = t, this.customHeight = e, this.boundsCustom.width = t, this.boundsCustom.height = e;
                    var n = new i.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
                    return s && this.game.world.add(n), this.layers.push(n), void 0 !== o && null !== typeof o && n.addMultiple(o), n
                },
                createFluidLayer: function(t, e) {
                    void 0 === e && (e = !0);
                    var o = new i.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
                    return e && this.game.world.add(o), this.layers.push(o), void 0 !== t && null !== typeof t && o.addMultiple(t), o
                },
                createFullLayer: function(t) {
                    var e = new i.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
                    return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
                },
                createFixedLayer: function(t) {
                    var e = new i.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
                    return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
                },
                reset: function() {
                    for (var t = this.layers.length; t--;) this.layers[t].persist || (this.layers[t].position = null, this.layers[t].scale = null, this.layers.slice(t, 1))
                },
                onResize: function(t, e) {
                    this.ratioH = t / e, this.ratioV = e / t, this.refresh(t, e)
                },
                refresh: function() {
                    this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
                },
                fitSprite: function(t) {
                    this.manager.scaleSprite(t), t.x = this.manager.bounds.centerX, t.y = this.manager.bounds.centerY
                },
                debug: function() {
                    this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1)
                }
            }, i.FlexGrid.prototype.constructor = i.FlexGrid, i.FlexLayer = function(t, e, o, s) {
                i.Group.call(this, t.game, null, "__flexLayer" + t.game.rnd.uuid(), !1), this.manager = t.manager, this.grid = t, this.persist = !1, this.position = e, this.bounds = o, this.scale = s, this.topLeft = o.topLeft, this.topMiddle = new i.Point(o.halfWidth, 0), this.topRight = o.topRight, this.bottomLeft = o.bottomLeft, this.bottomMiddle = new i.Point(o.halfWidth, o.bottom), this.bottomRight = o.bottomRight
            }, i.FlexLayer.prototype = Object.create(i.Group.prototype), i.FlexLayer.prototype.constructor = i.FlexLayer, i.FlexLayer.prototype.resize = function() {}, i.FlexLayer.prototype.debug = function() {
                this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9")
            }, i.Color = {
                packPixel: function(t, e, o, s) {
                    return i.Device.LITTLE_ENDIAN ? (s << 24 | o << 16 | e << 8 | t) >>> 0 : (t << 24 | e << 16 | o << 8 | s) >>> 0
                },
                unpackPixel: function(t, e, o, s) {
                    return void 0 !== e && null !== e || (e = i.Color.createColor()), void 0 !== o && null !== o || (o = !1), void 0 !== s && null !== s || (s = !1), i.Device.LITTLE_ENDIAN ? (e.a = (4278190080 & t) >>> 24, e.b = (16711680 & t) >>> 16, e.g = (65280 & t) >>> 8, e.r = 255 & t) : (e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t), e.color = t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a / 255 + ")", o && i.Color.RGBtoHSL(e.r, e.g, e.b, e), s && i.Color.RGBtoHSV(e.r, e.g, e.b, e), e
                },
                fromRGBA: function(t, e) {
                    return e || (e = i.Color.createColor()), e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")", e
                },
                toRGBA: function(t, e, i, o) {
                    return t << 24 | e << 16 | i << 8 | o
                },
                toABGR: function(t, e, i, o) {
                    return (o << 24 | i << 16 | e << 8 | t) >>> 0
                },
                RGBtoHSL: function(t, e, o, s) {
                    s || (s = i.Color.createColor(t, e, o, 1)), t /= 255, e /= 255, o /= 255;
                    var n = Math.min(t, e, o),
                        r = Math.max(t, e, o);
                    if (s.h = 0, s.s = 0, s.l = (r + n) / 2, r !== n) {
                        var a = r - n;
                        s.s = s.l > .5 ? a / (2 - r - n) : a / (r + n), r === t ? s.h = (e - o) / a + (e < o ? 6 : 0) : r === e ? s.h = (o - t) / a + 2 : r === o && (s.h = (t - e) / a + 4), s.h /= 6
                    }
                    return s
                },
                HSLtoRGB: function(t, e, o, s) {
                    if (s ? (s.r = o, s.g = o, s.b = o) : s = i.Color.createColor(o, o, o), 0 !== e) {
                        var n = o < .5 ? o * (1 + e) : o + e - o * e,
                            r = 2 * o - n;
                        s.r = i.Color.hueToColor(r, n, t + 1 / 3), s.g = i.Color.hueToColor(r, n, t), s.b = i.Color.hueToColor(r, n, t - 1 / 3)
                    }
                    return s.r = Math.floor(255 * s.r | 0), s.g = Math.floor(255 * s.g | 0), s.b = Math.floor(255 * s.b | 0), i.Color.updateColor(s), s
                },
                RGBtoHSV: function(t, e, o, s) {
                    s || (s = i.Color.createColor(t, e, o, 255)), t /= 255, e /= 255, o /= 255;
                    var n = Math.min(t, e, o),
                        r = Math.max(t, e, o),
                        a = r - n;
                    return s.h = 0, s.s = 0 === r ? 0 : a / r, s.v = r, r !== n && (r === t ? s.h = (e - o) / a + (e < o ? 6 : 0) : r === e ? s.h = (o - t) / a + 2 : r === o && (s.h = (t - e) / a + 4), s.h /= 6), s
                },
                HSVtoRGB: function(t, e, o, s) {
                    void 0 === s && (s = i.Color.createColor(0, 0, 0, 1, t, e, 0, o));
                    var n, r, a, h = Math.floor(6 * t),
                        l = 6 * t - h,
                        d = o * (1 - e),
                        c = o * (1 - l * e),
                        p = o * (1 - (1 - l) * e);
                    switch (h % 6) {
                        case 0:
                            n = o, r = p, a = d;
                            break;
                        case 1:
                            n = c, r = o, a = d;
                            break;
                        case 2:
                            n = d, r = o, a = p;
                            break;
                        case 3:
                            n = d, r = c, a = o;
                            break;
                        case 4:
                            n = p, r = d, a = o;
                            break;
                        case 5:
                            n = o, r = d, a = c
                    }
                    return s.r = Math.floor(255 * n), s.g = Math.floor(255 * r), s.b = Math.floor(255 * a), i.Color.updateColor(s), s
                },
                hueToColor: function(t, e, i) {
                    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
                },
                createColor: function(t, e, o, s, n, r, a, h) {
                    var l = {
                        r: t || 0,
                        g: e || 0,
                        b: o || 0,
                        a: s || 1,
                        h: n || 0,
                        s: r || 0,
                        l: a || 0,
                        v: h || 0,
                        color: 0,
                        color32: 0,
                        rgba: ""
                    };
                    return i.Color.updateColor(l)
                },
                updateColor: function(t) {
                    return t.rgba = "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + t.a.toString() + ")", t.color = i.Color.getColor(t.r, t.g, t.b), t.color32 = i.Color.getColor32(255 * t.a, t.r, t.g, t.b), t
                },
                getColor32: function(t, e, i, o) {
                    return t << 24 | e << 16 | i << 8 | o
                },
                getColor: function(t, e, i) {
                    return t << 16 | e << 8 | i
                },
                RGBtoString: function(t, e, o, s, n) {
                    return void 0 === s && (s = 255), void 0 === n && (n = "#"), "#" === n ? "#" + ((1 << 24) + (t << 16) + (e << 8) + o).toString(16).slice(1) : "0x" + i.Color.componentToHex(s) + i.Color.componentToHex(t) + i.Color.componentToHex(e) + i.Color.componentToHex(o)
                },
                hexToRGB: function(t) {
                    var e = i.Color.hexToColor(t);
                    if (e) return i.Color.getColor32(e.a, e.r, e.g, e.b)
                },
                hexToColor: function(t, e) {
                    t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, o) {
                        return e + e + i + i + o + o
                    });
                    var o = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                    if (o) {
                        var s = parseInt(o[1], 16),
                            n = parseInt(o[2], 16),
                            r = parseInt(o[3], 16);
                        e ? (e.r = s, e.g = n, e.b = r) : e = i.Color.createColor(s, n, r)
                    }
                    return e
                },
                webToColor: function(t, e) {
                    e || (e = i.Color.createColor());
                    var o = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t);
                    return o && (e.r = parseInt(o[1], 10), e.g = parseInt(o[2], 10), e.b = parseInt(o[3], 10), e.a = void 0 !== o[4] ? parseFloat(o[4]) : 1, i.Color.updateColor(e)), e
                },
                valueToColor: function(t, e) {
                    if (e || (e = i.Color.createColor()), "string" == typeof t) return 0 === t.indexOf("rgb") ? i.Color.webToColor(t, e) : (e.a = 1, i.Color.hexToColor(t, e));
                    if ("number" == typeof t) {
                        var o = i.Color.getRGB(t);
                        return e.r = o.r, e.g = o.g, e.b = o.b, e.a = o.a / 255, e
                    }
                    return e
                },
                componentToHex: function(t) {
                    var e = t.toString(16);
                    return 1 === e.length ? "0" + e : e
                },
                HSVColorWheel: function(t, e) {
                    void 0 === t && (t = 1), void 0 === e && (e = 1);
                    for (var o = [], s = 0; s <= 359; s++) o.push(i.Color.HSVtoRGB(s / 359, t, e));
                    return o
                },
                HSLColorWheel: function(t, e) {
                    void 0 === t && (t = .5), void 0 === e && (e = .5);
                    for (var o = [], s = 0; s <= 359; s++) o.push(i.Color.HSLtoRGB(s / 359, t, e));
                    return o
                },
                interpolateColor: function(t, e, o, s, n) {
                    void 0 === n && (n = 255);
                    var r = i.Color.getRGB(t),
                        a = i.Color.getRGB(e),
                        h = (a.red - r.red) * s / o + r.red,
                        l = (a.green - r.green) * s / o + r.green,
                        d = (a.blue - r.blue) * s / o + r.blue;
                    return i.Color.getColor32(n, h, l, d)
                },
                interpolateColorWithRGB: function(t, e, o, s, n, r) {
                    var a = i.Color.getRGB(t),
                        h = (e - a.red) * r / n + a.red,
                        l = (o - a.green) * r / n + a.green,
                        d = (s - a.blue) * r / n + a.blue;
                    return i.Color.getColor(h, l, d)
                },
                interpolateRGB: function(t, e, o, s, n, r, a, h) {
                    var l = (s - t) * h / a + t,
                        d = (n - e) * h / a + e,
                        c = (r - o) * h / a + o;
                    return i.Color.getColor(l, d, c)
                },
                getRandomColor: function(t, e, o) {
                    if (void 0 === t && (t = 0), void 0 === e && (e = 255), void 0 === o && (o = 255), e > 255 || t > e) return i.Color.getColor(255, 255, 255);
                    var s = t + Math.round(Math.random() * (e - t)),
                        n = t + Math.round(Math.random() * (e - t)),
                        r = t + Math.round(Math.random() * (e - t));
                    return i.Color.getColor32(o, s, n, r)
                },
                getRGB: function(t) {
                    return t > 16777215 ? {
                        alpha: t >>> 24,
                        red: t >> 16 & 255,
                        green: t >> 8 & 255,
                        blue: 255 & t,
                        a: t >>> 24,
                        r: t >> 16 & 255,
                        g: t >> 8 & 255,
                        b: 255 & t
                    } : {
                        alpha: 255,
                        red: t >> 16 & 255,
                        green: t >> 8 & 255,
                        blue: 255 & t,
                        a: 255,
                        r: t >> 16 & 255,
                        g: t >> 8 & 255,
                        b: 255 & t
                    }
                },
                getWebRGB: function(t) {
                    if ("object" == typeof t) return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255).toString() + ")";
                    var e = i.Color.getRGB(t);
                    return "rgba(" + e.r.toString() + "," + e.g.toString() + "," + e.b.toString() + "," + (e.a / 255).toString() + ")"
                },
                getAlpha: function(t) {
                    return t >>> 24
                },
                getAlphaFloat: function(t) {
                    return (t >>> 24) / 255
                },
                getRed: function(t) {
                    return t >> 16 & 255
                },
                getGreen: function(t) {
                    return t >> 8 & 255
                },
                getBlue: function(t) {
                    return 255 & t
                },
                blendNormal: function(t) {
                    return t
                },
                blendLighten: function(t, e) {
                    return e > t ? e : t
                },
                blendDarken: function(t, e) {
                    return e > t ? t : e
                },
                blendMultiply: function(t, e) {
                    return t * e / 255
                },
                blendAverage: function(t, e) {
                    return (t + e) / 2
                },
                blendAdd: function(t, e) {
                    return Math.min(255, t + e)
                },
                blendSubtract: function(t, e) {
                    return Math.max(0, t + e - 255)
                },
                blendDifference: function(t, e) {
                    return Math.abs(t - e)
                },
                blendNegation: function(t, e) {
                    return 255 - Math.abs(255 - t - e)
                },
                blendScreen: function(t, e) {
                    return 255 - ((255 - t) * (255 - e) >> 8)
                },
                blendExclusion: function(t, e) {
                    return t + e - 2 * t * e / 255
                },
                blendOverlay: function(t, e) {
                    return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255
                },
                blendSoftLight: function(t, e) {
                    return e < 128 ? 2 * (64 + (t >> 1)) * (e / 255) : 255 - 2 * (255 - (64 + (t >> 1))) * (255 - e) / 255
                },
                blendHardLight: function(t, e) {
                    return i.Color.blendOverlay(e, t)
                },
                blendColorDodge: function(t, e) {
                    return 255 === e ? e : Math.min(255, (t << 8) / (255 - e))
                },
                blendColorBurn: function(t, e) {
                    return 0 === e ? e : Math.max(0, 255 - (255 - t << 8) / e)
                },
                blendLinearDodge: function(t, e) {
                    return i.Color.blendAdd(t, e)
                },
                blendLinearBurn: function(t, e) {
                    return i.Color.blendSubtract(t, e)
                },
                blendLinearLight: function(t, e) {
                    return e < 128 ? i.Color.blendLinearBurn(t, 2 * e) : i.Color.blendLinearDodge(t, 2 * (e - 128))
                },
                blendVividLight: function(t, e) {
                    return e < 128 ? i.Color.blendColorBurn(t, 2 * e) : i.Color.blendColorDodge(t, 2 * (e - 128))
                },
                blendPinLight: function(t, e) {
                    return e < 128 ? i.Color.blendDarken(t, 2 * e) : i.Color.blendLighten(t, 2 * (e - 128))
                },
                blendHardMix: function(t, e) {
                    return i.Color.blendVividLight(t, e) < 128 ? 0 : 255
                },
                blendReflect: function(t, e) {
                    return 255 === e ? e : Math.min(255, t * t / (255 - e))
                },
                blendGlow: function(t, e) {
                    return i.Color.blendReflect(e, t)
                },
                blendPhoenix: function(t, e) {
                    return Math.min(t, e) - Math.max(t, e) + 255
                }
            }, i.Physics = function(t, e) {
                e = e || {}, this.game = t, this.config = e, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig()
            }, i.Physics.ARCADE = 0, i.Physics.P2JS = 1, i.Physics.NINJA = 2, i.Physics.BOX2D = 3, i.Physics.CHIPMUNK = 4, i.Physics.MATTERJS = 5, i.Physics.prototype = {
                parseConfig: function() {
                    this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !i.Physics.hasOwnProperty("Arcade") || (this.arcade = new i.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && i.Physics.hasOwnProperty("Ninja") && (this.ninja = new i.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && !0 === this.config.p2 && i.Physics.hasOwnProperty("P2") && (this.p2 = new i.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && i.Physics.hasOwnProperty("BOX2D") && (this.box2d = new i.Physics.BOX2D(this.game, this.config)), this.config.hasOwnProperty("matter") && !0 === this.config.matter && i.Physics.hasOwnProperty("Matter") && (this.matter = new i.Physics.Matter(this.game, this.config))
                },
                startSystem: function(t) {
                    t === i.Physics.ARCADE ? this.arcade = new i.Physics.Arcade(this.game) : t === i.Physics.P2JS ? null === this.p2 ? this.p2 = new i.Physics.P2(this.game, this.config) : this.p2.reset() : t === i.Physics.NINJA ? this.ninja = new i.Physics.Ninja(this.game) : t === i.Physics.BOX2D ? null === this.box2d ? this.box2d = new i.Physics.Box2D(this.game, this.config) : this.box2d.reset() : t === i.Physics.MATTERJS && (null === this.matter ? this.matter = new i.Physics.Matter(this.game, this.config) : this.matter.reset())
                },
                enable: function(t, e, o) {
                    void 0 === e && (e = i.Physics.ARCADE), void 0 === o && (o = !1), e === i.Physics.ARCADE ? this.arcade.enable(t) : e === i.Physics.P2JS && this.p2 ? this.p2.enable(t, o) : e === i.Physics.NINJA && this.ninja ? this.ninja.enableAABB(t) : e === i.Physics.BOX2D && this.box2d ? this.box2d.enable(t) : e === i.Physics.MATTERJS && this.matter ? this.matter.enable(t) : console.warn(t.key + " is attempting to enable a physics body using an unknown physics system.")
                },
                preUpdate: function() {
                    this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate()
                },
                update: function() {
                    this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update()
                },
                setBoundsToWorld: function() {
                    this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld()
                },
                clear: function() {
                    this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear()
                },
                reset: function() {
                    this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset()
                },
                destroy: function() {
                    this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null
                }
            }, i.Physics.prototype.constructor = i.Physics, i.Physics.Arcade = function(t) {
                this.game = t, this.gravity = new i.Point, this.bounds = new i.Rectangle(0, 0, t.world.width, t.world.height), this.checkCollision = {
                    up: !0,
                    down: !0,
                    left: !0,
                    right: !0
                }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, this.sortDirection = i.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, this.quadTree = new i.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._total = 0, this.setBoundsToWorld()
            }, i.Physics.Arcade.prototype.constructor = i.Physics.Arcade, i.Physics.Arcade.SORT_NONE = 0, i.Physics.Arcade.LEFT_RIGHT = 1, i.Physics.Arcade.RIGHT_LEFT = 2, i.Physics.Arcade.TOP_BOTTOM = 3, i.Physics.Arcade.BOTTOM_TOP = 4, i.Physics.Arcade.prototype = {
                setBounds: function(t, e, i, o) {
                    this.bounds.setTo(t, e, i, o)
                },
                setBoundsToWorld: function() {
                    this.bounds.copyFrom(this.game.world.bounds)
                },
                enable: function(t, e) {
                    void 0 === e && (e = !0);
                    var o = 1;
                    if (Array.isArray(t))
                        for (o = t.length; o--;) t[o] instanceof i.Group ? this.enable(t[o].children, e) : (this.enableBody(t[o]), e && t[o].hasOwnProperty("children") && t[o].children.length > 0 && this.enable(t[o], !0));
                    else t instanceof i.Group ? this.enable(t.children, e) : (this.enableBody(t), e && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, !0))
                },
                enableBody: function(t) {
                    t.hasOwnProperty("body") && null === t.body && (t.body = new i.Physics.Arcade.Body(t), t.parent && t.parent instanceof i.Group && t.parent.addToHash(t))
                },
                updateMotion: function(t) {
                    var e = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity;
                    t.angularVelocity += e, t.rotation += t.angularVelocity * this.game.time.physicsElapsed, t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x), t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y)
                },
                computeVelocity: function(t, e, i, o, s, n) {
                    return void 0 === n && (n = 1e4), 1 === t && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.game.time.physicsElapsed : 2 === t && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.game.time.physicsElapsed), o ? i += o * this.game.time.physicsElapsed : s && (s *= this.game.time.physicsElapsed, i - s > 0 ? i -= s : i + s < 0 ? i += s : i = 0), i > n ? i = n : i < -n && (i = -n), i
                },
                overlap: function(t, e, i, o, s) {
                    if (i = i || null, o = o || null, s = s || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                        for (var n = 0; n < e.length; n++) this.collideHandler(t, e[n], i, o, s, !0);
                    else if (Array.isArray(t) && !Array.isArray(e))
                        for (var n = 0; n < t.length; n++) this.collideHandler(t[n], e, i, o, s, !0);
                    else if (Array.isArray(t) && Array.isArray(e))
                        for (var n = 0; n < t.length; n++)
                            for (var r = 0; r < e.length; r++) this.collideHandler(t[n], e[r], i, o, s, !0);
                    else this.collideHandler(t, e, i, o, s, !0);
                    return this._total > 0
                },
                collide: function(t, e, i, o, s) {
                    if (i = i || null, o = o || null, s = s || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                        for (var n = 0; n < e.length; n++) this.collideHandler(t, e[n], i, o, s, !1);
                    else if (Array.isArray(t) && !Array.isArray(e))
                        for (var n = 0; n < t.length; n++) this.collideHandler(t[n], e, i, o, s, !1);
                    else if (Array.isArray(t) && Array.isArray(e))
                        for (var n = 0; n < t.length; n++)
                            for (var r = 0; r < e.length; r++) this.collideHandler(t[n], e[r], i, o, s, !1);
                    else this.collideHandler(t, e, i, o, s, !1);
                    return this._total > 0
                },
                sortLeftRight: function(t, e) {
                    return t.body && e.body ? t.body.x - e.body.x : 0
                },
                sortRightLeft: function(t, e) {
                    return t.body && e.body ? e.body.x - t.body.x : 0
                },
                sortTopBottom: function(t, e) {
                    return t.body && e.body ? t.body.y - e.body.y : 0
                },
                sortBottomTop: function(t, e) {
                    return t.body && e.body ? e.body.y - t.body.y : 0
                },
                sort: function(t, e) {
                    null !== t.physicsSortDirection ? e = t.physicsSortDirection : void 0 === e && (e = this.sortDirection), e === i.Physics.Arcade.LEFT_RIGHT ? t.hash.sort(this.sortLeftRight) : e === i.Physics.Arcade.RIGHT_LEFT ? t.hash.sort(this.sortRightLeft) : e === i.Physics.Arcade.TOP_BOTTOM ? t.hash.sort(this.sortTopBottom) : e === i.Physics.Arcade.BOTTOM_TOP && t.hash.sort(this.sortBottomTop)
                },
                collideHandler: function(t, e, o, s, n, r) {
                    if (void 0 === e && t.physicsType === i.GROUP) return this.sort(t), void this.collideGroupVsSelf(t, o, s, n, r);
                    t && e && t.exists && e.exists && (this.sortDirection !== i.Physics.Arcade.SORT_NONE && (t.physicsType === i.GROUP && this.sort(t), e.physicsType === i.GROUP && this.sort(e)), t.physicsType === i.SPRITE ? e.physicsType === i.SPRITE ? this.collideSpriteVsSprite(t, e, o, s, n, r) : e.physicsType === i.GROUP ? this.collideSpriteVsGroup(t, e, o, s, n, r) : e.physicsType === i.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(t, e, o, s, n, r) : t.physicsType === i.GROUP ? e.physicsType === i.SPRITE ? this.collideSpriteVsGroup(e, t, o, s, n, r) : e.physicsType === i.GROUP ? this.collideGroupVsGroup(t, e, o, s, n, r) : e.physicsType === i.TILEMAPLAYER && this.collideGroupVsTilemapLayer(t, e, o, s, n, r) : t.physicsType === i.TILEMAPLAYER && (e.physicsType === i.SPRITE ? this.collideSpriteVsTilemapLayer(e, t, o, s, n, r) : e.physicsType === i.GROUP && this.collideGroupVsTilemapLayer(e, t, o, s, n, r)))
                },
                collideSpriteVsSprite: function(t, e, i, o, s, n) {
                    return !(!t.body || !e.body) && (this.separate(t.body, e.body, o, s, n) && (i && i.call(s, t, e), this._total++), !0)
                },
                collideSpriteVsGroup: function(t, e, o, s, n, r) {
                    if (0 !== e.length && t.body)
                        if (this.skipQuadTree || t.body.skipQuadTree)
                            for (var a = {}, h = 0; h < e.hash.length; h++) {
                                var l = e.hash[h];
                                if (l && l.exists && l.body) {
                                    if (a = l.body.getBounds(a), this.sortDirection === i.Physics.Arcade.LEFT_RIGHT) {
                                        if (t.body.right < a.x) break;
                                        if (a.right < t.body.x) continue
                                    } else if (this.sortDirection === i.Physics.Arcade.RIGHT_LEFT) {
                                        if (t.body.x > a.right) break;
                                        if (a.x > t.body.right) continue
                                    } else if (this.sortDirection === i.Physics.Arcade.TOP_BOTTOM) {
                                        if (t.body.bottom < a.y) break;
                                        if (a.bottom < t.body.y) continue
                                    } else if (this.sortDirection === i.Physics.Arcade.BOTTOM_TOP) {
                                        if (t.body.y > a.bottom) break;
                                        if (a.y > t.body.bottom) continue
                                    }
                                    this.collideSpriteVsSprite(t, l, o, s, n, r)
                                }
                            } else {
                                this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(e);
                                for (var d = this.quadTree.retrieve(t), h = 0; h < d.length; h++) this.separate(t.body, d[h], s, n, r) && (o && o.call(n, t, d[h].sprite), this._total++)
                            }
                },
                collideGroupVsSelf: function(t, e, o, s, n) {
                    if (0 !== t.length)
                        for (var r = 0; r < t.hash.length; r++) {
                            var a = {},
                                h = t.hash[r];
                            if (h && h.exists && h.body) {
                                a = h.body.getBounds(a);
                                for (var l = r + 1; l < t.hash.length; l++) {
                                    var d = {},
                                        c = t.hash[l];
                                    if (c && c.exists && c.body) {
                                        if (d = c.body.getBounds(d), this.sortDirection === i.Physics.Arcade.LEFT_RIGHT) {
                                            if (a.right < d.x) break;
                                            if (d.right < a.x) continue
                                        } else if (this.sortDirection === i.Physics.Arcade.RIGHT_LEFT) {
                                            if (a.x > d.right) continue;
                                            if (d.x > a.right) break
                                        } else if (this.sortDirection === i.Physics.Arcade.TOP_BOTTOM) {
                                            if (a.bottom < d.y) continue;
                                            if (d.bottom < a.y) break
                                        } else if (this.sortDirection === i.Physics.Arcade.BOTTOM_TOP) {
                                            if (a.y > d.bottom) continue;
                                            if (d.y > h.body.bottom) break
                                        }
                                        this.collideSpriteVsSprite(h, c, e, o, s, n)
                                    }
                                }
                            }
                        }
                },
                collideGroupVsGroup: function(t, e, o, s, n, r) {
                    if (0 !== t.length && 0 !== e.length)
                        for (var a = 0; a < t.children.length; a++) t.children[a].exists && (t.children[a].physicsType === i.GROUP ? this.collideGroupVsGroup(t.children[a], e, o, s, n, r) : this.collideSpriteVsGroup(t.children[a], e, o, s, n, r))
                },
                separate: function(t, e, i, o, s) {
                    if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1;
                    if (i && !1 === i.call(o, t.sprite, e.sprite)) return !1;
                    if (t.isCircle && e.isCircle) return this.separateCircle(t, e, s);
                    if (t.isCircle !== e.isCircle) {
                        var n = t.isCircle ? e : t,
                            r = t.isCircle ? t : e,
                            a = {
                                x: n.x,
                                y: n.y,
                                right: n.right,
                                bottom: n.bottom
                            },
                            h = {
                                x: r.x + r.radius,
                                y: r.y + r.radius
                            };
                        if ((h.y < a.y || h.y > a.bottom) && (h.x < a.x || h.x > a.right)) return this.separateCircle(t, e, s)
                    }
                    var l = !1,
                        d = !1;
                    this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (l = this.separateX(t, e, s), this.intersects(t, e) && (d = this.separateY(t, e, s))) : (d = this.separateY(t, e, s), this.intersects(t, e) && (l = this.separateX(t, e, s)));
                    var c = l || d;
                    return c && (s ? (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)) : (t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite))), c
                },
                intersects: function(t, e) {
                    return t !== e && (t.isCircle ? e.isCircle ? i.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y) <= t.radius + e.radius : this.circleBodyIntersects(t, e) : e.isCircle ? this.circleBodyIntersects(e, t) : !(t.right <= e.position.x) && (!(t.bottom <= e.position.y) && (!(t.position.x >= e.right) && !(t.position.y >= e.bottom))))
                },
                circleBodyIntersects: function(t, e) {
                    var o = i.Math.clamp(t.center.x, e.left, e.right),
                        s = i.Math.clamp(t.center.y, e.top, e.bottom);
                    return (t.center.x - o) * (t.center.x - o) + (t.center.y - s) * (t.center.y - s) <= t.radius * t.radius
                },
                separateCircle: function(t, e, o) {
                    this.getOverlapX(t, e), this.getOverlapY(t, e);
                    var s = e.center.x - t.center.x,
                        n = e.center.y - t.center.y,
                        r = Math.atan2(n, s),
                        a = 0;
                    if (t.isCircle !== e.isCircle) {
                        var h = {
                                x: e.isCircle ? t.position.x : e.position.x,
                                y: e.isCircle ? t.position.y : e.position.y,
                                right: e.isCircle ? t.right : e.right,
                                bottom: e.isCircle ? t.bottom : e.bottom
                            },
                            l = {
                                x: t.isCircle ? t.position.x + t.radius : e.position.x + e.radius,
                                y: t.isCircle ? t.position.y + t.radius : e.position.y + e.radius,
                                radius: t.isCircle ? t.radius : e.radius
                            };
                        l.y < h.y ? l.x < h.x ? a = i.Math.distance(l.x, l.y, h.x, h.y) - l.radius : l.x > h.right && (a = i.Math.distance(l.x, l.y, h.right, h.y) - l.radius) : l.y > h.bottom && (l.x < h.x ? a = i.Math.distance(l.x, l.y, h.x, h.bottom) - l.radius : l.x > h.right && (a = i.Math.distance(l.x, l.y, h.right, h.bottom) - l.radius)), a *= -1
                    } else a = t.radius + e.radius - i.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y);
                    if (o || 0 === a || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== a && (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)), 0 !== a;
                    var d = {
                            x: t.velocity.x * Math.cos(r) + t.velocity.y * Math.sin(r),
                            y: t.velocity.x * Math.sin(r) - t.velocity.y * Math.cos(r)
                        },
                        c = {
                            x: e.velocity.x * Math.cos(r) + e.velocity.y * Math.sin(r),
                            y: e.velocity.x * Math.sin(r) - e.velocity.y * Math.cos(r)
                        },
                        p = ((t.mass - e.mass) * d.x + 2 * e.mass * c.x) / (t.mass + e.mass),
                        u = (2 * t.mass * d.x + (e.mass - t.mass) * c.x) / (t.mass + e.mass);
                    return t.immovable || (t.velocity.x = (p * Math.cos(r) - d.y * Math.sin(r)) * t.bounce.x, t.velocity.y = (d.y * Math.cos(r) + p * Math.sin(r)) * t.bounce.y), e.immovable || (e.velocity.x = (u * Math.cos(r) - c.y * Math.sin(r)) * e.bounce.x, e.velocity.y = (c.y * Math.cos(r) + u * Math.sin(r)) * e.bounce.y), Math.abs(r) < Math.PI / 2 ? t.velocity.x > 0 && !t.immovable && e.velocity.x > t.velocity.x ? t.velocity.x *= -1 : e.velocity.x < 0 && !e.immovable && t.velocity.x < e.velocity.x ? e.velocity.x *= -1 : t.velocity.y > 0 && !t.immovable && e.velocity.y > t.velocity.y ? t.velocity.y *= -1 : e.velocity.y < 0 && !e.immovable && t.velocity.y < e.velocity.y && (e.velocity.y *= -1) : Math.abs(r) > Math.PI / 2 && (t.velocity.x < 0 && !t.immovable && e.velocity.x < t.velocity.x ? t.velocity.x *= -1 : e.velocity.x > 0 && !e.immovable && t.velocity.x > e.velocity.x ? e.velocity.x *= -1 : t.velocity.y < 0 && !t.immovable && e.velocity.y < t.velocity.y ? t.velocity.y *= -1 : e.velocity.y > 0 && !e.immovable && t.velocity.x > e.velocity.y && (e.velocity.y *= -1)), t.immovable || (t.x += t.velocity.x * this.game.time.physicsElapsed - a * Math.cos(r), t.y += t.velocity.y * this.game.time.physicsElapsed - a * Math.sin(r)), e.immovable || (e.x += e.velocity.x * this.game.time.physicsElapsed + a * Math.cos(r), e.y += e.velocity.y * this.game.time.physicsElapsed + a * Math.sin(r)), t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite), !0
                },
                getOverlapX: function(t, e, i) {
                    var o = 0,
                        s = t.deltaAbsX() + e.deltaAbsX() + this.OVERLAP_BIAS;
                    return 0 === t.deltaX() && 0 === e.deltaX() ? (t.embedded = !0, e.embedded = !0) : t.deltaX() > e.deltaX() ? (o = t.right - e.x, o > s && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? o = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0)) : t.deltaX() < e.deltaX() && (o = t.x - e.width - e.x, -o > s && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? o = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0)), t.overlapX = o, e.overlapX = o, o
                },
                getOverlapY: function(t, e, i) {
                    var o = 0,
                        s = t.deltaAbsY() + e.deltaAbsY() + this.OVERLAP_BIAS;
                    return 0 === t.deltaY() && 0 === e.deltaY() ? (t.embedded = !0, e.embedded = !0) : t.deltaY() > e.deltaY() ? (o = t.bottom - e.y, o > s && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? o = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0)) : t.deltaY() < e.deltaY() && (o = t.y - e.bottom, -o > s && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? o = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0)), t.overlapY = o, e.overlapY = o, o
                },
                separateX: function(t, e, i) {
                    var o = this.getOverlapX(t, e, i);
                    if (i || 0 === o || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== o || t.embedded && e.embedded;
                    var s = t.velocity.x,
                        n = e.velocity.x;
                    if (t.immovable || e.immovable) t.immovable ? (e.x += o, e.velocity.x = s - n * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= o, t.velocity.x = n - s * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y));
                    else {
                        o *= .5, t.x -= o, e.x += o;
                        var r = Math.sqrt(n * n * e.mass / t.mass) * (n > 0 ? 1 : -1),
                            a = Math.sqrt(s * s * t.mass / e.mass) * (s > 0 ? 1 : -1),
                            h = .5 * (r + a);
                        r -= h, a -= h, t.velocity.x = h + r * t.bounce.x, e.velocity.x = h + a * e.bounce.x
                    }
                    return !0
                },
                separateY: function(t, e, i) {
                    var o = this.getOverlapY(t, e, i);
                    if (i || 0 === o || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return 0 !== o || t.embedded && e.embedded;
                    var s = t.velocity.y,
                        n = e.velocity.y;
                    if (t.immovable || e.immovable) t.immovable ? (e.y += o, e.velocity.y = s - n * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= o, t.velocity.y = n - s * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x));
                    else {
                        o *= .5, t.y -= o, e.y += o;
                        var r = Math.sqrt(n * n * e.mass / t.mass) * (n > 0 ? 1 : -1),
                            a = Math.sqrt(s * s * t.mass / e.mass) * (s > 0 ? 1 : -1),
                            h = .5 * (r + a);
                        r -= h, a -= h, t.velocity.y = h + r * t.bounce.y, e.velocity.y = h + a * e.bounce.y
                    }
                    return !0
                },
                getObjectsUnderPointer: function(t, e, i, o) {
                    if (0 !== e.length && t.exists) return this.getObjectsAtLocation(t.x, t.y, e, i, o, t)
                },
                getObjectsAtLocation: function(t, e, o, s, n, r) {
                    this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(o);
                    for (var a = new i.Rectangle(t, e, 1, 1), h = [], l = this.quadTree.retrieve(a), d = 0; d < l.length; d++) l[d].hitTest(t, e) && (s && s.call(n, r, l[d].sprite), h.push(l[d].sprite));
                    return h
                },
                moveToObject: function(t, e, i, o) {
                    void 0 === i && (i = 60), void 0 === o && (o = 0);
                    var s = Math.atan2(e.y - t.y, e.x - t.x);
                    return o > 0 && (i = this.distanceBetween(t, e) / (o / 1e3)), t.body.velocity.x = Math.cos(s) * i, t.body.velocity.y = Math.sin(s) * i, s
                },
                moveToPointer: function(t, e, i, o) {
                    void 0 === e && (e = 60), i = i || this.game.input.activePointer, void 0 === o && (o = 0);
                    var s = this.angleToPointer(t, i);
                    return o > 0 && (e = this.distanceToPointer(t, i) / (o / 1e3)), t.body.velocity.x = Math.cos(s) * e, t.body.velocity.y = Math.sin(s) * e, s
                },
                moveToXY: function(t, e, i, o, s) {
                    void 0 === o && (o = 60), void 0 === s && (s = 0);
                    var n = Math.atan2(i - t.y, e - t.x);
                    return s > 0 && (o = this.distanceToXY(t, e, i) / (s / 1e3)), t.body.velocity.x = Math.cos(n) * o, t.body.velocity.y = Math.sin(n) * o, n
                },
                velocityFromAngle: function(t, e, o) {
                    return void 0 === e && (e = 60), o = o || new i.Point, o.setTo(Math.cos(this.game.math.degToRad(t)) * e, Math.sin(this.game.math.degToRad(t)) * e)
                },
                velocityFromRotation: function(t, e, o) {
                    return void 0 === e && (e = 60), o = o || new i.Point, o.setTo(Math.cos(t) * e, Math.sin(t) * e)
                },
                accelerationFromRotation: function(t, e, o) {
                    return void 0 === e && (e = 60), o = o || new i.Point, o.setTo(Math.cos(t) * e, Math.sin(t) * e)
                },
                accelerateToObject: function(t, e, i, o, s) {
                    void 0 === i && (i = 60), void 0 === o && (o = 1e3), void 0 === s && (s = 1e3);
                    var n = this.angleBetween(t, e);
                    return t.body.acceleration.setTo(Math.cos(n) * i, Math.sin(n) * i), t.body.maxVelocity.setTo(o, s), n
                },
                accelerateToPointer: function(t, e, i, o, s) {
                    void 0 === i && (i = 60), void 0 === e && (e = this.game.input.activePointer), void 0 === o && (o = 1e3), void 0 === s && (s = 1e3);
                    var n = this.angleToPointer(t, e);
                    return t.body.acceleration.setTo(Math.cos(n) * i, Math.sin(n) * i), t.body.maxVelocity.setTo(o, s), n
                },
                accelerateToXY: function(t, e, i, o, s, n) {
                    void 0 === o && (o = 60), void 0 === s && (s = 1e3), void 0 === n && (n = 1e3);
                    var r = this.angleToXY(t, e, i);
                    return t.body.acceleration.setTo(Math.cos(r) * o, Math.sin(r) * o), t.body.maxVelocity.setTo(s, n), r
                },
                distanceBetween: function(t, e, i) {
                    void 0 === i && (i = !1);
                    var o = i ? t.world.x - e.world.x : t.x - e.x,
                        s = i ? t.world.y - e.world.y : t.y - e.y;
                    return Math.sqrt(o * o + s * s)
                },
                distanceToXY: function(t, e, i, o) {
                    void 0 === o && (o = !1);
                    var s = o ? t.world.x - e : t.x - e,
                        n = o ? t.world.y - i : t.y - i;
                    return Math.sqrt(s * s + n * n)
                },
                distanceToPointer: function(t, e, i) {
                    void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1);
                    var o = i ? t.world.x - e.worldX : t.x - e.worldX,
                        s = i ? t.world.y - e.worldY : t.y - e.worldY;
                    return Math.sqrt(o * o + s * s)
                },
                angleBetween: function(t, e, i) {
                    return void 0 === i && (i = !1), i ? Math.atan2(e.world.y - t.world.y, e.world.x - t.world.x) : Math.atan2(e.y - t.y, e.x - t.x)
                },
                angleBetweenCenters: function(t, e) {
                    var i = e.centerX - t.centerX,
                        o = e.centerY - t.centerY;
                    return Math.atan2(o, i)
                },
                angleToXY: function(t, e, i, o) {
                    return void 0 === o && (o = !1), o ? Math.atan2(i - t.world.y, e - t.world.x) : Math.atan2(i - t.y, e - t.x)
                },
                angleToPointer: function(t, e, i) {
                    return void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1), i ? Math.atan2(e.worldY - t.world.y, e.worldX - t.world.x) : Math.atan2(e.worldY - t.y, e.worldX - t.x)
                },
                worldAngleToPointer: function(t, e) {
                    return this.angleToPointer(t, e, !0)
                }
            }, i.Physics.Arcade.Body = function(t) {
                this.sprite = t, this.game = t.game, this.type = i.Physics.ARCADE, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new i.Point, this.position = new i.Point(t.x, t.y), this.prev = new i.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = t.angle, this.preRotation = t.angle, this.width = t.width, this.height = t.height, this.sourceWidth = t.width, this.sourceHeight = t.height, t.texture && (this.sourceWidth = t.texture.frame.width, this.sourceHeight = t.texture.frame.height), this.halfWidth = Math.abs(t.width / 2), this.halfHeight = Math.abs(t.height / 2), this.center = new i.Point(t.x + this.halfWidth, t.y + this.halfHeight), this.velocity = new i.Point, this.newVelocity = new i.Point, this.deltaMax = new i.Point, this.acceleration = new i.Point, this.drag = new i.Point, this.allowGravity = !0, this.gravity = new i.Point, this.bounce = new i.Point, this.worldBounce = null, this.onWorldBounds = null, this.onCollide = null, this.onOverlap = null, this.maxVelocity = new i.Point(1e4, 1e4), this.friction = new i.Point(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = i.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
                    none: !1,
                    any: !0,
                    up: !0,
                    down: !0,
                    left: !0,
                    right: !0
                }, this.touching = {
                    none: !0,
                    up: !1,
                    down: !1,
                    left: !1,
                    right: !1
                }, this.wasTouching = {
                    none: !0,
                    up: !1,
                    down: !1,
                    left: !1,
                    right: !1
                }, this.blocked = {
                    up: !1,
                    down: !1,
                    left: !1,
                    right: !1
                }, this.tilePadding = new i.Point, this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.moveTimer = 0, this.moveDistance = 0, this.moveDuration = 0, this.moveTarget = null, this.moveEnd = null, this.onMoveComplete = new i.Signal, this.movementCallback = null, this.movementCallbackContext = null, this._reset = !0, this._sx = t.scale.x, this._sy = t.scale.y, this._dx = 0, this._dy = 0
            }, i.Physics.Arcade.Body.prototype = {
                updateBounds: function() {
                    if (this.syncBounds) {
                        var t = this.sprite.getBounds();
                        t.ceilAll(), t.width === this.width && t.height === this.height || (this.width = t.width, this.height = t.height, this._reset = !0)
                    } else {
                        var e = Math.abs(this.sprite.scale.x),
                            i = Math.abs(this.sprite.scale.y);
                        e === this._sx && i === this._sy || (this.width = this.sourceWidth * e, this.height = this.sourceHeight * i, this._sx = e, this._sy = i, this._reset = !0)
                    }
                    this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight))
                },
                preUpdate: function() {
                    this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1)
                },
                updateMovement: function() {
                    var t = 0,
                        e = 0 !== this.overlapX || 0 !== this.overlapY;
                    if (this.moveDuration > 0 ? (this.moveTimer += this.game.time.elapsedMS, t = this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), t = this.moveTarget.length / this.moveDistance), this.movementCallback) var i = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, t);
                    return !(e || t >= 1 || void 0 !== i && !0 !== i) || (this.stopMovement(t >= 1 || this.stopVelocityOnCollide && e), !1)
                },
                stopMovement: function(t) {
                    this.isMoving && (this.isMoving = !1, t && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY))
                },
                postUpdate: function() {
                    this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = i.LEFT : this.deltaX() > 0 && (this.facing = i.RIGHT), this.deltaY() < 0 ? this.facing = i.UP : this.deltaY() > 0 && (this.facing = i.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y)
                },
                checkWorldBounds: function() {
                    var t = this.position,
                        e = this.game.physics.arcade.bounds,
                        i = this.game.physics.arcade.checkCollision,
                        o = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
                        s = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
                    if (this.isCircle) {
                        var n = {
                            x: this.center.x - this.radius,
                            y: this.center.y - this.radius,
                            right: this.center.x + this.radius,
                            bottom: this.center.y + this.radius
                        };
                        n.x < e.x && i.left ? (t.x = e.x - this.halfWidth + this.radius, this.velocity.x *= o, this.blocked.left = !0) : n.right > e.right && i.right && (t.x = e.right - this.halfWidth - this.radius, this.velocity.x *= o, this.blocked.right = !0), n.y < e.y && i.up ? (t.y = e.y - this.halfHeight + this.radius, this.velocity.y *= s, this.blocked.up = !0) : n.bottom > e.bottom && i.down && (t.y = e.bottom - this.halfHeight - this.radius, this.velocity.y *= s, this.blocked.down = !0)
                    } else t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= o, this.blocked.left = !0) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= o, this.blocked.right = !0), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= s, this.blocked.up = !0) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= s, this.blocked.down = !0);
                    return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right
                },
                moveFrom: function(t, e, i) {
                    if (void 0 === e && (e = this.speed), 0 === e) return !1;
                    var o;
                    return void 0 === i ? (o = this.angle, i = this.game.math.radToDeg(o)) : o = this.game.math.degToRad(i), this.moveTimer = 0, this.moveDuration = t, 0 === i || 180 === i ? this.velocity.set(Math.cos(o) * e, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(o) * e) : this.velocity.set(Math.cos(o) * e, Math.sin(o) * e), this.isMoving = !0, !0
                },
                moveTo: function(t, e, o) {
                    var s = e / (t / 1e3);
                    if (0 === s) return !1;
                    var n;
                    return void 0 === o ? (n = this.angle, o = this.game.math.radToDeg(n)) : n = this.game.math.degToRad(o), e = Math.abs(e), this.moveDuration = 0, this.moveDistance = e, null === this.moveTarget && (this.moveTarget = new i.Line, this.moveEnd = new i.Point), this.moveTarget.fromAngle(this.x, this.y, n, e), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === o || 180 === o ? this.velocity.set(Math.cos(n) * s, 0) : 90 === o || 270 === o ? this.velocity.set(0, Math.sin(n) * s) : this.velocity.set(Math.cos(n) * s, Math.sin(n) * s), this.isMoving = !0, !0
                },
                setSize: function(t, e, i, o) {
                    void 0 === i && (i = this.offset.x), void 0 === o && (o = this.offset.y), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(i, o), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.isCircle = !1, this.radius = 0
                },
                setCircle: function(t, e, i) {
                    void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(e, i), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)) : this.isCircle = !1
                },
                reset: function(t, e) {
                    this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this.position.x = t - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = e - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
                },
                getBounds: function(t) {
                    return this.isCircle ? (t.x = this.center.x - this.radius, t.y = this.center.y - this.radius, t.right = this.center.x + this.radius, t.bottom = this.center.y + this.radius) : (t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom), t
                },
                hitTest: function(t, e) {
                    return this.isCircle ? i.Circle.contains(this, t, e) : i.Rectangle.contains(this, t, e)
                },
                onFloor: function() {
                    return this.blocked.down
                },
                onCeiling: function() {
                    return this.blocked.up
                },
                onWall: function() {
                    return this.blocked.left || this.blocked.right
                },
                deltaAbsX: function() {
                    return this.deltaX() > 0 ? this.deltaX() : -this.deltaX()
                },
                deltaAbsY: function() {
                    return this.deltaY() > 0 ? this.deltaY() : -this.deltaY()
                },
                deltaX: function() {
                    return this.position.x - this.prev.x
                },
                deltaY: function() {
                    return this.position.y - this.prev.y
                },
                deltaZ: function() {
                    return this.rotation - this.preRotation
                },
                destroy: function() {
                    this.sprite.parent && this.sprite.parent instanceof i.Group && this.sprite.parent.removeFromHash(this.sprite), this.sprite.body = null, this.sprite = null
                }
            }, Object.defineProperty(i.Physics.Arcade.Body.prototype, "left", {
                get: function() {
                    return this.position.x
                }
            }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "right", {
                get: function() {
                    return this.position.x + this.width
                }
            }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "top", {
                get: function() {
                    return this.position.y
                }
            }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "bottom", {
                get: function() {
                    return this.position.y + this.height
                }
            }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "x", {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t
                }
            }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "y", {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t
                }
            }), i.Physics.Arcade.Body.render = function(t, e, i, o) {
                void 0 === o && (o = !0), i = i || "rgba(0,255,0,0.4)", t.fillStyle = i, t.strokeStyle = i, e.isCircle ? (t.beginPath(), t.arc(e.center.x - e.game.camera.x, e.center.y - e.game.camera.y, e.radius, 0, 2 * Math.PI), o ? t.fill() : t.stroke()) : o ? t.fillRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height) : t.strokeRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height)
            }, i.Physics.Arcade.Body.renderBodyInfo = function(t, e) {
                t.line("x: " + e.x.toFixed(2), "y: " + e.y.toFixed(2), "width: " + e.width, "height: " + e.height), t.line("velocity x: " + e.velocity.x.toFixed(2), "y: " + e.velocity.y.toFixed(2), "deltaX: " + e._dx.toFixed(2), "deltaY: " + e._dy.toFixed(2)), t.line("acceleration x: " + e.acceleration.x.toFixed(2), "y: " + e.acceleration.y.toFixed(2), "speed: " + e.speed.toFixed(2), "angle: " + e.angle.toFixed(2)), t.line("gravity x: " + e.gravity.x, "y: " + e.gravity.y, "bounce x: " + e.bounce.x.toFixed(2), "y: " + e.bounce.y.toFixed(2)), t.line("touching left: " + e.touching.left, "right: " + e.touching.right, "up: " + e.touching.up, "down: " + e.touching.down), t.line("blocked left: " + e.blocked.left, "right: " + e.blocked.right, "up: " + e.blocked.up, "down: " + e.blocked.down)
            }, i.Physics.Arcade.Body.prototype.constructor = i.Physics.Arcade.Body, i.Physics.Arcade.TilemapCollision = function() {}, i.Physics.Arcade.TilemapCollision.prototype = {
                TILE_BIAS: 16,
                collideSpriteVsTilemapLayer: function(t, e, i, o, s, n) {
                    if (t.body) {
                        var r = e.getTiles(t.body.position.x - t.body.tilePadding.x, t.body.position.y - t.body.tilePadding.y, t.body.width + t.body.tilePadding.x, t.body.height + t.body.tilePadding.y, !1, !1);
                        if (0 !== r.length)
                            for (var a = 0; a < r.length; a++) o ? o.call(s, t, r[a]) && this.separateTile(a, t.body, r[a], e, n) && (this._total++, i && i.call(s, t, r[a])) : this.separateTile(a, t.body, r[a], e, n) && (this._total++, i && i.call(s, t, r[a]))
                    }
                },
                collideGroupVsTilemapLayer: function(t, e, i, o, s, n) {
                    if (0 !== t.length)
                        for (var r = 0; r < t.children.length; r++) t.children[r].exists && this.collideSpriteVsTilemapLayer(t.children[r], e, i, o, s, n)
                },
                separateTile: function(t, e, i, o, s) {
                    if (!e.enable) return !1;
                    if (!i.intersects(e.position.x - 0, e.position.y - 0, e.right - 0, e.bottom - 0)) return !1;
                    if (s) return !0;
                    if (i.collisionCallback && !i.collisionCallback.call(i.collisionCallbackContext, e.sprite, i)) return !1;
                    if (void 0 !== i.layer.callbacks && i.layer.callbacks[i.index] && !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, e.sprite, i)) return !1;
                    if (!(i.faceLeft || i.faceRight || i.faceTop || i.faceBottom)) return !1;
                    var n = 0,
                        r = 0,
                        a = 0,
                        h = 1;
                    if (e.deltaAbsX() > e.deltaAbsY() ? a = -1 : e.deltaAbsX() < e.deltaAbsY() && (h = -1), 0 !== e.deltaX() && 0 !== e.deltaY() && (i.faceLeft || i.faceRight) && (i.faceTop || i.faceBottom) && (a = Math.min(Math.abs(e.position.x - 0 - i.right), Math.abs(e.right - 0 - i.left)), h = Math.min(Math.abs(e.position.y - 0 - i.bottom), Math.abs(e.bottom - 0 - i.top))), a < h) {
                        if ((i.faceLeft || i.faceRight) && 0 !== (n = this.tileCheckX(e, i, o)) && !i.intersects(e.position.x - 0, e.position.y - 0, e.right - 0, e.bottom - 0)) return !0;
                        (i.faceTop || i.faceBottom) && (r = this.tileCheckY(e, i, o))
                    } else {
                        if ((i.faceTop || i.faceBottom) && 0 !== (r = this.tileCheckY(e, i, o)) && !i.intersects(e.position.x - 0, e.position.y - 0, e.right - 0, e.bottom - 0)) return !0;
                        (i.faceLeft || i.faceRight) && (n = this.tileCheckX(e, i, o))
                    }
                    return 0 !== n || 0 !== r
                },
                tileCheckX: function(t, e, i) {
                    var o = 0;
                    return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x - 0 < e.right && (o = t.x - 0 - e.right) < -this.TILE_BIAS && (o = 0) : t.deltaX() > 0 && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right - 0 > e.left && (o = t.right - 0 - e.left) > this.TILE_BIAS && (o = 0), 0 !== o && (t.customSeparateX ? t.overlapX = o : this.processTileSeparationX(t, o)), o
                },
                tileCheckY: function(t, e, i) {
                    var o = 0;
                    return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y - 0 < e.bottom && (o = t.y - 0 - e.bottom) < -this.TILE_BIAS && (o = 0) : t.deltaY() > 0 && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom - 0 > e.top && (o = t.bottom - 0 - e.top) > this.TILE_BIAS && (o = 0), 0 !== o && (t.customSeparateY ? t.overlapY = o : this.processTileSeparationY(t, o)), o
                },
                processTileSeparationX: function(t, e) {
                    e < 0 ? t.blocked.left = !0 : e > 0 && (t.blocked.right = !0), t.position.x -= e, 0 === t.bounce.x ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x
                },
                processTileSeparationY: function(t, e) {
                    e < 0 ? t.blocked.up = !0 : e > 0 && (t.blocked.down = !0), t.position.y -= e, 0 === t.bounce.y ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y
                }
            }, i.Utils.mixinPrototype(i.Physics.Arcade.prototype, i.Physics.Arcade.TilemapCollision.prototype), i.ImageCollection = function(t, e, i, o, s, n, r) {
                (void 0 === i || i <= 0) && (i = 32), (void 0 === o || o <= 0) && (o = 32), void 0 === s && (s = 0), void 0 === n && (n = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | o, this.imageMargin = 0 | s, this.imageSpacing = 0 | n, this.properties = r || {}, this.images = [], this.total = 0
            }, i.ImageCollection.prototype = {
                containsImageIndex: function(t) {
                    return t >= this.firstgid && t < this.firstgid + this.total
                },
                addImage: function(t, e) {
                    this.images.push({
                        gid: t,
                        image: e
                    }), this.total++
                }
            }, i.ImageCollection.prototype.constructor = i.ImageCollection, i.Tile = function(t, e, i, o, s, n) {
                this.layer = t, this.index = e, this.x = i, this.y = o, this.rotation = 0, this.flipped = !1, this.worldX = i * s, this.worldY = o * n, this.width = s, this.height = n, this.centerX = Math.abs(s / 2), this.centerY = Math.abs(n / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.collisionCallback = null, this.collisionCallbackContext = this
            }, i.Tile.prototype = {
                containsPoint: function(t, e) {
                    return !(t < this.worldX || e < this.worldY || t > this.right || e > this.bottom)
                },
                intersects: function(t, e, i, o) {
                    return !(i <= this.worldX) && (!(o <= this.worldY) && (!(t >= this.worldX + this.width) && !(e >= this.worldY + this.height)))
                },
                setCollisionCallback: function(t, e) {
                    this.collisionCallback = t, this.collisionCallbackContext = e
                },
                destroy: function() {
                    this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null
                },
                setCollision: function(t, e, i, o) {
                    this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = o, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = o
                },
                resetCollision: function() {
                    this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1
                },
                isInteresting: function(t, e) {
                    return t && e ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : t ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!e && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight)
                },
                copy: function(t) {
                    this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext
                }
            }, i.Tile.prototype.constructor = i.Tile, Object.defineProperty(i.Tile.prototype, "collides", {
                get: function() {
                    return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
                }
            }), Object.defineProperty(i.Tile.prototype, "canCollide", {
                get: function() {
                    return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
                }
            }), Object.defineProperty(i.Tile.prototype, "left", {
                get: function() {
                    return this.worldX
                }
            }), Object.defineProperty(i.Tile.prototype, "right", {
                get: function() {
                    return this.worldX + this.width
                }
            }), Object.defineProperty(i.Tile.prototype, "top", {
                get: function() {
                    return this.worldY
                }
            }), Object.defineProperty(i.Tile.prototype, "bottom", {
                get: function() {
                    return this.worldY + this.height
                }
            }), i.Tilemap = function(t, e, o, s, n, r) {
                this.game = t, this.key = e;
                var a = i.TilemapParser.parse(this.game, e, o, s, n, r);
                null !== a && (this.width = a.width, this.height = a.height, this.tileWidth = a.tileWidth, this.tileHeight = a.tileHeight, this.orientation = a.orientation, this.format = a.format, this.version = a.version, this.properties = a.properties, this.widthInPixels = a.widthInPixels, this.heightInPixels = a.heightInPixels, this.layers = a.layers, this.tilesets = a.tilesets, this.imagecollections = a.imagecollections, this.tiles = a.tiles, this.objects = a.objects, this.collideIndexes = [], this.collision = a.collision, this.images = a.images, this.enableDebug = !1, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0)
            }, i.Tilemap.CSV = 0, i.Tilemap.TILED_JSON = 1, i.Tilemap.NORTH = 0, i.Tilemap.EAST = 1, i.Tilemap.SOUTH = 2, i.Tilemap.WEST = 3, i.Tilemap.prototype = {
                create: function(t, e, i, o, s, n) {
                    return void 0 === n && (n = this.game.world), this.width = e, this.height = i, this.setTileSize(o, s), this.layers.length = 0, this.createBlankLayer(t, e, i, o, s, n)
                },
                setTileSize: function(t, e) {
                    this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e
                },
                addTilesetImage: function(t, e, o, s, n, r, a) {
                    if (void 0 === t) return null;
                    void 0 === o && (o = this.tileWidth), void 0 === s && (s = this.tileHeight), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), 0 === o && (o = 32), 0 === s && (s = 32);
                    var h = null;
                    if (void 0 !== e && null !== e || (e = t), e instanceof i.BitmapData) h = e.canvas;
                    else {
                        if (!this.game.cache.checkImageKey(e)) return console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + e + '"'), null;
                        h = this.game.cache.getImage(e)
                    }
                    var l = this.getTilesetIndex(t);
                    if (null === l && this.format === i.Tilemap.TILED_JSON) return console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + t + '"'), null;
                    if (this.tilesets[l]) return this.tilesets[l].setImage(h), this.tilesets[l];
                    var d = new i.Tileset(t, a, o, s, n, r, {});
                    d.setImage(h), this.tilesets.push(d);
                    for (var c = this.tilesets.length - 1, p = n, u = n, b = 0, m = 0, y = 0, f = a; f < a + d.total && (this.tiles[f] = [p, u, c], p += o + r, ++b !== d.total) && (++m !== d.columns || (p = n, u += s + r, m = 0, ++y !== d.rows)); f++);
                    return d
                },
                createFromObjects: function(t, e, o, s, n, r, a, h, l) {
                    if (void 0 === n && (n = !0), void 0 === r && (r = !1), void 0 === a && (a = this.game.world), void 0 === h && (h = i.Sprite), void 0 === l && (l = !0), !this.objects[t]) return void console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + t);
                    for (var d = 0; d < this.objects[t].length; d++) {
                        var c = !1,
                            p = this.objects[t][d];
                        if (void 0 !== p.gid && "number" == typeof e && p.gid === e ? c = !0 : void 0 !== p.id && "number" == typeof e && p.id === e ? c = !0 : void 0 !== p.name && "string" == typeof e && p.name === e && (c = !0), c) {
                            var u = new h(this.game, parseFloat(p.x, 10), parseFloat(p.y, 10), o, s);
                            u.name = p.name, u.visible = p.visible, u.autoCull = r, u.exists = n, p.width && (u.width = p.width), p.height && (u.height = p.height), p.rotation && (u.angle = p.rotation), l && (u.y -= u.height), a.add(u);
                            for (var b in p.properties) a.set(u, b, p.properties[b], !1, !1, 0, !0)
                        }
                    }
                },
                createFromTiles: function(t, e, o, s, n, r) {
                    "number" == typeof t && (t = [t]), void 0 === e || null === e ? e = [] : "number" == typeof e && (e = [e]), s = this.getLayer(s), void 0 === n && (n = this.game.world), void 0 === r && (r = {}), void 0 === r.customClass && (r.customClass = i.Sprite), void 0 === r.adjustY && (r.adjustY = !0);
                    var a = this.layers[s].width,
                        h = this.layers[s].height;
                    if (this.copy(0, 0, a, h, s), this._results.length < 2) return 0;
                    for (var l, d = 0, c = 1, p = this._results.length; c < p; c++)
                        if (-1 !== t.indexOf(this._results[c].index)) {
                            l = new r.customClass(this.game, this._results[c].worldX, this._results[c].worldY, o);
                            for (var u in r) l[u] = r[u];
                            n.add(l), d++
                        }
                    if (1 === e.length)
                        for (c = 0; c < t.length; c++) this.replace(t[c], e[0], 0, 0, a, h, s);
                    else if (e.length > 1)
                        for (c = 0; c < t.length; c++) this.replace(t[c], e[c], 0, 0, a, h, s);
                    return d
                },
                createLayer: function(t, e, o, s) {
                    void 0 === e && (e = this.game.width), void 0 === o && (o = this.game.height), void 0 === s && (s = this.game.world);
                    var n = t;
                    if ("string" == typeof t && (n = this.getLayerIndex(t)), null === n || n > this.layers.length) return void console.warn("Tilemap.createLayer: Invalid layer ID given: " + n);
                    void 0 === e || e <= 0 ? e = Math.min(this.game.width, this.layers[n].widthInPixels) : e > this.game.width && (e = this.game.width), void 0 === o || o <= 0 ? o = Math.min(this.game.height, this.layers[n].heightInPixels) : o > this.game.height && (o = this.game.height), this.enableDebug && (console.group("Tilemap.createLayer"), console.log("Name:", this.layers[n].name), console.log("Size:", e, "x", o), console.log("Tileset:", this.tilesets[0].name, "index:", n));
                    var r = s.add(new i.TilemapLayer(this.game, this, n, e, o));
                    return this.enableDebug && console.groupEnd(), r
                },
                createBlankLayer: function(t, e, o, s, n, r) {
                    if (void 0 === r && (r = this.game.world), null !== this.getLayerIndex(t)) return void console.warn("Tilemap.createBlankLayer: Layer with matching name already exists: " + t);
                    for (var a, h = {
                            name: t,
                            x: 0,
                            y: 0,
                            width: e,
                            height: o,
                            widthInPixels: e * s,
                            heightInPixels: o * n,
                            alpha: 1,
                            visible: !0,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: [],
                            data: null
                        }, l = [], d = 0; d < o; d++) {
                        a = [];
                        for (var c = 0; c < e; c++) a.push(new i.Tile(h, -1, c, d, s, n));
                        l.push(a)
                    }
                    h.data = l, this.layers.push(h), this.currentLayer = this.layers.length - 1;
                    var p = h.widthInPixels,
                        u = h.heightInPixels;
                    p > this.game.width && (p = this.game.width), u > this.game.height && (u = this.game.height);
                    var l = new i.TilemapLayer(this.game, this, this.layers.length - 1, p, u);
                    return l.name = t, r.add(l)
                },
                getIndex: function(t, e) {
                    for (var i = 0; i < t.length; i++)
                        if (t[i].name === e) return i;
                    return null
                },
                getLayerIndex: function(t) {
                    return this.getIndex(this.layers, t)
                },
                getTilesetIndex: function(t) {
                    return this.getIndex(this.tilesets, t)
                },
                getImageIndex: function(t) {
                    return this.getIndex(this.images, t)
                },
                setTileIndexCallback: function(t, e, i, o) {
                    if (o = this.getLayer(o), "number" == typeof t) this.layers[o].callbacks[t] = {
                        callback: e,
                        callbackContext: i
                    };
                    else
                        for (var s = 0, n = t.length; s < n; s++) this.layers[o].callbacks[t[s]] = {
                            callback: e,
                            callbackContext: i
                        }
                },
                setTileLocationCallback: function(t, e, i, o, s, n, r) {
                    if (r = this.getLayer(r), this.copy(t, e, i, o, r), !(this._results.length < 2))
                        for (var a = 1; a < this._results.length; a++) this._results[a].setCollisionCallback(s, n)
                },
                setCollision: function(t, e, i, o) {
                    if (void 0 === e && (e = !0), void 0 === o && (o = !0), i = this.getLayer(i), "number" == typeof t) return this.setCollisionByIndex(t, e, i, !0);
                    if (Array.isArray(t)) {
                        for (var s = 0; s < t.length; s++) this.setCollisionByIndex(t[s], e, i, !1);
                        o && this.calculateFaces(i)
                    }
                },
                setCollisionBetween: function(t, e, i, o, s) {
                    if (void 0 === i && (i = !0), void 0 === s && (s = !0), o = this.getLayer(o), !(t > e)) {
                        for (var n = t; n <= e; n++) this.setCollisionByIndex(n, i, o, !1);
                        s && this.calculateFaces(o)
                    }
                },
                setCollisionByExclusion: function(t, e, i, o) {
                    void 0 === e && (e = !0), void 0 === o && (o = !0), i = this.getLayer(i);
                    for (var s = 0, n = this.tiles.length; s < n; s++) - 1 === t.indexOf(s) && this.setCollisionByIndex(s, e, i, !1);
                    o && this.calculateFaces(i)
                },
                setCollisionByIndex: function(t, e, i, o) {
                    if (void 0 === e && (e = !0), void 0 === i && (i = this.currentLayer), void 0 === o && (o = !0), e) this.collideIndexes.push(t);
                    else {
                        var s = this.collideIndexes.indexOf(t);
                        s > -1 && this.collideIndexes.splice(s, 1)
                    }
                    for (var n = 0; n < this.layers[i].height; n++)
                        for (var r = 0; r < this.layers[i].width; r++) {
                            var a = this.layers[i].data[n][r];
                            a && a.index === t && (e ? a.setCollision(!0, !0, !0, !0) : a.resetCollision(), a.faceTop = e, a.faceBottom = e, a.faceLeft = e, a.faceRight = e)
                        }
                    return o && this.calculateFaces(i), i
                },
                getLayer: function(t) {
                    return void 0 === t ? t = this.currentLayer : "string" == typeof t ? t = this.getLayerIndex(t) : t instanceof i.TilemapLayer && (t = t.index), t
                },
                setPreventRecalculate: function(t) {
                    if (!0 === t && !0 !== this.preventingRecalculate && (this.preventingRecalculate = !0, this.needToRecalculate = {}), !1 === t && !0 === this.preventingRecalculate) {
                        this.preventingRecalculate = !1;
                        for (var e in this.needToRecalculate) this.calculateFaces(e);
                        this.needToRecalculate = !1
                    }
                },
                calculateFaces: function(t) {
                    if (this.preventingRecalculate) return void(this.needToRecalculate[t] = !0);
                    for (var e = null, i = null, o = null, s = null, n = 0, r = this.layers[t].height; n < r; n++)
                        for (var a = 0, h = this.layers[t].width; a < h; a++) {
                            var l = this.layers[t].data[n][a];
                            l && (e = this.getTileAbove(t, a, n), i = this.getTileBelow(t, a, n), o = this.getTileLeft(t, a, n), s = this.getTileRight(t, a, n), l.collides && (l.faceTop = !0, l.faceBottom = !0, l.faceLeft = !0, l.faceRight = !0), e && e.collides && (l.faceTop = !1), i && i.collides && (l.faceBottom = !1), o && o.collides && (l.faceLeft = !1), s && s.collides && (l.faceRight = !1))
                        }
                },
                getTileAbove: function(t, e, i) {
                    return i > 0 ? this.layers[t].data[i - 1][e] : null
                },
                getTileBelow: function(t, e, i) {
                    return i < this.layers[t].height - 1 ? this.layers[t].data[i + 1][e] : null
                },
                getTileLeft: function(t, e, i) {
                    return e > 0 ? this.layers[t].data[i][e - 1] : null
                },
                getTileRight: function(t, e, i) {
                    return e < this.layers[t].width - 1 ? this.layers[t].data[i][e + 1] : null
                },
                setLayer: function(t) {
                    t = this.getLayer(t), this.layers[t] && (this.currentLayer = t)
                },
                hasTile: function(t, e, i) {
                    return i = this.getLayer(i), void 0 !== this.layers[i].data[e] && void 0 !== this.layers[i].data[e][t] && this.layers[i].data[e][t].index > -1
                },
                removeTile: function(t, e, o) {
                    if (o = this.getLayer(o), t >= 0 && t < this.layers[o].width && e >= 0 && e < this.layers[o].height && this.hasTile(t, e, o)) {
                        var s = this.layers[o].data[e][t];
                        return this.layers[o].data[e][t] = new i.Tile(this.layers[o], -1, t, e, this.tileWidth, this.tileHeight), this.layers[o].dirty = !0, this.calculateFaces(o), s
                    }
                },
                removeTileWorldXY: function(t, e, i, o, s) {
                    return s = this.getLayer(s), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, o) / o, this.removeTile(t, e, s)
                },
                putTile: function(t, e, o, s) {
                    if (null === t) return this.removeTile(e, o, s);
                    if (s = this.getLayer(s), e >= 0 && e < this.layers[s].width && o >= 0 && o < this.layers[s].height) {
                        var n;
                        return t instanceof i.Tile ? (n = t.index, this.hasTile(e, o, s) ? this.layers[s].data[o][e].copy(t) : this.layers[s].data[o][e] = new i.Tile(s, n, e, o, t.width, t.height)) : (n = t, this.hasTile(e, o, s) ? this.layers[s].data[o][e].index = n : this.layers[s].data[o][e] = new i.Tile(this.layers[s], n, e, o, this.tileWidth, this.tileHeight)), this.collideIndexes.indexOf(n) > -1 ? this.layers[s].data[o][e].setCollision(!0, !0, !0, !0) : this.layers[s].data[o][e].resetCollision(), this.layers[s].dirty = !0, this.calculateFaces(s), this.layers[s].data[o][e]
                    }
                    return null
                },
                putTileWorldXY: function(t, e, i, o, s, n) {
                    return n = this.getLayer(n), e = this.game.math.snapToFloor(e, o) / o, i = this.game.math.snapToFloor(i, s) / s, this.putTile(t, e, i, n)
                },
                searchTileIndex: function(t, e, i, o) {
                    void 0 === e && (e = 0), void 0 === i && (i = !1), o = this.getLayer(o);
                    var s = 0;
                    if (i) {
                        for (var n = this.layers[o].height - 1; n >= 0; n--)
                            for (var r = this.layers[o].width - 1; r >= 0; r--)
                                if (this.layers[o].data[n][r].index === t) {
                                    if (s === e) return this.layers[o].data[n][r];
                                    s++
                                }
                    } else
                        for (var n = 0; n < this.layers[o].height; n++)
                            for (var r = 0; r < this.layers[o].width; r++)
                                if (this.layers[o].data[n][r].index === t) {
                                    if (s === e) return this.layers[o].data[n][r];
                                    s++
                                } return null
                },
                getTile: function(t, e, i, o) {
                    return void 0 === o && (o = !1), i = this.getLayer(i), t >= 0 && t < this.layers[i].width && e >= 0 && e < this.layers[i].height ? -1 === this.layers[i].data[e][t].index ? o ? this.layers[i].data[e][t] : null : this.layers[i].data[e][t] : null
                },
                getTileWorldXY: function(t, e, i, o, s, n) {
                    return void 0 === i && (i = this.tileWidth), void 0 === o && (o = this.tileHeight), s = this.getLayer(s), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, o) / o, this.getTile(t, e, s, n)
                },
                copy: function(t, e, i, o, s) {
                    if (s = this.getLayer(s), !this.layers[s]) return void(this._results.length = 0);
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.layers[s].width), void 0 === o && (o = this.layers[s].height), t < 0 && (t = 0), e < 0 && (e = 0), i > this.layers[s].width && (i = this.layers[s].width), o > this.layers[s].height && (o = this.layers[s].height), this._results.length = 0, this._results.push({
                        x: t,
                        y: e,
                        width: i,
                        height: o,
                        layer: s
                    });
                    for (var n = e; n < e + o; n++)
                        for (var r = t; r < t + i; r++) this._results.push(this.layers[s].data[n][r]);
                    return this._results
                },
                paste: function(t, e, i, o) {
                    if (void 0 === t && (t = 0), void 0 === e && (e = 0), o = this.getLayer(o), i && !(i.length < 2)) {
                        for (var s = t - i[1].x, n = e - i[1].y, r = 1; r < i.length; r++) this.layers[o].data[n + i[r].y][s + i[r].x].copy(i[r]);
                        this.layers[o].dirty = !0, this.calculateFaces(o)
                    }
                },
                swap: function(t, e, i, o, s, n, r) {
                    r = this.getLayer(r), this.copy(i, o, s, n, r), this._results.length < 2 || (this._tempA = t, this._tempB = e, this._results.forEach(this.swapHandler, this), this.paste(i, o, this._results, r))
                },
                swapHandler: function(t) {
                    t.index === this._tempA ? t.index = this._tempB : t.index === this._tempB && (t.index = this._tempA)
                },
                forEach: function(t, e, i, o, s, n, r) {
                    r = this.getLayer(r), this.copy(i, o, s, n, r), this._results.length < 2 || (this._results.forEach(t, e), this.paste(i, o, this._results, r))
                },
                replace: function(t, e, i, o, s, n, r) {
                    if (r = this.getLayer(r), this.copy(i, o, s, n, r), !(this._results.length < 2)) {
                        for (var a = 1; a < this._results.length; a++) this._results[a].index === t && (this._results[a].index = e);
                        this.paste(i, o, this._results, r)
                    }
                },
                random: function(t, e, i, o, s) {
                    if (s = this.getLayer(s), this.copy(t, e, i, o, s), !(this._results.length < 2)) {
                        for (var n = [], r = 1; r < this._results.length; r++)
                            if (this._results[r].index) {
                                var a = this._results[r].index; - 1 === n.indexOf(a) && n.push(a)
                            }
                        for (var h = 1; h < this._results.length; h++) this._results[h].index = this.game.rnd.pick(n);
                        this.paste(t, e, this._results, s)
                    }
                },
                shuffle: function(t, e, o, s, n) {
                    if (n = this.getLayer(n), this.copy(t, e, o, s, n), !(this._results.length < 2)) {
                        for (var r = [], a = 1; a < this._results.length; a++) this._results[a].index && r.push(this._results[a].index);
                        i.ArrayUtils.shuffle(r);
                        for (var h = 1; h < this._results.length; h++) this._results[h].index = r[h - 1];
                        this.paste(t, e, this._results, n)
                    }
                },
                fill: function(t, e, i, o, s, n) {
                    if (n = this.getLayer(n), this.copy(e, i, o, s, n), !(this._results.length < 2)) {
                        for (var r = 1; r < this._results.length; r++) this._results[r].index = t;
                        this.paste(e, i, this._results, n)
                    }
                },
                removeAllLayers: function() {
                    this.layers.length = 0, this.currentLayer = 0
                },
                dump: function() {
                    for (var t = "", e = [""], i = 0; i < this.layers[this.currentLayer].height; i++) {
                        for (var o = 0; o < this.layers[this.currentLayer].width; o++) t += "%c  ", this.layers[this.currentLayer].data[i][o] > 1 ? this.debugMap[this.layers[this.currentLayer].data[i][o]] ? e.push("background: " + this.debugMap[this.layers[this.currentLayer].data[i][o]]) : e.push("background: #ffffff") : e.push("background: rgb(0, 0, 0)");
                        t += "\n"
                    }
                    e[0] = t, console.log.apply(console, e)
                },
                destroy: function() {
                    this.removeAllLayers(), this.data = [], this.game = null
                }
            }, i.Tilemap.prototype.constructor = i.Tilemap, Object.defineProperty(i.Tilemap.prototype, "layer", {
                get: function() {
                    return this.layers[this.currentLayer]
                },
                set: function(t) {
                    t !== this.currentLayer && this.setLayer(t)
                }
            }), i.TilemapLayer = function(t, e, o, s, n) {
                s |= 0, n |= 0, i.Sprite.call(this, t, 0, 0), this.map = e, this.index = o, this.layer = e.layers[o], this.canvas = PIXI.CanvasPool.create(this, s, n), this.context = this.canvas.getContext("2d"), this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))), this.type = i.TILEMAPLAYER, this.physicsType = i.TILEMAPLAYER, this.renderSettings = {
                    enableScrollDelta: !1,
                    overdrawRatio: .2,
                    copyCanvas: null
                }, this.debug = !1, this.exists = !0, this.debugSettings = {
                    missingImageFill: "rgb(255,255,255)",
                    debuggedTileOverfill: "rgba(0,255,0,0.4)",
                    forceFullRedraw: !0,
                    debugAlpha: .5,
                    facingEdgeStroke: "rgba(0,255,0,1)",
                    collidingTileOverfill: "rgba(0,255,0,0.2)"
                }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, this._wrap = !1, this._mc = {
                    scrollX: 0,
                    scrollY: 0,
                    renderWidth: 0,
                    renderHeight: 0,
                    tileWidth: e.tileWidth,
                    tileHeight: e.tileHeight,
                    cw: e.tileWidth,
                    ch: e.tileHeight,
                    tilesets: []
                }, this._scrollX = 0, this._scrollY = 0, this._results = [], t.device.canvasBitBltShift || (this.renderSettings.copyCanvas = i.TilemapLayer.ensureSharedCopyCanvas())
            }, i.TilemapLayer.prototype = Object.create(i.Sprite.prototype), i.TilemapLayer.prototype.constructor = i.TilemapLayer, i.TilemapLayer.prototype.preUpdateCore = i.Component.Core.preUpdate, i.TilemapLayer.sharedCopyCanvas = null, i.TilemapLayer.ensureSharedCopyCanvas = function() {
                return this.sharedCopyCanvas || (this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2)), this.sharedCopyCanvas
            }, i.TilemapLayer.prototype.preUpdate = function() {
                return this.preUpdateCore()
            }, i.TilemapLayer.prototype.postUpdate = function() {
                this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y
            }, i.TilemapLayer.prototype._renderCanvas = function(t) {
                this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderCanvas.call(this, t)
            }, i.TilemapLayer.prototype._renderWebGL = function(t) {
                this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderWebGL.call(this, t)
            }, i.TilemapLayer.prototype.destroy = function() {
                PIXI.CanvasPool.remove(this), i.Component.Destroy.prototype.destroy.call(this)
            }, i.TilemapLayer.prototype.resize = function(t, e) {
                this.canvas.width = t, this.canvas.height = e, this.texture.frame.resize(t, e), this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.texture.baseTexture.width = t, this.texture.baseTexture.height = e, this.texture.baseTexture.dirty(), this.texture.requiresUpdate = !0, this.texture._updateUvs(), this.dirty = !0
            }, i.TilemapLayer.prototype.resizeWorld = function() {
                this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y)
            }, i.TilemapLayer.prototype._fixX = function(t) {
                return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? t : 0 === this.scrollFactorX && 0 !== this.position.x ? t - this.position.x : this._scrollX + (t - this._scrollX / this.scrollFactorX)
            }, i.TilemapLayer.prototype._unfixX = function(t) {
                return 1 === this.scrollFactorX ? t : this._scrollX / this.scrollFactorX + (t - this._scrollX)
            }, i.TilemapLayer.prototype._fixY = function(t) {
                return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? t : 0 === this.scrollFactorY && 0 !== this.position.y ? t - this.position.y : this._scrollY + (t - this._scrollY / this.scrollFactorY)
            }, i.TilemapLayer.prototype._unfixY = function(t) {
                return 1 === this.scrollFactorY ? t : this._scrollY / this.scrollFactorY + (t - this._scrollY)
            }, i.TilemapLayer.prototype.getTileX = function(t) {
                return Math.floor(this._fixX(t) / this._mc.tileWidth)
            }, i.TilemapLayer.prototype.getTileY = function(t) {
                return Math.floor(this._fixY(t) / this._mc.tileHeight)
            }, i.TilemapLayer.prototype.getTileXY = function(t, e, i) {
                return i.x = this.getTileX(t), i.y = this.getTileY(e), i
            }, i.TilemapLayer.prototype.getRayCastTiles = function(t, e, i, o) {
                e || (e = this.rayStepRate), void 0 === i && (i = !1), void 0 === o && (o = !1);
                var s = this.getTiles(t.x, t.y, t.width, t.height, i, o);
                if (0 === s.length) return [];
                for (var n = t.coordinatesOnLine(e), r = [], a = 0; a < s.length; a++)
                    for (var h = 0; h < n.length; h++) {
                        var l = s[a],
                            d = n[h];
                        if (l.containsPoint(d[0], d[1])) {
                            r.push(l);
                            break
                        }
                    }
                return r
            }, i.TilemapLayer.prototype.getTiles = function(t, e, i, o, s, n) {
                void 0 === s && (s = !1), void 0 === n && (n = !1);
                var r = !(s || n);
                t = this._fixX(t), e = this._fixY(e);
                for (var a = Math.floor(t / (this._mc.cw * this.scale.x)), h = Math.floor(e / (this._mc.ch * this.scale.y)), l = Math.ceil((t + i) / (this._mc.cw * this.scale.x)) - a, d = Math.ceil((e + o) / (this._mc.ch * this.scale.y)) - h; this._results.length;) this._results.pop();
                for (var c = h; c < h + d; c++)
                    for (var p = a; p < a + l; p++) {
                        var u = this.layer.data[c];
                        u && u[p] && (r || u[p].isInteresting(s, n)) && this._results.push(u[p])
                    }
                return this._results.slice()
            }, i.TilemapLayer.prototype.resolveTileset = function(t) {
                var e = this._mc.tilesets;
                if (t < 2e3)
                    for (; e.length < t;) e.push(void 0);
                var i = this.map.tiles[t] && this.map.tiles[t][2];
                if (null !== i) {
                    var o = this.map.tilesets[i];
                    if (o && o.containsTileIndex(t)) return e[t] = o
                }
                return e[t] = null
            }, i.TilemapLayer.prototype.resetTilesetCache = function() {
                for (var t = this._mc.tilesets; t.length;) t.pop()
            }, i.TilemapLayer.prototype.setScale = function(t, e) {
                t = t || 1, e = e || t;
                for (var i = 0; i < this.layer.data.length; i++)
                    for (var o = this.layer.data[i], s = 0; s < o.length; s++) {
                        var n = o[s];
                        n.width = this.map.tileWidth * t, n.height = this.map.tileHeight * e, n.worldX = n.x * n.width, n.worldY = n.y * n.height
                    }
                this.scale.setTo(t, e)
            }, i.TilemapLayer.prototype.shiftCanvas = function(t, e, i) {
                var o = t.canvas,
                    s = o.width - Math.abs(e),
                    n = o.height - Math.abs(i),
                    r = 0,
                    a = 0,
                    h = e,
                    l = i;
                e < 0 && (r = -e, h = 0), i < 0 && (a = -i, l = 0);
                var d = this.renderSettings.copyCanvas;
                if (d) {
                    (d.width < s || d.height < n) && (d.width = s, d.height = n);
                    var c = d.getContext("2d");
                    c.clearRect(0, 0, s, n), c.drawImage(o, r, a, s, n, 0, 0, s, n), t.clearRect(h, l, s, n), t.drawImage(d, 0, 0, s, n, h, l, s, n)
                } else t.save(), t.globalCompositeOperation = "copy", t.drawImage(o, r, a, s, n, h, l, s, n), t.restore()
            }, i.TilemapLayer.prototype.renderRegion = function(t, e, i, o, s, n) {
                var r = this.context,
                    a = this.layer.width,
                    h = this.layer.height,
                    l = this._mc.tileWidth,
                    d = this._mc.tileHeight,
                    c = this._mc.tilesets,
                    p = NaN;
                this._wrap || (i <= s && (i = Math.max(0, i), s = Math.min(a - 1, s)), o <= n && (o = Math.max(0, o), n = Math.min(h - 1, n)));
                var u, b, m, y, f, g, x = i * l - t,
                    _ = o * d - e,
                    v = (i + (1 << 20) * a) % a,
                    w = (o + (1 << 20) * h) % h;
                for (y = w, g = n - o, b = _; g >= 0; y++, g--, b += d) {
                    y >= h && (y -= h);
                    var C = this.layer.data[y];
                    for (m = v, f = s - i, u = x; f >= 0; m++, f--, u += l) {
                        m >= a && (m -= a);
                        var S = C[m];
                        if (S && !(S.index < 0)) {
                            var A = S.index,
                                T = c[A];
                            void 0 === T && (T = this.resolveTileset(A)), S.alpha === p || this.debug || (r.globalAlpha = S.alpha, p = S.alpha), T ? S.rotation || S.flipped ? (r.save(), r.translate(u + S.centerX, b + S.centerY), r.rotate(S.rotation), S.flipped && r.scale(-1, 1), T.draw(r, -S.centerX, -S.centerY, A), r.restore()) : T.draw(r, u, b, A) : this.debugSettings.missingImageFill && (r.fillStyle = this.debugSettings.missingImageFill, r.fillRect(u, b, l, d)), S.debug && this.debugSettings.debuggedTileOverfill && (r.fillStyle = this.debugSettings.debuggedTileOverfill, r.fillRect(u, b, l, d))
                        }
                    }
                }
            }, i.TilemapLayer.prototype.renderDeltaScroll = function(t, e) {
                var i = this._mc.scrollX,
                    o = this._mc.scrollY,
                    s = this.canvas.width,
                    n = this.canvas.height,
                    r = this._mc.tileWidth,
                    a = this._mc.tileHeight,
                    h = 0,
                    l = -r,
                    d = 0,
                    c = -a;
                if (t < 0 ? (h = s + t, l = s - 1) : t > 0 && (l = t), e < 0 ? (d = n + e, c = n - 1) : e > 0 && (c = e), this.shiftCanvas(this.context, t, e), h = Math.floor((h + i) / r), l = Math.floor((l + i) / r), d = Math.floor((d + o) / a), c = Math.floor((c + o) / a), h <= l) {
                    this.context.clearRect(h * r - i, 0, (l - h + 1) * r, n);
                    var p = Math.floor((0 + o) / a),
                        u = Math.floor((n - 1 + o) / a);
                    this.renderRegion(i, o, h, p, l, u)
                }
                if (d <= c) {
                    this.context.clearRect(0, d * a - o, s, (c - d + 1) * a);
                    var b = Math.floor((0 + i) / r),
                        m = Math.floor((s - 1 + i) / r);
                    this.renderRegion(i, o, b, d, m, c)
                }
            }, i.TilemapLayer.prototype.renderFull = function() {
                var t = this._mc.scrollX,
                    e = this._mc.scrollY,
                    i = this.canvas.width,
                    o = this.canvas.height,
                    s = this._mc.tileWidth,
                    n = this._mc.tileHeight,
                    r = Math.floor(t / s),
                    a = Math.floor((i - 1 + t) / s),
                    h = Math.floor(e / n),
                    l = Math.floor((o - 1 + e) / n);
                this.context.clearRect(0, 0, i, o), this.renderRegion(t, e, r, h, a, l)
            }, i.TilemapLayer.prototype.render = function() {
                var t = !1;
                if (this.visible) {
                    (this.dirty || this.layer.dirty) && (this.layer.dirty = !1, t = !0);
                    var e = this.canvas.width,
                        i = this.canvas.height,
                        o = 0 | this._scrollX,
                        s = 0 | this._scrollY,
                        n = this._mc,
                        r = n.scrollX - o,
                        a = n.scrollY - s;
                    if (t || 0 !== r || 0 !== a || n.renderWidth !== e || n.renderHeight !== i) return this.context.save(), n.scrollX = o, n.scrollY = s, n.renderWidth === e && n.renderHeight === i || (n.renderWidth = e, n.renderHeight = i), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, this.debugSettings.forceFullRedraw && (t = !0)), !t && this.renderSettings.enableScrollDelta && Math.abs(r) + Math.abs(a) < Math.min(e, i) ? this.renderDeltaScroll(r, a) : this.renderFull(), this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.texture.baseTexture.dirty(), this.dirty = !1, this.context.restore(), !0
                }
            }, i.TilemapLayer.prototype.renderDebug = function() {
                var t, e, i, o, s, n, r = this._mc.scrollX,
                    a = this._mc.scrollY,
                    h = this.context,
                    l = this.canvas.width,
                    d = this.canvas.height,
                    c = this.layer.width,
                    p = this.layer.height,
                    u = this._mc.tileWidth,
                    b = this._mc.tileHeight,
                    m = Math.floor(r / u),
                    y = Math.floor((l - 1 + r) / u),
                    f = Math.floor(a / b),
                    g = Math.floor((d - 1 + a) / b),
                    x = m * u - r,
                    _ = f * b - a,
                    v = (m + (1 << 20) * c) % c,
                    w = (f + (1 << 20) * p) % p;
                for (h.strokeStyle = this.debugSettings.facingEdgeStroke, o = w, n = g - f, e = _; n >= 0; o++, n--, e += b) {
                    o >= p && (o -= p);
                    var C = this.layer.data[o];
                    for (i = v, s = y - m, t = x; s >= 0; i++, s--, t += u) {
                        i >= c && (i -= c);
                        var S = C[i];
                        !S || S.index < 0 || !S.collides || (this.debugSettings.collidingTileOverfill && (h.fillStyle = this.debugSettings.collidingTileOverfill, h.fillRect(t, e, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (h.beginPath(), S.faceTop && (h.moveTo(t, e), h.lineTo(t + this._mc.cw, e)), S.faceBottom && (h.moveTo(t, e + this._mc.ch), h.lineTo(t + this._mc.cw, e + this._mc.ch)), S.faceLeft && (h.moveTo(t, e), h.lineTo(t, e + this._mc.ch)), S.faceRight && (h.moveTo(t + this._mc.cw, e), h.lineTo(t + this._mc.cw, e + this._mc.ch)), h.closePath(), h.stroke()))
                    }
                }
            }, Object.defineProperty(i.TilemapLayer.prototype, "wrap", {
                get: function() {
                    return this._wrap
                },
                set: function(t) {
                    this._wrap = t, this.dirty = !0
                }
            }), Object.defineProperty(i.TilemapLayer.prototype, "scrollX", {
                get: function() {
                    return this._scrollX
                },
                set: function(t) {
                    this._scrollX = t
                }
            }), Object.defineProperty(i.TilemapLayer.prototype, "scrollY", {
                get: function() {
                    return this._scrollY
                },
                set: function(t) {
                    this._scrollY = t
                }
            }), Object.defineProperty(i.TilemapLayer.prototype, "collisionWidth", {
                get: function() {
                    return this._mc.cw
                },
                set: function(t) {
                    this._mc.cw = 0 | t, this.dirty = !0
                }
            }), Object.defineProperty(i.TilemapLayer.prototype, "collisionHeight", {
                get: function() {
                    return this._mc.ch
                },
                set: function(t) {
                    this._mc.ch = 0 | t, this.dirty = !0
                }
            }), i.TilemapParser = {
                INSERT_NULL: !1,
                parse: function(t, e, o, s, n, r) {
                    if (void 0 === o && (o = 32), void 0 === s && (s = 32), void 0 === n && (n = 10), void 0 === r && (r = 10), void 0 === e) return this.getEmptyData();
                    if (null === e) return this.getEmptyData(o, s, n, r);
                    var a = t.cache.getTilemapData(e);
                    if (a) {
                        if (a.format === i.Tilemap.CSV) return this.parseCSV(e, a.data, o, s);
                        if (!a.format || a.format === i.Tilemap.TILED_JSON) return this.parseTiledJSON(a.data)
                    } else console.warn("Phaser.TilemapParser.parse - No map data found for key " + e)
                },
                parseCSV: function(t, e, o, s) {
                    var n = this.getEmptyData();
                    e = e.trim();
                    for (var r = [], a = e.split("\n"), h = a.length, l = 0, d = 0; d < a.length; d++) {
                        r[d] = [];
                        for (var c = a[d].split(","), p = 0; p < c.length; p++) r[d][p] = new i.Tile(n.layers[0], parseInt(c[p], 10), p, d, o, s);
                        0 === l && (l = c.length)
                    }
                    return n.format = i.Tilemap.CSV, n.name = t, n.width = l, n.height = h, n.tileWidth = o, n.tileHeight = s, n.widthInPixels = l * o, n.heightInPixels = h * s, n.layers[0].width = l, n.layers[0].height = h, n.layers[0].widthInPixels = n.widthInPixels, n.layers[0].heightInPixels = n.heightInPixels, n.layers[0].data = r, n
                },
                getEmptyData: function(t, e, i, o) {
                    return {
                        width: void 0 !== i && null !== i ? i : 0,
                        height: void 0 !== o && null !== o ? o : 0,
                        tileWidth: void 0 !== t && null !== t ? t : 0,
                        tileHeight: void 0 !== e && null !== e ? e : 0,
                        orientation: "orthogonal",
                        version: "1",
                        properties: {},
                        widthInPixels: 0,
                        heightInPixels: 0,
                        layers: [{
                            name: "layer",
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0,
                            widthInPixels: 0,
                            heightInPixels: 0,
                            alpha: 1,
                            visible: !0,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: [],
                            data: []
                        }],
                        images: [],
                        objects: {},
                        collision: {},
                        tilesets: [],
                        tiles: []
                    }
                },
                parseTiledJSON: function(t) {
                    function e(t, e) {
                        var i = {};
                        for (var o in e) {
                            var s = e[o];
                            void 0 !== t[s] && (i[s] = t[s])
                        }
                        return i
                    }
                    if ("orthogonal" !== t.orientation) return console.warn("TilemapParser.parseTiledJSON - Only orthogonal map types are supported in this version of Phaser"), null;
                    for (var o = {
                            width: t.width,
                            height: t.height,
                            tileWidth: t.tilewidth,
                            tileHeight: t.tileheight,
                            orientation: t.orientation,
                            format: i.Tilemap.TILED_JSON,
                            version: t.version,
                            properties: t.properties,
                            widthInPixels: t.width * t.tilewidth,
                            heightInPixels: t.height * t.tileheight
                        }, s = [], n = 0; n < t.layers.length; n++)
                        if ("tilelayer" === t.layers[n].type) {
                            var r = t.layers[n];
                            if (!r.compression && r.encoding && "base64" === r.encoding) {
                                for (var a = window.atob(r.data), h = a.length, l = new Array(h), d = 0; d < h; d += 4) l[d / 4] = (a.charCodeAt(d) | a.charCodeAt(d + 1) << 8 | a.charCodeAt(d + 2) << 16 | a.charCodeAt(d + 3) << 24) >>> 0;
                                r.data = l, delete r.encoding
                            } else if (r.compression) {
                                console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + r.name + "'");
                                continue
                            }
                            var c = {
                                name: r.name,
                                x: r.x,
                                y: r.y,
                                width: r.width,
                                height: r.height,
                                widthInPixels: r.width * t.tilewidth,
                                heightInPixels: r.height * t.tileheight,
                                alpha: r.opacity,
                                visible: r.visible,
                                properties: {},
                                indexes: [],
                                callbacks: [],
                                bodies: []
                            };
                            r.properties && (c.properties = r.properties);
                            for (var p, u, b, m, y = 0, f = [], g = [], x = 0, h = r.data.length; x < h; x++) {
                                if (p = 0, u = !1, m = r.data[x], b = 0, m > 536870912) switch (m > 2147483648 && (m -= 2147483648, b += 4), m > 1073741824 && (m -= 1073741824, b += 2), m > 536870912 && (m -= 536870912, b += 1), b) {
                                    case 5:
                                        p = Math.PI / 2;
                                        break;
                                    case 6:
                                        p = Math.PI;
                                        break;
                                    case 3:
                                        p = 3 * Math.PI / 2;
                                        break;
                                    case 4:
                                        p = 0, u = !0;
                                        break;
                                    case 7:
                                        p = Math.PI / 2, u = !0;
                                        break;
                                    case 2:
                                        p = Math.PI, u = !0;
                                        break;
                                    case 1:
                                        p = 3 * Math.PI / 2, u = !0
                                }
                                if (m > 0) {
                                    var _ = new i.Tile(c, m, y, g.length, t.tilewidth, t.tileheight);
                                    _.rotation = p, _.flipped = u, 0 !== b && (_.flippedVal = b), f.push(_)
                                } else i.TilemapParser.INSERT_NULL ? f.push(null) : f.push(new i.Tile(c, -1, y, g.length, t.tilewidth, t.tileheight));
                                y++, y === r.width && (g.push(f), y = 0, f = [])
                            }
                            c.data = g, s.push(c)
                        }
                    o.layers = s;
                    for (var v = [], n = 0; n < t.layers.length; n++)
                        if ("imagelayer" === t.layers[n].type) {
                            var w = t.layers[n],
                                C = {
                                    name: w.name,
                                    image: w.image,
                                    x: w.x,
                                    y: w.y,
                                    alpha: w.opacity,
                                    visible: w.visible,
                                    properties: {}
                                };
                            w.properties && (C.properties = w.properties), v.push(C)
                        }
                    o.images = v;
                    for (var S = [], A = [], T = null, n = 0; n < t.tilesets.length; n++) {
                        var P = t.tilesets[n];
                        if (P.image) {
                            var B = new i.Tileset(P.name, P.firstgid, P.tilewidth, P.tileheight, P.margin, P.spacing, P.properties);
                            P.tileproperties && (B.tileProperties = P.tileproperties), B.updateTileData(P.imagewidth, P.imageheight), S.push(B)
                        } else {
                            var M = new i.ImageCollection(P.name, P.firstgid, P.tilewidth, P.tileheight, P.margin, P.spacing, P.properties);
                            for (var I in P.tiles) {
                                var C = P.tiles[I].image,
                                    m = P.firstgid + parseInt(I, 10);
                                M.addImage(m, C)
                            }
                            A.push(M)
                        }
                        T && (T.lastgid = P.firstgid - 1), T = P
                    }
                    o.tilesets = S, o.imagecollections = A;
                    for (var R = {}, D = {}, n = 0; n < t.layers.length; n++)
                        if ("objectgroup" === t.layers[n].type) {
                            var k = t.layers[n];
                            R[k.name] = [], D[k.name] = [];
                            for (var V = 0, h = k.objects.length; V < h; V++)
                                if (k.objects[V].gid) {
                                    var E = {
                                        gid: k.objects[V].gid,
                                        name: k.objects[V].name,
                                        type: k.objects[V].hasOwnProperty("type") ? k.objects[V].type : "",
                                        x: k.objects[V].x,
                                        y: k.objects[V].y,
                                        visible: k.objects[V].visible,
                                        properties: k.objects[V].properties
                                    };
                                    k.objects[V].rotation && (E.rotation = k.objects[V].rotation), R[k.name].push(E)
                                } else if (k.objects[V].polyline) {
                                var E = {
                                    name: k.objects[V].name,
                                    type: k.objects[V].type,
                                    x: k.objects[V].x,
                                    y: k.objects[V].y,
                                    width: k.objects[V].width,
                                    height: k.objects[V].height,
                                    visible: k.objects[V].visible,
                                    properties: k.objects[V].properties
                                };
                                k.objects[V].rotation && (E.rotation = k.objects[V].rotation), E.polyline = [];
                                for (var L = 0; L < k.objects[V].polyline.length; L++) E.polyline.push([k.objects[V].polyline[L].x, k.objects[V].polyline[L].y]);
                                D[k.name].push(E), R[k.name].push(E)
                            } else if (k.objects[V].polygon) {
                                var E = e(k.objects[V], ["name", "type", "x", "y", "visible", "rotation", "properties"]);
                                E.polygon = [];
                                for (var L = 0; L < k.objects[V].polygon.length; L++) E.polygon.push([k.objects[V].polygon[L].x, k.objects[V].polygon[L].y]);
                                R[k.name].push(E)
                            } else if (k.objects[V].ellipse) {
                                var E = e(k.objects[V], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                                R[k.name].push(E)
                            } else {
                                var E = e(k.objects[V], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                                E.rectangle = !0, R[k.name].push(E)
                            }
                        }
                    o.objects = R, o.collision = D, o.tiles = [];
                    for (var n = 0; n < o.tilesets.length; n++)
                        for (var P = o.tilesets[n], y = P.tileMargin, F = P.tileMargin, O = 0, G = 0, U = 0, x = P.firstgid; x < P.firstgid + P.total && (o.tiles[x] = [y, F, n], y += P.tileWidth + P.tileSpacing, ++O !== P.total) && (++G !== P.columns || (y = P.tileMargin, F += P.tileHeight + P.tileSpacing, G = 0, ++U !== P.rows)); x++);
                    for (var c, _, N, P, n = 0; n < o.layers.length; n++) {
                        c = o.layers[n], P = null;
                        for (var d = 0; d < c.data.length; d++) {
                            f = c.data[d];
                            for (var W = 0; W < f.length; W++) null === (_ = f[W]) || _.index < 0 || (N = o.tiles[_.index][2], P = o.tilesets[N], P.tileProperties && P.tileProperties[_.index - P.firstgid] && (_.properties = i.Utils.mixin(P.tileProperties[_.index - P.firstgid], _.properties)))
                        }
                    }
                    return o
                }
            }, i.Tileset = function(t, e, i, o, s, n, r) {
                (void 0 === i || i <= 0) && (i = 32), (void 0 === o || o <= 0) && (o = 32), void 0 === s && (s = 0), void 0 === n && (n = 0), this.name = t, this.firstgid = 0 | e, this.tileWidth = 0 | i, this.tileHeight = 0 | o, this.tileMargin = 0 | s, this.tileSpacing = 0 | n, this.properties = r || {}, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = []
            }, i.Tileset.prototype = {
                draw: function(t, e, i, o) {
                    var s = o - this.firstgid << 1;
                    s >= 0 && s + 1 < this.drawCoords.length && t.drawImage(this.image, this.drawCoords[s], this.drawCoords[s + 1], this.tileWidth, this.tileHeight, e, i, this.tileWidth, this.tileHeight)
                },
                containsTileIndex: function(t) {
                    return t >= this.firstgid && t < this.firstgid + this.total
                },
                setImage: function(t) {
                    this.image = t, this.updateTileData(t.width, t.height)
                },
                setSpacing: function(t, e) {
                    this.tileMargin = 0 | t, this.tileSpacing = 0 | e, this.image && this.updateTileData(this.image.width, this.image.height)
                },
                updateTileData: function(t, e) {
                    var i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing),
                        o = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
                    i % 1 == 0 && o % 1 == 0 || console.warn("Phaser.Tileset - " + this.name + " image tile area is not an even multiple of tile size"), i = Math.floor(i), o = Math.floor(o), (this.rows && this.rows !== i || this.columns && this.columns !== o) && console.warn("Phaser.Tileset - actual and expected number of tile rows and columns differ"), this.rows = i, this.columns = o, this.total = i * o, this.drawCoords.length = 0;
                    for (var s = this.tileMargin, n = this.tileMargin, r = 0; r < this.rows; r++) {
                        for (var a = 0; a < this.columns; a++) this.drawCoords.push(s), this.drawCoords.push(n), s += this.tileWidth + this.tileSpacing;
                        s = this.tileMargin, n += this.tileHeight + this.tileSpacing
                    }
                }
            }, i.Tileset.prototype.constructor = i.Tileset, i.Particle = function(t, e, o, s, n) {
                i.Sprite.call(this, t, e, o, s, n), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0
            }, i.Particle.prototype = Object.create(i.Sprite.prototype), i.Particle.prototype.constructor = i.Particle, i.Particle.prototype.update = function() {
                this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
            }, i.Particle.prototype.onEmit = function() {}, i.Particle.prototype.setAlphaData = function(t) {
                this.alphaData = t, this._a = t.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0
            }, i.Particle.prototype.setScaleData = function(t) {
                this.scaleData = t, this._s = t.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0
            }, i.Particle.prototype.reset = function(t, e, o) {
                return i.Component.Reset.prototype.reset.call(this, t, e, o), this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this
            }, i.Particles = function(t) {
                this.game = t, this.emitters = {}, this.ID = 0
            }, i.Particles.prototype = {
                add: function(t) {
                    return this.emitters[t.name] = t, t
                },
                remove: function(t) {
                    delete this.emitters[t.name]
                },
                update: function() {
                    for (var t in this.emitters) this.emitters[t].exists && this.emitters[t].update()
                }
            }, i.Particles.prototype.constructor = i.Particles, i.Particles.Arcade = {}, i.Particles.Arcade.Emitter = function(t, e, o, s) {
                this.maxParticles = s || 50, i.Group.call(this, t), this.name = "emitter" + this.game.particles.ID++, this.type = i.EMITTER, this.physicsType = i.GROUP, this.area = new i.Rectangle(e, o, 1, 1), this.minParticleSpeed = new i.Point(-100, -100), this.maxParticleSpeed = new i.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.gravity = 100, this.particleClass = i.Particle, this.particleDrag = new i.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new i.Point, this.on = !1, this.particleAnchor = new i.Point(.5, .5), this.blendMode = i.blendModes.NORMAL, this.emitX = e, this.emitY = o, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this._minParticleScale = new i.Point(1, 1), this._maxParticleScale = new i.Point(1, 1), this._quantity = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, this._flowTotal = 0, this._explode = !0, this._frames = null
            }, i.Particles.Arcade.Emitter.prototype = Object.create(i.Group.prototype), i.Particles.Arcade.Emitter.prototype.constructor = i.Particles.Arcade.Emitter, i.Particles.Arcade.Emitter.prototype.update = function() {
                if (this.on && this.game.time.time >= this._timer)
                    if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal)
                        if (this._flowQuantity > 0) {
                            for (var t = 0; t < this._flowQuantity; t++)
                                if (this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                                    this.on = !1;
                                    break
                                }
                        } else this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1));
                else this.emitParticle() && (this._counter++, this._quantity > 0 && this._counter >= this._quantity && (this.on = !1));
                var t = this.children.length;
                for (this.visible = this.exists = !1; t--;) this.children[t].exists && (this.visible = this.exists = !0, this.children[t].update())
            },
            i.Particles.Arcade.Emitter.prototype.makeParticles = function(t, e, i, o, s) {
                void 0 === e && (e = 0), void 0 === i && (i = this.maxParticles), void 0 === o && (o = !1), void 0 === s && (s = !1);
                var n, r = 0,
                    a = t,
                    h = e;
                for (this._frames = e, i > this.maxParticles && (this.maxParticles = i); r < i;) Array.isArray(t) && (a = this.game.rnd.pick(t)), Array.isArray(e) && (h = this.game.rnd.pick(e)), n = new this.particleClass(this.game, 0, 0, a, h), this.game.physics.arcade.enable(n, !1), o ? (n.body.checkCollision.any = !0, n.body.checkCollision.none = !1) : n.body.checkCollision.none = !0, n.body.collideWorldBounds = s, n.body.skipQuadTree = !0, n.exists = !1, n.visible = !1, n.anchor.copyFrom(this.particleAnchor), this.add(n), r++;
                return this
            }, i.Particles.Arcade.Emitter.prototype.kill = function() {
                return this.on = !1, this.alive = !1, this.exists = !1, this
            }, i.Particles.Arcade.Emitter.prototype.revive = function() {
                return this.alive = !0, this.exists = !0, this
            }, i.Particles.Arcade.Emitter.prototype.explode = function(t, e) {
                return this._flowTotal = 0, this.start(!0, t, 0, e, !1), this
            }, i.Particles.Arcade.Emitter.prototype.flow = function(t, e, i, o, s) {
                return void 0 !== i && 0 !== i || (i = 1), void 0 === o && (o = -1), void 0 === s && (s = !0), i > this.maxParticles && (i = this.maxParticles), this._counter = 0, this._flowQuantity = i, this._flowTotal = o, s ? (this.start(!0, t, e, i), this._counter += i, this.on = !0, this._timer = this.game.time.time + e * this.game.time.slowMotion) : this.start(!1, t, e, i), this
            }, i.Particles.Arcade.Emitter.prototype.start = function(t, e, i, o, s) {
                if (void 0 === t && (t = !0), void 0 === e && (e = 0), void 0 !== i && null !== i || (i = 250), void 0 === o && (o = 0), void 0 === s && (s = !1), o > this.maxParticles && (o = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = e, this.frequency = i, t || s)
                    for (var n = 0; n < o; n++) this.emitParticle();
                else this.on = !0, this._quantity = o, this._counter = 0, this._timer = this.game.time.time + i * this.game.time.slowMotion;
                return this
            }, i.Particles.Arcade.Emitter.prototype.emitParticle = function(t, e, i, o) {
                void 0 === t && (t = null), void 0 === e && (e = null);
                var s = this.getFirstExists(!1);
                if (null === s) return !1;
                var n = this.game.rnd;
                void 0 !== i && void 0 !== o ? s.loadTexture(i, o) : void 0 !== i && s.loadTexture(i);
                var r = this.emitX,
                    a = this.emitY;
                null !== t ? r = t : this.width > 1 && (r = n.between(this.left, this.right)), null !== e ? a = e : this.height > 1 && (a = n.between(this.top, this.bottom)), s.reset(r, a), s.angle = 0, s.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(s) : this.particleSendToBack && this.sendToBack(s), this.autoScale ? s.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? s.scale.set(n.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y || s.scale.set(n.realInRange(this._minParticleScale.x, this._maxParticleScale.x), n.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), void 0 === o && (Array.isArray(this._frames) ? s.frame = this.game.rnd.pick(this._frames) : s.frame = this._frames), this.autoAlpha ? s.setAlphaData(this.alphaData) : s.alpha = n.realInRange(this.minParticleAlpha, this.maxParticleAlpha), s.blendMode = this.blendMode;
                var h = s.body;
                return h.updateBounds(), h.bounce.copyFrom(this.bounce), h.drag.copyFrom(this.particleDrag), h.velocity.x = n.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), h.velocity.y = n.between(this.minParticleSpeed.y, this.maxParticleSpeed.y), h.angularVelocity = n.between(this.minRotation, this.maxRotation), h.gravity.y = this.gravity, h.angularDrag = this.angularDrag, s.onEmit(), !0
            }, i.Particles.Arcade.Emitter.prototype.destroy = function() {
                this.game.particles.remove(this), i.Group.prototype.destroy.call(this, !0, !1)
            }, i.Particles.Arcade.Emitter.prototype.setSize = function(t, e) {
                return this.area.width = t, this.area.height = e, this
            }, i.Particles.Arcade.Emitter.prototype.setXSpeed = function(t, e) {
                return t = t || 0, e = e || 0, this.minParticleSpeed.x = t, this.maxParticleSpeed.x = e, this
            }, i.Particles.Arcade.Emitter.prototype.setYSpeed = function(t, e) {
                return t = t || 0, e = e || 0, this.minParticleSpeed.y = t, this.maxParticleSpeed.y = e, this
            }, i.Particles.Arcade.Emitter.prototype.setRotation = function(t, e) {
                return t = t || 0, e = e || 0, this.minRotation = t, this.maxRotation = e, this
            }, i.Particles.Arcade.Emitter.prototype.setAlpha = function(t, e, o, s, n) {
                if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === o && (o = 0), void 0 === s && (s = i.Easing.Linear.None), void 0 === n && (n = !1), this.minParticleAlpha = t, this.maxParticleAlpha = e, this.autoAlpha = !1, o > 0 && t !== e) {
                    var r = {
                            v: t
                        },
                        a = this.game.make.tween(r).to({
                            v: e
                        }, o, s);
                    a.yoyo(n), this.alphaData = a.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0
                }
                return this
            }, i.Particles.Arcade.Emitter.prototype.setScale = function(t, e, o, s, n, r, a) {
                if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === o && (o = 1), void 0 === s && (s = 1), void 0 === n && (n = 0), void 0 === r && (r = i.Easing.Linear.None), void 0 === a && (a = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(t, o), this._maxParticleScale.set(e, s), this.autoScale = !1, n > 0 && (t !== e || o !== s)) {
                    var h = {
                            x: t,
                            y: o
                        },
                        l = this.game.make.tween(h).to({
                            x: e,
                            y: s
                        }, n, r);
                    l.yoyo(a), this.scaleData = l.generateData(60), this.scaleData.reverse(), this.autoScale = !0
                }
                return this
            }, i.Particles.Arcade.Emitter.prototype.at = function(t) {
                return t.center ? (this.emitX = t.center.x, this.emitY = t.center.y) : (this.emitX = t.world.x + t.anchor.x * t.width, this.emitY = t.world.y + t.anchor.y * t.height), this
            }, Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "width", {
                get: function() {
                    return this.area.width
                },
                set: function(t) {
                    this.area.width = t
                }
            }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "height", {
                get: function() {
                    return this.area.height
                },
                set: function(t) {
                    this.area.height = t
                }
            }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "x", {
                get: function() {
                    return this.emitX
                },
                set: function(t) {
                    this.emitX = t
                }
            }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "y", {
                get: function() {
                    return this.emitY
                },
                set: function(t) {
                    this.emitY = t
                }
            }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "left", {
                get: function() {
                    return Math.floor(this.x - this.area.width / 2)
                }
            }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "right", {
                get: function() {
                    return Math.floor(this.x + this.area.width / 2)
                }
            }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "top", {
                get: function() {
                    return Math.floor(this.y - this.area.height / 2)
                }
            }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "bottom", {
                get: function() {
                    return Math.floor(this.y + this.area.height / 2)
                }
            }), i.Weapon = function(t, e) {
                i.Plugin.call(this, t, e), this.bullets = null, this.autoExpandBulletsGroup = !1, this.autofire = !1, this.shots = 0, this.fireLimit = 0, this.fireRate = 100, this.fireRateVariance = 0, this.fireFrom = new i.Rectangle(0, 0, 1, 1), this.fireAngle = i.ANGLE_UP, this.bulletInheritSpriteSpeed = !1, this.bulletAnimation = "", this.bulletFrameRandom = !1, this.bulletFrameCycle = !1, this.bulletWorldWrap = !1, this.bulletWorldWrapPadding = 0, this.bulletAngleOffset = 0, this.bulletAngleVariance = 0, this.bulletSpeed = 200, this.bulletSpeedVariance = 0, this.bulletLifespan = 0, this.bulletKillDistance = 0, this.bulletGravity = new i.Point(0, 0), this.bulletRotateToVelocity = !1, this.bulletKey = "", this.bulletFrame = "", this._bulletClass = i.Bullet, this._bulletCollideWorldBounds = !1, this._bulletKillType = i.Weapon.KILL_WORLD_BOUNDS, this._data = {
                    customBody: !1,
                    width: 0,
                    height: 0,
                    offsetX: 0,
                    offsetY: 0
                }, this.bounds = new i.Rectangle, this.bulletBounds = t.world.bounds, this.bulletFrames = [], this.bulletFrameIndex = 0, this.anims = {}, this.onFire = new i.Signal, this.onKill = new i.Signal, this.onFireLimit = new i.Signal, this.trackedSprite = null, this.trackedPointer = null, this.trackRotation = !1, this.trackOffset = new i.Point, this._nextFire = 0, this._rotatedPoint = new i.Point
            }, i.Weapon.prototype = Object.create(i.Plugin.prototype), i.Weapon.prototype.constructor = i.Weapon, i.Weapon.KILL_NEVER = 0, i.Weapon.KILL_LIFESPAN = 1, i.Weapon.KILL_DISTANCE = 2, i.Weapon.KILL_WEAPON_BOUNDS = 3, i.Weapon.KILL_CAMERA_BOUNDS = 4, i.Weapon.KILL_WORLD_BOUNDS = 5, i.Weapon.KILL_STATIC_BOUNDS = 6, i.Weapon.prototype.createBullets = function(t, e, o, s) {
                return void 0 === t && (t = 1), void 0 === s && (s = this.game.world), this.bullets || (this.bullets = this.game.add.physicsGroup(i.Physics.ARCADE, s), this.bullets.classType = this._bulletClass), 0 !== t && (-1 === t && (this.autoExpandBulletsGroup = !0, t = 1), this.bullets.createMultiple(t, e, o), this.bullets.setAll("data.bulletManager", this), this.bulletKey = e, this.bulletFrame = o), this
            }, i.Weapon.prototype.forEach = function(t, e) {
                return this.bullets.forEachExists(t, e, arguments), this
            }, i.Weapon.prototype.pauseAll = function() {
                return this.bullets.setAll("body.enable", !1), this
            }, i.Weapon.prototype.resumeAll = function() {
                return this.bullets.setAll("body.enable", !0), this
            }, i.Weapon.prototype.killAll = function() {
                return this.bullets.callAllExists("kill", !0), this.bullets.setAll("body.enable", !0), this
            }, i.Weapon.prototype.resetShots = function(t) {
                return this.shots = 0, void 0 !== t && (this.fireLimit = t), this
            }, i.Weapon.prototype.destroy = function() {
                this.parent.remove(this, !1), this.bullets.destroy(), this.game = null, this.parent = null, this.active = !1, this.visible = !1
            }, i.Weapon.prototype.update = function() {
                this._bulletKillType === i.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(), this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)), this.autofire && this.fire()
            }, i.Weapon.prototype.trackSprite = function(t, e, i, o) {
                return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = !1), this.trackedPointer = null, this.trackedSprite = t, this.trackRotation = o, this.trackOffset.set(e, i), this
            }, i.Weapon.prototype.trackPointer = function(t, e, i) {
                return void 0 === t && (t = this.game.input.activePointer), void 0 === e && (e = 0), void 0 === i && (i = 0), this.trackedPointer = t, this.trackedSprite = null, this.trackRotation = !1, this.trackOffset.set(e, i), this
            }, i.Weapon.prototype.fire = function(t, e, o) {
                if (this.game.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit) return !1;
                var s = this.bulletSpeed;
                0 !== this.bulletSpeedVariance && (s += i.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)), t ? this.fireFrom.width > 1 ? this.fireFrom.centerOn(t.x, t.y) : (this.fireFrom.x = t.x, this.fireFrom.y = t.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y), this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.rotation), this.fireFrom.width > 1 ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x, this.fireFrom.y = this._rotatedPoint.y)) : this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y), this.bulletInheritSpriteSpeed && (s += this.trackedSprite.body.speed)) : this.trackedPointer && (this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y));
                var n = this.fireFrom.width > 1 ? this.fireFrom.randomX : this.fireFrom.x,
                    r = this.fireFrom.height > 1 ? this.fireFrom.randomY : this.fireFrom.y,
                    a = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
                void 0 !== e && void 0 !== o && (a = this.game.math.radToDeg(Math.atan2(o - r, e - n))), 0 !== this.bulletAngleVariance && (a += i.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance));
                var h = 0,
                    l = 0;
                0 === a || 180 === a ? h = Math.cos(this.game.math.degToRad(a)) * s : 90 === a || 270 === a ? l = Math.sin(this.game.math.degToRad(a)) * s : (h = Math.cos(this.game.math.degToRad(a)) * s, l = Math.sin(this.game.math.degToRad(a)) * s);
                var d = null;
                if (this.autoExpandBulletsGroup ? (d = this.bullets.getFirstExists(!1, !0, n, r, this.bulletKey, this.bulletFrame), d.data.bulletManager = this) : d = this.bullets.getFirstExists(!1), d) {
                    if (d.reset(n, r), d.data.fromX = n, d.data.fromY = r, d.data.killType = this.bulletKillType, d.data.killDistance = this.bulletKillDistance, d.data.rotateToVelocity = this.bulletRotateToVelocity, this.bulletKillType === i.Weapon.KILL_LIFESPAN && (d.lifespan = this.bulletLifespan), d.angle = a + this.bulletAngleOffset, "" !== this.bulletAnimation) {
                        if (null === d.animations.getAnimation(this.bulletAnimation)) {
                            var c = this.anims[this.bulletAnimation];
                            d.animations.add(c.name, c.frames, c.frameRate, c.loop, c.useNumericIndex)
                        }
                        d.animations.play(this.bulletAnimation)
                    } else this.bulletFrameCycle ? (d.frame = this.bulletFrames[this.bulletFrameIndex], ++this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (d.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]);
                    if (d.data.bodyDirty && (this._data.customBody && d.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY), d.body.collideWorldBounds = this.bulletCollideWorldBounds, d.data.bodyDirty = !1), d.body.velocity.set(h, l), d.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y), 0 !== this.bulletSpeedVariance) {
                        var p = this.fireRate;
                        p += i.Math.between(-this.fireRateVariance, this.fireRateVariance), p < 0 && (p = 0), this._nextFire = this.game.time.now + p
                    } else this._nextFire = this.game.time.now + this.fireRate;
                    this.shots++, this.onFire.dispatch(d, this, s), this.fireLimit > 0 && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit)
                }
                return d
            }, i.Weapon.prototype.fireAtPointer = function(t) {
                return void 0 === t && (t = this.game.input.activePointer), this.fire(null, t.worldX, t.worldY)
            }, i.Weapon.prototype.fireAtSprite = function(t) {
                return this.fire(null, t.world.x, t.world.y)
            }, i.Weapon.prototype.fireAtXY = function(t, e) {
                return this.fire(null, t, e)
            }, i.Weapon.prototype.setBulletBodyOffset = function(t, e, i, o) {
                return void 0 === i && (i = 0), void 0 === o && (o = 0), this._data.customBody = !0, this._data.width = t, this._data.height = e, this._data.offsetX = i, this._data.offsetY = o, this.bullets.callAll("body.setSize", "body", t, e, i, o), this.bullets.setAll("data.bodyDirty", !1), this
            }, i.Weapon.prototype.setBulletFrames = function(t, e, o, s) {
                return void 0 === o && (o = !0), void 0 === s && (s = !1), this.bulletFrames = i.ArrayUtils.numberArray(t, e), this.bulletFrameIndex = 0, this.bulletFrameCycle = o, this.bulletFrameRandom = s, this
            }, i.Weapon.prototype.addBulletAnimation = function(t, e, i, o, s) {
                return this.anims[t] = {
                    name: t,
                    frames: e,
                    frameRate: i,
                    loop: o,
                    useNumericIndex: s
                }, this.bullets.callAll("animations.add", "animations", t, e, i, o, s), this.bulletAnimation = t, this
            }, i.Weapon.prototype.debug = function(t, e, i) {
                void 0 === t && (t = 16), void 0 === e && (e = 32), void 0 === i && (i = !1), this.game.debug.text("Weapon Plugin", t, e), this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, t, e + 24), i && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)")
            }, Object.defineProperty(i.Weapon.prototype, "bulletClass", {
                get: function() {
                    return this._bulletClass
                },
                set: function(t) {
                    this._bulletClass = t, this.bullets.classType = this._bulletClass
                }
            }), Object.defineProperty(i.Weapon.prototype, "bulletKillType", {
                get: function() {
                    return this._bulletKillType
                },
                set: function(t) {
                    switch (t) {
                        case i.Weapon.KILL_STATIC_BOUNDS:
                        case i.Weapon.KILL_WEAPON_BOUNDS:
                            this.bulletBounds = this.bounds;
                            break;
                        case i.Weapon.KILL_CAMERA_BOUNDS:
                            this.bulletBounds = this.game.camera.view;
                            break;
                        case i.Weapon.KILL_WORLD_BOUNDS:
                            this.bulletBounds = this.game.world.bounds
                    }
                    this._bulletKillType = t
                }
            }), Object.defineProperty(i.Weapon.prototype, "bulletCollideWorldBounds", {
                get: function() {
                    return this._bulletCollideWorldBounds
                },
                set: function(t) {
                    this._bulletCollideWorldBounds = t, this.bullets.setAll("body.collideWorldBounds", t), this.bullets.setAll("data.bodyDirty", !1)
                }
            }), Object.defineProperty(i.Weapon.prototype, "x", {
                get: function() {
                    return this.fireFrom.x
                },
                set: function(t) {
                    this.fireFrom.x = t
                }
            }), Object.defineProperty(i.Weapon.prototype, "y", {
                get: function() {
                    return this.fireFrom.y
                },
                set: function(t) {
                    this.fireFrom.y = t
                }
            }), i.Bullet = function(t, e, o, s, n) {
                i.Sprite.call(this, t, e, o, s, n), this.anchor.set(.5), this.data = {
                    bulletManager: null,
                    fromX: 0,
                    fromY: 0,
                    bodyDirty: !0,
                    rotateToVelocity: !1,
                    killType: 0,
                    killDistance: 0
                }
            }, i.Bullet.prototype = Object.create(i.Sprite.prototype), i.Bullet.prototype.constructor = i.Bullet, i.Bullet.prototype.kill = function() {
                return this.alive = !1, this.exists = !1, this.visible = !1, this.data.bulletManager.onKill.dispatch(this), this
            }, i.Bullet.prototype.update = function() {
                this.exists && (this.data.killType > i.Weapon.KILL_LIFESPAN && (this.data.killType === i.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()), this.data.rotateToVelocity && (this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x)), this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding))
            }, i.Video = function(t, e, o) {
                if (void 0 === e && (e = null), void 0 === o && (o = null), this.game = t, this.key = e, this.width = 0, this.height = 0, this.type = i.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new i.Signal, this.onChangeSource = new i.Signal, this.onComplete = new i.Signal, this.onAccess = new i.Signal, this.onError = new i.Signal, this.onTimeout = new i.Signal, this.timeout = 15e3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, e && this.game.cache.checkVideoKey(e)) {
                    var s = this.game.cache.getVideo(e);
                    s.isBlob ? this.createVideoFromBlob(s.data) : this.video = s.data, this.width = this.video.videoWidth, this.height = this.video.videoHeight
                } else o && this.createVideoFromURL(o, !1);
                this.video && !o ? (this.baseTexture = new PIXI.BaseTexture(this.video), this.baseTexture.forceLoaded(this.width, this.height)) : (this.baseTexture = new PIXI.BaseTexture(i.Cache.DEFAULT.baseTexture.source), this.baseTexture.forceLoaded(this.width, this.height)), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new i.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), this.texture.valid = !1, null !== e && this.video && (this.texture.valid = this.video.canplay), this.snapshot = null, i.BitmapData && (this.snapshot = new i.BitmapData(this.game, "", this.width, this.height)), !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : s && (s.locked = !1)
            }, i.Video.prototype = {
                connectToMediaStream: function(t, e) {
                    return t && e && (this.video = t, this.videoStream = e, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this
                },
                startMediaStream: function(t, e, i) {
                    if (void 0 === t && (t = !1), void 0 === e && (e = null), void 0 === i && (i = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), !1;
                    null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), null !== e && (this.video.width = e), null !== i && (this.video.height = i), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
                    try {
                        navigator.getUserMedia({
                            audio: t,
                            video: !0
                        }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this))
                    } catch (t) {
                        this.getUserMediaError(t)
                    }
                    return this
                },
                getUserMediaTimeout: function() {
                    clearTimeout(this._timeOutID), this.onTimeout.dispatch(this)
                },
                getUserMediaError: function(t) {
                    clearTimeout(this._timeOutID), this.onError.dispatch(this, t)
                },
                getUserMediaSuccess: function(t) {
                    clearTimeout(this._timeOutID), this.videoStream = t, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = t : this.video.src = window.URL && window.URL.createObjectURL(t) || t;
                    var e = this;
                    this.video.onloadeddata = function() {
                        function t() {
                            if (i > 0)
                                if (e.video.videoWidth > 0) {
                                    var o = e.video.videoWidth,
                                        s = e.video.videoHeight;
                                    isNaN(e.video.videoHeight) && (s = o / (4 / 3)), e.video.play(), e.isStreaming = !0, e.baseTexture.source = e.video, e.updateTexture(null, o, s), e.onAccess.dispatch(e)
                                } else window.setTimeout(t, 500);
                            else console.warn("Unable to connect to video stream. Webcam error?");
                            i--
                        }
                        var i = 10;
                        t()
                    }
                },
                createVideoFromBlob: function(t) {
                    var e = this;
                    return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), this.video.addEventListener("loadeddata", function(t) {
                        e.updateTexture(t)
                    }, !0), this.video.src = window.URL.createObjectURL(t), this.video.canplay = !0, this
                },
                createVideoFromURL: function(t, e) {
                    return void 0 === e && (e = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), this.video.controls = !1, e && this.video.setAttribute("autoplay", "autoplay"), this.video.src = t, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = t, this
                },
                updateTexture: function(t, e, i) {
                    var o = !1;
                    void 0 !== e && null !== e || (e = this.video.videoWidth, o = !0), void 0 !== i && null !== i || (i = this.video.videoHeight), this.width = e, this.height = i, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), this.baseTexture.forceLoaded(e, i), this.texture.frame.resize(e, i), this.texture.width = e, this.texture.height = i, this.texture.valid = !0, this.snapshot && this.snapshot.resize(e, i), o && null !== this.key && (this.onChangeSource.dispatch(this, e, i), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)))
                },
                complete: function() {
                    this.onComplete.dispatch(this)
                },
                play: function(t, e) {
                    return void 0 === t && (t = !1), void 0 === e && (e = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), this.video.loop = t ? "loop" : "", this.video.playbackRate = e, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, t, e)), this
                },
                playHandler: function() {
                    this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture()
                },
                stop: function() {
                    return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(t) {
                        t.stop()
                    }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()), this
                },
                add: function(t) {
                    if (Array.isArray(t))
                        for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                    else t.loadTexture(this);
                    return this
                },
                addToWorld: function(t, e, i, o, s, n) {
                    s = s || 1, n = n || 1;
                    var r = this.game.add.image(t, e, this);
                    return r.anchor.set(i, o), r.scale.set(s, n), r
                },
                render: function() {
                    !this.disableTextureUpload && this.playing && this.baseTexture.dirty()
                },
                setMute: function() {
                    this._muted || (this._muted = !0, this.video.muted = !0)
                },
                unsetMute: function() {
                    this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1)
                },
                setPause: function() {
                    this._paused || this.touchLocked || (this._paused = !0, this.video.pause())
                },
                setResume: function() {
                    !this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play())
                },
                changeSource: function(t, e) {
                    return void 0 === e && (e = !0), this.texture.valid = !1, this.video.pause(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = t, this.video.load(), this._autoplay = e, e || (this.paused = !0), this
                },
                checkVideoProgress: function() {
                    4 === this.video.readyState ? this.updateTexture() : (this.retry--, this.retry > 0 ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : console.warn("Phaser.Video: Unable to start downloading video in time", this.isStreaming))
                },
                setTouchLock: function() {
                    this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0
                },
                unlock: function() {
                    if (this.touchLocked = !1, this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate), this.key) {
                        var t = this.game.cache.getVideo(this.key);
                        t && !t.isBlob && (t.locked = !1)
                    }
                    return !0
                },
                grab: function(t, e, i) {
                    return void 0 === t && (t = !1), void 0 === e && (e = 1), void 0 === i && (i = null), null === this.snapshot ? void console.warn("Video.grab cannot run because Phaser.BitmapData is unavailable") : (t && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, e, i), this.snapshot)
                },
                removeVideoElement: function() {
                    if (this.video) {
                        for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) this.video.removeChild(this.video.firstChild);
                        this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null
                    }
                },
                destroy: function() {
                    this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID)
                }
            }, Object.defineProperty(i.Video.prototype, "currentTime", {
                get: function() {
                    return this.video ? this.video.currentTime : 0
                },
                set: function(t) {
                    this.video.currentTime = t
                }
            }), Object.defineProperty(i.Video.prototype, "duration", {
                get: function() {
                    return this.video ? this.video.duration : 0
                }
            }), Object.defineProperty(i.Video.prototype, "progress", {
                get: function() {
                    return this.video ? this.video.currentTime / this.video.duration : 0
                }
            }), Object.defineProperty(i.Video.prototype, "mute", {
                get: function() {
                    return this._muted
                },
                set: function(t) {
                    if (t = t || null) {
                        if (this._muted) return;
                        this._codeMuted = !0, this.setMute()
                    } else {
                        if (!this._muted) return;
                        this._codeMuted = !1, this.unsetMute()
                    }
                }
            }), Object.defineProperty(i.Video.prototype, "paused", {
                get: function() {
                    return this._paused
                },
                set: function(t) {
                    if (t = t || null, !this.touchLocked)
                        if (t) {
                            if (this._paused) return;
                            this._codePaused = !0, this.setPause()
                        } else {
                            if (!this._paused) return;
                            this._codePaused = !1, this.setResume()
                        }
                }
            }), Object.defineProperty(i.Video.prototype, "volume", {
                get: function() {
                    return this.video ? this.video.volume : 1
                },
                set: function(t) {
                    t < 0 ? t = 0 : t > 1 && (t = 1), this.video && (this.video.volume = t)
                }
            }), Object.defineProperty(i.Video.prototype, "playbackRate", {
                get: function() {
                    return this.video ? this.video.playbackRate : 1
                },
                set: function(t) {
                    this.video && (this.video.playbackRate = t)
                }
            }), Object.defineProperty(i.Video.prototype, "loop", {
                get: function() {
                    return !!this.video && this.video.loop
                },
                set: function(t) {
                    t && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "")
                }
            }), Object.defineProperty(i.Video.prototype, "playing", {
                get: function() {
                    return !(this.video.paused && this.video.ended)
                }
            }), i.Video.prototype.constructor = i.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = i.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = i.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix), void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix), PIXI.Graphics && void 0 === PIXI.Graphics.POLY && (PIXI.Graphics.POLY = i.POLYGON, PIXI.Graphics.RECT = i.RECTANGLE, PIXI.Graphics.CIRC = i.CIRCLE, PIXI.Graphics.ELIP = i.ELLIPSE, PIXI.Graphics.RREC = i.ROUNDEDRECTANGLE), PIXI.TextureSilentFail = !0, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = i), exports.Phaser = i) : "undefined" != typeof define && define.amd ? define("Phaser", function() {
                return e.Phaser = i
            }()) : e.Phaser = i, i
    }.call(this);
var COMPILED = !1,
    goog = goog || {};
goog.global = this, goog.global.CLOSURE_UNCOMPILED_DEFINES, goog.global.CLOSURE_DEFINES, goog.isDef = function(t) {
    return void 0 !== t
}, goog.exportPath_ = function(t, e, i) {
    var o = t.split("."),
        s = i || goog.global;
    o[0] in s || !s.execScript || s.execScript("var " + o[0]);
    for (var n; o.length && (n = o.shift());) !o.length && goog.isDef(e) ? s[n] = e : s = s[n] ? s[n] : s[n] = {}
}, goog.define = function(t, e) {
    var i = e;
    COMPILED || (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, t) ? i = goog.global.CLOSURE_UNCOMPILED_DEFINES[t] : goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, t) && (i = goog.global.CLOSURE_DEFINES[t])), goog.exportPath_(t, i)
}, goog.DEBUG = !0, goog.define("goog.LOCALE", "en"), goog.define("goog.TRUSTED_SITE", !0), goog.define("goog.STRICT_MODE_COMPATIBLE", !1), goog.provide = function(t) {
    if (!COMPILED) {
        if (goog.isProvided_(t)) throw Error('Namespace "' + t + '" already declared.');
        delete goog.implicitNamespaces_[t];
        for (var e = t;
            (e = e.substring(0, e.lastIndexOf("."))) && !goog.getObjectByName(e);) goog.implicitNamespaces_[e] = !0
    }
    goog.exportPath_(t)
}, goog.setTestOnly = function(t) {
    if (COMPILED && !goog.DEBUG) throw t = t || "", Error("Importing test-only code into non-debug environment" + (t ? ": " + t : "."))
}, goog.forwardDeclare = function(t) {}, COMPILED || (goog.isProvided_ = function(t) {
    return !goog.implicitNamespaces_[t] && goog.isDefAndNotNull(goog.getObjectByName(t))
}, goog.implicitNamespaces_ = {}), goog.getObjectByName = function(t, e) {
    for (var i, o = t.split("."), s = e || goog.global; i = o.shift();) {
        if (!goog.isDefAndNotNull(s[i])) return null;
        s = s[i]
    }
    return s
}, goog.globalize = function(t, e) {
    var i = e || goog.global;
    for (var o in t) i[o] = t[o]
}, goog.addDependency = function(t, e, i) {
    if (goog.DEPENDENCIES_ENABLED) {
        for (var o, s, n = t.replace(/\\/g, "/"), r = goog.dependencies_, a = 0; o = e[a]; a++) r.nameToPath[o] = n, n in r.pathToNames || (r.pathToNames[n] = {}), r.pathToNames[n][o] = !0;
        for (var h = 0; s = i[h]; h++) n in r.requires || (r.requires[n] = {}), r.requires[n][s] = !0
    }
}, goog.define("goog.ENABLE_DEBUG_LOADER", !0), goog.require = function(t) {
    if (!COMPILED) {
        if (goog.isProvided_(t)) return;
        if (goog.ENABLE_DEBUG_LOADER) {
            var e = goog.getPathFromDeps_(t);
            if (e) return goog.included_[e] = !0, void goog.writeScripts_()
        }
        var i = "goog.require could not find: " + t;
        throw goog.global.console && goog.global.console.error(i), Error(i)
    }
}, goog.basePath = "", goog.global.CLOSURE_BASE_PATH, goog.global.CLOSURE_NO_DEPS, goog.global.CLOSURE_IMPORT_SCRIPT, goog.nullFunction = function() {}, goog.identityFunction = function(t, e) {
    return t
}, goog.abstractMethod = function() {
    throw Error("unimplemented abstract method")
}, goog.addSingletonGetter = function(t) {
    t.getInstance = function() {
        return t.instance_ ? t.instance_ : (goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = t), t.instance_ = new t)
    }
}, goog.instantiatedSingletons_ = [], goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER, goog.DEPENDENCIES_ENABLED && (goog.included_ = {}, goog.dependencies_ = {
    pathToNames: {},
    nameToPath: {},
    requires: {},
    visited: {},
    written: {}
}, goog.inHtmlDocument_ = function() {
    var t = goog.global.document;
    return void 0 !== t && "write" in t
}, goog.findBasePath_ = function() {
    if (goog.global.CLOSURE_BASE_PATH) return void(goog.basePath = goog.global.CLOSURE_BASE_PATH);
    if (goog.inHtmlDocument_())
        for (var t = goog.global.document, e = t.getElementsByTagName("script"), i = e.length - 1; i >= 0; --i) {
            var o = e[i].src,
                s = o.lastIndexOf("?"),
                n = -1 == s ? o.length : s;
            if ("base.js" == o.substr(n - 7, 7)) return void(goog.basePath = o.substr(0, n - 7))
        }
}, goog.importScript_ = function(t) {
    var e = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
    !goog.dependencies_.written[t] && e(t) && (goog.dependencies_.written[t] = !0)
}, goog.writeScriptTag_ = function(t) {
    if (goog.inHtmlDocument_()) {
        var e = goog.global.document;
        if ("complete" == e.readyState) {
            if (/\bdeps.js$/.test(t)) return !1;
            throw Error('Cannot write "' + t + '" after document load')
        }
        return e.write('<script type="text/javascript" src="' + t + '"><\/script>'), !0
    }
    return !1
}, goog.writeScripts_ = function() {
    function t(s) {
        if (!(s in o.written)) {
            if (s in o.visited) return void(s in i || (i[s] = !0, e.push(s)));
            if (o.visited[s] = !0, s in o.requires)
                for (var n in o.requires[s])
                    if (!goog.isProvided_(n)) {
                        if (!(n in o.nameToPath)) throw Error("Undefined nameToPath for " + n);
                        t(o.nameToPath[n])
                    }
            s in i || (i[s] = !0, e.push(s))
        }
    }
    var e = [],
        i = {},
        o = goog.dependencies_;
    for (var s in goog.included_) o.written[s] || t(s);
    for (var n = 0; n < e.length; n++) {
        if (!e[n]) throw Error("Undefined script input");
        goog.importScript_(goog.basePath + e[n])
    }
}, goog.getPathFromDeps_ = function(t) {
    return t in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[t] : null
}, goog.findBasePath_()), goog.typeOf = function(t) {
    var e = typeof t;
    if ("object" == e) {
        if (!t) return "null";
        if (t instanceof Array) return "array";
        if (t instanceof Object) return e;
        var i = Object.prototype.toString.call(t);
        if ("[object Window]" == i) return "object";
        if ("[object Array]" == i || "number" == typeof t.length && void 0 !== t.splice && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable("splice")) return "array";
        if ("[object Function]" == i || void 0 !== t.call && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable("call")) return "function"
    } else if ("function" == e && void 0 === t.call) return "object";
    return e
}, goog.isNull = function(t) {
    return null === t
}, goog.isDefAndNotNull = function(t) {
    return null != t
}, goog.isArray = function(t) {
    return "array" == goog.typeOf(t)
}, goog.isArrayLike = function(t) {
    var e = goog.typeOf(t);
    return "array" == e || "object" == e && "number" == typeof t.length
}, goog.isDateLike = function(t) {
    return goog.isObject(t) && "function" == typeof t.getFullYear
}, goog.isString = function(t) {
    return "string" == typeof t
}, goog.isBoolean = function(t) {
    return "boolean" == typeof t
}, goog.isNumber = function(t) {
    return "number" == typeof t
}, goog.isFunction = function(t) {
    return "function" == goog.typeOf(t)
}, goog.isObject = function(t) {
    var e = typeof t;
    return "object" == e && null != t || "function" == e
}, goog.getUid = function(t) {
    return t[goog.UID_PROPERTY_] || (t[goog.UID_PROPERTY_] = ++goog.uidCounter_)
}, goog.hasUid = function(t) {
    return !!t[goog.UID_PROPERTY_]
}, goog.removeUid = function(t) {
    "removeAttribute" in t && t.removeAttribute(goog.UID_PROPERTY_);
    try {
        delete t[goog.UID_PROPERTY_]
    } catch (t) {}
}, goog.UID_PROPERTY_ = "closure_uid_" + (1e9 * Math.random() >>> 0), goog.uidCounter_ = 0, goog.getHashCode = goog.getUid, goog.removeHashCode = goog.removeUid, goog.cloneObject = function(t) {
    var e = goog.typeOf(t);
    if ("object" == e || "array" == e) {
        if (t.clone) return t.clone();
        var i = "array" == e ? [] : {};
        for (var o in t) i[o] = goog.cloneObject(t[o]);
        return i
    }
    return t
}, goog.bindNative_ = function(t, e, i) {
    return t.call.apply(t.bind, arguments)
}, goog.bindJs_ = function(t, e, i) {
    if (!t) throw new Error;
    if (arguments.length > 2) {
        var o = Array.prototype.slice.call(arguments, 2);
        return function() {
            var i = Array.prototype.slice.call(arguments);
            return Array.prototype.unshift.apply(i, o), t.apply(e, i)
        }
    }
    return function() {
        return t.apply(e, arguments)
    }
}, goog.bind = function(t, e, i) {
    return Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_, goog.bind.apply(null, arguments)
}, goog.partial = function(t, e) {
    var i = Array.prototype.slice.call(arguments, 1);
    return function() {
        var e = i.slice();
        return e.push.apply(e, arguments), t.apply(this, e)
    }
}, goog.mixin = function(t, e) {
    for (var i in e) t[i] = e[i]
}, goog.now = goog.TRUSTED_SITE && Date.now || function() {
    return +new Date
}, goog.globalEval = function(t) {
    if (goog.global.execScript) goog.global.execScript(t, "JavaScript");
    else {
        if (!goog.global.eval) throw Error("goog.globalEval not available");
        if (null == goog.evalWorksForGlobals_ && (goog.global.eval("var _et_ = 1;"), void 0 !== goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_) goog.global.eval(t);
        else {
            var e = goog.global.document,
                i = e.createElement("script");
            i.type = "text/javascript", i.defer = !1, i.appendChild(e.createTextNode(t)), e.body.appendChild(i), e.body.removeChild(i)
        }
    }
}, goog.evalWorksForGlobals_ = null, goog.cssNameMapping_, goog.cssNameMappingStyle_, goog.getCssName = function(t, e) {
    var i, o = function(t) {
            return goog.cssNameMapping_[t] || t
        },
        s = function(t) {
            for (var e = t.split("-"), i = [], s = 0; s < e.length; s++) i.push(o(e[s]));
            return i.join("-")
        };
    return i = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? o : s : function(t) {
        return t
    }, e ? t + "-" + i(e) : i(t)
}, goog.setCssNameMapping = function(t, e) {
    goog.cssNameMapping_ = t, goog.cssNameMappingStyle_ = e
}, goog.global.CLOSURE_CSS_NAME_MAPPING, !COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING), goog.getMsg = function(t, e) {
    return e && (t = t.replace(/\{\$([^}]+)}/g, function(t, i) {
        return i in e ? e[i] : t
    })), t
}, goog.getMsgWithFallback = function(t, e) {
    return t
}, goog.exportSymbol = function(t, e, i) {
    goog.exportPath_(t, e, i)
}, goog.exportProperty = function(t, e, i) {
    t[e] = i
}, goog.inherits = function(t, e) {
    function i() {}
    i.prototype = e.prototype, t.superClass_ = e.prototype, t.prototype = new i, t.prototype.constructor = t, t.base = function(t, i, o) {
        var s = Array.prototype.slice.call(arguments, 2);
        return e.prototype[i].apply(t, s)
    }
}, goog.base = function(t, e, i) {
    var o = arguments.callee.caller;
    if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !o) throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");
    if (o.superClass_) return o.superClass_.constructor.apply(t, Array.prototype.slice.call(arguments, 1));
    for (var s = Array.prototype.slice.call(arguments, 2), n = !1, r = t.constructor; r; r = r.superClass_ && r.superClass_.constructor)
        if (r.prototype[e] === o) n = !0;
        else if (n) return r.prototype[e].apply(t, s);
    if (t[e] === o) return t.constructor.prototype[e].apply(t, s);
    throw Error("goog.base called from a method of one name to a method of a different name")
}, goog.scope = function(t) {
    t.call(goog.global)
}, COMPILED || (goog.global.COMPILED = COMPILED), goog.defineClass = function(t, e) {
    var i = e.constructor,
        o = e.statics;
    i && i != Object.prototype.constructor || (i = function() {
        throw Error("cannot instantiate an interface (no constructor defined).")
    });
    var s = goog.defineClass.createSealingConstructor_(i, t);
    return t && goog.inherits(s, t), delete e.constructor, delete e.statics, goog.defineClass.applyProperties_(s.prototype, e), null != o && (o instanceof Function ? o(s) : goog.defineClass.applyProperties_(s, o)), s
}, goog.defineClass.ClassDescriptor, goog.define("goog.defineClass.SEAL_CLASS_INSTANCES", goog.DEBUG), goog.defineClass.createSealingConstructor_ = function(t, e) {
    if (goog.defineClass.SEAL_CLASS_INSTANCES && Object.seal instanceof Function) {
        if (e && e.prototype && e.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) return t;
        var i = function() {
            var e = t.apply(this, arguments) || this;
            return this.constructor === i && Object.seal(e), e
        };
        return i
    }
    return t
}, goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], goog.defineClass.applyProperties_ = function(t, e) {
    var i;
    for (i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    for (var o = 0; o < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; o++) i = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[o], Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
}, goog.tagUnsealableClass = function(t) {
    !COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES && (t.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = !0)
}, goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable", goog.provide("box2d.b2Settings"), Object.defineProperty || (Object.defineProperty = function(t, e, i) {
    Object.__defineGetter__ && ("get" in i ? t.__defineGetter__(e, i.get) : "value" in i && t.__defineGetter__(e, i.value)), Object.__defineSetter__ && ("set" in i ? t.__defineSetter__(e, i.set) : "value" in i && t.__defineSetter__(e, i.value))
}), box2d.b2_maxFloat = 1e37, box2d.b2_epsilon = 1e-5, box2d.b2_epsilon_sq = box2d.b2_epsilon * box2d.b2_epsilon, box2d.b2_pi = Math.PI, box2d.b2_maxManifoldPoints = 2, box2d.b2_maxPolygonVertices = 8, box2d.b2_aabbExtension = .1, box2d.b2_aabbMultiplier = 2, box2d.b2_linearSlop = .008, box2d.b2_angularSlop = 2 / 180 * box2d.b2_pi, box2d.b2_polygonRadius = 2 * box2d.b2_linearSlop, box2d.b2_maxSubSteps = 8, box2d.b2_maxTOIContacts = 32, box2d.b2_velocityThreshold = 1, box2d.b2_maxLinearCorrection = .2, box2d.b2_maxAngularCorrection = 8 / 180 * box2d.b2_pi, box2d.b2_maxTranslation = 2, box2d.b2_maxTranslationSquared = box2d.b2_maxTranslation * box2d.b2_maxTranslation, box2d.b2_maxRotation = .5 * box2d.b2_pi, box2d.b2_maxRotationSquared = box2d.b2_maxRotation * box2d.b2_maxRotation, box2d.b2_baumgarte = .2, box2d.b2_toiBaumgarte = .75, box2d.b2_timeToSleep = .5, box2d.b2_linearSleepTolerance = .01, box2d.b2_angularSleepTolerance = 2 / 180 * box2d.b2_pi, box2d.b2Alloc = function(t) {
    return null
}, box2d.b2Free = function(t) {}, box2d.b2Log = function(t) {
    goog.global.console.log.apply(null, arguments)
}, box2d.b2Version = function(t, e, i) {
    this.major = t || 0, this.minor = e || 0, this.revision = i || 0
}, box2d.b2Version.prototype.major = 0, box2d.b2Version.prototype.minor = 0, box2d.b2Version.prototype.revision = 0, box2d.b2Version.prototype.toString = function() {
    return this.major + "." + this.minor + "." + this.revision
}, box2d.b2_version = new box2d.b2Version(2, 3, 0), box2d.b2_changelist = 278, box2d.b2ParseInt = function(t) {
    return parseInt(t, 10)
}, box2d.b2ParseUInt = function(t) {
    return box2d.b2Abs(parseInt(t, 10))
}, box2d.b2MakeArray = function(t, e) {
    void 0 === t && (t = 0);
    var i = new Array(t);
    if (void 0 !== e)
        for (var o = 0; o < t; ++o) i[o] = e(o);
    return i
}, box2d.b2MakeNumberArray = function(t) {
    return box2d.b2MakeArray(t, function(t) {
        return 0
    })
}, goog.provide("box2d.b2Math"), goog.require("box2d.b2Settings"), box2d.b2_pi_over_180 = box2d.b2_pi / 180, box2d.b2_180_over_pi = 180 / box2d.b2_pi, box2d.b2_two_pi = 2 * box2d.b2_pi, box2d.b2Abs = function(t) {
    return t < 0 ? -t : t
}, box2d.b2Min = function(t, e) {
    return t < e ? t : e
}, box2d.b2Max = function(t, e) {
    return t > e ? t : e
}, box2d.b2Clamp = function(t, e, i) {
    return t < e ? e : t > i ? i : t
}, box2d.b2Swap = function(t, e) {
    var i = t[0];
    t[0] = e[0], e[0] = i
}, box2d.b2IsValid = function(t) {
    return isFinite(t)
}, box2d.b2Sq = function(t) {
    return t * t
}, box2d.b2InvSqrt = function(t) {
    return 1 / Math.sqrt(t)
}, box2d.b2Sqrt = function(t) {
    return Math.sqrt(t)
}, box2d.b2Pow = function(t, e) {
    return Math.pow(t, e)
}, box2d.b2DegToRad = function(t) {
    return t * box2d.b2_pi_over_180
}, box2d.b2RadToDeg = function(t) {
    return t * box2d.b2_180_over_pi
}, box2d.b2Cos = function(t) {
    return Math.cos(t)
}, box2d.b2Sin = function(t) {
    return Math.sin(t)
}, box2d.b2Acos = function(t) {
    return Math.acos(t)
}, box2d.b2Asin = function(t) {
    return Math.asin(t)
}, box2d.b2Atan2 = function(t, e) {
    return Math.atan2(t, e)
}, box2d.b2NextPowerOfTwo = function(t) {
    return t |= t >> 1 & 2147483647, t |= t >> 2 & 1073741823, t |= t >> 4 & 268435455, t |= t >> 8 & 16777215, (t |= t >> 16 & 65535) + 1
}, box2d.b2IsPowerOfTwo = function(t) {
    return t > 0 && 0 == (t & t - 1)
}, box2d.b2Random = function() {
    return 2 * Math.random() - 1
}, box2d.b2RandomRange = function(t, e) {
    return (e - t) * Math.random() + t
}, box2d.b2Vec2 = function(t, e) {
    this.x = t || 0, this.y = e || 0
}, box2d.b2Vec2.prototype.x = 0, box2d.b2Vec2.prototype.y = 0, box2d.b2Vec2_zero = new box2d.b2Vec2, box2d.b2Vec2.ZERO = new box2d.b2Vec2, box2d.b2Vec2.UNITX = new box2d.b2Vec2(1, 0), box2d.b2Vec2.UNITY = new box2d.b2Vec2(0, 1), box2d.b2Vec2.s_t0 = new box2d.b2Vec2, box2d.b2Vec2.s_t1 = new box2d.b2Vec2, box2d.b2Vec2.s_t2 = new box2d.b2Vec2, box2d.b2Vec2.s_t3 = new box2d.b2Vec2, box2d.b2Vec2.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function(t) {
        return new box2d.b2Vec2
    })
}, box2d.b2Vec2.prototype.Clone = function() {
    return new box2d.b2Vec2(this.x, this.y)
}, box2d.b2Vec2.prototype.SetZero = function() {
    return this.x = 0, this.y = 0, this
}, box2d.b2Vec2.prototype.SetXY = function(t, e) {
    return this.x = t, this.y = e, this
}, box2d.b2Vec2.prototype.Copy = function(t) {
    return this.x = t.x, this.y = t.y, this
}, box2d.b2Vec2.prototype.SelfAdd = function(t) {
    return this.x += t.x, this.y += t.y, this
}, box2d.b2Vec2.prototype.SelfAddXY = function(t, e) {
    return this.x += t, this.y += e, this
}, box2d.b2Vec2.prototype.SelfSub = function(t) {
    return this.x -= t.x, this.y -= t.y, this
}, box2d.b2Vec2.prototype.SelfSubXY = function(t, e) {
    return this.x -= t, this.y -= e, this
}, box2d.b2Vec2.prototype.SelfMul = function(t) {
    return this.x *= t, this.y *= t, this
}, box2d.b2Vec2.prototype.SelfMulAdd = function(t, e) {
    return this.x += t * e.x, this.y += t * e.y, this
}, box2d.b2Vec2.prototype.SelfMulSub = function(t, e) {
    return this.x -= t * e.x, this.y -= t * e.y, this
}, box2d.b2Vec2.prototype.Dot = function(t) {
    return this.x * t.x + this.y * t.y
}, box2d.b2Vec2.prototype.Cross = function(t) {
    return this.x * t.y - this.y * t.x
}, box2d.b2Vec2.prototype.Length = function() {
    var t = this.x,
        e = this.y;
    return Math.sqrt(t * t + e * e)
}, box2d.b2Vec2.prototype.GetLength = box2d.b2Vec2.prototype.Length, box2d.b2Vec2.prototype.LengthSquared = function() {
    var t = this.x,
        e = this.y;
    return t * t + e * e
}, box2d.b2Vec2.prototype.GetLengthSquared = box2d.b2Vec2.prototype.LengthSquared, box2d.b2Vec2.prototype.Normalize = function() {
    var t = this.GetLength();
    if (t >= box2d.b2_epsilon) {
        var e = 1 / t;
        this.x *= e, this.y *= e
    }
    return t
}, box2d.b2Vec2.prototype.SelfNormalize = function() {
    var t = this.GetLength();
    if (t >= box2d.b2_epsilon) {
        var e = 1 / t;
        this.x *= e, this.y *= e
    }
    return this
}, box2d.b2Vec2.prototype.SelfRotate = function(t, e) {
    var i = this.x,
        o = this.y;
    return this.x = t * i - e * o, this.y = e * i + t * o, this
}, box2d.b2Vec2.prototype.SelfRotateRadians = function(t) {
    return this.SelfRotate(Math.cos(t), Math.sin(t))
}, box2d.b2Vec2.prototype.SelfRotateDegrees = function(t) {
    return this.SelfRotateRadians(box2d.b2DegToRad(t))
}, box2d.b2Vec2.prototype.IsValid = function() {
    return isFinite(this.x) && isFinite(this.y)
}, box2d.b2Vec2.prototype.SelfCrossVS = function(t) {
    var e = this.x;
    return this.x = t * this.y, this.y = -t * e, this
}, box2d.b2Vec2.prototype.SelfCrossSV = function(t) {
    var e = this.x;
    return this.x = -t * this.y, this.y = t * e, this
}, box2d.b2Vec2.prototype.SelfMinV = function(t) {
    return this.x = box2d.b2Min(this.x, t.x), this.y = box2d.b2Min(this.y, t.y), this
}, box2d.b2Vec2.prototype.SelfMaxV = function(t) {
    return this.x = box2d.b2Max(this.x, t.x), this.y = box2d.b2Max(this.y, t.y), this
}, box2d.b2Vec2.prototype.SelfAbs = function() {
    return this.x = box2d.b2Abs(this.x), this.y = box2d.b2Abs(this.y), this
}, box2d.b2Vec2.prototype.SelfNeg = function() {
    return this.x = -this.x, this.y = -this.y, this
}, box2d.b2Vec2.prototype.SelfSkew = function() {
    var t = this.x;
    return this.x = -this.y, this.y = t, this
}, box2d.b2AbsV = function(t, e) {
    return e.x = box2d.b2Abs(t.x), e.y = box2d.b2Abs(t.y), e
}, box2d.b2MinV = function(t, e, i) {
    return i.x = box2d.b2Min(t.x, e.x), i.y = box2d.b2Min(t.y, e.y), i
}, box2d.b2MaxV = function(t, e, i) {
    return i.x = box2d.b2Max(t.x, e.x), i.y = box2d.b2Max(t.y, e.y), i
}, box2d.b2ClampV = function(t, e, i, o) {
    return o.x = box2d.b2Clamp(t.x, e.x, i.x), o.y = box2d.b2Clamp(t.y, e.y, i.y), o
}, box2d.b2RotateV = function(t, e, i, o) {
    var s = t.x,
        n = t.y;
    return o.x = e * s - i * n, o.y = i * s + e * n, o
}, box2d.b2RotateRadiansV = function(t, e, i) {
    return box2d.b2RotateV(t, Math.cos(e), Math.sin(e), i)
}, box2d.b2RotateDegreesV = function(t, e, i) {
    return box2d.b2RotateRadiansV(t, box2d.b2DegToRad(e), i)
}, box2d.b2DotVV = function(t, e) {
    return t.x * e.x + t.y * e.y
}, box2d.b2CrossVV = function(t, e) {
    return t.x * e.y - t.y * e.x
}, box2d.b2CrossVS = function(t, e, i) {
    var o = t.x;
    return i.x = e * t.y, i.y = -e * o, i
}, box2d.b2CrossVOne = function(t, e) {
    var i = t.x;
    return e.x = t.y, e.y = -i, e
}, box2d.b2CrossSV = function(t, e, i) {
    var o = e.x;
    return i.x = -t * e.y, i.y = t * o, i
};
box2d.b2CrossOneV = function(t, e) {
        var i = t.x;
        return e.x = -t.y, e.y = i, e
    }, box2d.b2AddVV = function(t, e, i) {
        return i.x = t.x + e.x, i.y = t.y + e.y, i
    }, box2d.b2SubVV = function(t, e, i) {
        return i.x = t.x - e.x, i.y = t.y - e.y, i
    }, box2d.b2MulSV = function(t, e, i) {
        return i.x = e.x * t, i.y = e.y * t, i
    }, box2d.b2AddVMulSV = function(t, e, i, o) {
        return o.x = t.x + e * i.x, o.y = t.y + e * i.y, o
    }, box2d.b2SubVMulSV = function(t, e, i, o) {
        return o.x = t.x - e * i.x, o.y = t.y - e * i.y, o
    }, box2d.b2AddVCrossSV = function(t, e, i, o) {
        var s = i.x;
        return o.x = t.x - e * i.y, o.y = t.y + e * s, o
    }, box2d.b2MidVV = function(t, e, i) {
        return i.x = .5 * (t.x + e.x), i.y = .5 * (t.y + e.y), i
    }, box2d.b2ExtVV = function(t, e, i) {
        return i.x = .5 * (e.x - t.x), i.y = .5 * (e.y - t.y), i
    }, box2d.b2IsEqualToV = function(t, e) {
        return t.x === e.x && t.y === e.y
    }, box2d.b2DistanceVV = function(t, e) {
        var i = t.x - e.x,
            o = t.y - e.y;
        return Math.sqrt(i * i + o * o)
    }, box2d.b2DistanceSquaredVV = function(t, e) {
        var i = t.x - e.x,
            o = t.y - e.y;
        return i * i + o * o
    }, box2d.b2NegV = function(t, e) {
        return e.x = -t.x, e.y = -t.y, e
    }, box2d.b2Vec3 = function(t, e, i) {
        this.x = t || 0, this.y = e || 0, this.z = i || 0
    }, box2d.b2Vec3.prototype.x = 0, box2d.b2Vec3.prototype.y = 0, box2d.b2Vec3.prototype.z = 0, box2d.b2Vec3.ZERO = new box2d.b2Vec3, box2d.b2Vec3.s_t0 = new box2d.b2Vec3, box2d.b2Vec3.prototype.Clone = function() {
        return new box2d.b2Vec3(this.x, this.y, this.z)
    }, box2d.b2Vec3.prototype.SetZero = function() {
        return this.x = 0, this.y = 0, this.z = 0, this
    }, box2d.b2Vec3.prototype.SetXYZ = function(t, e, i) {
        return this.x = t, this.y = e, this.z = i, this
    }, box2d.b2Vec3.prototype.Copy = function(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this
    }, box2d.b2Vec3.prototype.SelfNeg = function() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }, box2d.b2Vec3.prototype.SelfAdd = function(t) {
        return this.x += t.x, this.y += t.y, this.z += t.z, this
    }, box2d.b2Vec3.prototype.SelfAddXYZ = function(t, e, i) {
        return this.x += t, this.y += e, this.z += i, this
    }, box2d.b2Vec3.prototype.SelfSub = function(t) {
        return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
    }, box2d.b2Vec3.prototype.SelfSubXYZ = function(t, e, i) {
        return this.x -= t, this.y -= e, this.z -= i, this
    }, box2d.b2Vec3.prototype.SelfMul = function(t) {
        return this.x *= t, this.y *= t, this.z *= t, this
    }, box2d.b2DotV3V3 = function(t, e) {
        return t.x * e.x + t.y * e.y + t.z * e.z
    }, box2d.b2CrossV3V3 = function(t, e, i) {
        var o = t.x,
            s = t.y,
            n = t.z,
            r = e.x,
            a = e.y,
            h = e.z;
        return i.x = s * h - n * a, i.y = n * r - o * h, i.z = o * a - s * r, i
    }, box2d.b2Mat22 = function() {
        this.ex = new box2d.b2Vec2(1, 0), this.ey = new box2d.b2Vec2(0, 1)
    }, box2d.b2Mat22.prototype.ex = null, box2d.b2Mat22.prototype.ey = null, box2d.b2Mat22.IDENTITY = new box2d.b2Mat22, box2d.b2Mat22.prototype.Clone = function() {
        return (new box2d.b2Mat22).Copy(this)
    }, box2d.b2Mat22.FromVV = function(t, e) {
        return (new box2d.b2Mat22).SetVV(t, e)
    }, box2d.b2Mat22.FromSSSS = function(t, e, i, o) {
        return (new box2d.b2Mat22).SetSSSS(t, e, i, o)
    }, box2d.b2Mat22.FromAngleRadians = function(t) {
        return (new box2d.b2Mat22).SetAngleRadians(t)
    }, box2d.b2Mat22.prototype.SetSSSS = function(t, e, i, o) {
        return this.ex.SetXY(t, i), this.ey.SetXY(e, o), this
    }, box2d.b2Mat22.prototype.SetVV = function(t, e) {
        return this.ex.Copy(t), this.ey.Copy(e), this
    }, box2d.b2Mat22.prototype.SetAngle = function(t) {
        var e = Math.cos(t),
            i = Math.sin(t);
        return this.ex.SetXY(e, i), this.ey.SetXY(-i, e), this
    }, box2d.b2Mat22.prototype.SetAngleRadians = box2d.b2Mat22.prototype.SetAngle, box2d.b2Mat22.prototype.SetAngleDegrees = function(t) {
        return this.SetAngle(box2d.b2DegToRad(t))
    }, box2d.b2Mat22.prototype.Copy = function(t) {
        return this.ex.Copy(t.ex), this.ey.Copy(t.ey), this
    }, box2d.b2Mat22.prototype.SetIdentity = function() {
        return this.ex.SetXY(1, 0), this.ey.SetXY(0, 1), this
    }, box2d.b2Mat22.prototype.SetZero = function() {
        return this.ex.SetZero(), this.ey.SetZero(), this
    }, box2d.b2Mat22.prototype.GetAngle = function() {
        return Math.atan2(this.ex.y, this.ex.x)
    }, box2d.b2Mat22.prototype.GetAngleRadians = box2d.b2Mat22.prototype.GetAngle, box2d.b2Mat22.prototype.GetInverse = function(t) {
        var e = this.ex.x,
            i = this.ey.x,
            o = this.ex.y,
            s = this.ey.y,
            n = e * s - i * o;
        return 0 !== n && (n = 1 / n), t.ex.x = n * s, t.ey.x = -n * i, t.ex.y = -n * o, t.ey.y = n * e, t
    }, box2d.b2Mat22.prototype.Solve = function(t, e, i) {
        var o = this.ex.x,
            s = this.ey.x,
            n = this.ex.y,
            r = this.ey.y,
            a = o * r - s * n;
        return 0 !== a && (a = 1 / a), i.x = a * (r * t - s * e), i.y = a * (o * e - n * t), i
    }, box2d.b2Mat22.prototype.SelfAbs = function() {
        return this.ex.SelfAbs(), this.ey.SelfAbs(), this
    }, box2d.b2Mat22.prototype.SelfInv = function() {
        return this.GetInverse(this)
    }, box2d.b2Mat22.prototype.SelfAddM = function(t) {
        return this.ex.SelfAdd(t.ex), this.ey.SelfAdd(t.ey), this
    }, box2d.b2Mat22.prototype.SelfSubM = function(t) {
        return this.ex.SelfSub(t.ex), this.ey.SelfSub(t.ey), this
    }, box2d.b2AbsM = function(t, e) {
        var i = t.ex,
            o = t.ey;
        return e.ex.x = box2d.b2Abs(i.x), e.ex.y = box2d.b2Abs(i.y), e.ey.x = box2d.b2Abs(o.x), e.ey.y = box2d.b2Abs(o.y), e
    }, box2d.b2MulMV = function(t, e, i) {
        var o = t.ex,
            s = t.ey,
            n = e.x,
            r = e.y;
        return i.x = o.x * n + s.x * r, i.y = o.y * n + s.y * r, i
    }, box2d.b2MulTMV = function(t, e, i) {
        var o = t.ex,
            s = t.ey,
            n = e.x,
            r = e.y;
        return i.x = o.x * n + o.y * r, i.y = s.x * n + s.y * r, i
    }, box2d.b2AddMM = function(t, e, i) {
        var o = t.ex,
            s = t.ey,
            n = e.ex,
            r = e.ey;
        return i.ex.x = o.x + n.x, i.ex.y = o.y + n.y, i.ey.x = s.x + r.x, i.ey.y = s.y + r.y, i
    }, box2d.b2MulMM = function(t, e, i) {
        var o = t.ex.x,
            s = t.ex.y,
            n = t.ey.x,
            r = t.ey.y,
            a = e.ex.x,
            h = e.ex.y,
            l = e.ey.x,
            d = e.ey.y;
        return i.ex.x = o * a + n * h, i.ex.y = s * a + r * h, i.ey.x = o * l + n * d, i.ey.y = s * l + r * d, i
    }, box2d.b2MulTMM = function(t, e, i) {
        var o = t.ex.x,
            s = t.ex.y,
            n = t.ey.x,
            r = t.ey.y,
            a = e.ex.x,
            h = e.ex.y,
            l = e.ey.x,
            d = e.ey.y;
        return i.ex.x = o * a + s * h, i.ex.y = n * a + r * h, i.ey.x = o * l + s * d, i.ey.y = n * l + r * d, i
    }, box2d.b2Mat33 = function() {
        this.ex = new box2d.b2Vec3(1, 0, 0), this.ey = new box2d.b2Vec3(0, 1, 0), this.ez = new box2d.b2Vec3(0, 0, 1)
    }, box2d.b2Mat33.prototype.ex = null, box2d.b2Mat33.prototype.ey = null, box2d.b2Mat33.prototype.ez = null, box2d.b2Mat33.IDENTITY = new box2d.b2Mat33, box2d.b2Mat33.prototype.Clone = function() {
        return (new box2d.b2Mat33).Copy(this)
    }, box2d.b2Mat33.prototype.SetVVV = function(t, e, i) {
        return this.ex.Copy(t), this.ey.Copy(e), this.ez.Copy(i), this
    }, box2d.b2Mat33.prototype.Copy = function(t) {
        return this.ex.Copy(t.ex), this.ey.Copy(t.ey), this.ez.Copy(t.ez), this
    }, box2d.b2Mat33.prototype.SetIdentity = function() {
        return this.ex.SetXYZ(1, 0, 0), this.ey.SetXYZ(0, 1, 0), this.ez.SetXYZ(0, 0, 1), this
    }, box2d.b2Mat33.prototype.SetZero = function() {
        return this.ex.SetZero(), this.ey.SetZero(), this.ez.SetZero(), this
    }, box2d.b2Mat33.prototype.SelfAddM = function(t) {
        return this.ex.SelfAdd(t.ex), this.ey.SelfAdd(t.ey), this.ez.SelfAdd(t.ez), this
    }, box2d.b2Mat33.prototype.Solve33 = function(t, e, i, o) {
        var s = this.ex.x,
            n = this.ex.y,
            r = this.ex.z,
            a = this.ey.x,
            h = this.ey.y,
            l = this.ey.z,
            d = this.ez.x,
            c = this.ez.y,
            p = this.ez.z,
            u = s * (h * p - l * c) + n * (l * d - a * p) + r * (a * c - h * d);
        return 0 !== u && (u = 1 / u), o.x = u * (t * (h * p - l * c) + e * (l * d - a * p) + i * (a * c - h * d)), o.y = u * (s * (e * p - i * c) + n * (i * d - t * p) + r * (t * c - e * d)), o.z = u * (s * (h * i - l * e) + n * (l * t - a * i) + r * (a * e - h * t)), o
    }, box2d.b2Mat33.prototype.Solve22 = function(t, e, i) {
        var o = this.ex.x,
            s = this.ey.x,
            n = this.ex.y,
            r = this.ey.y,
            a = o * r - s * n;
        return 0 !== a && (a = 1 / a), i.x = a * (r * t - s * e), i.y = a * (o * e - n * t), i
    }, box2d.b2Mat33.prototype.GetInverse22 = function(t) {
        var e = this.ex.x,
            i = this.ey.x,
            o = this.ex.y,
            s = this.ey.y,
            n = e * s - i * o;
        0 !== n && (n = 1 / n), t.ex.x = n * s, t.ey.x = -n * i, t.ex.z = 0, t.ex.y = -n * o, t.ey.y = n * e, t.ey.z = 0, t.ez.x = 0, t.ez.y = 0, t.ez.z = 0
    }, box2d.b2Mat33.prototype.GetSymInverse33 = function(t) {
        var e = box2d.b2DotV3V3(this.ex, box2d.b2CrossV3V3(this.ey, this.ez, box2d.b2Vec3.s_t0));
        0 !== e && (e = 1 / e);
        var i = this.ex.x,
            o = this.ey.x,
            s = this.ez.x,
            n = this.ey.y,
            r = this.ez.y,
            a = this.ez.z;
        t.ex.x = e * (n * a - r * r), t.ex.y = e * (s * r - o * a), t.ex.z = e * (o * r - s * n), t.ey.x = t.ex.y, t.ey.y = e * (i * a - s * s), t.ey.z = e * (s * o - i * r), t.ez.x = t.ex.z, t.ez.y = t.ey.z, t.ez.z = e * (i * n - o * o)
    }, box2d.b2MulM33V3 = function(t, e, i) {
        var o = e.x,
            s = e.y,
            n = e.z;
        return i.x = t.ex.x * o + t.ey.x * s + t.ez.x * n, i.y = t.ex.y * o + t.ey.y * s + t.ez.y * n, i.z = t.ex.z * o + t.ey.z * s + t.ez.z * n, i
    }, box2d.b2MulM33XYZ = function(t, e, i, o, s) {
        return s.x = t.ex.x * e + t.ey.x * i + t.ez.x * o, s.y = t.ex.y * e + t.ey.y * i + t.ez.y * o, s.z = t.ex.z * e + t.ey.z * i + t.ez.z * o, s
    }, box2d.b2MulM33V2 = function(t, e, i) {
        var o = e.x,
            s = e.y;
        return i.x = t.ex.x * o + t.ey.x * s, i.y = t.ex.y * o + t.ey.y * s, i
    }, box2d.b2MulM33XY = function(t, e, i, o) {
        return o.x = t.ex.x * e + t.ey.x * i, o.y = t.ex.y * e + t.ey.y * i, o
    }, box2d.b2Rot = function(t) {
        t && (this.angle = t, this.s = Math.sin(t), this.c = Math.cos(t))
    }, box2d.b2Rot.prototype.angle = 0, box2d.b2Rot.prototype.s = 0, box2d.b2Rot.prototype.c = 1, box2d.b2Rot.IDENTITY = new box2d.b2Rot, box2d.b2Rot.prototype.Clone = function() {
        return (new box2d.b2Rot).Copy(this)
    }, box2d.b2Rot.prototype.Copy = function(t) {
        return this.angle = t.angle, this.s = t.s, this.c = t.c, this
    }, box2d.b2Rot.prototype.SetAngle = function(t) {
        return this.angle !== t && (this.angle = t, this.s = Math.sin(t), this.c = Math.cos(t)), this
    }, box2d.b2Rot.prototype.SetAngleRadians = box2d.b2Rot.prototype.SetAngle, box2d.b2Rot.prototype.SetAngleDegrees = function(t) {
        return this.SetAngle(box2d.b2DegToRad(t))
    }, box2d.b2Rot.prototype.SetIdentity = function() {
        return this.angle = 0, this.s = 0, this.c = 1, this
    }, box2d.b2Rot.prototype.GetAngle = function() {
        return this.angle
    }, box2d.b2Rot.prototype.GetAngleRadians = box2d.b2Rot.prototype.GetAngle, box2d.b2Rot.prototype.GetAngleDegrees = function() {
        return box2d.b2RadToDeg(this.GetAngle())
    }, box2d.b2Rot.prototype.GetXAxis = function(t) {
        return t.x = this.c, t.y = this.s, t
    }, box2d.b2Rot.prototype.GetYAxis = function(t) {
        return t.x = -this.s, t.y = this.c, t
    }, box2d.b2MulRR = function(t, e, i) {
        var o = t.c,
            s = t.s,
            n = e.c,
            r = e.s;
        for (i.s = s * n + o * r, i.c = o * n - s * r, i.angle = t.angle + e.angle; i.angle < -box2d.b2_pi;) i.angle += box2d.b2_two_pi;
        for (; i.angle >= box2d.b2_pi;) i.angle -= box2d.b2_two_pi;
        return i
    }, box2d.b2MulTRR = function(t, e, i) {
        var o = t.c,
            s = t.s,
            n = e.c,
            r = e.s;
        for (i.s = o * r - s * n, i.c = o * n + s * r, i.angle = t.angle - e.angle; i.angle < -box2d.b2_pi;) i.angle += box2d.b2_two_pi;
        for (; i.angle >= box2d.b2_pi;) i.angle -= box2d.b2_two_pi;
        return i
    }, box2d.b2MulRV = function(t, e, i) {
        var o = t.c,
            s = t.s,
            n = e.x,
            r = e.y;
        return i.x = o * n - s * r, i.y = s * n + o * r, i
    }, box2d.b2MulTRV = function(t, e, i) {
        var o = t.c,
            s = t.s,
            n = e.x,
            r = e.y;
        return i.x = o * n + s * r, i.y = -s * n + o * r, i
    }, box2d.b2Transform = function() {
        this.p = new box2d.b2Vec2, this.q = new box2d.b2Rot
    }, box2d.b2Transform.prototype.p = null, box2d.b2Transform.prototype.q = null, box2d.b2Transform.IDENTITY = new box2d.b2Transform, box2d.b2Transform.prototype.Clone = function() {
        return (new box2d.b2Transform).Copy(this)
    }, box2d.b2Transform.prototype.Copy = function(t) {
        return this.p.Copy(t.p), this.q.Copy(t.q), this
    }, box2d.b2Transform.prototype.SetIdentity = function() {
        return this.p.SetZero(), this.q.SetIdentity(), this
    }, box2d.b2Transform.prototype.SetPositionRotation = function(t, e) {
        return this.p.Copy(t), this.q.Copy(e), this
    }, box2d.b2Transform.prototype.SetPositionAngleRadians = function(t, e) {
        return this.p.Copy(t), this.q.SetAngleRadians(e), this
    }, box2d.b2Transform.prototype.SetPosition = function(t) {
        return this.p.Copy(t), this
    }, box2d.b2Transform.prototype.SetPositionXY = function(t, e) {
        return this.p.SetXY(t, e), this
    }, box2d.b2Transform.prototype.SetRotation = function(t) {
        return this.q.Copy(t), this
    }, box2d.b2Transform.prototype.SetRotationAngleRadians = function(t) {
        return this.q.SetAngleRadians(t), this
    }, box2d.b2Transform.prototype.GetPosition = function() {
        return this.p
    }, box2d.b2Transform.prototype.GetRotation = function() {
        return this.q
    }, box2d.b2Transform.prototype.GetRotationAngle = function() {
        return this.q.GetAngle()
    }, box2d.b2Transform.prototype.GetRotationAngleRadians = box2d.b2Transform.prototype.GetRotationAngle, box2d.b2Transform.prototype.GetAngle = function() {
        return this.q.GetAngle()
    }, box2d.b2Transform.prototype.GetAngleRadians = box2d.b2Transform.prototype.GetAngle, box2d.b2MulXV = function(t, e, i) {
        var o = t.q.c,
            s = t.q.s,
            n = e.x,
            r = e.y;
        return i.x = o * n - s * r + t.p.x, i.y = s * n + o * r + t.p.y, i
    }, box2d.b2MulTXV = function(t, e, i) {
        var o = t.q.c,
            s = t.q.s,
            n = e.x - t.p.x,
            r = e.y - t.p.y;
        return i.x = o * n + s * r, i.y = -s * n + o * r, i
    }, box2d.b2MulXX = function(t, e, i) {
        return box2d.b2MulRR(t.q, e.q, i.q), box2d.b2AddVV(box2d.b2MulRV(t.q, e.p, i.p), t.p, i.p), i
    }, box2d.b2MulTXX = function(t, e, i) {
        return box2d.b2MulTRR(t.q, e.q, i.q), box2d.b2MulTRV(t.q, box2d.b2SubVV(e.p, t.p, i.p), i.p), i
    }, box2d.b2Sweep = function() {
        this.localCenter = new box2d.b2Vec2, this.c0 = new box2d.b2Vec2, this.c = new box2d.b2Vec2
    }, box2d.b2Sweep.prototype.localCenter = null, box2d.b2Sweep.prototype.c0 = null, box2d.b2Sweep.prototype.c = null, box2d.b2Sweep.prototype.a0 = 0, box2d.b2Sweep.prototype.a = 0, box2d.b2Sweep.prototype.alpha0 = 0, box2d.b2Sweep.prototype.Clone = function() {
        return (new box2d.b2Sweep).Copy(this)
    }, box2d.b2Sweep.prototype.Copy = function(t) {
        return this.localCenter.Copy(t.localCenter), this.c0.Copy(t.c0), this.c.Copy(t.c), this.a0 = t.a0, this.a = t.a, this.alpha0 = t.alpha0, this
    }, box2d.b2Sweep.prototype.GetTransform = function(t, e) {
        var i = 1 - e;
        t.p.x = i * this.c0.x + e * this.c.x, t.p.y = i * this.c0.y + e * this.c.y;
        var o = i * this.a0 + e * this.a;
        return t.q.SetAngleRadians(o), t.p.SelfSub(box2d.b2MulRV(t.q, this.localCenter, box2d.b2Vec2.s_t0)), t
    }, box2d.b2Sweep.prototype.Advance = function(t) {
        var e = (t - this.alpha0) / (1 - this.alpha0);
        this.c0.x += e * (this.c.x - this.c0.x), this.c0.y += e * (this.c.y - this.c0.y), this.a0 += e * (this.a - this.a0), this.alpha0 = t
    }, box2d.b2Sweep.prototype.Normalize = function() {
        var t = box2d.b2_two_pi * Math.floor(this.a0 / box2d.b2_two_pi);
        this.a0 -= t, this.a -= t
    }, goog.provide("box2d.b2Controller"), goog.require("box2d.b2Settings"), box2d.b2ControllerEdge = function() {}, box2d.b2ControllerEdge.prototype.controller = null, box2d.b2ControllerEdge.prototype.body = null, box2d.b2ControllerEdge.prototype.prevBody = null, box2d.b2ControllerEdge.prototype.nextBody = null, box2d.b2ControllerEdge.prototype.prevController = null, box2d.b2ControllerEdge.prototype.nextController = null, box2d.b2Controller = function() {}, box2d.b2Controller.prototype.m_world = null, box2d.b2Controller.prototype.m_bodyList = null, box2d.b2Controller.prototype.m_bodyCount = 0, box2d.b2Controller.prototype.m_prev = null, box2d.b2Controller.prototype.m_next = null, box2d.b2Controller.prototype.Step = function(t) {}, box2d.b2Controller.prototype.Draw = function(t) {}, box2d.b2Controller.prototype.GetNext = function() {
        return this.m_next
    }, box2d.b2Controller.prototype.GetPrev = function() {
        return this.m_prev
    }, box2d.b2Controller.prototype.GetWorld = function() {
        return this.m_world
    }, box2d.b2Controller.prototype.GetBodyList = function() {
        return this.m_bodyList
    }, box2d.b2Controller.prototype.AddBody = function(t) {
        var e = new box2d.b2ControllerEdge;
        e.body = t, e.controller = this, e.nextBody = this.m_bodyList, e.prevBody = null, this.m_bodyList && (this.m_bodyList.prevBody = e), this.m_bodyList = e, ++this.m_bodyCount, e.nextController = t.m_controllerList, e.prevController = null, t.m_controllerList && (t.m_controllerList.prevController = e), t.m_controllerList = e, ++t.m_controllerCount
    }, box2d.b2Controller.prototype.RemoveBody = function(t) {
        for (var e = this.m_bodyList; e && e.body !== t;) e = e.nextBody;
        e.prevBody && (e.prevBody.nextBody = e.nextBody), e.nextBody && (e.nextBody.prevBody = e.prevBody), this.m_bodyList === e && (this.m_bodyList = e.nextBody), --this.m_bodyCount, e.nextController && (e.nextController.prevController = e.prevController), e.prevController && (e.prevController.nextController = e.nextController), t.m_controllerList === e && (t.m_controllerList = e.nextController), --t.m_controllerCount
    }, box2d.b2Controller.prototype.Clear = function() {
        for (; this.m_bodyList;) this.RemoveBody(this.m_bodyList.body);
        this.m_bodyCount = 0
    }, goog.provide("box2d.b2ConstantAccelController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), box2d.b2ConstantAccelController = function() {
        goog.base(this), this.A = new box2d.b2Vec2(0, 0)
    }, goog.inherits(box2d.b2ConstantAccelController, box2d.b2Controller), box2d.b2ConstantAccelController.prototype.A = null, box2d.b2ConstantAccelController.prototype.Step = function(t) {
        for (var e = box2d.b2MulSV(t.dt, this.A, box2d.b2ConstantAccelController.prototype.Step.s_dtA), i = this.m_bodyList; i; i = i.nextBody) {
            var o = i.body;
            o.IsAwake() && o.SetLinearVelocity(box2d.b2AddVV(o.GetLinearVelocity(), e, box2d.b2Vec2.s_t0))
        }
    }, box2d.b2ConstantAccelController.prototype.Step.s_dtA = new box2d.b2Vec2, goog.provide("box2d.b2Joint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), box2d.b2JointType = {
        e_unknownJoint: 0,
        e_revoluteJoint: 1,
        e_prismaticJoint: 2,
        e_distanceJoint: 3,
        e_pulleyJoint: 4,
        e_mouseJoint: 5,
        e_gearJoint: 6,
        e_wheelJoint: 7,
        e_weldJoint: 8,
        e_frictionJoint: 9,
        e_ropeJoint: 10,
        e_motorJoint: 11,
        e_areaJoint: 12
    }, goog.exportProperty(box2d.b2JointType, "e_unknownJoint", box2d.b2JointType.e_unknownJoint), goog.exportProperty(box2d.b2JointType, "e_revoluteJoint", box2d.b2JointType.e_revoluteJoint), goog.exportProperty(box2d.b2JointType, "e_prismaticJoint", box2d.b2JointType.e_prismaticJoint), goog.exportProperty(box2d.b2JointType, "e_distanceJoint", box2d.b2JointType.e_distanceJoint), goog.exportProperty(box2d.b2JointType, "e_pulleyJoint", box2d.b2JointType.e_pulleyJoint), goog.exportProperty(box2d.b2JointType, "e_mouseJoint", box2d.b2JointType.e_mouseJoint), goog.exportProperty(box2d.b2JointType, "e_gearJoint", box2d.b2JointType.e_gearJoint), goog.exportProperty(box2d.b2JointType, "e_wheelJoint", box2d.b2JointType.e_wheelJoint), goog.exportProperty(box2d.b2JointType, "e_weldJoint", box2d.b2JointType.e_weldJoint), goog.exportProperty(box2d.b2JointType, "e_frictionJoint", box2d.b2JointType.e_frictionJoint), goog.exportProperty(box2d.b2JointType, "e_ropeJoint", box2d.b2JointType.e_ropeJoint), goog.exportProperty(box2d.b2JointType, "e_motorJoint", box2d.b2JointType.e_motorJoint), goog.exportProperty(box2d.b2JointType, "e_areaJoint", box2d.b2JointType.e_areaJoint), box2d.b2LimitState = {
        e_inactiveLimit: 0,
        e_atLowerLimit: 1,
        e_atUpperLimit: 2,
        e_equalLimits: 3
    }, goog.exportProperty(box2d.b2LimitState, "e_inactiveLimit", box2d.b2LimitState.e_inactiveLimit), goog.exportProperty(box2d.b2LimitState, "e_atLowerLimit", box2d.b2LimitState.e_atLowerLimit), goog.exportProperty(box2d.b2LimitState, "e_atUpperLimit", box2d.b2LimitState.e_atUpperLimit),
    goog.exportProperty(box2d.b2LimitState, "e_equalLimits", box2d.b2LimitState.e_equalLimits), box2d.b2Jacobian = function() {
        this.linear = new box2d.b2Vec2
    }, box2d.b2Jacobian.prototype.linear = null, box2d.b2Jacobian.prototype.angularA = 0, box2d.b2Jacobian.prototype.angularB = 0, box2d.b2Jacobian.prototype.SetZero = function() {
        return this.linear.SetZero(), this.angularA = 0, this.angularB = 0, this
    }, box2d.b2Jacobian.prototype.Set = function(t, e, i) {
        return this.linear.Copy(t), this.angularA = e, this.angularB = i, this
    }, box2d.b2JointEdge = function() {}, box2d.b2JointEdge.prototype.other = null, box2d.b2JointEdge.prototype.joint = null, box2d.b2JointEdge.prototype.prev = null;
box2d.b2JointEdge.prototype.next = null, box2d.b2JointDef = function(t) {
    this.type = t
}, box2d.b2JointDef.prototype.type = box2d.b2JointType.e_unknownJoint, box2d.b2JointDef.prototype.userData = null, box2d.b2JointDef.prototype.bodyA = null, box2d.b2JointDef.prototype.bodyB = null, box2d.b2JointDef.prototype.collideConnected = !1, box2d.b2Joint = function(t) {
    this.m_type = t.type, this.m_edgeA = new box2d.b2JointEdge, this.m_edgeB = new box2d.b2JointEdge, this.m_bodyA = t.bodyA, this.m_bodyB = t.bodyB, this.m_collideConnected = t.collideConnected, this.m_userData = t.userData
}, box2d.b2Joint.prototype.m_type = box2d.b2JointType.e_unknownJoint, box2d.b2Joint.prototype.m_prev = null, box2d.b2Joint.prototype.m_next = null, box2d.b2Joint.prototype.m_edgeA = null, box2d.b2Joint.prototype.m_edgeB = null, box2d.b2Joint.prototype.m_bodyA = null, box2d.b2Joint.prototype.m_bodyB = null, box2d.b2Joint.prototype.m_index = 0, box2d.b2Joint.prototype.m_islandFlag = !1, box2d.b2Joint.prototype.m_collideConnected = !1, box2d.b2Joint.prototype.m_userData = null, box2d.b2Joint.prototype.GetAnchorA = function(t) {
    return t.SetZero()
}, box2d.b2Joint.prototype.GetAnchorB = function(t) {
    return t.SetZero()
}, box2d.b2Joint.prototype.GetReactionForce = function(t, e) {
    return e.SetZero()
}, box2d.b2Joint.prototype.GetReactionTorque = function(t) {
    return 0
}, box2d.b2Joint.prototype.InitVelocityConstraints = function(t) {}, box2d.b2Joint.prototype.SolveVelocityConstraints = function(t) {}, box2d.b2Joint.prototype.SolvePositionConstraints = function(t) {
    return !1
}, box2d.b2Joint.prototype.GetType = function() {
    return this.m_type
}, box2d.b2Joint.prototype.GetBodyA = function() {
    return this.m_bodyA
}, box2d.b2Joint.prototype.GetBodyB = function() {
    return this.m_bodyB
}, box2d.b2Joint.prototype.GetNext = function() {
    return this.m_next
}, box2d.b2Joint.prototype.GetUserData = function() {
    return this.m_userData
}, box2d.b2Joint.prototype.SetUserData = function(t) {
    this.m_userData = t
}, box2d.b2Joint.prototype.GetCollideConnected = function() {
    return this.m_collideConnected
}, box2d.b2Joint.prototype.Dump = function() {}, box2d.b2Joint.prototype.IsActive = function() {
    return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
}, box2d.b2Joint.prototype.ShiftOrigin = function(t) {}, goog.provide("box2d.b2RevoluteJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2RevoluteJointDef = function() {
    goog.base(this, box2d.b2JointType.e_revoluteJoint), this.localAnchorA = new box2d.b2Vec2(0, 0), this.localAnchorB = new box2d.b2Vec2(0, 0)
}, goog.inherits(box2d.b2RevoluteJointDef, box2d.b2JointDef), box2d.b2RevoluteJointDef.prototype.localAnchorA = null, box2d.b2RevoluteJointDef.prototype.localAnchorB = null, box2d.b2RevoluteJointDef.prototype.referenceAngle = 0, box2d.b2RevoluteJointDef.prototype.enableLimit = !1, box2d.b2RevoluteJointDef.prototype.lowerAngle = 0, box2d.b2RevoluteJointDef.prototype.upperAngle = 0, box2d.b2RevoluteJointDef.prototype.enableMotor = !1, box2d.b2RevoluteJointDef.prototype.motorSpeed = 0, box2d.b2RevoluteJointDef.prototype.maxMotorTorque = 0, box2d.b2RevoluteJointDef.prototype.Initialize = function(t, e, i) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB), this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
}, box2d.b2RevoluteJoint = function(t) {
    goog.base(this, t), this.m_localAnchorA = new box2d.b2Vec2, this.m_localAnchorB = new box2d.b2Vec2, this.m_impulse = new box2d.b2Vec3, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_mass = new box2d.b2Mat33, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_K = new box2d.b2Mat22, this.m_localAnchorA.Copy(t.localAnchorA), this.m_localAnchorB.Copy(t.localAnchorB), this.m_referenceAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_motorImpulse = 0, this.m_lowerAngle = t.lowerAngle, this.m_upperAngle = t.upperAngle, this.m_maxMotorTorque = t.maxMotorTorque, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = box2d.b2LimitState.e_inactiveLimit
}, goog.inherits(box2d.b2RevoluteJoint, box2d.b2Joint), box2d.b2RevoluteJoint.prototype.m_localAnchorA = null, box2d.b2RevoluteJoint.prototype.m_localAnchorB = null, box2d.b2RevoluteJoint.prototype.m_impulse = null, box2d.b2RevoluteJoint.prototype.m_motorImpulse = 0, box2d.b2RevoluteJoint.prototype.m_enableMotor = !1, box2d.b2RevoluteJoint.prototype.m_maxMotorTorque = 0, box2d.b2RevoluteJoint.prototype.m_motorSpeed = 0, box2d.b2RevoluteJoint.prototype.m_enableLimit = !1, box2d.b2RevoluteJoint.prototype.m_referenceAngle = 0, box2d.b2RevoluteJoint.prototype.m_lowerAngle = 0, box2d.b2RevoluteJoint.prototype.m_upperAngle = 0, box2d.b2RevoluteJoint.prototype.m_indexA = 0, box2d.b2RevoluteJoint.prototype.m_indexB = 0, box2d.b2RevoluteJoint.prototype.m_rA = null, box2d.b2RevoluteJoint.prototype.m_rB = null, box2d.b2RevoluteJoint.prototype.m_localCenterA = null, box2d.b2RevoluteJoint.prototype.m_localCenterB = null, box2d.b2RevoluteJoint.prototype.m_invMassA = 0, box2d.b2RevoluteJoint.prototype.m_invMassB = 0, box2d.b2RevoluteJoint.prototype.m_invIA = 0, box2d.b2RevoluteJoint.prototype.m_invIB = 0, box2d.b2RevoluteJoint.prototype.m_mass = null, box2d.b2RevoluteJoint.prototype.m_motorMass = 0, box2d.b2RevoluteJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit, box2d.b2RevoluteJoint.prototype.m_qA = null, box2d.b2RevoluteJoint.prototype.m_qB = null, box2d.b2RevoluteJoint.prototype.m_lalcA = null, box2d.b2RevoluteJoint.prototype.m_lalcB = null, box2d.b2RevoluteJoint.prototype.m_K = null, box2d.b2RevoluteJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].a,
        i = t.velocities[this.m_indexA].v,
        o = t.velocities[this.m_indexA].w,
        s = t.positions[this.m_indexB].a,
        n = t.velocities[this.m_indexB].v,
        r = t.velocities[this.m_indexB].w,
        a = this.m_qA.SetAngleRadians(e),
        h = this.m_qB.SetAngleRadians(s);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(a, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(h, this.m_lalcB, this.m_rB);
    var l = this.m_invMassA,
        d = this.m_invMassB,
        c = this.m_invIA,
        p = this.m_invIB,
        u = c + p === 0;
    if (this.m_mass.ex.x = l + d + this.m_rA.y * this.m_rA.y * c + this.m_rB.y * this.m_rB.y * p, this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * c - this.m_rB.y * this.m_rB.x * p, this.m_mass.ez.x = -this.m_rA.y * c - this.m_rB.y * p, this.m_mass.ex.y = this.m_mass.ey.x, this.m_mass.ey.y = l + d + this.m_rA.x * this.m_rA.x * c + this.m_rB.x * this.m_rB.x * p, this.m_mass.ez.y = this.m_rA.x * c + this.m_rB.x * p, this.m_mass.ex.z = this.m_mass.ez.x, this.m_mass.ey.z = this.m_mass.ez.y, this.m_mass.ez.z = c + p, this.m_motorMass = c + p, this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass), (!1 === this.m_enableMotor || u) && (this.m_motorImpulse = 0), this.m_enableLimit && !1 === u) {
        var b = s - e - this.m_referenceAngle;
        box2d.b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * box2d.b2_angularSlop ? this.m_limitState = box2d.b2LimitState.e_equalLimits : b <= this.m_lowerAngle ? (this.m_limitState !== box2d.b2LimitState.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = box2d.b2LimitState.e_atLowerLimit) : b >= this.m_upperAngle ? (this.m_limitState !== box2d.b2LimitState.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = box2d.b2LimitState.e_atUpperLimit) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z = 0)
    } else this.m_limitState = box2d.b2LimitState.e_inactiveLimit;
    if (t.step.warmStarting) {
        this.m_impulse.SelfMul(t.step.dtRatio), this.m_motorImpulse *= t.step.dtRatio;
        var m = box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y);
        i.SelfMulSub(l, m), o -= c * (box2d.b2CrossVV(this.m_rA, m) + this.m_motorImpulse + this.m_impulse.z), n.SelfMulAdd(d, m), r += p * (box2d.b2CrossVV(this.m_rB, m) + this.m_motorImpulse + this.m_impulse.z)
    } else this.m_impulse.SetZero(), this.m_motorImpulse = 0;
    t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = r
}, box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB,
        l = a + h === 0;
    if (this.m_enableMotor && this.m_limitState !== box2d.b2LimitState.e_equalLimits && !1 === l) {
        var d = s - i - this.m_motorSpeed,
            c = -this.m_motorMass * d,
            p = this.m_motorImpulse,
            u = t.step.dt * this.m_maxMotorTorque;
        this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + c, -u, u), c = this.m_motorImpulse - p, i -= a * c, s += h * c
    }
    if (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit && !1 === l) {
        var b = box2d.b2SubVV(box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1),
            m = s - i,
            c = this.m_mass.Solve33(b.x, b.y, m, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3).SelfNeg();
        if (this.m_limitState === box2d.b2LimitState.e_equalLimits) this.m_impulse.SelfAdd(c);
        else if (this.m_limitState === box2d.b2LimitState.e_atLowerLimit) {
            var y = this.m_impulse.z + c.z;
            if (y < 0) {
                var f = -b.x + this.m_impulse.z * this.m_mass.ez.x,
                    g = -b.y + this.m_impulse.z * this.m_mass.ez.y,
                    x = this.m_mass.Solve22(f, g, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced);
                c.x = x.x, c.y = x.y, c.z = -this.m_impulse.z, this.m_impulse.x += x.x, this.m_impulse.y += x.y, this.m_impulse.z = 0
            } else this.m_impulse.SelfAdd(c)
        } else if (this.m_limitState === box2d.b2LimitState.e_atUpperLimit) {
            var y = this.m_impulse.z + c.z;
            if (y > 0) {
                var f = -b.x + this.m_impulse.z * this.m_mass.ez.x,
                    g = -b.y + this.m_impulse.z * this.m_mass.ez.y,
                    x = this.m_mass.Solve22(f, g, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced);
                c.x = x.x, c.y = x.y, c.z = -this.m_impulse.z, this.m_impulse.x += x.x, this.m_impulse.y += x.y, this.m_impulse.z = 0
            } else this.m_impulse.SelfAdd(c)
        }
        var _ = box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P.SetXY(c.x, c.y);
        e.SelfMulSub(n, _), i -= a * (box2d.b2CrossVV(this.m_rA, _) + c.z), o.SelfMulAdd(r, _), s += h * (box2d.b2CrossVV(this.m_rB, _) + c.z)
    } else {
        var d = box2d.b2SubVV(box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot),
            c = this.m_mass.Solve22(-d.x, -d.y, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2);
        this.m_impulse.x += c.x, this.m_impulse.y += c.y, e.SelfMulSub(n, c), i -= a * box2d.b2CrossVV(this.m_rA, c), o.SelfMulAdd(r, c), s += h * box2d.b2CrossVV(this.m_rB, c)
    }
    t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3 = new box2d.b2Vec3, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2 = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints = function(t) {
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        s = t.positions[this.m_indexB].a,
        n = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(s),
        a = 0,
        h = 0,
        l = this.m_invIA + this.m_invIB === 0;
    if (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit && !1 === l) {
        var d = s - i - this.m_referenceAngle,
            c = 0;
        if (this.m_limitState === box2d.b2LimitState.e_equalLimits) {
            var p = box2d.b2Clamp(d - this.m_lowerAngle, -box2d.b2_maxAngularCorrection, box2d.b2_maxAngularCorrection);
            c = -this.m_motorMass * p, a = box2d.b2Abs(p)
        } else if (this.m_limitState === box2d.b2LimitState.e_atLowerLimit) {
            var p = d - this.m_lowerAngle;
            a = -p, p = box2d.b2Clamp(p + box2d.b2_angularSlop, -box2d.b2_maxAngularCorrection, 0), c = -this.m_motorMass * p
        } else if (this.m_limitState === box2d.b2LimitState.e_atUpperLimit) {
            var p = d - this.m_upperAngle;
            a = p, p = box2d.b2Clamp(p - box2d.b2_angularSlop, 0, box2d.b2_maxAngularCorrection), c = -this.m_motorMass * p
        }
        i -= this.m_invIA * c, s += this.m_invIB * c
    }
    n.SetAngleRadians(i), r.SetAngleRadians(s), box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var u = box2d.b2MulRV(n, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var b = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        p = box2d.b2SubVV(box2d.b2AddVV(o, b, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, u, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C);
    h = p.GetLength();
    var m = this.m_invMassA,
        y = this.m_invMassB,
        f = this.m_invIA,
        g = this.m_invIB,
        x = this.m_K;
    x.ex.x = m + y + f * u.y * u.y + g * b.y * b.y, x.ex.y = -f * u.x * u.y - g * b.x * b.y, x.ey.x = x.ex.y, x.ey.y = m + y + f * u.x * u.x + g * b.x * b.x;
    var _ = x.Solve(p.x, p.y, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg();
    return e.SelfMulSub(m, _), i -= f * box2d.b2CrossVV(u, _), o.SelfMulAdd(y, _), s += g * box2d.b2CrossVV(b, _), t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = s, h <= box2d.b2_linearSlop && a <= box2d.b2_angularSlop
}, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2RevoluteJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2RevoluteJoint.prototype.GetReactionForce = function(t, e) {
    return e.SetXY(t * this.m_impulse.x, t * this.m_impulse.y)
}, box2d.b2RevoluteJoint.prototype.GetReactionTorque = function(t) {
    return t * this.m_impulse.z
}, box2d.b2RevoluteJoint.prototype.GetLocalAnchorA = function(t) {
    return t.Copy(this.m_localAnchorA)
}, box2d.b2RevoluteJoint.prototype.GetLocalAnchorB = function(t) {
    return t.Copy(this.m_localAnchorB)
}, box2d.b2RevoluteJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
}, box2d.b2RevoluteJoint.prototype.GetJointAngleRadians = function() {
    return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
}, box2d.b2RevoluteJoint.prototype.GetJointSpeed = function() {
    return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
}, box2d.b2RevoluteJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
}, box2d.b2RevoluteJoint.prototype.EnableMotor = function(t) {
    this.m_enableMotor !== t && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t)
}, box2d.b2RevoluteJoint.prototype.GetMotorTorque = function(t) {
    return t * this.m_motorImpulse
}, box2d.b2RevoluteJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
}, box2d.b2RevoluteJoint.prototype.SetMaxMotorTorque = function(t) {
    this.m_maxMotorTorque = t
}, box2d.b2RevoluteJoint.prototype.GetMaxMotorTorque = function() {
    return this.m_maxMotorTorque
}, box2d.b2RevoluteJoint.prototype.IsLimitEnabled = function() {
    return this.m_enableLimit
}, box2d.b2RevoluteJoint.prototype.EnableLimit = function(t) {
    t !== this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = t, this.m_impulse.z = 0)
}, box2d.b2RevoluteJoint.prototype.GetLowerLimit = function() {
    return this.m_lowerAngle
}, box2d.b2RevoluteJoint.prototype.GetUpperLimit = function() {
    return this.m_upperAngle
}, box2d.b2RevoluteJoint.prototype.SetLimits = function(t, e) {
    t === this.m_lowerAngle && e === this.m_upperAngle || (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_impulse.z = 0, this.m_lowerAngle = t, this.m_upperAngle = e)
}, box2d.b2RevoluteJoint.prototype.SetMotorSpeed = function(t) {
    this.m_motorSpeed !== t && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t)
}, box2d.b2RevoluteJoint.prototype.Dump = function() {}, goog.provide("box2d.b2PrismaticJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2PrismaticJointDef = function() {
    goog.base(this, box2d.b2JointType.e_prismaticJoint), this.localAnchorA = new box2d.b2Vec2, this.localAnchorB = new box2d.b2Vec2, this.localAxisA = new box2d.b2Vec2(1, 0)
}, goog.inherits(box2d.b2PrismaticJointDef, box2d.b2JointDef), box2d.b2PrismaticJointDef.prototype.localAnchorA = null, box2d.b2PrismaticJointDef.prototype.localAnchorB = null, box2d.b2PrismaticJointDef.prototype.localAxisA = null, box2d.b2PrismaticJointDef.prototype.referenceAngle = 0, box2d.b2PrismaticJointDef.prototype.enableLimit = !1, box2d.b2PrismaticJointDef.prototype.lowerTranslation = 0, box2d.b2PrismaticJointDef.prototype.upperTranslation = 0, box2d.b2PrismaticJointDef.prototype.enableMotor = !1, box2d.b2PrismaticJointDef.prototype.maxMotorForce = 0, box2d.b2PrismaticJointDef.prototype.motorSpeed = 0, box2d.b2PrismaticJointDef.prototype.Initialize = function(t, e, i, o) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB), this.bodyA.GetLocalVector(o, this.localAxisA), this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
}, box2d.b2PrismaticJoint = function(t) {
    goog.base(this, t), this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_localXAxisA = t.localAxisA.Clone().SelfNormalize(), this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2), this.m_referenceAngle = t.referenceAngle, this.m_impulse = new box2d.b2Vec3(0, 0, 0), this.m_lowerTranslation = t.lowerTranslation, this.m_upperTranslation = t.upperTranslation, this.m_maxMotorForce = t.maxMotorForce, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_axis = new box2d.b2Vec2(0, 0), this.m_perp = new box2d.b2Vec2(0, 0), this.m_K = new box2d.b2Mat33, this.m_K3 = new box2d.b2Mat33, this.m_K2 = new box2d.b2Mat22, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2
}, goog.inherits(box2d.b2PrismaticJoint, box2d.b2Joint), box2d.b2PrismaticJoint.prototype.m_localAnchorA = null, box2d.b2PrismaticJoint.prototype.m_localAnchorB = null, box2d.b2PrismaticJoint.prototype.m_localXAxisA = null, box2d.b2PrismaticJoint.prototype.m_localYAxisA = null, box2d.b2PrismaticJoint.prototype.m_referenceAngle = 0, box2d.b2PrismaticJoint.prototype.m_impulse = null, box2d.b2PrismaticJoint.prototype.m_motorImpulse = 0, box2d.b2PrismaticJoint.prototype.m_lowerTranslation = 0, box2d.b2PrismaticJoint.prototype.m_upperTranslation = 0, box2d.b2PrismaticJoint.prototype.m_maxMotorForce = 0, box2d.b2PrismaticJoint.prototype.m_motorSpeed = 0, box2d.b2PrismaticJoint.prototype.m_enableLimit = !1, box2d.b2PrismaticJoint.prototype.m_enableMotor = !1, box2d.b2PrismaticJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit, box2d.b2PrismaticJoint.prototype.m_indexA = 0, box2d.b2PrismaticJoint.prototype.m_indexB = 0, box2d.b2PrismaticJoint.prototype.m_localCenterA = null, box2d.b2PrismaticJoint.prototype.m_localCenterB = null, box2d.b2PrismaticJoint.prototype.m_invMassA = 0, box2d.b2PrismaticJoint.prototype.m_invMassB = 0, box2d.b2PrismaticJoint.prototype.m_invIA = 0, box2d.b2PrismaticJoint.prototype.m_invIB = 0, box2d.b2PrismaticJoint.prototype.m_axis = null, box2d.b2PrismaticJoint.prototype.m_perp = null, box2d.b2PrismaticJoint.prototype.m_s1 = 0, box2d.b2PrismaticJoint.prototype.m_s2 = 0, box2d.b2PrismaticJoint.prototype.m_a1 = 0, box2d.b2PrismaticJoint.prototype.m_a2 = 0, box2d.b2PrismaticJoint.prototype.m_K = null, box2d.b2PrismaticJoint.prototype.m_K3 = null, box2d.b2PrismaticJoint.prototype.m_K2 = null, box2d.b2PrismaticJoint.prototype.m_motorMass = 0, box2d.b2PrismaticJoint.prototype.m_qA = null, box2d.b2PrismaticJoint.prototype.m_qB = null, box2d.b2PrismaticJoint.prototype.m_lalcA = null, box2d.b2PrismaticJoint.prototype.m_lalcB = null, box2d.b2PrismaticJoint.prototype.m_rA = null, box2d.b2PrismaticJoint.prototype.m_rB = null, box2d.b2PrismaticJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        s = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        d = this.m_qB.SetAngleRadians(r);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var c = box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var p = box2d.b2MulRV(d, this.m_lalcB, this.m_rB),
        u = box2d.b2AddVV(box2d.b2SubVV(n, e, box2d.b2Vec2.s_t0), box2d.b2SubVV(p, c, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d),
        b = this.m_invMassA,
        m = this.m_invMassB,
        y = this.m_invIA,
        f = this.m_invIB;
    if (box2d.b2MulRV(l, this.m_localXAxisA, this.m_axis), this.m_a1 = box2d.b2CrossVV(box2d.b2AddVV(u, c, box2d.b2Vec2.s_t0), this.m_axis), this.m_a2 = box2d.b2CrossVV(p, this.m_axis), this.m_motorMass = b + m + y * this.m_a1 * this.m_a1 + f * this.m_a2 * this.m_a2, this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass), box2d.b2MulRV(l, this.m_localYAxisA, this.m_perp), this.m_s1 = box2d.b2CrossVV(box2d.b2AddVV(u, c, box2d.b2Vec2.s_t0), this.m_perp), this.m_s2 = box2d.b2CrossVV(p, this.m_perp), this.m_K.ex.x = b + m + y * this.m_s1 * this.m_s1 + f * this.m_s2 * this.m_s2, this.m_K.ex.y = y * this.m_s1 + f * this.m_s2, this.m_K.ex.z = y * this.m_s1 * this.m_a1 + f * this.m_s2 * this.m_a2, this.m_K.ey.x = this.m_K.ex.y, this.m_K.ey.y = y + f, 0 === this.m_K.ey.y && (this.m_K.ey.y = 1), this.m_K.ey.z = y * this.m_a1 + f * this.m_a2, this.m_K.ez.x = this.m_K.ex.z, this.m_K.ez.y = this.m_K.ey.z, this.m_K.ez.z = b + m + y * this.m_a1 * this.m_a1 + f * this.m_a2 * this.m_a2, this.m_enableLimit) {
        var g = box2d.b2DotVV(this.m_axis, u);
        box2d.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * box2d.b2_linearSlop ? this.m_limitState = box2d.b2LimitState.e_equalLimits : g <= this.m_lowerTranslation ? this.m_limitState !== box2d.b2LimitState.e_atLowerLimit && (this.m_limitState = box2d.b2LimitState.e_atLowerLimit, this.m_impulse.z = 0) : g >= this.m_upperTranslation ? this.m_limitState !== box2d.b2LimitState.e_atUpperLimit && (this.m_limitState = box2d.b2LimitState.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z = 0)
    } else this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z = 0;
    if (!1 === this.m_enableMotor && (this.m_motorImpulse = 0), t.step.warmStarting) {
        this.m_impulse.SelfMul(t.step.dtRatio), this.m_motorImpulse *= t.step.dtRatio;
        var x = box2d.b2AddVV(box2d.b2MulSV(this.m_impulse.x, this.m_perp, box2d.b2Vec2.s_t0), box2d.b2MulSV(this.m_motorImpulse + this.m_impulse.z, this.m_axis, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P),
            _ = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1,
            v = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
        o.SelfMulSub(b, x), s -= y * _, a.SelfMulAdd(m, x), h += f * v
    } else this.m_impulse.SetZero(), this.m_motorImpulse = 0;
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = h
}, box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB;
    if (this.m_enableMotor && this.m_limitState !== box2d.b2LimitState.e_equalLimits) {
        var l = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(o, e, box2d.b2Vec2.s_t0)) + this.m_a2 * s - this.m_a1 * i,
            d = this.m_motorMass * (this.m_motorSpeed - l),
            c = this.m_motorImpulse,
            p = t.step.dt * this.m_maxMotorForce;
        this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + d, -p, p), d = this.m_motorImpulse - c;
        var u = box2d.b2MulSV(d, this.m_axis, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P),
            b = d * this.m_a1,
            m = d * this.m_a2;
        e.SelfMulSub(n, u), i -= a * b, o.SelfMulAdd(r, u), s += h * m
    }
    var y = box2d.b2DotVV(this.m_perp, box2d.b2SubVV(o, e, box2d.b2Vec2.s_t0)) + this.m_s2 * s - this.m_s1 * i,
        f = s - i;
    if (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit) {
        var g = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(o, e, box2d.b2Vec2.s_t0)) + this.m_a2 * s - this.m_a1 * i,
            x = box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1.Copy(this.m_impulse),
            _ = this.m_K.Solve33(-y, -f, -g, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3);
        this.m_impulse.SelfAdd(_), this.m_limitState === box2d.b2LimitState.e_atLowerLimit ? this.m_impulse.z = box2d.b2Max(this.m_impulse.z, 0) : this.m_limitState === box2d.b2LimitState.e_atUpperLimit && (this.m_impulse.z = box2d.b2Min(this.m_impulse.z, 0));
        var v = -y - (this.m_impulse.z - x.z) * this.m_K.ez.x,
            w = -f - (this.m_impulse.z - x.z) * this.m_K.ez.y,
            C = this.m_K.Solve22(v, w, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r);
        C.x += x.x, C.y += x.y, this.m_impulse.x = C.x, this.m_impulse.y = C.y, _.x = this.m_impulse.x - x.x, _.y = this.m_impulse.y - x.y, _.z = this.m_impulse.z - x.z;
        var u = box2d.b2AddVV(box2d.b2MulSV(_.x, this.m_perp, box2d.b2Vec2.s_t0), box2d.b2MulSV(_.z, this.m_axis, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P),
            b = _.x * this.m_s1 + _.y + _.z * this.m_a1,
            m = _.x * this.m_s2 + _.y + _.z * this.m_a2;
        e.SelfMulSub(n, u), i -= a * b, o.SelfMulAdd(r, u), s += h * m
    } else {
        var _ = this.m_K.Solve22(-y, -f, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2);
        this.m_impulse.x += _.x, this.m_impulse.y += _.y;
        var u = box2d.b2MulSV(_.x, this.m_perp, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P),
            b = _.x * this.m_s1 + _.y,
            m = _.x * this.m_s2 + _.y;
        e.SelfMulSub(n, u), i -= a * b, o.SelfMulAdd(r, u), s += h * m
    }
    t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1 = new box2d.b2Vec3, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3 = new box2d.b2Vec3, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2 = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints = function(t) {
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        s = t.positions[this.m_indexB].a,
        n = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(s),
        a = this.m_invMassA,
        h = this.m_invMassB,
        l = this.m_invIA,
        d = this.m_invIB,
        c = box2d.b2MulRV(n, this.m_lalcA, this.m_rA),
        p = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        u = box2d.b2SubVV(box2d.b2AddVV(o, p, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, c, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d),
        b = box2d.b2MulRV(n, this.m_localXAxisA, this.m_axis),
        m = box2d.b2CrossVV(box2d.b2AddVV(u, c, box2d.b2Vec2.s_t0), b),
        y = box2d.b2CrossVV(p, b),
        f = box2d.b2MulRV(n, this.m_localYAxisA, this.m_perp),
        g = box2d.b2CrossVV(box2d.b2AddVV(u, c, box2d.b2Vec2.s_t0), f),
        x = box2d.b2CrossVV(p, f),
        _ = box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse,
        v = box2d.b2DotVV(f, u),
        w = s - i - this.m_referenceAngle,
        C = box2d.b2Abs(v),
        S = box2d.b2Abs(w),
        A = !1,
        T = 0;
    if (this.m_enableLimit) {
        var P = box2d.b2DotVV(b, u);
        box2d.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * box2d.b2_linearSlop ? (T = box2d.b2Clamp(P, -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection), C = box2d.b2Max(C, box2d.b2Abs(P)), A = !0) : P <= this.m_lowerTranslation ? (T = box2d.b2Clamp(P - this.m_lowerTranslation + box2d.b2_linearSlop, -box2d.b2_maxLinearCorrection, 0), C = box2d.b2Max(C, this.m_lowerTranslation - P), A = !0) : P >= this.m_upperTranslation && (T = box2d.b2Clamp(P - this.m_upperTranslation - box2d.b2_linearSlop, 0, box2d.b2_maxLinearCorrection), C = box2d.b2Max(C, P - this.m_upperTranslation), A = !0)
    }
    if (A) {
        var B = a + h + l * g * g + d * x * x,
            M = l * g + d * x,
            I = l * g * m + d * x * y,
            R = l + d;
        0 === R && (R = 1);
        var D = l * m + d * y,
            k = a + h + l * m * m + d * y * y,
            V = this.m_K3;
        V.ex.SetXYZ(B, M, I), V.ey.SetXYZ(M, R, D), V.ez.SetXYZ(I, D, k), _ = V.Solve33(-v, -w, -T, _)
    } else {
        var B = a + h + l * g * g + d * x * x,
            M = l * g + d * x,
            R = l + d;
        0 === R && (R = 1);
        var E = this.m_K2;
        E.ex.SetXY(B, M), E.ey.SetXY(M, R);
        var L = E.Solve(-v, -w, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1);
        _.x = L.x, _.y = L.y, _.z = 0
    }
    var F = box2d.b2AddVV(box2d.b2MulSV(_.x, f, box2d.b2Vec2.s_t0), box2d.b2MulSV(_.z, b, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P),
        O = _.x * g + _.y + _.z * m,
        G = _.x * x + _.y + _.z * y;
    return e.SelfMulSub(a, F), i -= l * O, o.SelfMulAdd(h, F), s += d * G, t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = s, C <= box2d.b2_linearSlop && S <= box2d.b2_angularSlop
}, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1 = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2PrismaticJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2PrismaticJoint.prototype.GetReactionForce = function(t, e) {
    return e.SetXY(t * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), t * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
}, box2d.b2PrismaticJoint.prototype.GetReactionTorque = function(t) {
    return t * this.m_impulse.y
}, box2d.b2PrismaticJoint.prototype.GetLocalAnchorA = function(t) {
    return t.Copy(this.m_localAnchorA)
}, box2d.b2PrismaticJoint.prototype.GetLocalAnchorB = function(t) {
    return t.Copy(this.m_localAnchorB)
}, box2d.b2PrismaticJoint.prototype.GetLocalAxisA = function(t) {
    return t.Copy(this.m_localXAxisA)
}, box2d.b2PrismaticJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
}, box2d.b2PrismaticJoint.prototype.GetJointTranslation = function() {
    var t = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA),
        e = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB),
        i = box2d.b2SubVV(e, t, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d),
        o = this.m_bodyA.GetWorldVector(this.m_localXAxisA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis);
    return box2d.b2DotVV(i, o)
}, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetJointSpeed = function() {
    var t = this.m_bodyA,
        e = this.m_bodyB;
    box2d.b2SubVV(this.m_localAnchorA, t.m_sweep.localCenter, this.m_lalcA);
    var i = box2d.b2MulRV(t.m_xf.q, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, e.m_sweep.localCenter, this.m_lalcB);
    var o = box2d.b2MulRV(e.m_xf.q, this.m_lalcB, this.m_rB),
        s = box2d.b2AddVV(t.m_sweep.c, i, box2d.b2Vec2.s_t0),
        n = box2d.b2AddVV(e.m_sweep.c, o, box2d.b2Vec2.s_t1),
        r = box2d.b2SubVV(n, s, box2d.b2Vec2.s_t2),
        a = t.GetWorldVector(this.m_localXAxisA, this.m_axis),
        h = t.m_linearVelocity,
        l = e.m_linearVelocity,
        d = t.m_angularVelocity,
        c = e.m_angularVelocity;
    return box2d.b2DotVV(r, box2d.b2CrossSV(d, a, box2d.b2Vec2.s_t0)) + box2d.b2DotVV(a, box2d.b2SubVV(box2d.b2AddVCrossSV(l, c, o, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(h, d, i, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0))
}, box2d.b2PrismaticJoint.prototype.IsLimitEnabled = function() {
    return this.m_enableLimit
}, box2d.b2PrismaticJoint.prototype.EnableLimit = function(t) {
    t !== this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = t, this.m_impulse.z = 0)
}, box2d.b2PrismaticJoint.prototype.GetLowerLimit = function() {
    return this.m_lowerTranslation
}, box2d.b2PrismaticJoint.prototype.GetUpperLimit = function() {
    return this.m_upperTranslation
}, box2d.b2PrismaticJoint.prototype.SetLimits = function(t, e) {
    t === this.m_lowerTranslation && e === this.m_upperTranslation || (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = t, this.m_upperTranslation = e, this.m_impulse.z = 0)
}, box2d.b2PrismaticJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
}, box2d.b2PrismaticJoint.prototype.EnableMotor = function(t) {
    this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t
}, box2d.b2PrismaticJoint.prototype.SetMotorSpeed = function(t) {
    this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t
}, box2d.b2PrismaticJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
}, box2d.b2PrismaticJoint.prototype.SetMaxMotorForce = function(t) {
    this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = t
}, box2d.b2PrismaticJoint.prototype.GetMaxMotorForce = function() {
    return this.m_maxMotorForce
}, box2d.b2PrismaticJoint.prototype.GetMotorForce = function(t) {
    return t * this.m_motorImpulse
}, box2d.b2PrismaticJoint.prototype.Dump = function() {}, goog.provide("box2d.b2GearJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), goog.require("box2d.b2RevoluteJoint"), goog.require("box2d.b2PrismaticJoint"), box2d.b2GearJointDef = function() {
    goog.base(this, box2d.b2JointType.e_gearJoint)
}, goog.inherits(box2d.b2GearJointDef, box2d.b2JointDef), box2d.b2GearJointDef.prototype.joint1 = null, box2d.b2GearJointDef.prototype.joint2 = null, box2d.b2GearJointDef.prototype.ratio = 1, box2d.b2GearJoint = function(t) {
    goog.base(this, t), this.m_joint1 = t.joint1, this.m_joint2 = t.joint2, this.m_localAnchorA = new box2d.b2Vec2, this.m_localAnchorB = new box2d.b2Vec2, this.m_localAnchorC = new box2d.b2Vec2, this.m_localAnchorD = new box2d.b2Vec2, this.m_localAxisC = new box2d.b2Vec2, this.m_localAxisD = new box2d.b2Vec2, this.m_lcA = new box2d.b2Vec2, this.m_lcB = new box2d.b2Vec2, this.m_lcC = new box2d.b2Vec2, this.m_lcD = new box2d.b2Vec2, this.m_JvAC = new box2d.b2Vec2, this.m_JvBD = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_qC = new box2d.b2Rot, this.m_qD = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_lalcC = new box2d.b2Vec2, this.m_lalcD = new box2d.b2Vec2, this.m_typeA = this.m_joint1.GetType(), this.m_typeB = this.m_joint2.GetType();
    var e, i;
    this.m_bodyC = this.m_joint1.GetBodyA(), this.m_bodyA = this.m_joint1.GetBodyB();
    var o = this.m_bodyA.m_xf,
        s = this.m_bodyA.m_sweep.a,
        n = this.m_bodyC.m_xf,
        r = this.m_bodyC.m_sweep.a;
    if (this.m_typeA === box2d.b2JointType.e_revoluteJoint) {
        var a = t.joint1;
        this.m_localAnchorC.Copy(a.m_localAnchorA), this.m_localAnchorA.Copy(a.m_localAnchorB), this.m_referenceAngleA = a.m_referenceAngle, this.m_localAxisC.SetZero(), e = s - r - this.m_referenceAngleA
    } else {
        var h = t.joint1;
        this.m_localAnchorC.Copy(h.m_localAnchorA), this.m_localAnchorA.Copy(h.m_localAnchorB), this.m_referenceAngleA = h.m_referenceAngle, this.m_localAxisC.Copy(h.m_localXAxisA);
        var l = this.m_localAnchorC,
            d = box2d.b2MulTRV(n.q, box2d.b2AddVV(box2d.b2MulRV(o.q, this.m_localAnchorA, box2d.b2Vec2.s_t0), box2d.b2SubVV(o.p, n.p, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        e = box2d.b2DotVV(box2d.b2SubVV(d, l, box2d.b2Vec2.s_t0), this.m_localAxisC)
    }
    this.m_bodyD = this.m_joint2.GetBodyA(), this.m_bodyB = this.m_joint2.GetBodyB();
    var c = this.m_bodyB.m_xf,
        p = this.m_bodyB.m_sweep.a,
        u = this.m_bodyD.m_xf,
        b = this.m_bodyD.m_sweep.a;
    if (this.m_typeB === box2d.b2JointType.e_revoluteJoint) {
        var a = t.joint2;
        this.m_localAnchorD.Copy(a.m_localAnchorA), this.m_localAnchorB.Copy(a.m_localAnchorB), this.m_referenceAngleB = a.m_referenceAngle, this.m_localAxisD.SetZero(), i = p - b - this.m_referenceAngleB
    } else {
        var h = t.joint2;
        this.m_localAnchorD.Copy(h.m_localAnchorA), this.m_localAnchorB.Copy(h.m_localAnchorB), this.m_referenceAngleB = h.m_referenceAngle, this.m_localAxisD.Copy(h.m_localXAxisA);
        var m = this.m_localAnchorD,
            y = box2d.b2MulTRV(u.q, box2d.b2AddVV(box2d.b2MulRV(c.q, this.m_localAnchorB, box2d.b2Vec2.s_t0), box2d.b2SubVV(c.p, u.p, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        i = box2d.b2DotVV(box2d.b2SubVV(y, m, box2d.b2Vec2.s_t0), this.m_localAxisD)
    }
    this.m_ratio = t.ratio, this.m_constant = e + this.m_ratio * i, this.m_impulse = 0
}, goog.inherits(box2d.b2GearJoint, box2d.b2Joint), box2d.b2GearJoint.prototype.m_joint1 = null, box2d.b2GearJoint.prototype.m_joint2 = null, box2d.b2GearJoint.prototype.m_typeA = box2d.b2JointType.e_unknownJoint, box2d.b2GearJoint.prototype.m_typeB = box2d.b2JointType.e_unknownJoint, box2d.b2GearJoint.prototype.m_bodyC = null, box2d.b2GearJoint.prototype.m_bodyD = null, box2d.b2GearJoint.prototype.m_localAnchorA = null, box2d.b2GearJoint.prototype.m_localAnchorB = null, box2d.b2GearJoint.prototype.m_localAnchorC = null, box2d.b2GearJoint.prototype.m_localAnchorD = null, box2d.b2GearJoint.prototype.m_localAxisC = null, box2d.b2GearJoint.prototype.m_localAxisD = null, box2d.b2GearJoint.prototype.m_referenceAngleA = 0, box2d.b2GearJoint.prototype.m_referenceAngleB = 0, box2d.b2GearJoint.prototype.m_constant = 0, box2d.b2GearJoint.prototype.m_ratio = 0, box2d.b2GearJoint.prototype.m_impulse = 0, box2d.b2GearJoint.prototype.m_indexA = 0, box2d.b2GearJoint.prototype.m_indexB = 0, box2d.b2GearJoint.prototype.m_indexC = 0, box2d.b2GearJoint.prototype.m_indexD = 0, box2d.b2GearJoint.prototype.m_lcA = null, box2d.b2GearJoint.prototype.m_lcB = null, box2d.b2GearJoint.prototype.m_lcC = null, box2d.b2GearJoint.prototype.m_lcD = null, box2d.b2GearJoint.prototype.m_mA = 0, box2d.b2GearJoint.prototype.m_mB = 0, box2d.b2GearJoint.prototype.m_mC = 0, box2d.b2GearJoint.prototype.m_mD = 0, box2d.b2GearJoint.prototype.m_iA = 0, box2d.b2GearJoint.prototype.m_iB = 0, box2d.b2GearJoint.prototype.m_iC = 0, box2d.b2GearJoint.prototype.m_iD = 0, box2d.b2GearJoint.prototype.m_JvAC = null, box2d.b2GearJoint.prototype.m_JvBD = null, box2d.b2GearJoint.prototype.m_JwA = 0, box2d.b2GearJoint.prototype.m_JwB = 0, box2d.b2GearJoint.prototype.m_JwC = 0, box2d.b2GearJoint.prototype.m_JwD = 0, box2d.b2GearJoint.prototype.m_mass = 0, box2d.b2GearJoint.prototype.m_qA = null, box2d.b2GearJoint.prototype.m_qB = null, box2d.b2GearJoint.prototype.m_qC = null, box2d.b2GearJoint.prototype.m_qD = null, box2d.b2GearJoint.prototype.m_lalcA = null, box2d.b2GearJoint.prototype.m_lalcB = null, box2d.b2GearJoint.prototype.m_lalcC = null, box2d.b2GearJoint.prototype.m_lalcD = null, box2d.b2GearJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_indexC = this.m_bodyC.m_islandIndex, this.m_indexD = this.m_bodyD.m_islandIndex, this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter), this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter), this.m_mA = this.m_bodyA.m_invMass, this.m_mB = this.m_bodyB.m_invMass, this.m_mC = this.m_bodyC.m_invMass, this.m_mD = this.m_bodyD.m_invMass, this.m_iA = this.m_bodyA.m_invI, this.m_iB = this.m_bodyB.m_invI, this.m_iC = this.m_bodyC.m_invI, this.m_iD = this.m_bodyD.m_invI;
    var e = t.positions[this.m_indexA].a,
        i = t.velocities[this.m_indexA].v,
        o = t.velocities[this.m_indexA].w,
        s = t.positions[this.m_indexB].a,
        n = t.velocities[this.m_indexB].v,
        r = t.velocities[this.m_indexB].w,
        a = t.positions[this.m_indexC].a,
        h = t.velocities[this.m_indexC].v,
        l = t.velocities[this.m_indexC].w,
        d = t.positions[this.m_indexD].a,
        c = t.velocities[this.m_indexD].v,
        p = t.velocities[this.m_indexD].w,
        u = this.m_qA.SetAngleRadians(e),
        b = this.m_qB.SetAngleRadians(s),
        m = this.m_qC.SetAngleRadians(a),
        y = this.m_qD.SetAngleRadians(d);
    if (this.m_mass = 0, this.m_typeA === box2d.b2JointType.e_revoluteJoint) this.m_JvAC.SetZero(), this.m_JwA = 1, this.m_JwC = 1, this.m_mass += this.m_iA + this.m_iC;
    else {
        var f = box2d.b2MulRV(m, this.m_localAxisC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u);
        box2d.b2SubVV(this.m_localAnchorC, this.m_lcC, this.m_lalcC);
        var g = box2d.b2MulRV(m, this.m_lalcC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC);
        box2d.b2SubVV(this.m_localAnchorA, this.m_lcA, this.m_lalcA);
        var x = box2d.b2MulRV(u, this.m_lalcA, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA);
        this.m_JvAC.Copy(f), this.m_JwC = box2d.b2CrossVV(g, f), this.m_JwA = box2d.b2CrossVV(x, f), this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA
    }
    if (this.m_typeB === box2d.b2JointType.e_revoluteJoint) this.m_JvBD.SetZero(), this.m_JwB = this.m_ratio, this.m_JwD = this.m_ratio, this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
    else {
        var f = box2d.b2MulRV(y, this.m_localAxisD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u);
        box2d.b2SubVV(this.m_localAnchorD, this.m_lcD, this.m_lalcD);
        var _ = box2d.b2MulRV(y, this.m_lalcD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD);
        box2d.b2SubVV(this.m_localAnchorB, this.m_lcB, this.m_lalcB);
        var v = box2d.b2MulRV(b, this.m_lalcB, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB);
        box2d.b2MulSV(this.m_ratio, f, this.m_JvBD), this.m_JwD = this.m_ratio * box2d.b2CrossVV(_, f), this.m_JwB = this.m_ratio * box2d.b2CrossVV(v, f), this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB
    }
    this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0, t.step.warmStarting ? (i.SelfMulAdd(this.m_mA * this.m_impulse, this.m_JvAC), o += this.m_iA * this.m_impulse * this.m_JwA, n.SelfMulAdd(this.m_mB * this.m_impulse, this.m_JvBD), r += this.m_iB * this.m_impulse * this.m_JwB, h.SelfMulSub(this.m_mC * this.m_impulse, this.m_JvAC), l -= this.m_iC * this.m_impulse * this.m_JwC, c.SelfMulSub(this.m_mD * this.m_impulse, this.m_JvBD), p -= this.m_iD * this.m_impulse * this.m_JwD) : this.m_impulse = 0, t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = r, t.velocities[this.m_indexC].w = l, t.velocities[this.m_indexD].w = p
}, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u = new box2d.b2Vec2, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA = new box2d.b2Vec2, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB = new box2d.b2Vec2, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC = new box2d.b2Vec2, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = t.velocities[this.m_indexC].v,
        r = t.velocities[this.m_indexC].w,
        a = t.velocities[this.m_indexD].v,
        h = t.velocities[this.m_indexD].w,
        l = box2d.b2DotVV(this.m_JvAC, box2d.b2SubVV(e, n, box2d.b2Vec2.s_t0)) + box2d.b2DotVV(this.m_JvBD, box2d.b2SubVV(o, a, box2d.b2Vec2.s_t0));
    l += this.m_JwA * i - this.m_JwC * r + (this.m_JwB * s - this.m_JwD * h);
    var d = -this.m_mass * l;
    this.m_impulse += d, e.SelfMulAdd(this.m_mA * d, this.m_JvAC), i += this.m_iA * d * this.m_JwA, o.SelfMulAdd(this.m_mB * d, this.m_JvBD), s += this.m_iB * d * this.m_JwB, n.SelfMulSub(this.m_mC * d, this.m_JvAC), r -= this.m_iC * d * this.m_JwC, a.SelfMulSub(this.m_mD * d, this.m_JvBD), h -= this.m_iD * d * this.m_JwD, t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s, t.velocities[this.m_indexC].w = r, t.velocities[this.m_indexD].w = h
}, box2d.b2GearJoint.prototype.SolvePositionConstraints = function(t) {
    var e, i, o, s, n, r, a = t.positions[this.m_indexA].c,
        h = t.positions[this.m_indexA].a,
        l = t.positions[this.m_indexB].c,
        d = t.positions[this.m_indexB].a,
        c = t.positions[this.m_indexC].c,
        p = t.positions[this.m_indexC].a,
        u = t.positions[this.m_indexD].c,
        b = t.positions[this.m_indexD].a,
        m = this.m_qA.SetAngleRadians(h),
        y = this.m_qB.SetAngleRadians(d),
        f = this.m_qC.SetAngleRadians(p),
        g = this.m_qD.SetAngleRadians(b),
        x = this.m_JvAC,
        _ = this.m_JvBD,
        v = 0;
    if (this.m_typeA === box2d.b2JointType.e_revoluteJoint) x.SetZero(), o = 1, n = 1, v += this.m_iA + this.m_iC, e = h - p - this.m_referenceAngleA;
    else {
        var w = box2d.b2MulRV(f, this.m_localAxisC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u),
            C = box2d.b2MulRV(f, this.m_lalcC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC),
            S = box2d.b2MulRV(m, this.m_lalcA, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA);
        x.Copy(w), n = box2d.b2CrossVV(C, w), o = box2d.b2CrossVV(S, w), v += this.m_mC + this.m_mA + this.m_iC * n * n + this.m_iA * o * o;
        var A = this.m_lalcC,
            T = box2d.b2MulTRV(f, box2d.b2AddVV(S, box2d.b2SubVV(a, c, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        e = box2d.b2DotVV(box2d.b2SubVV(T, A, box2d.b2Vec2.s_t0), this.m_localAxisC)
    }
    if (this.m_typeB === box2d.b2JointType.e_revoluteJoint) _.SetZero(), s = this.m_ratio, r = this.m_ratio, v += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD), i = d - b - this.m_referenceAngleB;
    else {
        var w = box2d.b2MulRV(g, this.m_localAxisD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u),
            P = box2d.b2MulRV(g, this.m_lalcD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD),
            B = box2d.b2MulRV(y, this.m_lalcB, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB);
        box2d.b2MulSV(this.m_ratio, w, _), r = this.m_ratio * box2d.b2CrossVV(P, w), s = this.m_ratio * box2d.b2CrossVV(B, w), v += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * r * r + this.m_iB * s * s;
        var M = this.m_lalcD,
            I = box2d.b2MulTRV(g, box2d.b2AddVV(B, box2d.b2SubVV(l, u, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        i = box2d.b2DotVV(box2d.b2SubVV(I, M, box2d.b2Vec2.s_t0), this.m_localAxisD)
    }
    var R = e + this.m_ratio * i - this.m_constant,
        D = 0;
    return v > 0 && (D = -R / v), a.SelfMulAdd(this.m_mA * D, x), h += this.m_iA * D * o, l.SelfMulAdd(this.m_mB * D, _), d += this.m_iB * D * s, c.SelfMulSub(this.m_mC * D, x), p -= this.m_iC * D * n, u.SelfMulSub(this.m_mD * D, _), b -= this.m_iD * D * r, t.positions[this.m_indexA].a = h, t.positions[this.m_indexB].a = d, t.positions[this.m_indexC].a = p, t.positions[this.m_indexD].a = b, 0 < box2d.b2_linearSlop
}, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD = new box2d.b2Vec2, box2d.b2GearJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2GearJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2GearJoint.prototype.GetReactionForce = function(t, e) {
    return box2d.b2MulSV(t * this.m_impulse, this.m_JvAC, e)
}, box2d.b2GearJoint.prototype.GetReactionTorque = function(t) {
    return t * this.m_impulse * this.m_JwA
}, box2d.b2GearJoint.prototype.GetJoint1 = function() {
    return this.m_joint1
}, box2d.b2GearJoint.prototype.GetJoint2 = function() {
    return this.m_joint2
}, box2d.b2GearJoint.prototype.GetRatio = function() {
    return this.m_ratio
}, box2d.b2GearJoint.prototype.SetRatio = function(t) {
    this.m_ratio = t
}, box2d.b2GearJoint.prototype.Dump = function() {}, goog.provide("box2d.b2Distance"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), box2d.b2DistanceProxy = function() {
    this.m_buffer = box2d.b2Vec2.MakeArray(2)
}, box2d.b2DistanceProxy.prototype.m_buffer = null, box2d.b2DistanceProxy.prototype.m_vertices = null, box2d.b2DistanceProxy.prototype.m_count = 0, box2d.b2DistanceProxy.prototype.m_radius = 0, box2d.b2DistanceProxy.prototype.Reset = function() {
    return this.m_vertices = null, this.m_count = 0, this.m_radius = 0, this
}, box2d.b2DistanceProxy.prototype.SetShape = function(t, e) {
    t.SetupDistanceProxy(this, e)
}, box2d.b2DistanceProxy.prototype.GetSupport = function(t) {
    for (var e = 0, i = box2d.b2DotVV(this.m_vertices[0], t), o = 1; o < this.m_count; ++o) {
        var s = box2d.b2DotVV(this.m_vertices[o], t);
        s > i && (e = o, i = s)
    }
    return e
}, box2d.b2DistanceProxy.prototype.GetSupportVertex = function(t, e) {
    for (var i = 0, o = box2d.b2DotVV(this.m_vertices[0], t), s = 1; s < this.m_count; ++s) {
        var n = box2d.b2DotVV(this.m_vertices[s], t);
        n > o && (i = s, o = n)
    }
    return e.Copy(this.m_vertices[i])
}, box2d.b2DistanceProxy.prototype.GetVertexCount = function() {
    return this.m_count
}, box2d.b2DistanceProxy.prototype.GetVertex = function(t) {
    return this.m_vertices[t]
}, box2d.b2SimplexCache = function() {
    this.indexA = box2d.b2MakeNumberArray(3), this.indexB = box2d.b2MakeNumberArray(3)
}, box2d.b2SimplexCache.prototype.metric = 0, box2d.b2SimplexCache.prototype.count = 0, box2d.b2SimplexCache.prototype.indexA = null, box2d.b2SimplexCache.prototype.indexB = null, box2d.b2SimplexCache.prototype.Reset = function() {
    return this.metric = 0, this.count = 0, this
}, box2d.b2DistanceInput = function() {
    this.proxyA = new box2d.b2DistanceProxy, this.proxyB = new box2d.b2DistanceProxy, this.transformA = new box2d.b2Transform, this.transformB = new box2d.b2Transform
}, box2d.b2DistanceInput.prototype.proxyA = null, box2d.b2DistanceInput.prototype.proxyB = null, box2d.b2DistanceInput.prototype.transformA = null, box2d.b2DistanceInput.prototype.transformB = null, box2d.b2DistanceInput.prototype.useRadii = !1, box2d.b2DistanceInput.prototype.Reset = function() {
    return this.proxyA.Reset(), this.proxyB.Reset(), this.transformA.SetIdentity(), this.transformB.SetIdentity(), this.useRadii = !1, this
}, box2d.b2DistanceOutput = function() {
    this.pointA = new box2d.b2Vec2, this.pointB = new box2d.b2Vec2
}, box2d.b2DistanceOutput.prototype.pointA = null, box2d.b2DistanceOutput.prototype.pointB = null, box2d.b2DistanceOutput.prototype.distance = 0, box2d.b2DistanceOutput.prototype.iterations = 0, box2d.b2DistanceOutput.prototype.Reset = function() {
    return this.pointA.SetZero(), this.pointB.SetZero(), this.distance = 0, this.iterations = 0, this
}, box2d.b2_gjkCalls = 0, box2d.b2_gjkIters = 0, box2d.b2_gjkMaxIters = 0, box2d.b2SimplexVertex = function() {
    this.wA = new box2d.b2Vec2, this.wB = new box2d.b2Vec2, this.w = new box2d.b2Vec2
}, box2d.b2SimplexVertex.prototype.wA = null, box2d.b2SimplexVertex.prototype.wB = null, box2d.b2SimplexVertex.prototype.w = null, box2d.b2SimplexVertex.prototype.a = 0, box2d.b2SimplexVertex.prototype.indexA = 0, box2d.b2SimplexVertex.prototype.indexB = 0, box2d.b2SimplexVertex.prototype.Copy = function(t) {
    return this.wA.Copy(t.wA), this.wB.Copy(t.wB), this.w.Copy(t.w), this.a = t.a, this.indexA = t.indexA, this.indexB = t.indexB, this
}, box2d.b2Simplex = function() {
    this.m_v1 = new box2d.b2SimplexVertex, this.m_v2 = new box2d.b2SimplexVertex, this.m_v3 = new box2d.b2SimplexVertex, this.m_vertices = new Array(3), this.m_vertices[0] = this.m_v1, this.m_vertices[1] = this.m_v2, this.m_vertices[2] = this.m_v3
}, box2d.b2Simplex.prototype.m_v1 = null, box2d.b2Simplex.prototype.m_v2 = null, box2d.b2Simplex.prototype.m_v3 = null, box2d.b2Simplex.prototype.m_vertices = null, box2d.b2Simplex.prototype.m_count = 0, box2d.b2Simplex.prototype.ReadCache = function(t, e, i, o, s) {
    this.m_count = t.count;
    for (var n = this.m_vertices, r = 0; r < this.m_count; ++r) {
        var a = n[r];
        a.indexA = t.indexA[r], a.indexB = t.indexB[r];
        var h = e.GetVertex(a.indexA),
            l = o.GetVertex(a.indexB);
        box2d.b2MulXV(i, h, a.wA), box2d.b2MulXV(s, l, a.wB), box2d.b2SubVV(a.wB, a.wA, a.w), a.a = 0
    }
    if (this.m_count > 1) {
        var d = t.metric,
            c = this.GetMetric();
        (c < .5 * d || 2 * d < c || c < box2d.b2_epsilon) && (this.m_count = 0)
    }
    if (0 === this.m_count) {
        var a = n[0];
        a.indexA = 0, a.indexB = 0;
        var h = e.GetVertex(0),
            l = o.GetVertex(0);
        box2d.b2MulXV(i, h, a.wA), box2d.b2MulXV(s, l, a.wB), box2d.b2SubVV(a.wB, a.wA, a.w), a.a = 1, this.m_count = 1
    }
}, box2d.b2Simplex.prototype.WriteCache = function(t) {
    t.metric = this.GetMetric(), t.count = this.m_count;
    for (var e = this.m_vertices, i = 0; i < this.m_count; ++i) t.indexA[i] = e[i].indexA, t.indexB[i] = e[i].indexB
}, box2d.b2Simplex.prototype.GetSearchDirection = function(t) {
    switch (this.m_count) {
        case 1:
            return box2d.b2NegV(this.m_v1.w, t);
        case 2:
            var e = box2d.b2SubVV(this.m_v2.w, this.m_v1.w, t);
            return box2d.b2CrossVV(e, box2d.b2NegV(this.m_v1.w, box2d.b2Vec2.s_t0)) > 0 ? box2d.b2CrossOneV(e, t) : box2d.b2CrossVOne(e, t);
        default:
            return t.SetZero()
    }
}, box2d.b2Simplex.prototype.GetClosestPoint = function(t) {
    switch (this.m_count) {
        case 0:
            return t.SetZero();
        case 1:
            return t.Copy(this.m_v1.w);
        case 2:
            return t.SetXY(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
        case 3:
        default:
            return t.SetZero()
    }
}, box2d.b2Simplex.prototype.GetWitnessPoints = function(t, e) {
    switch (this.m_count) {
        case 0:
            break;
        case 1:
            t.Copy(this.m_v1.wA), e.Copy(this.m_v1.wB);
            break;
        case 2:
            t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x, t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y, e.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x, e.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
            break;
        case 3:
            e.x = t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x, e.y = t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y
    }
}, box2d.b2Simplex.prototype.GetMetric = function() {
    switch (this.m_count) {
        case 0:
        case 1:
            return 0;
        case 2:
            return box2d.b2DistanceVV(this.m_v1.w, this.m_v2.w);
        case 3:
            return box2d.b2CrossVV(box2d.b2SubVV(this.m_v2.w, this.m_v1.w, box2d.b2Vec2.s_t0), box2d.b2SubVV(this.m_v3.w, this.m_v1.w, box2d.b2Vec2.s_t1));
        default:
            return 0
    }
}, box2d.b2Simplex.prototype.Solve2 = function() {
    var t = this.m_v1.w,
        e = this.m_v2.w,
        i = box2d.b2SubVV(e, t, box2d.b2Simplex.s_e12),
        o = -box2d.b2DotVV(t, i);
    if (o <= 0) return this.m_v1.a = 1, void(this.m_count = 1);
    var s = box2d.b2DotVV(e, i);
    if (s <= 0) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Copy(this.m_v2);
    var n = 1 / (s + o);
    this.m_v1.a = s * n, this.m_v2.a = o * n, this.m_count = 2
}, box2d.b2Simplex.prototype.Solve3 = function() {
    var t = this.m_v1.w,
        e = this.m_v2.w,
        i = this.m_v3.w,
        o = box2d.b2SubVV(e, t, box2d.b2Simplex.s_e12),
        s = box2d.b2DotVV(t, o),
        n = box2d.b2DotVV(e, o),
        r = n,
        a = -s,
        h = box2d.b2SubVV(i, t, box2d.b2Simplex.s_e13),
        l = box2d.b2DotVV(t, h),
        d = box2d.b2DotVV(i, h),
        c = d,
        p = -l,
        u = box2d.b2SubVV(i, e, box2d.b2Simplex.s_e23),
        b = box2d.b2DotVV(e, u),
        m = box2d.b2DotVV(i, u),
        y = m,
        f = -b,
        g = box2d.b2CrossVV(o, h),
        x = g * box2d.b2CrossVV(e, i),
        _ = g * box2d.b2CrossVV(i, t),
        v = g * box2d.b2CrossVV(t, e);
    if (a <= 0 && p <= 0) return this.m_v1.a = 1, void(this.m_count = 1);
    if (r > 0 && a > 0 && v <= 0) {
        var w = 1 / (r + a);
        return this.m_v1.a = r * w, this.m_v2.a = a * w, void(this.m_count = 2)
    }
    if (c > 0 && p > 0 && _ <= 0) {
        var C = 1 / (c + p);
        return this.m_v1.a = c * C, this.m_v3.a = p * C, this.m_count = 2, void this.m_v2.Copy(this.m_v3)
    }
    if (r <= 0 && f <= 0) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Copy(this.m_v2);
    if (c <= 0 && y <= 0) return this.m_v3.a = 1, this.m_count = 1, void this.m_v1.Copy(this.m_v3);
    if (y > 0 && f > 0 && x <= 0) {
        var S = 1 / (y + f);
        return this.m_v2.a = y * S, this.m_v3.a = f * S, this.m_count = 2, void this.m_v1.Copy(this.m_v3)
    }
    var A = 1 / (x + _ + v);
    this.m_v1.a = x * A, this.m_v2.a = _ * A, this.m_v3.a = v * A, this.m_count = 3
}, box2d.b2Simplex.s_e12 = new box2d.b2Vec2, box2d.b2Simplex.s_e13 = new box2d.b2Vec2, box2d.b2Simplex.s_e23 = new box2d.b2Vec2, box2d.b2Distance = function(t, e, i) {
    ++box2d.b2_gjkCalls;
    var o = i.proxyA,
        s = i.proxyB,
        n = i.transformA,
        r = i.transformB,
        a = box2d.b2Distance.s_simplex;
    a.ReadCache(e, o, n, s, r);
    for (var h = a.m_vertices, l = box2d.b2Distance.s_saveA, d = box2d.b2Distance.s_saveB, c = 0, p = box2d.b2_maxFloat, u = p, b = 0; b < 20;) {
        c = a.m_count;
        for (var m = 0; m < c; ++m) l[m] = h[m].indexA, d[m] = h[m].indexB;
        switch (a.m_count) {
            case 1:
                break;
            case 2:
                a.Solve2();
                break;
            case 3:
                a.Solve3()
        }
        if (3 === a.m_count) break;
        var y = a.GetClosestPoint(box2d.b2Distance.s_p);
        u = y.GetLengthSquared(), p = u;
        var f = a.GetSearchDirection(box2d.b2Distance.s_d);
        if (f.GetLengthSquared() < box2d.b2_epsilon_sq) break;
        var g = h[a.m_count];
        g.indexA = o.GetSupport(box2d.b2MulTRV(n.q, box2d.b2NegV(f, box2d.b2Vec2.s_t0), box2d.b2Distance.s_supportA)), box2d.b2MulXV(n, o.GetVertex(g.indexA), g.wA), g.indexB = s.GetSupport(box2d.b2MulTRV(r.q, f, box2d.b2Distance.s_supportB)), box2d.b2MulXV(r, s.GetVertex(g.indexB), g.wB), box2d.b2SubVV(g.wB, g.wA, g.w), ++b, ++box2d.b2_gjkIters;
        for (var x = !1, m = 0; m < c; ++m)
            if (g.indexA === l[m] && g.indexB === d[m]) {
                x = !0;
                break
            }
        if (x) break;
        ++a.m_count
    }
    if (box2d.b2_gjkMaxIters = box2d.b2Max(box2d.b2_gjkMaxIters, b), a.GetWitnessPoints(t.pointA, t.pointB), t.distance = box2d.b2DistanceVV(t.pointA, t.pointB), t.iterations = b, a.WriteCache(e), i.useRadii) {
        var _ = o.m_radius,
            v = s.m_radius;
        if (t.distance > _ + v && t.distance > box2d.b2_epsilon) {
            t.distance -= _ + v;
            var w = box2d.b2SubVV(t.pointB, t.pointA, box2d.b2Distance.s_normal);
            w.Normalize(), t.pointA.SelfMulAdd(_, w), t.pointB.SelfMulSub(v, w)
        } else {
            var y = box2d.b2MidVV(t.pointA, t.pointB, box2d.b2Distance.s_p);
            t.pointA.Copy(y), t.pointB.Copy(y), t.distance = 0
        }
    }
}, box2d.b2Distance.s_simplex = new box2d.b2Simplex, box2d.b2Distance.s_saveA = box2d.b2MakeNumberArray(3), box2d.b2Distance.s_saveB = box2d.b2MakeNumberArray(3), box2d.b2Distance.s_p = new box2d.b2Vec2, box2d.b2Distance.s_d = new box2d.b2Vec2, box2d.b2Distance.s_normal = new box2d.b2Vec2, box2d.b2Distance.s_supportA = new box2d.b2Vec2, box2d.b2Distance.s_supportB = new box2d.b2Vec2, goog.provide("box2d.b2WeldJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2WeldJointDef = function() {
    goog.base(this, box2d.b2JointType.e_weldJoint), this.localAnchorA = new box2d.b2Vec2, this.localAnchorB = new box2d.b2Vec2
}, goog.inherits(box2d.b2WeldJointDef, box2d.b2JointDef), box2d.b2WeldJointDef.prototype.localAnchorA = null, box2d.b2WeldJointDef.prototype.localAnchorB = null, box2d.b2WeldJointDef.prototype.referenceAngle = 0, box2d.b2WeldJointDef.prototype.frequencyHz = 0, box2d.b2WeldJointDef.prototype.dampingRatio = 0, box2d.b2WeldJointDef.prototype.Initialize = function(t, e, i) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB), this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
}, box2d.b2WeldJoint = function(t) {
    goog.base(this, t), this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_referenceAngle = t.referenceAngle, this.m_impulse = new box2d.b2Vec3(0, 0, 0), this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_mass = new box2d.b2Mat33, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_K = new box2d.b2Mat33
}, goog.inherits(box2d.b2WeldJoint, box2d.b2Joint), box2d.b2WeldJoint.prototype.m_frequencyHz = 0, box2d.b2WeldJoint.prototype.m_dampingRatio = 0, box2d.b2WeldJoint.prototype.m_bias = 0, box2d.b2WeldJoint.prototype.m_localAnchorA = null, box2d.b2WeldJoint.prototype.m_localAnchorB = null, box2d.b2WeldJoint.prototype.m_referenceAngle = 0, box2d.b2WeldJoint.prototype.m_gamma = 0, box2d.b2WeldJoint.prototype.m_impulse = null, box2d.b2WeldJoint.prototype.m_indexA = 0, box2d.b2WeldJoint.prototype.m_indexB = 0, box2d.b2WeldJoint.prototype.m_rA = null, box2d.b2WeldJoint.prototype.m_rB = null, box2d.b2WeldJoint.prototype.m_localCenterA = null, box2d.b2WeldJoint.prototype.m_localCenterB = null, box2d.b2WeldJoint.prototype.m_invMassA = 0, box2d.b2WeldJoint.prototype.m_invMassB = 0, box2d.b2WeldJoint.prototype.m_invIA = 0, box2d.b2WeldJoint.prototype.m_invIB = 0;
box2d.b2WeldJoint.prototype.m_mass = null, box2d.b2WeldJoint.prototype.m_qA = null, box2d.b2WeldJoint.prototype.m_qB = null, box2d.b2WeldJoint.prototype.m_lalcA = null, box2d.b2WeldJoint.prototype.m_lalcB = null, box2d.b2WeldJoint.prototype.m_K = null, box2d.b2WeldJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].a,
        i = t.velocities[this.m_indexA].v,
        o = t.velocities[this.m_indexA].w,
        s = t.positions[this.m_indexB].a,
        n = t.velocities[this.m_indexB].v,
        r = t.velocities[this.m_indexB].w,
        a = this.m_qA.SetAngleRadians(e),
        h = this.m_qB.SetAngleRadians(s);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(a, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(h, this.m_lalcB, this.m_rB);
    var l = this.m_invMassA,
        d = this.m_invMassB,
        c = this.m_invIA,
        p = this.m_invIB,
        u = this.m_K;
    if (u.ex.x = l + d + this.m_rA.y * this.m_rA.y * c + this.m_rB.y * this.m_rB.y * p, u.ey.x = -this.m_rA.y * this.m_rA.x * c - this.m_rB.y * this.m_rB.x * p, u.ez.x = -this.m_rA.y * c - this.m_rB.y * p, u.ex.y = u.ey.x, u.ey.y = l + d + this.m_rA.x * this.m_rA.x * c + this.m_rB.x * this.m_rB.x * p, u.ez.y = this.m_rA.x * c + this.m_rB.x * p, u.ex.z = u.ez.x, u.ey.z = u.ez.y, u.ez.z = c + p, this.m_frequencyHz > 0) {
        u.GetInverse22(this.m_mass);
        var b = c + p,
            m = b > 0 ? 1 / b : 0,
            y = s - e - this.m_referenceAngle,
            f = 2 * box2d.b2_pi * this.m_frequencyHz,
            g = 2 * m * this.m_dampingRatio * f,
            x = m * f * f,
            _ = t.step.dt;
        this.m_gamma = _ * (g + _ * x), this.m_gamma = 0 !== this.m_gamma ? 1 / this.m_gamma : 0, this.m_bias = y * _ * x * this.m_gamma, b += this.m_gamma, this.m_mass.ez.z = 0 !== b ? 1 / b : 0
    } else u.GetSymInverse33(this.m_mass), this.m_gamma = 0, this.m_bias = 0;
    if (t.step.warmStarting) {
        this.m_impulse.SelfMul(t.step.dtRatio);
        var v = box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y);
        i.SelfMulSub(l, v), o -= c * (box2d.b2CrossVV(this.m_rA, v) + this.m_impulse.z), n.SelfMulAdd(d, v), r += p * (box2d.b2CrossVV(this.m_rB, v) + this.m_impulse.z)
    } else this.m_impulse.SetZero();
    t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = r
}, box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB;
    if (this.m_frequencyHz > 0) {
        var l = s - i,
            d = -this.m_mass.ez.z * (l + this.m_bias + this.m_gamma * this.m_impulse.z);
        this.m_impulse.z += d, i -= a * d, s += h * d;
        var c = box2d.b2SubVV(box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1),
            p = box2d.b2MulM33XY(this.m_mass, c.x, c.y, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1).SelfNeg();
        this.m_impulse.x += p.x, this.m_impulse.y += p.y;
        var u = p;
        e.SelfMulSub(n, u), i -= a * box2d.b2CrossVV(this.m_rA, u), o.SelfMulAdd(r, u), s += h * box2d.b2CrossVV(this.m_rB, u)
    } else {
        var c = box2d.b2SubVV(box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1),
            l = s - i,
            b = box2d.b2MulM33XYZ(this.m_mass, c.x, c.y, l, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg();
        this.m_impulse.SelfAdd(b);
        var u = box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P.SetXY(b.x, b.y);
        e.SelfMulSub(n, u), i -= a * (box2d.b2CrossVV(this.m_rA, u) + b.z), o.SelfMulAdd(r, u), s += h * (box2d.b2CrossVV(this.m_rB, u) + b.z)
    }
    t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1 = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec3, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolvePositionConstraints = function(t) {
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        s = t.positions[this.m_indexB].a,
        n = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(s),
        a = this.m_invMassA,
        h = this.m_invMassB,
        l = this.m_invIA,
        d = this.m_invIB;
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var c = box2d.b2MulRV(n, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var p, u, b = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        m = this.m_K;
    if (m.ex.x = a + h + c.y * c.y * l + b.y * b.y * d, m.ey.x = -c.y * c.x * l - b.y * b.x * d, m.ez.x = -c.y * l - b.y * d, m.ex.y = m.ey.x, m.ey.y = a + h + c.x * c.x * l + b.x * b.x * d, m.ez.y = c.x * l + b.x * d, m.ex.z = m.ez.x, m.ey.z = m.ez.y, m.ez.z = l + d, this.m_frequencyHz > 0) {
        var y = box2d.b2SubVV(box2d.b2AddVV(o, b, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, c, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1);
        p = y.GetLength(), u = 0;
        var f = m.Solve22(y.x, y.y, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P).SelfNeg();
        e.SelfMulSub(a, f), i -= l * box2d.b2CrossVV(c, f), o.SelfMulAdd(h, f), s += d * box2d.b2CrossVV(b, f)
    } else {
        var y = box2d.b2SubVV(box2d.b2AddVV(o, b, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, c, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1),
            g = s - i - this.m_referenceAngle;
        p = y.GetLength(), u = box2d.b2Abs(g);
        var x = m.Solve33(y.x, y.y, g, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg(),
            f = box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P.SetXY(x.x, x.y);
        e.SelfMulSub(a, f), i -= l * (box2d.b2CrossVV(this.m_rA, f) + x.z), o.SelfMulAdd(h, f), s += d * (box2d.b2CrossVV(this.m_rB, f) + x.z)
    }
    return t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = s, p <= box2d.b2_linearSlop && u <= box2d.b2_angularSlop
}, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1 = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3, box2d.b2WeldJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2WeldJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2WeldJoint.prototype.GetReactionForce = function(t, e) {
    return e.SetXY(t * this.m_impulse.x, t * this.m_impulse.y)
}, box2d.b2WeldJoint.prototype.GetReactionTorque = function(t) {
    return t * this.m_impulse.z
}, box2d.b2WeldJoint.prototype.GetLocalAnchorA = function(t) {
    return t.Copy(this.m_localAnchorA)
}, box2d.b2WeldJoint.prototype.GetLocalAnchorB = function(t) {
    return t.Copy(this.m_localAnchorB)
}, box2d.b2WeldJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
}, box2d.b2WeldJoint.prototype.SetFrequency = function(t) {
    this.m_frequencyHz = t
}, box2d.b2WeldJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
}, box2d.b2WeldJoint.prototype.SetDampingRatio = function(t) {
    this.m_dampingRatio = t
}, box2d.b2WeldJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
}, box2d.b2WeldJoint.prototype.Dump = function() {}, goog.provide("box2d.b2RopeJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2RopeJointDef = function() {
    goog.base(this, box2d.b2JointType.e_ropeJoint), this.localAnchorA = new box2d.b2Vec2(-1, 0), this.localAnchorB = new box2d.b2Vec2(1, 0)
}, goog.inherits(box2d.b2RopeJointDef, box2d.b2JointDef), box2d.b2RopeJointDef.prototype.localAnchorA = null, box2d.b2RopeJointDef.prototype.localAnchorB = null, box2d.b2RopeJointDef.prototype.maxLength = 0, box2d.b2RopeJoint = function(t) {
    goog.base(this, t), this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_maxLength = t.maxLength, this.m_u = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2
}, goog.inherits(box2d.b2RopeJoint, box2d.b2Joint), box2d.b2RopeJoint.prototype.m_localAnchorA = null, box2d.b2RopeJoint.prototype.m_localAnchorB = null, box2d.b2RopeJoint.prototype.m_maxLength = 0, box2d.b2RopeJoint.prototype.m_length = 0, box2d.b2RopeJoint.prototype.m_impulse = 0, box2d.b2RopeJoint.prototype.m_indexA = 0, box2d.b2RopeJoint.prototype.m_indexB = 0, box2d.b2RopeJoint.prototype.m_u = null, box2d.b2RopeJoint.prototype.m_rA = null, box2d.b2RopeJoint.prototype.m_rB = null, box2d.b2RopeJoint.prototype.m_localCenterA = null, box2d.b2RopeJoint.prototype.m_localCenterB = null, box2d.b2RopeJoint.prototype.m_invMassA = 0, box2d.b2RopeJoint.prototype.m_invMassB = 0, box2d.b2RopeJoint.prototype.m_invIA = 0, box2d.b2RopeJoint.prototype.m_invIB = 0, box2d.b2RopeJoint.prototype.m_mass = 0, box2d.b2RopeJoint.prototype.m_state = box2d.b2LimitState.e_inactiveLimit, box2d.b2RopeJoint.prototype.m_qA = null, box2d.b2RopeJoint.prototype.m_qB = null, box2d.b2RopeJoint.prototype.m_lalcA = null, box2d.b2RopeJoint.prototype.m_lalcB = null, box2d.b2RopeJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        s = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        d = this.m_qB.SetAngleRadians(r);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(l, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(d, this.m_lalcB, this.m_rB), this.m_u.Copy(n).SelfAdd(this.m_rB).SelfSub(e).SelfSub(this.m_rA), this.m_length = this.m_u.GetLength();
    var c = this.m_length - this.m_maxLength;
    if (this.m_state = c > 0 ? box2d.b2LimitState.e_atUpperLimit : box2d.b2LimitState.e_inactiveLimit, !(this.m_length > box2d.b2_linearSlop)) return this.m_u.SetZero(), this.m_mass = 0, void(this.m_impulse = 0);
    this.m_u.SelfMul(1 / this.m_length);
    var p = box2d.b2CrossVV(this.m_rA, this.m_u),
        u = box2d.b2CrossVV(this.m_rB, this.m_u),
        b = this.m_invMassA + this.m_invIA * p * p + this.m_invMassB + this.m_invIB * u * u;
    if (this.m_mass = 0 !== b ? 1 / b : 0, t.step.warmStarting) {
        this.m_impulse *= t.step.dtRatio;
        var m = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P);
        o.SelfMulSub(this.m_invMassA, m), s -= this.m_invIA * box2d.b2CrossVV(this.m_rA, m), a.SelfMulAdd(this.m_invMassB, m), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, m)
    } else this.m_impulse = 0;
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = h
}, box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA),
        r = box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB),
        a = this.m_length - this.m_maxLength,
        h = box2d.b2DotVV(this.m_u, box2d.b2SubVV(r, n, box2d.b2Vec2.s_t0));
    a < 0 && (h += t.step.inv_dt * a);
    var l = -this.m_mass * h,
        d = this.m_impulse;
    this.m_impulse = box2d.b2Min(0, this.m_impulse + l), l = this.m_impulse - d;
    var c = box2d.b2MulSV(l, this.m_u, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P);
    e.SelfMulSub(this.m_invMassA, c), i -= this.m_invIA * box2d.b2CrossVV(this.m_rA, c), o.SelfMulAdd(this.m_invMassB, c), s += this.m_invIB * box2d.b2CrossVV(this.m_rB, c), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.SolvePositionConstraints = function(t) {
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        s = t.positions[this.m_indexB].a,
        n = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(s);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var a = box2d.b2MulRV(n, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var h = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        l = this.m_u.Copy(o).SelfAdd(h).SelfSub(e).SelfSub(a),
        d = l.Normalize(),
        c = d - this.m_maxLength;
    c = box2d.b2Clamp(c, 0, box2d.b2_maxLinearCorrection);
    var p = -this.m_mass * c,
        u = box2d.b2MulSV(p, l, box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P);
    return e.SelfMulSub(this.m_invMassA, u), i -= this.m_invIA * box2d.b2CrossVV(a, u), o.SelfMulAdd(this.m_invMassB, u), s += this.m_invIB * box2d.b2CrossVV(h, u), t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = s, d - this.m_maxLength < box2d.b2_linearSlop
}, box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2RopeJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2RopeJoint.prototype.GetReactionForce = function(t, e) {
    return box2d.b2MulSV(t * this.m_impulse, this.m_u, e)
}, box2d.b2RopeJoint.prototype.GetReactionTorque = function(t) {
    return 0
}, box2d.b2RopeJoint.prototype.GetLocalAnchorA = function(t) {
    return t.Copy(this.m_localAnchorA)
}, box2d.b2RopeJoint.prototype.GetLocalAnchorB = function(t) {
    return t.Copy(this.m_localAnchorB)
}, box2d.b2RopeJoint.prototype.SetMaxLength = function(t) {
    this.m_maxLength = t
}, box2d.b2RopeJoint.prototype.GetMaxLength = function() {
    return this.m_maxLength
}, box2d.b2RopeJoint.prototype.GetLimitState = function() {
    return this.m_state
}, box2d.b2RopeJoint.prototype.Dump = function() {}, goog.provide("box2d.b2GravityController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), box2d.b2GravityController = function() {
    goog.base(this)
}, goog.inherits(box2d.b2GravityController, box2d.b2Controller), box2d.b2GravityController.prototype.G = 1, box2d.b2GravityController.prototype.invSqr = !0, box2d.b2GravityController.prototype.Step = function(t) {
    if (this.invSqr)
        for (var e = this.m_bodyList; e; e = e.nextBody)
            for (var i = e.body, o = i.GetWorldCenter(), s = i.GetMass(), n = this.m_bodyList; n !== e; n = n.nextBody) {
                var r = n.body,
                    a = r.GetWorldCenter(),
                    h = r.GetMass(),
                    l = a.x - o.x,
                    d = a.y - o.y,
                    c = l * l + d * d;
                if (!(c < box2d.b2_epsilon)) {
                    var p = box2d.b2GravityController.prototype.Step.s_f.SetXY(l, d);
                    p.SelfMul(this.G / c / box2d.b2Sqrt(c) * s * h), i.IsAwake() && i.ApplyForce(p, o), r.IsAwake() && r.ApplyForce(p.SelfMul(-1), a)
                }
            } else
                for (var e = this.m_bodyList; e; e = e.nextBody)
                    for (var i = e.body, o = i.GetWorldCenter(), s = i.GetMass(), n = this.m_bodyList; n !== e; n = n.nextBody) {
                        var r = n.body,
                            a = r.GetWorldCenter(),
                            h = r.GetMass(),
                            l = a.x - o.x,
                            d = a.y - o.y,
                            c = l * l + d * d;
                        if (!(c < box2d.b2_epsilon)) {
                            var p = box2d.b2GravityController.prototype.Step.s_f.SetXY(l, d);
                            p.SelfMul(this.G / c * s * h), i.IsAwake() && i.ApplyForce(p, o), r.IsAwake() && r.ApplyForce(p.SelfMul(-1), a)
                        }
                    }
}, box2d.b2GravityController.prototype.Step.s_f = new box2d.b2Vec2, goog.provide("box2d.b2TimeStep"), goog.require("box2d.b2Settings"), box2d.b2Profile = function() {}, box2d.b2Profile.prototype.step = 0, box2d.b2Profile.prototype.collide = 0, box2d.b2Profile.prototype.solve = 0, box2d.b2Profile.prototype.solveInit = 0, box2d.b2Profile.prototype.solveVelocity = 0, box2d.b2Profile.prototype.solvePosition = 0, box2d.b2Profile.prototype.broadphase = 0, box2d.b2Profile.prototype.solveTOI = 0, box2d.b2Profile.prototype.Reset = function() {
    return this.step = 0, this.collide = 0, this.solve = 0, this.solveInit = 0, this.solveVelocity = 0, this.solvePosition = 0, this.broadphase = 0, this.solveTOI = 0, this
}, box2d.b2TimeStep = function() {}, box2d.b2TimeStep.prototype.dt = 0, box2d.b2TimeStep.prototype.inv_dt = 0, box2d.b2TimeStep.prototype.dtRatio = 0, box2d.b2TimeStep.prototype.velocityIterations = 0, box2d.b2TimeStep.prototype.positionIterations = 0, box2d.b2TimeStep.prototype.warmStarting = !1, box2d.b2TimeStep.prototype.Copy = function(t) {
    return this.dt = t.dt, this.inv_dt = t.inv_dt, this.dtRatio = t.dtRatio, this.positionIterations = t.positionIterations, this.velocityIterations = t.velocityIterations, this.warmStarting = t.warmStarting, this
}, box2d.b2Position = function() {
    this.c = new box2d.b2Vec2
}, box2d.b2Position.prototype.c = null, box2d.b2Position.prototype.a = 0, box2d.b2Position.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function(t) {
        return new box2d.b2Position
    })
}, box2d.b2Velocity = function() {
    this.v = new box2d.b2Vec2
}, box2d.b2Velocity.prototype.v = null, box2d.b2Velocity.prototype.w = 0, box2d.b2Velocity.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function(t) {
        return new box2d.b2Velocity
    })
}, box2d.b2SolverData = function() {
    this.step = new box2d.b2TimeStep
}, box2d.b2SolverData.prototype.step = null, box2d.b2SolverData.prototype.positions = null, box2d.b2SolverData.prototype.velocities = null, goog.provide("box2d.b2Collision"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Distance"), box2d.b2ContactFeatureType = {
    e_vertex: 0,
    e_face: 1
}, goog.exportProperty(box2d.b2ContactFeatureType, "e_vertex", box2d.b2ContactFeatureType.e_vertex), goog.exportProperty(box2d.b2ContactFeatureType, "e_face", box2d.b2ContactFeatureType.e_face), box2d.b2ContactFeature = function(t) {
    this._id = t
}, box2d.b2ContactFeature.prototype._id = null, box2d.b2ContactFeature.prototype._indexA = 0, box2d.b2ContactFeature.prototype._indexB = 0, box2d.b2ContactFeature.prototype._typeA = 0, box2d.b2ContactFeature.prototype._typeB = 0, Object.defineProperty(box2d.b2ContactFeature.prototype, "indexA", {
    enumerable: !1,
    configurable: !0,
    get: function() {
        return this._indexA
    },
    set: function(t) {
        this._indexA = t, this._id._key = 4294967040 & this._id._key | 255 & this._indexA
    }
}), Object.defineProperty(box2d.b2ContactFeature.prototype, "indexB", {
    enumerable: !1,
    configurable: !0,
    get: function() {
        return this._indexB
    },
    set: function(t) {
        this._indexB = t, this._id._key = 4294902015 & this._id._key | this._indexB << 8 & 65280
    }
}), Object.defineProperty(box2d.b2ContactFeature.prototype, "typeA", {
    enumerable: !1,
    configurable: !0,
    get: function() {
        return this._typeA
    },
    set: function(t) {
        this._typeA = t, this._id._key = 4278255615 & this._id._key | this._typeA << 16 & 16711680
    }
}), Object.defineProperty(box2d.b2ContactFeature.prototype, "typeB", {
    enumerable: !1,
    configurable: !0,
    get: function() {
        return this._typeB
    },
    set: function(t) {
        this._typeB = t, this._id._key = 16777215 & this._id._key | this._typeB << 24 & 4278190080
    }
}), box2d.b2ContactID = function() {
    this.cf = new box2d.b2ContactFeature(this)
}, box2d.b2ContactID.prototype.cf = null, box2d.b2ContactID.prototype.key = 0, box2d.b2ContactID.prototype.Copy = function(t) {
    return this.key = t.key, this
}, box2d.b2ContactID.prototype.Clone = function() {
    return (new box2d.b2ContactID).Copy(this)
}, Object.defineProperty(box2d.b2ContactID.prototype, "key", {
    enumerable: !1,
    configurable: !0,
    get: function() {
        return this._key
    },
    set: function(t) {
        this._key = t, this.cf._indexA = 255 & this._key, this.cf._indexB = this._key >> 8 & 255, this.cf._typeA = this._key >> 16 & 255, this.cf._typeB = this._key >> 24 & 255
    }
}), box2d.b2ManifoldPoint = function() {
    this.localPoint = new box2d.b2Vec2, this.id = new box2d.b2ContactID
}, box2d.b2ManifoldPoint.prototype.localPoint = null, box2d.b2ManifoldPoint.prototype.normalImpulse = 0, box2d.b2ManifoldPoint.prototype.tangentImpulse = 0, box2d.b2ManifoldPoint.prototype.id = null, box2d.b2ManifoldPoint.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function(t) {
        return new box2d.b2ManifoldPoint
    })
}, box2d.b2ManifoldPoint.prototype.Reset = function() {
    this.localPoint.SetZero(), this.normalImpulse = 0, this.tangentImpulse = 0, this.id.key = 0
}, box2d.b2ManifoldPoint.prototype.Copy = function(t) {
    return this.localPoint.Copy(t.localPoint), this.normalImpulse = t.normalImpulse, this.tangentImpulse = t.tangentImpulse, this.id.Copy(t.id), this
}, box2d.b2ManifoldType = {
    e_unknown: -1,
    e_circles: 0,
    e_faceA: 1,
    e_faceB: 2
}, goog.exportProperty(box2d.b2ManifoldType, "e_unknown", box2d.b2ManifoldType.e_unknown), goog.exportProperty(box2d.b2ManifoldType, "e_circles", box2d.b2ManifoldType.e_circles), goog.exportProperty(box2d.b2ManifoldType, "e_faceA", box2d.b2ManifoldType.e_faceA), goog.exportProperty(box2d.b2ManifoldType, "e_faceB", box2d.b2ManifoldType.e_faceB), box2d.b2Manifold = function() {
    this.points = box2d.b2ManifoldPoint.MakeArray(box2d.b2_maxManifoldPoints), this.localNormal = new box2d.b2Vec2, this.localPoint = new box2d.b2Vec2, this.type = box2d.b2ManifoldType.e_unknown, this.pointCount = 0
}, box2d.b2Manifold.prototype.points = null, box2d.b2Manifold.prototype.localNormal = null, box2d.b2Manifold.prototype.localPoint = null, box2d.b2Manifold.prototype.type = box2d.b2ManifoldType.e_unknown, box2d.b2Manifold.prototype.pointCount = 0, box2d.b2Manifold.prototype.Reset = function() {
    for (var t = 0, e = box2d.b2_maxManifoldPoints; t < e; ++t) this.points[t].Reset();
    this.localNormal.SetZero(), this.localPoint.SetZero(), this.type = box2d.b2ManifoldType.e_unknown, this.pointCount = 0
}, box2d.b2Manifold.prototype.Copy = function(t) {
    this.pointCount = t.pointCount;
    for (var e = 0, i = box2d.b2_maxManifoldPoints; e < i; ++e) this.points[e].Copy(t.points[e]);
    return this.localNormal.Copy(t.localNormal), this.localPoint.Copy(t.localPoint), this.type = t.type, this
}, box2d.b2Manifold.prototype.Clone = function() {
    return (new box2d.b2Manifold).Copy(this)
}, box2d.b2WorldManifold = function() {
    this.normal = new box2d.b2Vec2, this.points = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints), this.separations = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints)
}, box2d.b2WorldManifold.prototype.normal = null, box2d.b2WorldManifold.prototype.points = null, box2d.b2WorldManifold.prototype.separations = null, box2d.b2WorldManifold.prototype.Initialize = function(t, e, i, o, s) {
    if (0 !== t.pointCount) switch (t.type) {
        case box2d.b2ManifoldType.e_circles:
            this.normal.SetXY(1, 0);
            var n = box2d.b2MulXV(e, t.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointA),
                r = box2d.b2MulXV(o, t.points[0].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointB);
            box2d.b2DistanceSquaredVV(n, r) > box2d.b2_epsilon_sq && box2d.b2SubVV(r, n, this.normal).SelfNormalize();
            var a = box2d.b2AddVMulSV(n, i, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA),
                h = box2d.b2SubVMulSV(r, s, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
            box2d.b2MidVV(a, h, this.points[0]), this.separations[0] = box2d.b2DotVV(box2d.b2SubVV(h, a, box2d.b2Vec2.s_t0), this.normal);
            break;
        case box2d.b2ManifoldType.e_faceA:
            box2d.b2MulRV(e.q, t.localNormal, this.normal);
            for (var l = box2d.b2MulXV(e, t.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint), d = 0, c = t.pointCount; d < c; ++d) {
                var p = box2d.b2MulXV(o, t.points[d].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint),
                    u = i - box2d.b2DotVV(box2d.b2SubVV(p, l, box2d.b2Vec2.s_t0), this.normal),
                    a = box2d.b2AddVMulSV(p, u, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA),
                    h = box2d.b2SubVMulSV(p, s, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
                box2d.b2MidVV(a, h, this.points[d]), this.separations[d] = box2d.b2DotVV(box2d.b2SubVV(h, a, box2d.b2Vec2.s_t0), this.normal)
            }
            break;
        case box2d.b2ManifoldType.e_faceB:
            box2d.b2MulRV(o.q, t.localNormal, this.normal);
            for (var l = box2d.b2MulXV(o, t.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint), d = 0, c = t.pointCount; d < c; ++d) {
                var p = box2d.b2MulXV(e, t.points[d].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint),
                    u = s - box2d.b2DotVV(box2d.b2SubVV(p, l, box2d.b2Vec2.s_t0), this.normal),
                    h = box2d.b2AddVMulSV(p, u, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB),
                    a = box2d.b2SubVMulSV(p, i, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA);
                box2d.b2MidVV(a, h, this.points[d]), this.separations[d] = box2d.b2DotVV(box2d.b2SubVV(a, h, box2d.b2Vec2.s_t0), this.normal)
            }
            this.normal.SelfNeg()
    }
}, box2d.b2WorldManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_cA = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_cB = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2, box2d.b2PointState = {
    b2_nullState: 0,
    b2_addState: 1,
    b2_persistState: 2,
    b2_removeState: 3
}, goog.exportProperty(box2d.b2PointState, "b2_nullState   ", box2d.b2PointState.b2_nullState), goog.exportProperty(box2d.b2PointState, "b2_addState    ", box2d.b2PointState.b2_addState), goog.exportProperty(box2d.b2PointState, "b2_persistState", box2d.b2PointState.b2_persistState), goog.exportProperty(box2d.b2PointState, "b2_removeState ", box2d.b2PointState.b2_removeState), box2d.b2GetPointStates = function(t, e, i, o) {
    for (var s = 0, n = i.pointCount; s < n; ++s) {
        var r = i.points[s].id,
            a = r.key;
        t[s] = box2d.b2PointState.b2_removeState;
        for (var h = 0, l = o.pointCount; h < l; ++h)
            if (o.points[h].id.key === a) {
                t[s] = box2d.b2PointState.b2_persistState;
                break
            }
    }
    for (var n = box2d.b2_maxManifoldPoints; s < n; ++s) t[s] = box2d.b2PointState.b2_nullState;
    for (var s = 0, n = o.pointCount; s < n; ++s) {
        var r = o.points[s].id,
            a = r.key;
        e[s] = box2d.b2PointState.b2_addState;
        for (var h = 0, l = i.pointCount; h < l; ++h)
            if (i.points[h].id.key === a) {
                e[s] = box2d.b2PointState.b2_persistState;
                break
            }
    }
    for (var n = box2d.b2_maxManifoldPoints; s < n; ++s) e[s] = box2d.b2PointState.b2_nullState
}, box2d.b2ClipVertex = function() {
    this.v = new box2d.b2Vec2, this.id = new box2d.b2ContactID
}, box2d.b2ClipVertex.prototype.v = null, box2d.b2ClipVertex.prototype.id = null, box2d.b2ClipVertex.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function(t) {
        return new box2d.b2ClipVertex
    })
}, box2d.b2ClipVertex.prototype.Copy = function(t) {
    return this.v.Copy(t.v), this.id.Copy(t.id), this
}, box2d.b2RayCastInput = function() {
    this.p1 = new box2d.b2Vec2, this.p2 = new box2d.b2Vec2, this.maxFraction = 1
}, box2d.b2RayCastInput.prototype.p1 = null, box2d.b2RayCastInput.prototype.p2 = null, box2d.b2RayCastInput.prototype.maxFraction = 1, box2d.b2RayCastInput.prototype.Copy = function(t) {
    return this.p1.Copy(t.p1), this.p2.Copy(t.p2), this.maxFraction = t.maxFraction, this
}, box2d.b2RayCastOutput = function() {
    this.normal = new box2d.b2Vec2, this.fraction = 0
}, box2d.b2RayCastOutput.prototype.normal = null, box2d.b2RayCastOutput.prototype.fraction = 0, box2d.b2RayCastOutput.prototype.Copy = function(t) {
    return this.normal.Copy(t.normal), this.fraction = t.fraction, this
}, box2d.b2AABB = function() {
    this.lowerBound = new box2d.b2Vec2, this.upperBound = new box2d.b2Vec2, this.m_out_center = new box2d.b2Vec2, this.m_out_extent = new box2d.b2Vec2
}, box2d.b2AABB.prototype.lowerBound = null;
box2d.b2AABB.prototype.upperBound = null, box2d.b2AABB.prototype.m_out_center = null, box2d.b2AABB.prototype.m_out_extent = null, box2d.b2AABB.prototype.Copy = function(t) {
    return this.lowerBound.Copy(t.lowerBound), this.upperBound.Copy(t.upperBound), this
}, box2d.b2AABB.prototype.IsValid = function() {
    var t = this.upperBound.x - this.lowerBound.x,
        e = this.upperBound.y - this.lowerBound.y,
        i = t >= 0 && e >= 0;
    return i = i && this.lowerBound.IsValid() && this.upperBound.IsValid()
}, box2d.b2AABB.prototype.GetCenter = function() {
    return box2d.b2MidVV(this.lowerBound, this.upperBound, this.m_out_center)
}, box2d.b2AABB.prototype.GetExtents = function() {
    return box2d.b2ExtVV(this.lowerBound, this.upperBound, this.m_out_extent)
}, box2d.b2AABB.prototype.GetPerimeter = function() {
    return 2 * (this.upperBound.x - this.lowerBound.x + (this.upperBound.y - this.lowerBound.y))
}, box2d.b2AABB.prototype.Combine1 = function(t) {
    return this.lowerBound.x = box2d.b2Min(this.lowerBound.x, t.lowerBound.x), this.lowerBound.y = box2d.b2Min(this.lowerBound.y, t.lowerBound.y), this.upperBound.x = box2d.b2Max(this.upperBound.x, t.upperBound.x), this.upperBound.y = box2d.b2Max(this.upperBound.y, t.upperBound.y), this
}, box2d.b2AABB.prototype.Combine2 = function(t, e) {
    return this.lowerBound.x = box2d.b2Min(t.lowerBound.x, e.lowerBound.x), this.lowerBound.y = box2d.b2Min(t.lowerBound.y, e.lowerBound.y), this.upperBound.x = box2d.b2Max(t.upperBound.x, e.upperBound.x), this.upperBound.y = box2d.b2Max(t.upperBound.y, e.upperBound.y), this
}, box2d.b2AABB.Combine = function(t, e, i) {
    return i.Combine2(t, e), i
}, box2d.b2AABB.prototype.Contains = function(t) {
    var e = !0;
    return e = e && this.lowerBound.x <= t.lowerBound.x, e = e && this.lowerBound.y <= t.lowerBound.y, e = e && t.upperBound.x <= this.upperBound.x, e = e && t.upperBound.y <= this.upperBound.y
}, box2d.b2AABB.prototype.RayCast = function(t, e) {
    var i = -box2d.b2_maxFloat,
        o = box2d.b2_maxFloat,
        s = e.p1.x,
        n = e.p1.y,
        r = e.p2.x - e.p1.x,
        a = e.p2.y - e.p1.y,
        h = box2d.b2Abs(r),
        l = box2d.b2Abs(a),
        d = t.normal;
    if (h < box2d.b2_epsilon) {
        if (s < this.lowerBound.x || this.upperBound.x < s) return !1
    } else {
        var c = 1 / r,
            p = (this.lowerBound.x - s) * c,
            u = (this.upperBound.x - s) * c,
            b = -1;
        if (p > u) {
            var m = p;
            p = u, u = m, b = 1
        }
        if (p > i && (d.x = b, d.y = 0, i = p), o = box2d.b2Min(o, u), i > o) return !1
    }
    if (l < box2d.b2_epsilon) {
        if (n < this.lowerBound.y || this.upperBound.y < n) return !1
    } else {
        var c = 1 / a,
            p = (this.lowerBound.y - n) * c,
            u = (this.upperBound.y - n) * c,
            b = -1;
        if (p > u) {
            var m = p;
            p = u, u = m, b = 1
        }
        if (p > i && (d.x = 0, d.y = b, i = p), o = box2d.b2Min(o, u), i > o) return !1
    }
    return !(i < 0 || e.maxFraction < i) && (t.fraction = i, !0)
}, box2d.b2AABB.prototype.TestOverlap = function(t) {
    var e = t.lowerBound.x - this.upperBound.x,
        i = t.lowerBound.y - this.upperBound.y,
        o = this.lowerBound.x - t.upperBound.x,
        s = this.lowerBound.y - t.upperBound.y;
    return !(e > 0 || i > 0) && !(o > 0 || s > 0)
}, box2d.b2TestOverlapAABB = function(t, e) {
    var i = e.lowerBound.x - t.upperBound.x,
        o = e.lowerBound.y - t.upperBound.y,
        s = t.lowerBound.x - e.upperBound.x,
        n = t.lowerBound.y - e.upperBound.y;
    return !(i > 0 || o > 0) && !(s > 0 || n > 0)
}, box2d.b2ClipSegmentToLine = function(t, e, i, o, s) {
    var n = 0,
        r = e[0],
        a = e[1],
        h = box2d.b2DotVV(i, r.v) - o,
        l = box2d.b2DotVV(i, a.v) - o;
    if (h <= 0 && t[n++].Copy(r), l <= 0 && t[n++].Copy(a), h * l < 0) {
        var d = h / (h - l),
            c = t[n].v;
        c.x = r.v.x + d * (a.v.x - r.v.x), c.y = r.v.y + d * (a.v.y - r.v.y);
        var p = t[n].id;
        p.cf.indexA = s, p.cf.indexB = r.id.cf.indexB, p.cf.typeA = box2d.b2ContactFeatureType.e_vertex, p.cf.typeB = box2d.b2ContactFeatureType.e_face, ++n
    }
    return n
}, box2d.b2TestOverlapShape = function(t, e, i, o, s, n) {
    var r = box2d.b2TestOverlapShape.s_input.Reset();
    r.proxyA.SetShape(t, e), r.proxyB.SetShape(i, o), r.transformA.Copy(s), r.transformB.Copy(n), r.useRadii = !0;
    var a = box2d.b2TestOverlapShape.s_simplexCache.Reset();
    a.count = 0;
    var h = box2d.b2TestOverlapShape.s_output.Reset();
    return box2d.b2Distance(h, a, r), h.distance < 10 * box2d.b2_epsilon
}, box2d.b2TestOverlapShape.s_input = new box2d.b2DistanceInput, box2d.b2TestOverlapShape.s_simplexCache = new box2d.b2SimplexCache, box2d.b2TestOverlapShape.s_output = new box2d.b2DistanceOutput, goog.provide("box2d.b2Timer"), goog.require("box2d.b2Settings"), box2d.b2Timer = function() {
    this.m_start = Date.now()
}, box2d.b2Timer.prototype.m_start = 0, box2d.b2Timer.prototype.Reset = function() {
    return this.m_start = Date.now(), this
}, box2d.b2Timer.prototype.GetMilliseconds = function() {
    return Date.now() - this.m_start
}, box2d.b2Counter = function() {}, box2d.b2Counter.prototype.m_count = 0, box2d.b2Counter.prototype.m_min_count = 0, box2d.b2Counter.prototype.m_max_count = 0, box2d.b2Counter.prototype.GetCount = function() {
    return this.m_count
}, box2d.b2Counter.prototype.GetMinCount = function() {
    return this.m_min_count
}, box2d.b2Counter.prototype.GetMaxCount = function() {
    return this.m_max_count
}, box2d.b2Counter.prototype.ResetCount = function() {
    var t = this.m_count;
    return this.m_count = 0, t
}, box2d.b2Counter.prototype.ResetMinCount = function() {
    this.m_min_count = 0
}, box2d.b2Counter.prototype.ResetMaxCount = function() {
    this.m_max_count = 0
}, box2d.b2Counter.prototype.Increment = function() {
    this.m_count++, this.m_max_count < this.m_count && (this.m_max_count = this.m_count)
}, box2d.b2Counter.prototype.Decrement = function() {
    this.m_count--, this.m_min_count > this.m_count && (this.m_min_count = this.m_count)
}, goog.provide("box2d.b2TimeOfImpact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Distance"), goog.require("box2d.b2Math"), goog.require("box2d.b2Timer"), box2d.b2_toiTime = 0, box2d.b2_toiMaxTime = 0, box2d.b2_toiCalls = 0, box2d.b2_toiIters = 0, box2d.b2_toiMaxIters = 0, box2d.b2_toiRootIters = 0, box2d.b2_toiMaxRootIters = 0, box2d.b2TOIInput = function() {
    this.proxyA = new box2d.b2DistanceProxy, this.proxyB = new box2d.b2DistanceProxy, this.sweepA = new box2d.b2Sweep, this.sweepB = new box2d.b2Sweep
}, box2d.b2TOIInput.prototype.proxyA = null, box2d.b2TOIInput.prototype.proxyB = null, box2d.b2TOIInput.prototype.sweepA = null, box2d.b2TOIInput.prototype.sweepB = null, box2d.b2TOIInput.prototype.tMax = 0, box2d.b2TOIOutputState = {
    e_unknown: 0,
    e_failed: 1,
    e_overlapped: 2,
    e_touching: 3,
    e_separated: 4
}, goog.exportProperty(box2d.b2TOIOutputState, "e_unknown", box2d.b2TOIOutputState.e_unknown), goog.exportProperty(box2d.b2TOIOutputState, "e_failed", box2d.b2TOIOutputState.e_failed), goog.exportProperty(box2d.b2TOIOutputState, "e_overlapped", box2d.b2TOIOutputState.e_overlapped), goog.exportProperty(box2d.b2TOIOutputState, "e_touching", box2d.b2TOIOutputState.e_touching), goog.exportProperty(box2d.b2TOIOutputState, "e_separated", box2d.b2TOIOutputState.e_separated), box2d.b2TOIOutput = function() {}, box2d.b2TOIOutput.prototype.state = box2d.b2TOIOutputState.e_unknown, box2d.b2TOIOutput.prototype.t = 0, box2d.b2SeparationFunctionType = {
    e_unknown: -1,
    e_points: 0,
    e_faceA: 1,
    e_faceB: 2
}, goog.exportProperty(box2d.b2SeparationFunctionType, "e_unknown", box2d.b2SeparationFunctionType.e_unknown), goog.exportProperty(box2d.b2SeparationFunctionType, "e_points", box2d.b2SeparationFunctionType.e_points), goog.exportProperty(box2d.b2SeparationFunctionType, "e_faceA", box2d.b2SeparationFunctionType.e_faceA), goog.exportProperty(box2d.b2SeparationFunctionType, "e_faceB", box2d.b2SeparationFunctionType.e_faceB), box2d.b2SeparationFunction = function() {
    this.m_sweepA = new box2d.b2Sweep, this.m_sweepB = new box2d.b2Sweep, this.m_localPoint = new box2d.b2Vec2, this.m_axis = new box2d.b2Vec2
}, box2d.b2SeparationFunction.prototype.m_proxyA = null, box2d.b2SeparationFunction.prototype.m_proxyB = null, box2d.b2SeparationFunction.prototype.m_sweepA = null, box2d.b2SeparationFunction.prototype.m_sweepB = null, box2d.b2SeparationFunction.prototype.m_type = box2d.b2SeparationFunctionType.e_unknown, box2d.b2SeparationFunction.prototype.m_localPoint = null, box2d.b2SeparationFunction.prototype.m_axis = null, box2d.b2SeparationFunction.prototype.Initialize = function(t, e, i, o, s, n) {
    this.m_proxyA = e, this.m_proxyB = o;
    var r = t.count;
    this.m_sweepA.Copy(i), this.m_sweepB.Copy(s);
    var a = box2d.b2TimeOfImpact.s_xfA,
        h = box2d.b2TimeOfImpact.s_xfB;
    if (this.m_sweepA.GetTransform(a, n), this.m_sweepB.GetTransform(h, n), 1 === r) {
        this.m_type = box2d.b2SeparationFunctionType.e_points;
        var l = this.m_proxyA.GetVertex(t.indexA[0]),
            d = this.m_proxyB.GetVertex(t.indexB[0]),
            c = box2d.b2MulXV(a, l, box2d.b2TimeOfImpact.s_pointA),
            p = box2d.b2MulXV(h, d, box2d.b2TimeOfImpact.s_pointB);
        box2d.b2SubVV(p, c, this.m_axis);
        var u = this.m_axis.Normalize();
        return u
    }
    if (t.indexA[0] === t.indexA[1]) {
        this.m_type = box2d.b2SeparationFunctionType.e_faceB;
        var b = this.m_proxyB.GetVertex(t.indexB[0]),
            m = this.m_proxyB.GetVertex(t.indexB[1]);
        box2d.b2CrossVOne(box2d.b2SubVV(m, b, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize();
        var y = box2d.b2MulRV(h.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);
        box2d.b2MidVV(b, m, this.m_localPoint);
        var p = box2d.b2MulXV(h, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB),
            l = this.m_proxyA.GetVertex(t.indexA[0]),
            c = box2d.b2MulXV(a, l, box2d.b2TimeOfImpact.s_pointA),
            u = box2d.b2DotVV(box2d.b2SubVV(c, p, box2d.b2Vec2.s_t0), y);
        return u < 0 && (this.m_axis.SelfNeg(), u = -u), u
    }
    this.m_type = box2d.b2SeparationFunctionType.e_faceA;
    var f = this.m_proxyA.GetVertex(t.indexA[0]),
        g = this.m_proxyA.GetVertex(t.indexA[1]);
    box2d.b2CrossVOne(box2d.b2SubVV(g, f, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize();
    var y = box2d.b2MulRV(a.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);
    box2d.b2MidVV(f, g, this.m_localPoint);
    var c = box2d.b2MulXV(a, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA),
        d = this.m_proxyB.GetVertex(t.indexB[0]),
        p = box2d.b2MulXV(h, d, box2d.b2TimeOfImpact.s_pointB),
        u = box2d.b2DotVV(box2d.b2SubVV(p, c, box2d.b2Vec2.s_t0), y);
    return u < 0 && (this.m_axis.SelfNeg(), u = -u), u
}, box2d.b2SeparationFunction.prototype.FindMinSeparation = function(t, e, i) {
    var o = box2d.b2TimeOfImpact.s_xfA,
        s = box2d.b2TimeOfImpact.s_xfB;
    switch (this.m_sweepA.GetTransform(o, i), this.m_sweepB.GetTransform(s, i), this.m_type) {
        case box2d.b2SeparationFunctionType.e_points:
            var n = box2d.b2MulTRV(o.q, this.m_axis, box2d.b2TimeOfImpact.s_axisA),
                r = box2d.b2MulTRV(s.q, box2d.b2NegV(this.m_axis, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB);
            t[0] = this.m_proxyA.GetSupport(n), e[0] = this.m_proxyB.GetSupport(r);
            var a = this.m_proxyA.GetVertex(t[0]),
                h = this.m_proxyB.GetVertex(e[0]),
                l = box2d.b2MulXV(o, a, box2d.b2TimeOfImpact.s_pointA),
                d = box2d.b2MulXV(s, h, box2d.b2TimeOfImpact.s_pointB),
                c = box2d.b2DotVV(box2d.b2SubVV(d, l, box2d.b2Vec2.s_t0), this.m_axis);
            return c;
        case box2d.b2SeparationFunctionType.e_faceA:
            var p = box2d.b2MulRV(o.q, this.m_axis, box2d.b2TimeOfImpact.s_normal),
                l = box2d.b2MulXV(o, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA),
                r = box2d.b2MulTRV(s.q, box2d.b2NegV(p, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB);
            t[0] = -1, e[0] = this.m_proxyB.GetSupport(r);
            var h = this.m_proxyB.GetVertex(e[0]),
                d = box2d.b2MulXV(s, h, box2d.b2TimeOfImpact.s_pointB),
                c = box2d.b2DotVV(box2d.b2SubVV(d, l, box2d.b2Vec2.s_t0), p);
            return c;
        case box2d.b2SeparationFunctionType.e_faceB:
            var p = box2d.b2MulRV(s.q, this.m_axis, box2d.b2TimeOfImpact.s_normal),
                d = box2d.b2MulXV(s, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB),
                n = box2d.b2MulTRV(o.q, box2d.b2NegV(p, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisA);
            e[0] = -1, t[0] = this.m_proxyA.GetSupport(n);
            var a = this.m_proxyA.GetVertex(t[0]),
                l = box2d.b2MulXV(o, a, box2d.b2TimeOfImpact.s_pointA),
                c = box2d.b2DotVV(box2d.b2SubVV(l, d, box2d.b2Vec2.s_t0), p);
            return c;
        default:
            return t[0] = -1, e[0] = -1, 0
    }
}, box2d.b2SeparationFunction.prototype.Evaluate = function(t, e, i) {
    var o = box2d.b2TimeOfImpact.s_xfA,
        s = box2d.b2TimeOfImpact.s_xfB;
    switch (this.m_sweepA.GetTransform(o, i), this.m_sweepB.GetTransform(s, i), this.m_type) {
        case box2d.b2SeparationFunctionType.e_points:
            var n = this.m_proxyA.GetVertex(t),
                r = this.m_proxyB.GetVertex(e),
                a = box2d.b2MulXV(o, n, box2d.b2TimeOfImpact.s_pointA),
                h = box2d.b2MulXV(s, r, box2d.b2TimeOfImpact.s_pointB),
                l = box2d.b2DotVV(box2d.b2SubVV(h, a, box2d.b2Vec2.s_t0), this.m_axis);
            return l;
        case box2d.b2SeparationFunctionType.e_faceA:
            var d = box2d.b2MulRV(o.q, this.m_axis, box2d.b2TimeOfImpact.s_normal),
                a = box2d.b2MulXV(o, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA),
                r = this.m_proxyB.GetVertex(e),
                h = box2d.b2MulXV(s, r, box2d.b2TimeOfImpact.s_pointB),
                l = box2d.b2DotVV(box2d.b2SubVV(h, a, box2d.b2Vec2.s_t0), d);
            return l;
        case box2d.b2SeparationFunctionType.e_faceB:
            var d = box2d.b2MulRV(s.q, this.m_axis, box2d.b2TimeOfImpact.s_normal),
                h = box2d.b2MulXV(s, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB),
                n = this.m_proxyA.GetVertex(t),
                a = box2d.b2MulXV(o, n, box2d.b2TimeOfImpact.s_pointA),
                l = box2d.b2DotVV(box2d.b2SubVV(a, h, box2d.b2Vec2.s_t0), d);
            return l;
        default:
            return 0
    }
}, box2d.b2TimeOfImpact = function(t, e) {
    var i = box2d.b2TimeOfImpact.s_timer.Reset();
    ++box2d.b2_toiCalls, t.state = box2d.b2TOIOutputState.e_unknown, t.t = e.tMax;
    var o = e.proxyA,
        s = e.proxyB,
        n = box2d.b2TimeOfImpact.s_sweepA.Copy(e.sweepA),
        r = box2d.b2TimeOfImpact.s_sweepB.Copy(e.sweepB);
    n.Normalize(), r.Normalize();
    var a = e.tMax,
        h = o.m_radius + s.m_radius,
        l = box2d.b2Max(box2d.b2_linearSlop, h - 3 * box2d.b2_linearSlop),
        d = .25 * box2d.b2_linearSlop,
        c = 0,
        p = 0,
        u = box2d.b2TimeOfImpact.s_cache;
    u.count = 0;
    var b = box2d.b2TimeOfImpact.s_distanceInput;
    for (b.proxyA = e.proxyA, b.proxyB = e.proxyB, b.useRadii = !1;;) {
        var m = box2d.b2TimeOfImpact.s_xfA,
            y = box2d.b2TimeOfImpact.s_xfB;
        n.GetTransform(m, c), r.GetTransform(y, c), b.transformA.Copy(m), b.transformB.Copy(y);
        var f = box2d.b2TimeOfImpact.s_distanceOutput;
        if (box2d.b2Distance(f, u, b), f.distance <= 0) {
            t.state = box2d.b2TOIOutputState.e_overlapped, t.t = 0;
            break
        }
        if (f.distance < l + d) {
            t.state = box2d.b2TOIOutputState.e_touching, t.t = c;
            break
        }
        var g = box2d.b2TimeOfImpact.s_fcn;
        g.Initialize(u, o, n, s, r, c);
        for (var x = !1, _ = a, v = 0;;) {
            var w = box2d.b2TimeOfImpact.s_indexA,
                C = box2d.b2TimeOfImpact.s_indexB,
                S = g.FindMinSeparation(w, C, _);
            if (S > l + d) {
                t.state = box2d.b2TOIOutputState.e_separated, t.t = a, x = !0;
                break
            }
            if (S > l - d) {
                c = _;
                break
            }
            var A = g.Evaluate(w[0], C[0], c);
            if (A < l - d) {
                t.state = box2d.b2TOIOutputState.e_failed, t.t = c, x = !0;
                break
            }
            if (A <= l + d) {
                t.state = box2d.b2TOIOutputState.e_touching, t.t = c, x = !0;
                break
            }
            for (var T = 0, P = c, B = _;;) {
                var M = 0;
                M = 1 & T ? P + (l - A) * (B - P) / (S - A) : .5 * (P + B), ++T, ++box2d.b2_toiRootIters;
                var I = g.Evaluate(w[0], C[0], M);
                if (box2d.b2Abs(I - l) < d) {
                    _ = M;
                    break
                }
                if (I > l ? (P = M, A = I) : (B = M, S = I), 50 === T) break
            }
            if (box2d.b2_toiMaxRootIters = box2d.b2Max(box2d.b2_toiMaxRootIters, T), ++v === box2d.b2_maxPolygonVertices) break
        }
        if (++p, ++box2d.b2_toiIters, x) break;
        if (20 === p) {
            t.state = box2d.b2TOIOutputState.e_failed, t.t = c;
            break
        }
    }
    box2d.b2_toiMaxIters = box2d.b2Max(box2d.b2_toiMaxIters, p);
    var R = i.GetMilliseconds();
    box2d.b2_toiMaxTime = box2d.b2Max(box2d.b2_toiMaxTime, R), box2d.b2_toiTime += R
}, box2d.b2TimeOfImpact.s_timer = new box2d.b2Timer, box2d.b2TimeOfImpact.s_cache = new box2d.b2SimplexCache, box2d.b2TimeOfImpact.s_distanceInput = new box2d.b2DistanceInput, box2d.b2TimeOfImpact.s_distanceOutput = new box2d.b2DistanceOutput, box2d.b2TimeOfImpact.s_xfA = new box2d.b2Transform, box2d.b2TimeOfImpact.s_xfB = new box2d.b2Transform, box2d.b2TimeOfImpact.s_indexA = box2d.b2MakeNumberArray(1), box2d.b2TimeOfImpact.s_indexB = box2d.b2MakeNumberArray(1), box2d.b2TimeOfImpact.s_fcn = new box2d.b2SeparationFunction, box2d.b2TimeOfImpact.s_sweepA = new box2d.b2Sweep, box2d.b2TimeOfImpact.s_sweepB = new box2d.b2Sweep, box2d.b2TimeOfImpact.s_pointA = new box2d.b2Vec2, box2d.b2TimeOfImpact.s_pointB = new box2d.b2Vec2, box2d.b2TimeOfImpact.s_normal = new box2d.b2Vec2, box2d.b2TimeOfImpact.s_axisA = new box2d.b2Vec2, box2d.b2TimeOfImpact.s_axisB = new box2d.b2Vec2, goog.provide("box2d.b2Contact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Collision"), goog.require("box2d.b2TimeOfImpact"), box2d.b2MixFriction = function(t, e) {
    return box2d.b2Sqrt(t * e)
}, box2d.b2MixRestitution = function(t, e) {
    return t > e ? t : e
}, box2d.b2ContactEdge = function() {}, box2d.b2ContactEdge.prototype.other = null, box2d.b2ContactEdge.prototype.contact = null, box2d.b2ContactEdge.prototype.prev = null, box2d.b2ContactEdge.prototype.next = null, box2d.b2ContactFlag = {
    e_none: 0,
    e_islandFlag: 1,
    e_touchingFlag: 2,
    e_enabledFlag: 4,
    e_filterFlag: 8,
    e_bulletHitFlag: 16,
    e_toiFlag: 32
}, goog.exportProperty(box2d.b2ContactFlag, "e_none", box2d.b2ContactFlag.e_none), goog.exportProperty(box2d.b2ContactFlag, "e_islandFlag", box2d.b2ContactFlag.e_islandFlag), goog.exportProperty(box2d.b2ContactFlag, "e_touchingFlag", box2d.b2ContactFlag.e_touchingFlag), goog.exportProperty(box2d.b2ContactFlag, "e_enabledFlag", box2d.b2ContactFlag.e_enabledFlag), goog.exportProperty(box2d.b2ContactFlag, "e_filterFlag", box2d.b2ContactFlag.e_filterFlag), goog.exportProperty(box2d.b2ContactFlag, "e_bulletHitFlag", box2d.b2ContactFlag.e_bulletHitFlag), goog.exportProperty(box2d.b2ContactFlag, "e_toiFlag", box2d.b2ContactFlag.e_toiFlag), box2d.b2Contact = function() {
    this.m_nodeA = new box2d.b2ContactEdge, this.m_nodeB = new box2d.b2ContactEdge, this.m_manifold = new box2d.b2Manifold, this.m_oldManifold = new box2d.b2Manifold
}, box2d.b2Contact.prototype.m_flags = box2d.b2ContactFlag.e_none, box2d.b2Contact.prototype.m_prev = null, box2d.b2Contact.prototype.m_next = null, box2d.b2Contact.prototype.m_nodeA = null, box2d.b2Contact.prototype.m_nodeB = null, box2d.b2Contact.prototype.m_fixtureA = null, box2d.b2Contact.prototype.m_fixtureB = null, box2d.b2Contact.prototype.m_indexA = 0, box2d.b2Contact.prototype.m_indexB = 0, box2d.b2Contact.prototype.m_manifold = null, box2d.b2Contact.prototype.m_toiCount = 0, box2d.b2Contact.prototype.m_toi = 0, box2d.b2Contact.prototype.m_friction = 0, box2d.b2Contact.prototype.m_restitution = 0, box2d.b2Contact.prototype.m_tangentSpeed = 0, box2d.b2Contact.prototype.m_oldManifold = null, box2d.b2Contact.prototype.GetManifold = function() {
    return this.m_manifold
}, box2d.b2Contact.prototype.GetWorldManifold = function(t) {
    var e = this.m_fixtureA.GetBody(),
        i = this.m_fixtureB.GetBody(),
        o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    t.Initialize(this.m_manifold, e.GetTransform(), o.m_radius, i.GetTransform(), s.m_radius)
}, box2d.b2Contact.prototype.IsTouching = function() {
    return (this.m_flags & box2d.b2ContactFlag.e_touchingFlag) === box2d.b2ContactFlag.e_touchingFlag
}, box2d.b2Contact.prototype.SetEnabled = function(t) {
    t ? this.m_flags |= box2d.b2ContactFlag.e_enabledFlag : this.m_flags &= ~box2d.b2ContactFlag.e_enabledFlag
}, box2d.b2Contact.prototype.IsEnabled = function() {
    return (this.m_flags & box2d.b2ContactFlag.e_enabledFlag) === box2d.b2ContactFlag.e_enabledFlag
}, box2d.b2Contact.prototype.GetNext = function() {
    return this.m_next
}, box2d.b2Contact.prototype.GetFixtureA = function() {
    return this.m_fixtureA
}, box2d.b2Contact.prototype.GetChildIndexA = function() {
    return this.m_indexA
}, box2d.b2Contact.prototype.GetFixtureB = function() {
    return this.m_fixtureB
}, box2d.b2Contact.prototype.GetChildIndexB = function() {
    return this.m_indexB
}, box2d.b2Contact.prototype.Evaluate = function(t, e, i) {}, box2d.b2Contact.prototype.FlagForFiltering = function() {
    this.m_flags |= box2d.b2ContactFlag.e_filterFlag
}, box2d.b2Contact.prototype.SetFriction = function(t) {
    this.m_friction = t
}, box2d.b2Contact.prototype.GetFriction = function() {
    return this.m_friction
}, box2d.b2Contact.prototype.ResetFriction = function() {
    this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction)
}, box2d.b2Contact.prototype.SetRestitution = function(t) {
    this.m_restitution = t
}, box2d.b2Contact.prototype.GetRestitution = function() {
    return this.m_restitution
}, box2d.b2Contact.prototype.ResetRestitution = function() {
    this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution)
}, box2d.b2Contact.prototype.SetTangentSpeed = function(t) {
    this.m_tangentSpeed = t
}, box2d.b2Contact.prototype.GetTangentSpeed = function() {
    return this.m_tangentSpeed
}, box2d.b2Contact.prototype.Reset = function(t, e, i, o) {
    this.m_flags = box2d.b2ContactFlag.e_enabledFlag, this.m_fixtureA = t, this.m_fixtureB = i, this.m_indexA = e, this.m_indexB = o, this.m_manifold.pointCount = 0, this.m_prev = null, this.m_next = null, this.m_nodeA.contact = null, this.m_nodeA.prev = null, this.m_nodeA.next = null, this.m_nodeA.other = null, this.m_nodeB.contact = null, this.m_nodeB.prev = null, this.m_nodeB.next = null, this.m_nodeB.other = null, this.m_toiCount = 0, this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction), this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution)
}, box2d.b2Contact.prototype.Update = function(t) {
    var e = this.m_oldManifold;
    this.m_oldManifold = this.m_manifold, this.m_manifold = e, this.m_flags |= box2d.b2ContactFlag.e_enabledFlag;
    var i = !1,
        o = (this.m_flags & box2d.b2ContactFlag.e_touchingFlag) === box2d.b2ContactFlag.e_touchingFlag,
        s = this.m_fixtureA.IsSensor(),
        n = this.m_fixtureB.IsSensor(),
        r = s || n,
        a = this.m_fixtureA.GetBody(),
        h = this.m_fixtureB.GetBody(),
        l = a.GetTransform(),
        d = h.GetTransform();
    if (r) {
        var c = this.m_fixtureA.GetShape(),
            p = this.m_fixtureB.GetShape();
        i = box2d.b2TestOverlapShape(c, this.m_indexA, p, this.m_indexB, l, d), this.m_manifold.pointCount = 0
    } else {
        this.Evaluate(this.m_manifold, l, d), i = this.m_manifold.pointCount > 0;
        for (var u = 0; u < this.m_manifold.pointCount; ++u) {
            var b = this.m_manifold.points[u];
            b.normalImpulse = 0, b.tangentImpulse = 0;
            for (var m = b.id, y = 0; y < this.m_oldManifold.pointCount; ++y) {
                var f = this.m_oldManifold.points[y];
                if (f.id.key === m.key) {
                    b.normalImpulse = f.normalImpulse, b.tangentImpulse = f.tangentImpulse;
                    break
                }
            }
        }
        i !== o && (a.SetAwake(!0), h.SetAwake(!0))
    }
    i ? this.m_flags |= box2d.b2ContactFlag.e_touchingFlag : this.m_flags &= ~box2d.b2ContactFlag.e_touchingFlag, !1 === o && !0 === i && t && t.BeginContact(this), !0 === o && !1 === i && t && t.EndContact(this), !1 === r && i && t && t.PreSolve(this, this.m_oldManifold)
}, box2d.b2Contact.prototype.ComputeTOI = function(t, e) {
    var i = box2d.b2Contact.prototype.ComputeTOI.s_input;
    i.proxyA.SetShape(this.m_fixtureA.GetShape(), this.m_indexA), i.proxyB.SetShape(this.m_fixtureB.GetShape(), this.m_indexB), i.sweepA.Copy(t), i.sweepB.Copy(e), i.tMax = box2d.b2_linearSlop;
    var o = box2d.b2Contact.prototype.ComputeTOI.s_output;
    return box2d.b2TimeOfImpact(o, i), o.t
}, box2d.b2Contact.prototype.ComputeTOI.s_input = new box2d.b2TOIInput, box2d.b2Contact.prototype.ComputeTOI.s_output = new box2d.b2TOIOutput, goog.provide("box2d.b2PolygonAndCircleContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), box2d.b2PolygonAndCircleContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2PolygonAndCircleContact, box2d.b2Contact), box2d.b2PolygonAndCircleContact.Create = function(t) {
    return new box2d.b2PolygonAndCircleContact
}, box2d.b2PolygonAndCircleContact.Destroy = function(t, e) {}, box2d.b2PolygonAndCircleContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o)
}, box2d.b2PolygonAndCircleContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    box2d.b2CollidePolygonAndCircle(t, o instanceof box2d.b2PolygonShape ? o : null, e, s instanceof box2d.b2CircleShape ? s : null, i)
}, goog.provide("box2d.b2EdgeAndPolygonContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), box2d.b2EdgeAndPolygonContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2EdgeAndPolygonContact, box2d.b2Contact), box2d.b2EdgeAndPolygonContact.Create = function(t) {
    return new box2d.b2EdgeAndPolygonContact
}, box2d.b2EdgeAndPolygonContact.Destroy = function(t, e) {}, box2d.b2EdgeAndPolygonContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o)
}, box2d.b2EdgeAndPolygonContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    box2d.b2CollideEdgeAndPolygon(t, o instanceof box2d.b2EdgeShape ? o : null, e, s instanceof box2d.b2PolygonShape ? s : null, i)
}, goog.provide("box2d.b2Shape"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Distance"), box2d.b2MassData = function() {
    this.center = new box2d.b2Vec2(0, 0)
}, box2d.b2MassData.prototype.mass = 0, box2d.b2MassData.prototype.center = null, box2d.b2MassData.prototype.I = 0, box2d.b2ShapeType = {
    e_unknown: -1,
    e_circleShape: 0,
    e_edgeShape: 1,
    e_polygonShape: 2,
    e_chainShape: 3,
    e_shapeTypeCount: 4
}, goog.exportProperty(box2d.b2ShapeType, "e_unknown", box2d.b2ShapeType.e_unknown), goog.exportProperty(box2d.b2ShapeType, "e_circleShape", box2d.b2ShapeType.e_circleShape), goog.exportProperty(box2d.b2ShapeType, "e_edgeShape", box2d.b2ShapeType.e_edgeShape), goog.exportProperty(box2d.b2ShapeType, "e_polygonShape", box2d.b2ShapeType.e_polygonShape), goog.exportProperty(box2d.b2ShapeType, "e_chainShape", box2d.b2ShapeType.e_chainShape), goog.exportProperty(box2d.b2ShapeType, "e_shapeTypeCount", box2d.b2ShapeType.e_shapeTypeCount), box2d.b2Shape = function(t, e) {
    this.m_type = t, this.m_radius = e
}, box2d.b2Shape.prototype.m_type = box2d.b2ShapeType.e_unknown, box2d.b2Shape.prototype.m_radius = 0, box2d.b2Shape.prototype.Clone = function() {
    return null
}, box2d.b2Shape.prototype.Copy = function(t) {
    return this.m_radius = t.m_radius, this
}, box2d.b2Shape.prototype.GetType = function() {
    return this.m_type
}, box2d.b2Shape.prototype.GetChildCount = function() {
    return 0
}, box2d.b2Shape.prototype.TestPoint = function(t, e) {
    return !1
};
box2d.b2Shape.prototype.RayCast = function(t, e, i, o) {
    return !1
}, box2d.b2Shape.prototype.ComputeAABB = function(t, e, i) {}, box2d.b2Shape.prototype.ComputeMass = function(t, e) {}, box2d.b2Shape.prototype.SetupDistanceProxy = function(t, e) {}, box2d.b2Shape.prototype.ComputeSubmergedArea = function(t, e, i, o) {
    return 0
}, box2d.b2Shape.prototype.Dump = function() {}, goog.provide("box2d.b2PolygonShape"), goog.require("box2d.b2Shape"), box2d.b2PolygonShape = function() {
    goog.base(this, box2d.b2ShapeType.e_polygonShape, box2d.b2_polygonRadius), this.m_centroid = new box2d.b2Vec2(0, 0), this.m_vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices), this.m_normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices)
}, goog.inherits(box2d.b2PolygonShape, box2d.b2Shape), box2d.b2PolygonShape.prototype.m_centroid = null, box2d.b2PolygonShape.prototype.m_vertices = null, box2d.b2PolygonShape.prototype.m_normals = null, box2d.b2PolygonShape.prototype.m_count = 0, box2d.b2PolygonShape.prototype.Clone = function() {
    return (new box2d.b2PolygonShape).Copy(this)
}, box2d.b2PolygonShape.prototype.Copy = function(t) {
    goog.base(this, "Copy", t), this.m_centroid.Copy(t.m_centroid), this.m_count = t.m_count;
    for (var e = 0, i = this.m_count; e < i; ++e) this.m_vertices[e].Copy(t.m_vertices[e]), this.m_normals[e].Copy(t.m_normals[e]);
    return this
}, box2d.b2PolygonShape.prototype.SetAsBox = function(t, e) {
    return this.m_count = 4, this.m_vertices[0].SetXY(-t, -e), this.m_vertices[1].SetXY(t, -e), this.m_vertices[2].SetXY(t, e), this.m_vertices[3].SetXY(-t, e), this.m_normals[0].SetXY(0, -1), this.m_normals[1].SetXY(1, 0), this.m_normals[2].SetXY(0, 1), this.m_normals[3].SetXY(-1, 0), this.m_centroid.SetZero(), this
}, box2d.b2PolygonShape.prototype.SetAsOrientedBox = function(t, e, i, o) {
    this.m_count = 4, this.m_vertices[0].SetXY(-t, -e), this.m_vertices[1].SetXY(t, -e), this.m_vertices[2].SetXY(t, e), this.m_vertices[3].SetXY(-t, e), this.m_normals[0].SetXY(0, -1), this.m_normals[1].SetXY(1, 0), this.m_normals[2].SetXY(0, 1), this.m_normals[3].SetXY(-1, 0), this.m_centroid.Copy(i);
    var s = new box2d.b2Transform;
    s.SetPosition(i), s.SetRotationAngleRadians(o);
    for (var n = 0, r = this.m_count; n < r; ++n) box2d.b2MulXV(s, this.m_vertices[n], this.m_vertices[n]), box2d.b2MulRV(s.q, this.m_normals[n], this.m_normals[n]);
    return this
}, box2d.b2PolygonShape.prototype.Set = function(t, e) {
    if (void 0 === e && (e = t.length), e < 3) return this.SetAsBox(1, 1);
    for (var i = box2d.b2Min(e, box2d.b2_maxPolygonVertices), o = box2d.b2PolygonShape.prototype.Set.s_ps, s = 0, n = 0; n < i; ++n) {
        for (var r = t[n], a = !0, h = 0; h < s; ++h)
            if (box2d.b2DistanceSquaredVV(r, o[h]) < .5 * box2d.b2_linearSlop) {
                a = !1;
                break
            }
        a && o[s++].Copy(r)
    }
    if ((i = s) < 3) return this.SetAsBox(1, 1);
    for (var l = 0, d = o[0].x, n = 1; n < i; ++n) {
        var c = o[n].x;
        (c > d || c === d && o[n].y < o[l].y) && (l = n, d = c)
    }
    for (var p = box2d.b2PolygonShape.prototype.Set.s_hull, u = 0, b = l;;) {
        p[u] = b;
        for (var m = 0, h = 1; h < i; ++h)
            if (m !== b) {
                var y = box2d.b2SubVV(o[m], o[p[u]], box2d.b2PolygonShape.prototype.Set.s_r),
                    r = box2d.b2SubVV(o[h], o[p[u]], box2d.b2PolygonShape.prototype.Set.s_v),
                    f = box2d.b2CrossVV(y, r);
                f < 0 && (m = h), 0 === f && r.GetLengthSquared() > y.GetLengthSquared() && (m = h)
            } else m = h;
        if (++u, b = m, m === l) break
    }
    this.m_count = u;
    for (var n = 0; n < u; ++n) this.m_vertices[n].Copy(o[p[n]]);
    for (var n = 0, g = u; n < g; ++n) {
        var x = this.m_vertices[n],
            _ = this.m_vertices[(n + 1) % g],
            v = box2d.b2SubVV(_, x, box2d.b2Vec2.s_t0);
        box2d.b2CrossVOne(v, this.m_normals[n]).SelfNormalize()
    }
    return box2d.b2PolygonShape.ComputeCentroid(this.m_vertices, u, this.m_centroid), this
}, box2d.b2PolygonShape.prototype.Set.s_ps = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices), box2d.b2PolygonShape.prototype.Set.s_hull = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices), box2d.b2PolygonShape.prototype.Set.s_r = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.Set.s_v = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.SetAsVector = function(t, e) {
    return this.Set(t, e), this
}, box2d.b2PolygonShape.prototype.SetAsArray = function(t, e) {
    return this.Set(t, e), this
}, box2d.b2PolygonShape.prototype.GetChildCount = function() {
    return 1
}, box2d.b2PolygonShape.prototype.TestPoint = function(t, e) {
    for (var i = box2d.b2MulTXV(t, e, box2d.b2PolygonShape.prototype.TestPoint.s_pLocal), o = 0, s = this.m_count; o < s; ++o) {
        if (box2d.b2DotVV(this.m_normals[o], box2d.b2SubVV(i, this.m_vertices[o], box2d.b2Vec2.s_t0)) > 0) return !1
    }
    return !0
}, box2d.b2PolygonShape.prototype.TestPoint.s_pLocal = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.RayCast = function(t, e, i, o) {
    for (var s = box2d.b2MulTXV(i, e.p1, box2d.b2PolygonShape.prototype.RayCast.s_p1), n = box2d.b2MulTXV(i, e.p2, box2d.b2PolygonShape.prototype.RayCast.s_p2), r = box2d.b2SubVV(n, s, box2d.b2PolygonShape.prototype.RayCast.s_d), a = 0, h = e.maxFraction, l = -1, d = 0, c = this.m_count; d < c; ++d) {
        var p = box2d.b2DotVV(this.m_normals[d], box2d.b2SubVV(this.m_vertices[d], s, box2d.b2Vec2.s_t0)),
            u = box2d.b2DotVV(this.m_normals[d], r);
        if (0 === u) {
            if (p < 0) return !1
        } else u < 0 && p < a * u ? (a = p / u, l = d) : u > 0 && p < h * u && (h = p / u);
        if (h < a) return !1
    }
    return l >= 0 && (t.fraction = a, box2d.b2MulRV(i.q, this.m_normals[l], t.normal), !0)
}, box2d.b2PolygonShape.prototype.RayCast.s_p1 = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.RayCast.s_p2 = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.RayCast.s_d = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeAABB = function(t, e, i) {
    for (var o = box2d.b2MulXV(e, this.m_vertices[0], t.lowerBound), s = t.upperBound.Copy(o), n = 0, r = this.m_count; n < r; ++n) {
        var a = box2d.b2MulXV(e, this.m_vertices[n], box2d.b2PolygonShape.prototype.ComputeAABB.s_v);
        box2d.b2MinV(a, o, o), box2d.b2MaxV(a, s, s)
    }
    var h = this.m_radius;
    o.SelfSubXY(h, h), s.SelfAddXY(h, h)
}, box2d.b2PolygonShape.prototype.ComputeAABB.s_v = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeMass = function(t, e) {
    for (var i = box2d.b2PolygonShape.prototype.ComputeMass.s_center.SetZero(), o = 0, s = 0, n = box2d.b2PolygonShape.prototype.ComputeMass.s_s.SetZero(), r = 0, a = this.m_count; r < a; ++r) n.SelfAdd(this.m_vertices[r]);
    n.SelfMul(1 / this.m_count);
    for (var r = 0, a = this.m_count; r < a; ++r) {
        var h = box2d.b2SubVV(this.m_vertices[r], n, box2d.b2PolygonShape.prototype.ComputeMass.s_e1),
            l = box2d.b2SubVV(this.m_vertices[(r + 1) % a], n, box2d.b2PolygonShape.prototype.ComputeMass.s_e2),
            d = box2d.b2CrossVV(h, l),
            c = .5 * d;
        o += c, i.SelfAdd(box2d.b2MulSV(c * (1 / 3), box2d.b2AddVV(h, l, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1));
        var p = h.x,
            u = h.y,
            b = l.x,
            m = l.y;
        s += 1 / 3 * .25 * d * (p * p + b * p + b * b + (u * u + m * u + m * m))
    }
    t.mass = e * o, i.SelfMul(1 / o), box2d.b2AddVV(i, n, t.center), t.I = e * s, t.I += t.mass * (box2d.b2DotVV(t.center, t.center) - box2d.b2DotVV(i, i))
}, box2d.b2PolygonShape.prototype.ComputeMass.s_center = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeMass.s_s = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeMass.s_e1 = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeMass.s_e2 = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.Validate = function() {
    for (var t = 0; t < this.m_count; ++t)
        for (var e = t, i = (t + 1) % this.m_count, o = this.m_vertices[e], s = box2d.b2SubVV(this.m_vertices[i], o, box2d.b2PolygonShape.prototype.Validate.s_e), n = 0; n < this.m_count; ++n)
            if (n !== e && n !== i) {
                var r = box2d.b2SubVV(this.m_vertices[n], o, box2d.b2PolygonShape.prototype.Validate.s_v),
                    a = box2d.b2CrossVV(s, r);
                if (a < 0) return !1
            }
    return !0
}, box2d.b2PolygonShape.prototype.Validate.s_e = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.Validate.s_v = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.SetupDistanceProxy = function(t, e) {
    t.m_vertices = this.m_vertices, t.m_count = this.m_count, t.m_radius = this.m_radius
}, box2d.b2PolygonShape.prototype.ComputeSubmergedArea = function(t, e, i, o) {
    for (var s = box2d.b2MulTRV(i.q, t, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL), n = e - box2d.b2DotVV(t, i.p), r = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths, a = 0, h = -1, l = -1, d = !1, c = 0, p = this.m_count; c < p; ++c) {
        r[c] = box2d.b2DotVV(s, this.m_vertices[c]) - n;
        var u = r[c] < -box2d.b2_epsilon;
        c > 0 && (u ? d || (h = c - 1, a++) : d && (l = c - 1, a++)), d = u
    }
    switch (a) {
        case 0:
            if (d) {
                var b = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md;
                return this.ComputeMass(b, 1), box2d.b2MulXV(i, b.center, o), b.mass
            }
            return 0;
        case 1:
            -1 === h ? h = this.m_count - 1 : l = this.m_count - 1
    }
    for (var m = (h + 1) % this.m_count, y = (l + 1) % this.m_count, f = (0 - r[h]) / (r[m] - r[h]), g = (0 - r[l]) / (r[y] - r[l]), x = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec.SetXY(this.m_vertices[h].x * (1 - f) + this.m_vertices[m].x * f, this.m_vertices[h].y * (1 - f) + this.m_vertices[m].y * f), _ = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec.SetXY(this.m_vertices[l].x * (1 - g) + this.m_vertices[y].x * g, this.m_vertices[l].y * (1 - g) + this.m_vertices[y].y * g), v = 0, w = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center.SetZero(), C = this.m_vertices[m], S = null, c = m; c !== y;) {
        c = (c + 1) % this.m_count, S = c === y ? _ : this.m_vertices[c];
        var A = .5 * ((C.x - x.x) * (S.y - x.y) - (C.y - x.y) * (S.x - x.x));
        v += A, w.x += A * (x.x + C.x + S.x) / 3, w.y += A * (x.y + C.y + S.y) / 3, C = S
    }
    return w.SelfMul(1 / v), box2d.b2MulXV(i, w, o), v
}, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices), box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md = new box2d.b2MassData, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2PolygonShape*/ var shape = new box2d.b2PolygonShape();\n"), box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices);
    for (var t = 0; t < this.m_count; ++t) box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", t, this.m_vertices[t].x, this.m_vertices[t].y);
    box2d.b2Log("    shape.Set(vs, %d);\n", this.m_count)
}, box2d.b2PolygonShape.ComputeCentroid = function(t, e, i) {
    var o = i;
    o.SetZero();
    for (var s = 0, n = box2d.b2PolygonShape.ComputeCentroid.s_pRef.SetZero(), r = 0; r < e; ++r) {
        var a = n,
            h = t[r],
            l = t[(r + 1) % e],
            d = box2d.b2SubVV(h, a, box2d.b2PolygonShape.ComputeCentroid.s_e1),
            c = box2d.b2SubVV(l, a, box2d.b2PolygonShape.ComputeCentroid.s_e2),
            p = box2d.b2CrossVV(d, c),
            u = .5 * p;
        s += u, o.x += u * (1 / 3) * (a.x + h.x + l.x), o.y += u * (1 / 3) * (a.y + h.y + l.y)
    }
    return o.SelfMul(1 / s), o
}, box2d.b2PolygonShape.ComputeCentroid.s_pRef = new box2d.b2Vec2, box2d.b2PolygonShape.ComputeCentroid.s_e1 = new box2d.b2Vec2, box2d.b2PolygonShape.ComputeCentroid.s_e2 = new box2d.b2Vec2, goog.provide("box2d.b2CollideEdge"), goog.require("box2d.b2Collision"), box2d.b2CollideEdgeAndCircle = function(t, e, i, o, s) {
    t.pointCount = 0;
    var n = box2d.b2MulTXV(i, box2d.b2MulXV(s, o.m_p, box2d.b2Vec2.s_t0), box2d.b2CollideEdgeAndCircle.s_Q),
        r = e.m_vertex1,
        a = e.m_vertex2,
        h = box2d.b2SubVV(a, r, box2d.b2CollideEdgeAndCircle.s_e),
        l = box2d.b2DotVV(h, box2d.b2SubVV(a, n, box2d.b2Vec2.s_t0)),
        d = box2d.b2DotVV(h, box2d.b2SubVV(n, r, box2d.b2Vec2.s_t0)),
        c = e.m_radius + o.m_radius,
        p = box2d.b2CollideEdgeAndCircle.s_id;
    if (p.cf.indexB = 0, p.cf.typeB = box2d.b2ContactFeatureType.e_vertex, d <= 0) {
        var u = r,
            b = box2d.b2SubVV(n, u, box2d.b2CollideEdgeAndCircle.s_d),
            m = box2d.b2DotVV(b, b);
        if (m > c * c) return;
        if (e.m_hasVertex0) {
            var y = e.m_vertex0,
                f = r,
                g = box2d.b2SubVV(f, y, box2d.b2CollideEdgeAndCircle.s_e1);
            if (box2d.b2DotVV(g, box2d.b2SubVV(f, n, box2d.b2Vec2.s_t0)) > 0) return
        }
        return p.cf.indexA = 0, p.cf.typeA = box2d.b2ContactFeatureType.e_vertex, t.pointCount = 1, t.type = box2d.b2ManifoldType.e_circles, t.localNormal.SetZero(), t.localPoint.Copy(u), t.points[0].id.Copy(p), void t.points[0].localPoint.Copy(o.m_p)
    }
    if (l <= 0) {
        var u = a,
            b = box2d.b2SubVV(n, u, box2d.b2CollideEdgeAndCircle.s_d),
            m = box2d.b2DotVV(b, b);
        if (m > c * c) return;
        if (e.m_hasVertex3) {
            var x = e.m_vertex3,
                _ = a,
                v = box2d.b2SubVV(x, _, box2d.b2CollideEdgeAndCircle.s_e2);
            if (box2d.b2DotVV(v, box2d.b2SubVV(n, _, box2d.b2Vec2.s_t0)) > 0) return
        }
        return p.cf.indexA = 1, p.cf.typeA = box2d.b2ContactFeatureType.e_vertex, t.pointCount = 1, t.type = box2d.b2ManifoldType.e_circles, t.localNormal.SetZero(), t.localPoint.Copy(u), t.points[0].id.Copy(p), void t.points[0].localPoint.Copy(o.m_p)
    }
    var w = box2d.b2DotVV(h, h),
        u = box2d.b2CollideEdgeAndCircle.s_P;
    u.x = 1 / w * (l * r.x + d * a.x), u.y = 1 / w * (l * r.y + d * a.y);
    var b = box2d.b2SubVV(n, u, box2d.b2CollideEdgeAndCircle.s_d),
        m = box2d.b2DotVV(b, b);
    if (!(m > c * c)) {
        var C = box2d.b2CollideEdgeAndCircle.s_n.SetXY(-h.y, h.x);
        box2d.b2DotVV(C, box2d.b2SubVV(n, r, box2d.b2Vec2.s_t0)) < 0 && C.SetXY(-C.x, -C.y), C.Normalize(), p.cf.indexA = 0, p.cf.typeA = box2d.b2ContactFeatureType.e_face, t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, t.localNormal.Copy(C), t.localPoint.Copy(r), t.points[0].id.Copy(p), t.points[0].localPoint.Copy(o.m_p)
    }
}, box2d.b2CollideEdgeAndCircle.s_Q = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_e = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_d = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_e1 = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_e2 = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_P = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_n = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_id = new box2d.b2ContactID, box2d.b2EPAxisType = {
    e_unknown: 0,
    e_edgeA: 1,
    e_edgeB: 2
}, goog.exportProperty(box2d.b2EPAxisType, "e_unknown", box2d.b2EPAxisType.e_unknown), goog.exportProperty(box2d.b2EPAxisType, "e_edgeA", box2d.b2EPAxisType.e_edgeA), goog.exportProperty(box2d.b2EPAxisType, "e_edgeB", box2d.b2EPAxisType.e_edgeB), box2d.b2EPAxis = function() {}, box2d.b2EPAxis.prototype.type = box2d.b2EPAxisType.e_unknown, box2d.b2EPAxis.prototype.index = 0, box2d.b2EPAxis.prototype.separation = 0, box2d.b2TempPolygon = function() {
    this.vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices), this.normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices), this.count = 0
}, box2d.b2TempPolygon.prototype.vertices = null, box2d.b2TempPolygon.prototype.normals = null, box2d.b2TempPolygon.prototype.count = 0, box2d.b2ReferenceFace = function() {
    this.i1 = 0, this.i2 = 0, this.v1 = new box2d.b2Vec2, this.v2 = new box2d.b2Vec2, this.normal = new box2d.b2Vec2, this.sideNormal1 = new box2d.b2Vec2, this.sideOffset1 = 0, this.sideNormal2 = new box2d.b2Vec2, this.sideOffset2 = 0
}, box2d.b2ReferenceFace.prototype.i1 = 0, box2d.b2ReferenceFace.prototype.i2 = 0, box2d.b2ReferenceFace.prototype.v1 = null, box2d.b2ReferenceFace.prototype.v2 = null, box2d.b2ReferenceFace.prototype.normal = null, box2d.b2ReferenceFace.prototype.sideNormal1 = null, box2d.b2ReferenceFace.prototype.sideOffset1 = 0, box2d.b2ReferenceFace.prototype.sideNormal2 = null, box2d.b2ReferenceFace.prototype.sideOffset2 = 0, box2d.b2EPColliderVertexType = {
    e_isolated: 0,
    e_concave: 1,
    e_convex: 2
}, goog.exportProperty(box2d.b2EPColliderVertexType, "e_isolated", box2d.b2EPColliderVertexType.e_isolated), goog.exportProperty(box2d.b2EPColliderVertexType, "e_concave", box2d.b2EPColliderVertexType.e_concave), goog.exportProperty(box2d.b2EPColliderVertexType, "e_convex", box2d.b2EPColliderVertexType.e_convex), box2d.b2EPCollider = function() {
    this.m_polygonB = new box2d.b2TempPolygon, this.m_xf = new box2d.b2Transform, this.m_centroidB = new box2d.b2Vec2, this.m_v0 = new box2d.b2Vec2, this.m_v1 = new box2d.b2Vec2, this.m_v2 = new box2d.b2Vec2, this.m_v3 = new box2d.b2Vec2, this.m_normal0 = new box2d.b2Vec2, this.m_normal1 = new box2d.b2Vec2, this.m_normal2 = new box2d.b2Vec2, this.m_normal = new box2d.b2Vec2, this.m_type1 = box2d.b2EPColliderVertexType.e_isolated, this.m_type2 = box2d.b2EPColliderVertexType.e_isolated, this.m_lowerLimit = new box2d.b2Vec2, this.m_upperLimit = new box2d.b2Vec2, this.m_radius = 0, this.m_front = !1
}, box2d.b2EPCollider.prototype.m_polygonB = null, box2d.b2EPCollider.prototype.m_xf = null, box2d.b2EPCollider.prototype.m_centroidB = null, box2d.b2EPCollider.prototype.m_v0 = null, box2d.b2EPCollider.prototype.m_v1 = null, box2d.b2EPCollider.prototype.m_v2 = null, box2d.b2EPCollider.prototype.m_v3 = null, box2d.b2EPCollider.prototype.m_normal0 = null, box2d.b2EPCollider.prototype.m_normal1 = null, box2d.b2EPCollider.prototype.m_normal2 = null, box2d.b2EPCollider.prototype.m_normal = null, box2d.b2EPCollider.prototype.m_type1 = box2d.b2EPColliderVertexType.e_isolated, box2d.b2EPCollider.prototype.m_type2 = box2d.b2EPColliderVertexType.e_isolated, box2d.b2EPCollider.prototype.m_lowerLimit = null, box2d.b2EPCollider.prototype.m_upperLimit = null, box2d.b2EPCollider.prototype.m_radius = 0, box2d.b2EPCollider.prototype.m_front = !1, box2d.b2EPCollider.prototype.Collide = function(t, e, i, o, s) {
    box2d.b2MulTXX(i, s, this.m_xf), box2d.b2MulXV(this.m_xf, o.m_centroid, this.m_centroidB), this.m_v0.Copy(e.m_vertex0), this.m_v1.Copy(e.m_vertex1), this.m_v2.Copy(e.m_vertex2), this.m_v3.Copy(e.m_vertex3);
    var n = e.m_hasVertex0,
        r = e.m_hasVertex3,
        a = box2d.b2SubVV(this.m_v2, this.m_v1, box2d.b2EPCollider.s_edge1);
    a.Normalize(), this.m_normal1.SetXY(a.y, -a.x);
    var h = box2d.b2DotVV(this.m_normal1, box2d.b2SubVV(this.m_centroidB, this.m_v1, box2d.b2Vec2.s_t0)),
        l = 0,
        d = 0,
        c = !1,
        p = !1;
    if (n) {
        var u = box2d.b2SubVV(this.m_v1, this.m_v0, box2d.b2EPCollider.s_edge0);
        u.Normalize(), this.m_normal0.SetXY(u.y, -u.x), c = box2d.b2CrossVV(u, a) >= 0, l = box2d.b2DotVV(this.m_normal0, box2d.b2SubVV(this.m_centroidB, this.m_v0, box2d.b2Vec2.s_t0))
    }
    if (r) {
        var b = box2d.b2SubVV(this.m_v3, this.m_v2, box2d.b2EPCollider.s_edge2);
        b.Normalize(), this.m_normal2.SetXY(b.y, -b.x), p = box2d.b2CrossVV(a, b) > 0, d = box2d.b2DotVV(this.m_normal2, box2d.b2SubVV(this.m_centroidB, this.m_v2, box2d.b2Vec2.s_t0))
    }
    n && r ? c && p ? (this.m_front = l >= 0 || h >= 0 || d >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg())) : c ? (this.m_front = l >= 0 || h >= 0 && d >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg())) : p ? (this.m_front = d >= 0 || l >= 0 && h >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal0).SelfNeg())) : (this.m_front = l >= 0 && h >= 0 && d >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(), this.m_upperLimit.Copy(this.m_normal0).SelfNeg())) : n ? c ? (this.m_front = l >= 0 || h >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1).SelfNeg())) : (this.m_front = l >= 0 && h >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal0).SelfNeg())) : r ? p ? (this.m_front = h >= 0 || d >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1),
        this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1))) : (this.m_front = h >= 0 && d >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1))) : (this.m_front = h >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1))), this.m_polygonB.count = o.m_count;
    for (var m = 0, y = o.m_count; m < y; ++m) box2d.b2MulXV(this.m_xf, o.m_vertices[m], this.m_polygonB.vertices[m]), box2d.b2MulRV(this.m_xf.q, o.m_normals[m], this.m_polygonB.normals[m]);
    this.m_radius = 2 * box2d.b2_polygonRadius, t.pointCount = 0;
    var f = this.ComputeEdgeSeparation(box2d.b2EPCollider.s_edgeAxis);
    if (f.type !== box2d.b2EPAxisType.e_unknown && !(f.separation > this.m_radius)) {
        var g = this.ComputePolygonSeparation(box2d.b2EPCollider.s_polygonAxis);
        if (!(g.type !== box2d.b2EPAxisType.e_unknown && g.separation > this.m_radius)) {
            var x;
            x = g.type === box2d.b2EPAxisType.e_unknown ? f : g.separation > .98 * f.separation + .001 ? g : f;
            var _ = box2d.b2EPCollider.s_ie,
                v = box2d.b2EPCollider.s_rf;
            if (x.type === box2d.b2EPAxisType.e_edgeA) {
                t.type = box2d.b2ManifoldType.e_faceA;
                for (var w = 0, C = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[0]), m = 1, y = this.m_polygonB.count; m < y; ++m) {
                    var S = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[m]);
                    S < C && (C = S, w = m)
                }
                var A = w,
                    T = (A + 1) % this.m_polygonB.count,
                    P = _[0];
                P.v.Copy(this.m_polygonB.vertices[A]), P.id.cf.indexA = 0, P.id.cf.indexB = A, P.id.cf.typeA = box2d.b2ContactFeatureType.e_face, P.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex;
                var B = _[1];
                B.v.Copy(this.m_polygonB.vertices[T]), B.id.cf.indexA = 0, B.id.cf.indexB = T, B.id.cf.typeA = box2d.b2ContactFeatureType.e_face, B.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex, this.m_front ? (v.i1 = 0, v.i2 = 1, v.v1.Copy(this.m_v1), v.v2.Copy(this.m_v2), v.normal.Copy(this.m_normal1)) : (v.i1 = 1, v.i2 = 0, v.v1.Copy(this.m_v2), v.v2.Copy(this.m_v1), v.normal.Copy(this.m_normal1).SelfNeg())
            } else {
                t.type = box2d.b2ManifoldType.e_faceB;
                var P = _[0];
                P.v.Copy(this.m_v1), P.id.cf.indexA = 0, P.id.cf.indexB = x.index, P.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex, P.id.cf.typeB = box2d.b2ContactFeatureType.e_face;
                var B = _[1];
                B.v.Copy(this.m_v2), B.id.cf.indexA = 0, B.id.cf.indexB = x.index, B.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex, B.id.cf.typeB = box2d.b2ContactFeatureType.e_face, v.i1 = x.index, v.i2 = (v.i1 + 1) % this.m_polygonB.count, v.v1.Copy(this.m_polygonB.vertices[v.i1]), v.v2.Copy(this.m_polygonB.vertices[v.i2]), v.normal.Copy(this.m_polygonB.normals[v.i1])
            }
            v.sideNormal1.SetXY(v.normal.y, -v.normal.x), v.sideNormal2.Copy(v.sideNormal1).SelfNeg(), v.sideOffset1 = box2d.b2DotVV(v.sideNormal1, v.v1), v.sideOffset2 = box2d.b2DotVV(v.sideNormal2, v.v2);
            var M = box2d.b2EPCollider.s_clipPoints1,
                I = box2d.b2EPCollider.s_clipPoints2;
            if (!(box2d.b2ClipSegmentToLine(M, _, v.sideNormal1, v.sideOffset1, v.i1) < box2d.b2_maxManifoldPoints || box2d.b2ClipSegmentToLine(I, M, v.sideNormal2, v.sideOffset2, v.i2) < box2d.b2_maxManifoldPoints)) {
                x.type === box2d.b2EPAxisType.e_edgeA ? (t.localNormal.Copy(v.normal), t.localPoint.Copy(v.v1)) : (t.localNormal.Copy(o.m_normals[v.i1]), t.localPoint.Copy(o.m_vertices[v.i1]));
                for (var R = 0, m = 0, y = box2d.b2_maxManifoldPoints; m < y; ++m) {
                    if (box2d.b2DotVV(v.normal, box2d.b2SubVV(I[m].v, v.v1, box2d.b2Vec2.s_t0)) <= this.m_radius) {
                        var D = t.points[R];
                        x.type === box2d.b2EPAxisType.e_edgeA ? (box2d.b2MulTXV(this.m_xf, I[m].v, D.localPoint), D.id = I[m].id) : (D.localPoint.Copy(I[m].v), D.id.cf.typeA = I[m].id.cf.typeB, D.id.cf.typeB = I[m].id.cf.typeA, D.id.cf.indexA = I[m].id.cf.indexB, D.id.cf.indexB = I[m].id.cf.indexA), ++R
                    }
                }
                t.pointCount = R
            }
        }
    }
}, box2d.b2EPCollider.s_edge1 = new box2d.b2Vec2, box2d.b2EPCollider.s_edge0 = new box2d.b2Vec2, box2d.b2EPCollider.s_edge2 = new box2d.b2Vec2, box2d.b2EPCollider.s_ie = box2d.b2ClipVertex.MakeArray(2), box2d.b2EPCollider.s_rf = new box2d.b2ReferenceFace, box2d.b2EPCollider.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2), box2d.b2EPCollider.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2), box2d.b2EPCollider.s_edgeAxis = new box2d.b2EPAxis, box2d.b2EPCollider.s_polygonAxis = new box2d.b2EPAxis, box2d.b2EPCollider.prototype.ComputeEdgeSeparation = function(t) {
    var e = t;
    e.type = box2d.b2EPAxisType.e_edgeA, e.index = this.m_front ? 0 : 1, e.separation = box2d.b2_maxFloat;
    for (var i = 0, o = this.m_polygonB.count; i < o; ++i) {
        var s = box2d.b2DotVV(this.m_normal, box2d.b2SubVV(this.m_polygonB.vertices[i], this.m_v1, box2d.b2Vec2.s_t0));
        s < e.separation && (e.separation = s)
    }
    return e
}, box2d.b2EPCollider.prototype.ComputePolygonSeparation = function(t) {
    var e = t;
    e.type = box2d.b2EPAxisType.e_unknown, e.index = -1, e.separation = -box2d.b2_maxFloat;
    for (var i = box2d.b2EPCollider.s_perp.SetXY(-this.m_normal.y, this.m_normal.x), o = 0, s = this.m_polygonB.count; o < s; ++o) {
        var n = box2d.b2NegV(this.m_polygonB.normals[o], box2d.b2EPCollider.s_n),
            r = box2d.b2DotVV(n, box2d.b2SubVV(this.m_polygonB.vertices[o], this.m_v1, box2d.b2Vec2.s_t0)),
            a = box2d.b2DotVV(n, box2d.b2SubVV(this.m_polygonB.vertices[o], this.m_v2, box2d.b2Vec2.s_t0)),
            h = box2d.b2Min(r, a);
        if (h > this.m_radius) return e.type = box2d.b2EPAxisType.e_edgeB, e.index = o, e.separation = h, e;
        if (box2d.b2DotVV(n, i) >= 0) {
            if (box2d.b2DotVV(box2d.b2SubVV(n, this.m_upperLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop) continue
        } else if (box2d.b2DotVV(box2d.b2SubVV(n, this.m_lowerLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop) continue;
        h > e.separation && (e.type = box2d.b2EPAxisType.e_edgeB, e.index = o, e.separation = h)
    }
    return e
}, box2d.b2EPCollider.s_n = new box2d.b2Vec2, box2d.b2EPCollider.s_perp = new box2d.b2Vec2, box2d.b2CollideEdgeAndPolygon = function(t, e, i, o, s) {
    box2d.b2CollideEdgeAndPolygon.s_collider.Collide(t, e, i, o, s)
}, box2d.b2CollideEdgeAndPolygon.s_collider = new box2d.b2EPCollider, goog.provide("box2d.b2EdgeShape"), goog.require("box2d.b2Shape"), box2d.b2EdgeShape = function() {
    goog.base(this, box2d.b2ShapeType.e_edgeShape, box2d.b2_polygonRadius), this.m_vertex1 = new box2d.b2Vec2, this.m_vertex2 = new box2d.b2Vec2, this.m_vertex0 = new box2d.b2Vec2, this.m_vertex3 = new box2d.b2Vec2
}, goog.inherits(box2d.b2EdgeShape, box2d.b2Shape), box2d.b2EdgeShape.prototype.m_vertex1 = null, box2d.b2EdgeShape.prototype.m_vertex2 = null, box2d.b2EdgeShape.prototype.m_vertex0 = null, box2d.b2EdgeShape.prototype.m_vertex3 = null, box2d.b2EdgeShape.prototype.m_hasVertex0 = !1, box2d.b2EdgeShape.prototype.m_hasVertex3 = !1, box2d.b2EdgeShape.prototype.Set = function(t, e) {
    return this.m_vertex1.Copy(t), this.m_vertex2.Copy(e), this.m_hasVertex0 = !1, this.m_hasVertex3 = !1, this
}, box2d.b2EdgeShape.prototype.SetAsEdge = box2d.b2EdgeShape.prototype.Set, box2d.b2EdgeShape.prototype.Clone = function() {
    return (new box2d.b2EdgeShape).Copy(this)
}, box2d.b2EdgeShape.prototype.Copy = function(t) {
    return goog.base(this, "Copy", t), this.m_vertex1.Copy(t.m_vertex1), this.m_vertex2.Copy(t.m_vertex2), this.m_vertex0.Copy(t.m_vertex0), this.m_vertex3.Copy(t.m_vertex3), this.m_hasVertex0 = t.m_hasVertex0, this.m_hasVertex3 = t.m_hasVertex3, this
}, box2d.b2EdgeShape.prototype.GetChildCount = function() {
    return 1
}, box2d.b2EdgeShape.prototype.TestPoint = function(t, e) {
    return !1
}, box2d.b2EdgeShape.prototype.RayCast = function(t, e, i, o) {
    var s = box2d.b2MulTXV(i, e.p1, box2d.b2EdgeShape.prototype.RayCast.s_p1),
        n = box2d.b2MulTXV(i, e.p2, box2d.b2EdgeShape.prototype.RayCast.s_p2),
        r = box2d.b2SubVV(n, s, box2d.b2EdgeShape.prototype.RayCast.s_d),
        a = this.m_vertex1,
        h = this.m_vertex2,
        l = box2d.b2SubVV(h, a, box2d.b2EdgeShape.prototype.RayCast.s_e),
        d = t.normal.SetXY(l.y, -l.x).SelfNormalize(),
        c = box2d.b2DotVV(d, box2d.b2SubVV(a, s, box2d.b2Vec2.s_t0)),
        p = box2d.b2DotVV(d, r);
    if (0 === p) return !1;
    var u = c / p;
    if (u < 0 || e.maxFraction < u) return !1;
    var b = box2d.b2AddVMulSV(s, u, r, box2d.b2EdgeShape.prototype.RayCast.s_q),
        m = box2d.b2SubVV(h, a, box2d.b2EdgeShape.prototype.RayCast.s_r),
        y = box2d.b2DotVV(m, m);
    if (0 === y) return !1;
    var f = box2d.b2DotVV(box2d.b2SubVV(b, a, box2d.b2Vec2.s_t0), m) / y;
    return !(f < 0 || 1 < f) && (t.fraction = u, box2d.b2MulRV(i.q, t.normal, t.normal), c > 0 && t.normal.SelfNeg(), !0)
}, box2d.b2EdgeShape.prototype.RayCast.s_p1 = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_p2 = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_d = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_e = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_q = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_r = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.ComputeAABB = function(t, e, i) {
    var o = box2d.b2MulXV(e, this.m_vertex1, box2d.b2EdgeShape.prototype.ComputeAABB.s_v1),
        s = box2d.b2MulXV(e, this.m_vertex2, box2d.b2EdgeShape.prototype.ComputeAABB.s_v2);
    box2d.b2MinV(o, s, t.lowerBound), box2d.b2MaxV(o, s, t.upperBound);
    var n = this.m_radius;
    t.lowerBound.SelfSubXY(n, n), t.upperBound.SelfAddXY(n, n)
}, box2d.b2EdgeShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.ComputeMass = function(t, e) {
    t.mass = 0, box2d.b2MidVV(this.m_vertex1, this.m_vertex2, t.center), t.I = 0
}, box2d.b2EdgeShape.prototype.SetupDistanceProxy = function(t, e) {
    t.m_vertices = new Array(2), t.m_vertices[0] = this.m_vertex1, t.m_vertices[1] = this.m_vertex2, t.m_count = 2, t.m_radius = this.m_radius
}, box2d.b2EdgeShape.prototype.ComputeSubmergedArea = function(t, e, i, o) {
    return o.SetZero(), 0
}, box2d.b2EdgeShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2EdgeShape*/ var shape = new box2d.b2EdgeShape();\n"), box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius), box2d.b2Log("    shape.m_vertex0.SetXY(%.15f, %.15f);\n", this.m_vertex0.x, this.m_vertex0.y), box2d.b2Log("    shape.m_vertex1.SetXY(%.15f, %.15f);\n", this.m_vertex1.x, this.m_vertex1.y), box2d.b2Log("    shape.m_vertex2.SetXY(%.15f, %.15f);\n", this.m_vertex2.x, this.m_vertex2.y), box2d.b2Log("    shape.m_vertex3.SetXY(%.15f, %.15f);\n", this.m_vertex3.x, this.m_vertex3.y), box2d.b2Log("    shape.m_hasVertex0 = %s;\n", this.m_hasVertex0), box2d.b2Log("    shape.m_hasVertex3 = %s;\n", this.m_hasVertex3)
}, goog.provide("box2d.b2ChainShape"), goog.require("box2d.b2Shape"), goog.require("box2d.b2EdgeShape"), box2d.b2ChainShape = function() {
    goog.base(this, box2d.b2ShapeType.e_chainShape, box2d.b2_polygonRadius), this.m_prevVertex = new box2d.b2Vec2, this.m_nextVertex = new box2d.b2Vec2
}, goog.inherits(box2d.b2ChainShape, box2d.b2Shape), box2d.b2ChainShape.prototype.m_vertices = null, box2d.b2ChainShape.prototype.m_count = 0, box2d.b2ChainShape.prototype.m_prevVertex = null, box2d.b2ChainShape.prototype.m_nextVertex = null, box2d.b2ChainShape.prototype.m_hasPrevVertex = !1, box2d.b2ChainShape.prototype.m_hasNextVertex = !1, box2d.b2ChainShape.prototype.CreateLoop = function(t, e) {
    e = e || t.length, this.m_count = e + 1, this.m_vertices = box2d.b2Vec2.MakeArray(this.m_count);
    for (var i = 0; i < e; ++i) this.m_vertices[i].Copy(t[i]);
    return this.m_vertices[e].Copy(this.m_vertices[0]), this.m_prevVertex.Copy(this.m_vertices[this.m_count - 2]), this.m_nextVertex.Copy(this.m_vertices[1]), this.m_hasPrevVertex = !0, this.m_hasNextVertex = !0, this
}, box2d.b2ChainShape.prototype.CreateChain = function(t, e) {
    e = e || t.length, this.m_count = e, this.m_vertices = box2d.b2Vec2.MakeArray(e);
    for (var i = 0; i < e; ++i) this.m_vertices[i].Copy(t[i]);
    return this.m_hasPrevVertex = !1, this.m_hasNextVertex = !1, this.m_prevVertex.SetZero(), this.m_nextVertex.SetZero(), this
}, box2d.b2ChainShape.prototype.SetPrevVertex = function(t) {
    return this.m_prevVertex.Copy(t), this.m_hasPrevVertex = !0, this
}, box2d.b2ChainShape.prototype.SetNextVertex = function(t) {
    return this.m_nextVertex.Copy(t), this.m_hasNextVertex = !0, this
}, box2d.b2ChainShape.prototype.Clone = function() {
    return (new box2d.b2ChainShape).Copy(this)
}, box2d.b2ChainShape.prototype.Copy = function(t) {
    return goog.base(this, "Copy", t), this.CreateChain(t.m_vertices, t.m_count), this.m_prevVertex.Copy(t.m_prevVertex), this.m_nextVertex.Copy(t.m_nextVertex), this.m_hasPrevVertex = t.m_hasPrevVertex, this.m_hasNextVertex = t.m_hasNextVertex, this
}, box2d.b2ChainShape.prototype.GetChildCount = function() {
    return this.m_count - 1
}, box2d.b2ChainShape.prototype.GetChildEdge = function(t, e) {
    t.m_type = box2d.b2ShapeType.e_edgeShape, t.m_radius = this.m_radius, t.m_vertex1.Copy(this.m_vertices[e]), t.m_vertex2.Copy(this.m_vertices[e + 1]), e > 0 ? (t.m_vertex0.Copy(this.m_vertices[e - 1]), t.m_hasVertex0 = !0) : (t.m_vertex0.Copy(this.m_prevVertex), t.m_hasVertex0 = this.m_hasPrevVertex), e < this.m_count - 2 ? (t.m_vertex3.Copy(this.m_vertices[e + 2]), t.m_hasVertex3 = !0) : (t.m_vertex3.Copy(this.m_nextVertex), t.m_hasVertex3 = this.m_hasNextVertex)
}, box2d.b2ChainShape.prototype.TestPoint = function(t, e) {
    return !1
}, box2d.b2ChainShape.prototype.RayCast = function(t, e, i, o) {
    var s = box2d.b2ChainShape.s_edgeShape;
    return s.m_vertex1.Copy(this.m_vertices[o]), s.m_vertex2.Copy(this.m_vertices[(o + 1) % this.m_count]), s.RayCast(t, e, i, 0)
}, box2d.b2ChainShape.s_edgeShape = new box2d.b2EdgeShape, box2d.b2ChainShape.prototype.ComputeAABB = function(t, e, i) {
    var o = this.m_vertices[i],
        s = this.m_vertices[(i + 1) % this.m_count],
        n = box2d.b2MulXV(e, o, box2d.b2ChainShape.prototype.ComputeAABB.s_v1),
        r = box2d.b2MulXV(e, s, box2d.b2ChainShape.prototype.ComputeAABB.s_v2);
    box2d.b2MinV(n, r, t.lowerBound), box2d.b2MaxV(n, r, t.upperBound)
}, box2d.b2ChainShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2, box2d.b2ChainShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2, box2d.b2ChainShape.prototype.ComputeMass = function(t, e) {
    t.mass = 0, t.center.SetZero(), t.I = 0
}, box2d.b2ChainShape.prototype.SetupDistanceProxy = function(t, e) {
    t.m_buffer[0].Copy(this.m_vertices[e]), e + 1 < this.m_count ? t.m_buffer[1].Copy(this.m_vertices[e + 1]) : t.m_buffer[1].Copy(this.m_vertices[0]), t.m_vertices = t.m_buffer, t.m_count = 2, t.m_radius = this.m_radius
}, box2d.b2ChainShape.prototype.ComputeSubmergedArea = function(t, e, i, o) {
    return o.SetZero(), 0
}, box2d.b2ChainShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2ChainShape*/ var shape = new box2d.b2ChainShape();\n"), box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices);
    for (var t = 0; t < this.m_count; ++t) box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", t, this.m_vertices[t].x, this.m_vertices[t].y);
    box2d.b2Log("    shape.CreateChain(vs, %d);\n", this.m_count), box2d.b2Log("    shape.m_prevVertex.SetXY(%.15f, %.15f);\n", this.m_prevVertex.x, this.m_prevVertex.y), box2d.b2Log("    shape.m_nextVertex.SetXY(%.15f, %.15f);\n", this.m_nextVertex.x, this.m_nextVertex.y), box2d.b2Log("    shape.m_hasPrevVertex = %s;\n", this.m_hasPrevVertex ? "true" : "false"), box2d.b2Log("    shape.m_hasNextVertex = %s;\n", this.m_hasNextVertex ? "true" : "false")
}, goog.provide("box2d.b2ChainAndPolygonContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollideEdge"), goog.require("box2d.b2ChainShape"), goog.require("box2d.b2PolygonShape"), box2d.b2ChainAndPolygonContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2ChainAndPolygonContact, box2d.b2Contact), box2d.b2ChainAndPolygonContact.Create = function(t) {
    return new box2d.b2ChainAndPolygonContact
}, box2d.b2ChainAndPolygonContact.Destroy = function(t, e) {}, box2d.b2ChainAndPolygonContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o)
}, box2d.b2ChainAndPolygonContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape(),
        n = o instanceof box2d.b2ChainShape ? o : null,
        r = box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge;
    n.GetChildEdge(r, this.m_indexA), box2d.b2CollideEdgeAndPolygon(t, r, e, s instanceof box2d.b2PolygonShape ? s : null, i)
}, box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape, goog.provide("box2d.b2CollidePolygon"), goog.require("box2d.b2Collision");
box2d.b2FindMaxSeparation = function(t, e, i, o, s) {
    for (var n = e.m_count, r = o.m_count, a = e.m_normals, h = e.m_vertices, l = o.m_vertices, d = box2d.b2MulTXX(s, i, box2d.b2FindMaxSeparation.s_xf), c = 0, p = -box2d.b2_maxFloat, u = 0; u < n; ++u) {
        for (var b = box2d.b2MulRV(d.q, a[u], box2d.b2FindMaxSeparation.s_n), m = box2d.b2MulXV(d, h[u], box2d.b2FindMaxSeparation.s_v1), y = box2d.b2_maxFloat, f = 0; f < r; ++f) {
            var g = box2d.b2DotVV(b, box2d.b2SubVV(l[f], m, box2d.b2Vec2.s_t0));
            g < y && (y = g)
        }
        y > p && (p = y, c = u)
    }
    return t[0] = c, p
}, box2d.b2FindMaxSeparation.s_xf = new box2d.b2Transform, box2d.b2FindMaxSeparation.s_n = new box2d.b2Vec2, box2d.b2FindMaxSeparation.s_v1 = new box2d.b2Vec2, box2d.b2FindIncidentEdge = function(t, e, i, o, s, n) {
    for (var r = (e.m_count, e.m_normals), a = s.m_count, h = s.m_vertices, l = s.m_normals, d = box2d.b2MulTRV(n.q, box2d.b2MulRV(i.q, r[o], box2d.b2Vec2.s_t0), box2d.b2FindIncidentEdge.s_normal1), c = 0, p = box2d.b2_maxFloat, u = 0; u < a; ++u) {
        var b = box2d.b2DotVV(d, l[u]);
        b < p && (p = b, c = u)
    }
    var m = c,
        y = (m + 1) % a,
        f = t[0];
    box2d.b2MulXV(n, h[m], f.v);
    var g = f.id.cf;
    g.indexA = o, g.indexB = m, g.typeA = box2d.b2ContactFeatureType.e_face, g.typeB = box2d.b2ContactFeatureType.e_vertex;
    var x = t[1];
    box2d.b2MulXV(n, h[y], x.v);
    var _ = x.id.cf;
    _.indexA = o, _.indexB = y, _.typeA = box2d.b2ContactFeatureType.e_face, _.typeB = box2d.b2ContactFeatureType.e_vertex
}, box2d.b2FindIncidentEdge.s_normal1 = new box2d.b2Vec2, box2d.b2CollidePolygons = function(t, e, i, o, s) {
    t.pointCount = 0;
    var n = e.m_radius + o.m_radius,
        r = box2d.b2CollidePolygons.s_edgeA;
    r[0] = 0;
    var a = box2d.b2FindMaxSeparation(r, e, i, o, s);
    if (!(a > n)) {
        var h = box2d.b2CollidePolygons.s_edgeB;
        h[0] = 0;
        var l = box2d.b2FindMaxSeparation(h, o, s, e, i);
        if (!(l > n)) {
            var d, c, p, u, b = 0,
                m = 0;
            l > .98 * a + .001 ? (d = o, c = e, p = s, u = i, b = h[0], t.type = box2d.b2ManifoldType.e_faceB, m = 1) : (d = e, c = o, p = i, u = s, b = r[0], t.type = box2d.b2ManifoldType.e_faceA, m = 0);
            var y = box2d.b2CollidePolygons.s_incidentEdge;
            box2d.b2FindIncidentEdge(y, d, p, b, c, u);
            var f = d.m_count,
                g = d.m_vertices,
                x = b,
                _ = (b + 1) % f,
                v = g[x],
                w = g[_],
                C = box2d.b2SubVV(w, v, box2d.b2CollidePolygons.s_localTangent);
            C.Normalize();
            var S = box2d.b2CrossVOne(C, box2d.b2CollidePolygons.s_localNormal),
                A = box2d.b2MidVV(v, w, box2d.b2CollidePolygons.s_planePoint),
                T = box2d.b2MulRV(p.q, C, box2d.b2CollidePolygons.s_tangent),
                P = box2d.b2CrossVOne(T, box2d.b2CollidePolygons.s_normal),
                B = box2d.b2MulXV(p, v, box2d.b2CollidePolygons.s_v11),
                M = box2d.b2MulXV(p, w, box2d.b2CollidePolygons.s_v12),
                I = box2d.b2DotVV(P, B),
                R = -box2d.b2DotVV(T, B) + n,
                D = box2d.b2DotVV(T, M) + n,
                k = box2d.b2CollidePolygons.s_clipPoints1,
                V = box2d.b2CollidePolygons.s_clipPoints2,
                E = box2d.b2NegV(T, box2d.b2CollidePolygons.s_ntangent);
            if (!(box2d.b2ClipSegmentToLine(k, y, E, R, x) < 2 || box2d.b2ClipSegmentToLine(V, k, T, D, _) < 2)) {
                t.localNormal.Copy(S), t.localPoint.Copy(A);
                for (var L = 0, F = 0; F < box2d.b2_maxManifoldPoints; ++F) {
                    var O = V[F];
                    if (box2d.b2DotVV(P, O.v) - I <= n) {
                        var G = t.points[L];
                        if (box2d.b2MulTXV(u, O.v, G.localPoint), G.id.Copy(O.id), m) {
                            var U = G.id.cf;
                            G.id.cf.indexA = U.indexB, G.id.cf.indexB = U.indexA, G.id.cf.typeA = U.typeB, G.id.cf.typeB = U.typeA
                        }++L
                    }
                }
                t.pointCount = L
            }
        }
    }
}, box2d.b2CollidePolygons.s_incidentEdge = box2d.b2ClipVertex.MakeArray(2), box2d.b2CollidePolygons.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2), box2d.b2CollidePolygons.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2), box2d.b2CollidePolygons.s_edgeA = box2d.b2MakeNumberArray(1), box2d.b2CollidePolygons.s_edgeB = box2d.b2MakeNumberArray(1), box2d.b2CollidePolygons.s_localTangent = new box2d.b2Vec2, box2d.b2CollidePolygons.s_localNormal = new box2d.b2Vec2, box2d.b2CollidePolygons.s_planePoint = new box2d.b2Vec2, box2d.b2CollidePolygons.s_normal = new box2d.b2Vec2, box2d.b2CollidePolygons.s_tangent = new box2d.b2Vec2, box2d.b2CollidePolygons.s_ntangent = new box2d.b2Vec2, box2d.b2CollidePolygons.s_v11 = new box2d.b2Vec2, box2d.b2CollidePolygons.s_v12 = new box2d.b2Vec2, goog.provide("box2d.b2PolygonContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollidePolygon"), box2d.b2PolygonContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2PolygonContact, box2d.b2Contact), box2d.b2PolygonContact.Create = function(t) {
    return new box2d.b2PolygonContact
}, box2d.b2PolygonContact.Destroy = function(t, e) {}, box2d.b2PolygonContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o)
}, box2d.b2PolygonContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    box2d.b2CollidePolygons(t, o instanceof box2d.b2PolygonShape ? o : null, e, s instanceof box2d.b2PolygonShape ? s : null, i)
}, goog.provide("box2d.b2CollideCircle"), goog.require("box2d.b2Collision"), box2d.b2CollideCircles = function(t, e, i, o, s) {
    t.pointCount = 0;
    var n = box2d.b2MulXV(i, e.m_p, box2d.b2CollideCircles.s_pA),
        r = box2d.b2MulXV(s, o.m_p, box2d.b2CollideCircles.s_pB),
        a = box2d.b2DistanceSquaredVV(n, r),
        h = e.m_radius + o.m_radius;
    a > h * h || (t.type = box2d.b2ManifoldType.e_circles, t.localPoint.Copy(e.m_p), t.localNormal.SetZero(), t.pointCount = 1, t.points[0].localPoint.Copy(o.m_p), t.points[0].id.key = 0)
}, box2d.b2CollideCircles.s_pA = new box2d.b2Vec2, box2d.b2CollideCircles.s_pB = new box2d.b2Vec2, box2d.b2CollidePolygonAndCircle = function(t, e, i, o, s) {
    t.pointCount = 0;
    for (var n = box2d.b2MulXV(s, o.m_p, box2d.b2CollidePolygonAndCircle.s_c), r = box2d.b2MulTXV(i, n, box2d.b2CollidePolygonAndCircle.s_cLocal), a = 0, h = -box2d.b2_maxFloat, l = e.m_radius + o.m_radius, d = e.m_count, c = e.m_vertices, p = e.m_normals, u = 0; u < d; ++u) {
        var b = box2d.b2DotVV(p[u], box2d.b2SubVV(r, c[u], box2d.b2Vec2.s_t0));
        if (b > l) return;
        b > h && (h = b, a = u)
    }
    var m = a,
        y = (m + 1) % d,
        f = c[m],
        g = c[y];
    if (h < box2d.b2_epsilon) return t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, t.localNormal.Copy(p[a]), box2d.b2MidVV(f, g, t.localPoint), t.points[0].localPoint.Copy(o.m_p), void(t.points[0].id.key = 0);
    var x = box2d.b2DotVV(box2d.b2SubVV(r, f, box2d.b2Vec2.s_t0), box2d.b2SubVV(g, f, box2d.b2Vec2.s_t1)),
        _ = box2d.b2DotVV(box2d.b2SubVV(r, g, box2d.b2Vec2.s_t0), box2d.b2SubVV(f, g, box2d.b2Vec2.s_t1));
    if (x <= 0) {
        if (box2d.b2DistanceSquaredVV(r, f) > l * l) return;
        t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, box2d.b2SubVV(r, f, t.localNormal).SelfNormalize(), t.localPoint.Copy(f), t.points[0].localPoint.Copy(o.m_p), t.points[0].id.key = 0
    } else if (_ <= 0) {
        if (box2d.b2DistanceSquaredVV(r, g) > l * l) return;
        t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, box2d.b2SubVV(r, g, t.localNormal).SelfNormalize(), t.localPoint.Copy(g), t.points[0].localPoint.Copy(o.m_p), t.points[0].id.key = 0
    } else {
        var v = box2d.b2MidVV(f, g, box2d.b2CollidePolygonAndCircle.s_faceCenter);
        if ((h = box2d.b2DotVV(box2d.b2SubVV(r, v, box2d.b2Vec2.s_t1), p[m])) > l) return;
        t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, t.localNormal.Copy(p[m]).SelfNormalize(), t.localPoint.Copy(v), t.points[0].localPoint.Copy(o.m_p), t.points[0].id.key = 0
    }
}, box2d.b2CollidePolygonAndCircle.s_c = new box2d.b2Vec2, box2d.b2CollidePolygonAndCircle.s_cLocal = new box2d.b2Vec2, box2d.b2CollidePolygonAndCircle.s_faceCenter = new box2d.b2Vec2, goog.provide("box2d.b2CircleContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollideCircle"), box2d.b2CircleContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2CircleContact, box2d.b2Contact), box2d.b2CircleContact.Create = function(t) {
    return new box2d.b2CircleContact
}, box2d.b2CircleContact.Destroy = function(t, e) {}, box2d.b2CircleContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o)
}, box2d.b2CircleContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    box2d.b2CollideCircles(t, o instanceof box2d.b2CircleShape ? o : null, e, s instanceof box2d.b2CircleShape ? s : null, i)
}, goog.provide("box2d.b2ChainAndCircleContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollideEdge"), box2d.b2ChainAndCircleContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2ChainAndCircleContact, box2d.b2Contact), box2d.b2ChainAndCircleContact.Create = function(t) {
    return new box2d.b2ChainAndCircleContact
}, box2d.b2ChainAndCircleContact.Destroy = function(t, e) {}, box2d.b2ChainAndCircleContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o)
}, box2d.b2ChainAndCircleContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape(),
        n = o instanceof box2d.b2ChainShape ? o : null,
        r = box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge;
    n.GetChildEdge(r, this.m_indexA), box2d.b2CollideEdgeAndCircle(t, r, e, s instanceof box2d.b2CircleShape ? s : null, i)
}, box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape, goog.provide("box2d.b2EdgeAndCircleContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollideEdge"), box2d.b2EdgeAndCircleContact = function() {
    goog.base(this)
}, goog.inherits(box2d.b2EdgeAndCircleContact, box2d.b2Contact), box2d.b2EdgeAndCircleContact.Create = function(t) {
    return new box2d.b2EdgeAndCircleContact
}, box2d.b2EdgeAndCircleContact.Destroy = function(t, e) {}, box2d.b2EdgeAndCircleContact.prototype.Reset = function(t, e, i, o) {
    goog.base(this, "Reset", t, e, i, o)
}, box2d.b2EdgeAndCircleContact.prototype.Evaluate = function(t, e, i) {
    var o = this.m_fixtureA.GetShape(),
        s = this.m_fixtureB.GetShape();
    box2d.b2CollideEdgeAndCircle(t, o instanceof box2d.b2EdgeShape ? o : null, e, s instanceof box2d.b2CircleShape ? s : null, i)
}, goog.provide("box2d.b2ContactSolver"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Collision"), goog.require("box2d.b2CircleContact"), goog.require("box2d.b2PolygonAndCircleContact"), goog.require("box2d.b2PolygonContact"), goog.require("box2d.b2EdgeAndCircleContact"), goog.require("box2d.b2EdgeAndPolygonContact"), goog.require("box2d.b2ChainAndCircleContact"), goog.require("box2d.b2ChainAndPolygonContact"), box2d.b2VelocityConstraintPoint = function() {
    this.rA = new box2d.b2Vec2, this.rB = new box2d.b2Vec2
}, box2d.b2VelocityConstraintPoint.prototype.rA = null, box2d.b2VelocityConstraintPoint.prototype.rB = null, box2d.b2VelocityConstraintPoint.prototype.normalImpulse = 0, box2d.b2VelocityConstraintPoint.prototype.tangentImpulse = 0, box2d.b2VelocityConstraintPoint.prototype.normalMass = 0, box2d.b2VelocityConstraintPoint.prototype.tangentMass = 0, box2d.b2VelocityConstraintPoint.prototype.velocityBias = 0, box2d.b2VelocityConstraintPoint.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function(t) {
        return new box2d.b2VelocityConstraintPoint
    })
}, box2d.b2ContactVelocityConstraint = function() {
    this.points = box2d.b2VelocityConstraintPoint.MakeArray(box2d.b2_maxManifoldPoints), this.normal = new box2d.b2Vec2, this.tangent = new box2d.b2Vec2, this.normalMass = new box2d.b2Mat22, this.K = new box2d.b2Mat22
}, box2d.b2ContactVelocityConstraint.prototype.points = null, box2d.b2ContactVelocityConstraint.prototype.normal = null, box2d.b2ContactVelocityConstraint.prototype.tangent = null, box2d.b2ContactVelocityConstraint.prototype.normalMass = null, box2d.b2ContactVelocityConstraint.prototype.K = null, box2d.b2ContactVelocityConstraint.prototype.indexA = 0, box2d.b2ContactVelocityConstraint.prototype.indexB = 0, box2d.b2ContactVelocityConstraint.prototype.invMassA = 0, box2d.b2ContactVelocityConstraint.prototype.invMassB = 0, box2d.b2ContactVelocityConstraint.prototype.invIA = 0, box2d.b2ContactVelocityConstraint.prototype.invIB = 0, box2d.b2ContactVelocityConstraint.prototype.friction = 0, box2d.b2ContactVelocityConstraint.prototype.restitution = 0, box2d.b2ContactVelocityConstraint.prototype.tangentSpeed = 0, box2d.b2ContactVelocityConstraint.prototype.pointCount = 0, box2d.b2ContactVelocityConstraint.prototype.contactIndex = 0, box2d.b2ContactVelocityConstraint.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function(t) {
        return new box2d.b2ContactVelocityConstraint
    })
}, box2d.b2ContactPositionConstraint = function() {
    this.localPoints = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints), this.localNormal = new box2d.b2Vec2, this.localPoint = new box2d.b2Vec2, this.localCenterA = new box2d.b2Vec2, this.localCenterB = new box2d.b2Vec2
}, box2d.b2ContactPositionConstraint.prototype.localPoints = null, box2d.b2ContactPositionConstraint.prototype.localNormal = null, box2d.b2ContactPositionConstraint.prototype.localPoint = null, box2d.b2ContactPositionConstraint.prototype.indexA = 0, box2d.b2ContactPositionConstraint.prototype.indexB = 0, box2d.b2ContactPositionConstraint.prototype.invMassA = 0, box2d.b2ContactPositionConstraint.prototype.invMassB = 0, box2d.b2ContactPositionConstraint.prototype.localCenterA = null, box2d.b2ContactPositionConstraint.prototype.localCenterB = null, box2d.b2ContactPositionConstraint.prototype.invIA = 0, box2d.b2ContactPositionConstraint.prototype.invIB = 0, box2d.b2ContactPositionConstraint.prototype.type = box2d.b2ManifoldType.e_unknown, box2d.b2ContactPositionConstraint.prototype.radiusA = 0, box2d.b2ContactPositionConstraint.prototype.radiusB = 0, box2d.b2ContactPositionConstraint.prototype.pointCount = 0, box2d.b2ContactPositionConstraint.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function(t) {
        return new box2d.b2ContactPositionConstraint
    })
}, box2d.b2ContactSolverDef = function() {
    this.step = new box2d.b2TimeStep
}, box2d.b2ContactSolverDef.prototype.step = null, box2d.b2ContactSolverDef.prototype.contacts = null, box2d.b2ContactSolverDef.prototype.count = 0, box2d.b2ContactSolverDef.prototype.positions = null, box2d.b2ContactSolverDef.prototype.velocities = null, box2d.b2ContactSolverDef.prototype.allocator = null, box2d.b2ContactSolver = function() {
    this.m_step = new box2d.b2TimeStep, this.m_positionConstraints = box2d.b2ContactPositionConstraint.MakeArray(1024), this.m_velocityConstraints = box2d.b2ContactVelocityConstraint.MakeArray(1024)
}, box2d.b2ContactSolver.prototype.m_step = null, box2d.b2ContactSolver.prototype.m_positions = null, box2d.b2ContactSolver.prototype.m_velocities = null, box2d.b2ContactSolver.prototype.m_allocator = null, box2d.b2ContactSolver.prototype.m_positionConstraints = null, box2d.b2ContactSolver.prototype.m_velocityConstraints = null, box2d.b2ContactSolver.prototype.m_contacts = null, box2d.b2ContactSolver.prototype.m_count = 0, box2d.b2ContactSolver.prototype.Initialize = function(t) {
    if (this.m_step.Copy(t.step), this.m_allocator = t.allocator, this.m_count = t.count, this.m_positionConstraints.length < this.m_count)
        for (var e = box2d.b2Max(2 * this.m_positionConstraints.length, this.m_count); this.m_positionConstraints.length < e;) this.m_positionConstraints[this.m_positionConstraints.length] = new box2d.b2ContactPositionConstraint;
    if (this.m_velocityConstraints.length < this.m_count)
        for (var e = box2d.b2Max(2 * this.m_velocityConstraints.length, this.m_count); this.m_velocityConstraints.length < e;) this.m_velocityConstraints[this.m_velocityConstraints.length] = new box2d.b2ContactVelocityConstraint;
    this.m_positions = t.positions, this.m_velocities = t.velocities, this.m_contacts = t.contacts;
    var i, o, s, n, r, a, h, l, d, c, p, u, b, m, y, f, g, x, _;
    for (i = 0, o = this.m_count; i < o; ++i)
        for (r = this.m_contacts[i], a = r.m_fixtureA, h = r.m_fixtureB, l = a.GetShape(), d = h.GetShape(), c = l.m_radius, p = d.m_radius, u = a.GetBody(), b = h.GetBody(), m = r.GetManifold(), y = m.pointCount, f = this.m_velocityConstraints[i], f.friction = r.m_friction, f.restitution = r.m_restitution, f.tangentSpeed = r.m_tangentSpeed, f.indexA = u.m_islandIndex, f.indexB = b.m_islandIndex, f.invMassA = u.m_invMass, f.invMassB = b.m_invMass, f.invIA = u.m_invI, f.invIB = b.m_invI, f.contactIndex = i, f.pointCount = y, f.K.SetZero(), f.normalMass.SetZero(), g = this.m_positionConstraints[i], g.indexA = u.m_islandIndex, g.indexB = b.m_islandIndex, g.invMassA = u.m_invMass, g.invMassB = b.m_invMass, g.localCenterA.Copy(u.m_sweep.localCenter), g.localCenterB.Copy(b.m_sweep.localCenter), g.invIA = u.m_invI, g.invIB = b.m_invI, g.localNormal.Copy(m.localNormal), g.localPoint.Copy(m.localPoint), g.pointCount = y, g.radiusA = c, g.radiusB = p, g.type = m.type, s = 0, n = y; s < n; ++s) x = m.points[s], _ = f.points[s], this.m_step.warmStarting ? (_.normalImpulse = this.m_step.dtRatio * x.normalImpulse, _.tangentImpulse = this.m_step.dtRatio * x.tangentImpulse) : (_.normalImpulse = 0, _.tangentImpulse = 0), _.rA.SetZero(), _.rB.SetZero(), _.normalMass = 0, _.tangentMass = 0, _.velocityBias = 0, g.localPoints[s].Copy(x.localPoint);
    return this
}, box2d.b2ContactSolver.prototype.InitializeVelocityConstraints = function() {
    var t, e, i, o, s, n, r, a, h, l, d, c, p, u, b, m, y, f, g, x, _, v, w, C, S, A, T, P, B, M, I, R, D, k, V, E, L, F, O, G, U, N, W, J, X = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA,
        j = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB,
        H = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold;
    for (t = 0, e = this.m_count; t < e; ++t) {
        for (s = this.m_velocityConstraints[t], n = this.m_positionConstraints[t], r = n.radiusA, a = n.radiusB, h = this.m_contacts[s.contactIndex].GetManifold(), l = s.indexA, d = s.indexB, c = s.invMassA, p = s.invMassB, u = s.invIA, b = s.invIB, m = n.localCenterA, y = n.localCenterB, f = this.m_positions[l].c, g = this.m_positions[l].a, x = this.m_velocities[l].v, _ = this.m_velocities[l].w,
            v = this.m_positions[d].c, w = this.m_positions[d].a, C = this.m_velocities[d].v, S = this.m_velocities[d].w, X.q.SetAngleRadians(g), j.q.SetAngleRadians(w), box2d.b2SubVV(f, box2d.b2MulRV(X.q, m, box2d.b2Vec2.s_t0), X.p), box2d.b2SubVV(v, box2d.b2MulRV(j.q, y, box2d.b2Vec2.s_t0), j.p), H.Initialize(h, X, r, j, a), s.normal.Copy(H.normal), box2d.b2CrossVOne(s.normal, s.tangent), A = s.pointCount, i = 0, o = A; i < o; ++i) T = s.points[i], box2d.b2SubVV(H.points[i], f, T.rA), box2d.b2SubVV(H.points[i], v, T.rB), P = box2d.b2CrossVV(T.rA, s.normal), B = box2d.b2CrossVV(T.rB, s.normal), M = c + p + u * P * P + b * B * B, T.normalMass = M > 0 ? 1 / M : 0, I = s.tangent, R = box2d.b2CrossVV(T.rA, I), D = box2d.b2CrossVV(T.rB, I), k = c + p + u * R * R + b * D * D, T.tangentMass = k > 0 ? 1 / k : 0, T.velocityBias = 0, (V = box2d.b2DotVV(s.normal, box2d.b2SubVV(box2d.b2AddVCrossSV(C, S, T.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(x, _, T.rA, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0))) < -box2d.b2_velocityThreshold && (T.velocityBias += -s.restitution * V);
        2 === s.pointCount && (E = s.points[0], L = s.points[1], F = box2d.b2CrossVV(E.rA, s.normal), O = box2d.b2CrossVV(E.rB, s.normal), G = box2d.b2CrossVV(L.rA, s.normal), U = box2d.b2CrossVV(L.rB, s.normal), N = c + p + u * F * F + b * O * O, W = c + p + u * G * G + b * U * U, J = c + p + u * F * G + b * O * U, N * N < 1e3 * (N * W - J * J) ? (s.K.ex.SetXY(N, J), s.K.ey.SetXY(J, W), s.K.GetInverse(s.normalMass)) : s.pointCount = 1)
    }
}, box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA = new box2d.b2Transform, box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB = new box2d.b2Transform, box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold = new box2d.b2WorldManifold, box2d.b2ContactSolver.prototype.WarmStart = function() {
    var t, e, i, o, s, n, r, a, h, l, d, c, p, u, b, m, y, f, g, x = box2d.b2ContactSolver.prototype.WarmStart.s_P;
    for (t = 0, e = this.m_count; t < e; ++t) {
        for (s = this.m_velocityConstraints[t], n = s.indexA, r = s.indexB, a = s.invMassA, h = s.invIA, l = s.invMassB, d = s.invIB, c = s.pointCount, p = this.m_velocities[n].v, u = this.m_velocities[n].w, b = this.m_velocities[r].v, m = this.m_velocities[r].w, y = s.normal, f = s.tangent, i = 0, o = c; i < o; ++i) g = s.points[i], box2d.b2AddVV(box2d.b2MulSV(g.normalImpulse, y, box2d.b2Vec2.s_t0), box2d.b2MulSV(g.tangentImpulse, f, box2d.b2Vec2.s_t1), x), u -= h * box2d.b2CrossVV(g.rA, x), p.SelfMulSub(a, x), m += d * box2d.b2CrossVV(g.rB, x), b.SelfMulAdd(l, x);
        this.m_velocities[n].w = u, this.m_velocities[r].w = m
    }
}, box2d.b2ContactSolver.prototype.WarmStart.s_P = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints = function() {
    var t, e, i, o, s, n, r, a, h, l, d, c, p, u, b, m, y, f, g, x, _, v, w, C, S, A, T, P, B, M = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv,
        I = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1,
        R = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2,
        D = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P,
        k = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a,
        V = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b,
        E = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x,
        L = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d,
        F = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1,
        O = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2,
        G = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2;
    for (t = 0, e = this.m_count; t < e; ++t) {
        for (s = this.m_velocityConstraints[t], n = s.indexA, r = s.indexB, a = s.invMassA, h = s.invIA, l = s.invMassB, d = s.invIB, c = s.pointCount, p = this.m_velocities[n].v, u = this.m_velocities[n].w, b = this.m_velocities[r].v, m = this.m_velocities[r].w, y = s.normal, f = s.tangent, g = s.friction, i = 0, o = c; i < o; ++i) x = s.points[i], box2d.b2SubVV(box2d.b2AddVCrossSV(b, m, x.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, u, x.rA, box2d.b2Vec2.s_t1), M), _ = box2d.b2DotVV(M, f) - s.tangentSpeed, w = x.tangentMass * -_, C = g * x.normalImpulse, S = box2d.b2Clamp(x.tangentImpulse + w, -C, C), w = S - x.tangentImpulse, x.tangentImpulse = S, box2d.b2MulSV(w, f, D), p.SelfMulSub(a, D), u -= h * box2d.b2CrossVV(x.rA, D), b.SelfMulAdd(l, D), m += d * box2d.b2CrossVV(x.rB, D);
        if (1 === s.pointCount) x = s.points[0], box2d.b2SubVV(box2d.b2AddVCrossSV(b, m, x.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, u, x.rA, box2d.b2Vec2.s_t1), M), v = box2d.b2DotVV(M, y), w = -x.normalMass * (v - x.velocityBias), S = box2d.b2Max(x.normalImpulse + w, 0), w = S - x.normalImpulse, x.normalImpulse = S, box2d.b2MulSV(w, y, D), p.SelfMulSub(a, D), u -= h * box2d.b2CrossVV(x.rA, D), b.SelfMulAdd(l, D), m += d * box2d.b2CrossVV(x.rB, D);
        else
            for (A = s.points[0], T = s.points[1], k.SetXY(A.normalImpulse, T.normalImpulse), box2d.b2SubVV(box2d.b2AddVCrossSV(b, m, A.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, u, A.rA, box2d.b2Vec2.s_t1), I), box2d.b2SubVV(box2d.b2AddVCrossSV(b, m, T.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, u, T.rA, box2d.b2Vec2.s_t1), R), P = box2d.b2DotVV(I, y), B = box2d.b2DotVV(R, y), V.x = P - A.velocityBias, V.y = B - T.velocityBias, V.SelfSub(box2d.b2MulMV(s.K, k, box2d.b2Vec2.s_t0));;) {
                if (box2d.b2MulMV(s.normalMass, V, E).SelfNeg(), E.x >= 0 && E.y >= 0) {
                    box2d.b2SubVV(E, k, L), box2d.b2MulSV(L.x, y, F), box2d.b2MulSV(L.y, y, O), box2d.b2AddVV(F, O, G), p.SelfMulSub(a, G), u -= h * (box2d.b2CrossVV(A.rA, F) + box2d.b2CrossVV(T.rA, O)), b.SelfMulAdd(l, G), m += d * (box2d.b2CrossVV(A.rB, F) + box2d.b2CrossVV(T.rB, O)), A.normalImpulse = E.x, T.normalImpulse = E.y;
                    break
                }
                if (E.x = -A.normalMass * V.x, E.y = 0, P = 0, B = s.K.ex.y * E.x + V.y, E.x >= 0 && B >= 0) {
                    box2d.b2SubVV(E, k, L), box2d.b2MulSV(L.x, y, F), box2d.b2MulSV(L.y, y, O), box2d.b2AddVV(F, O, G), p.SelfMulSub(a, G), u -= h * (box2d.b2CrossVV(A.rA, F) + box2d.b2CrossVV(T.rA, O)), b.SelfMulAdd(l, G), m += d * (box2d.b2CrossVV(A.rB, F) + box2d.b2CrossVV(T.rB, O)), A.normalImpulse = E.x, T.normalImpulse = E.y;
                    break
                }
                if (E.x = 0, E.y = -T.normalMass * V.y, P = s.K.ey.x * E.y + V.x, B = 0, E.y >= 0 && P >= 0) {
                    box2d.b2SubVV(E, k, L), box2d.b2MulSV(L.x, y, F), box2d.b2MulSV(L.y, y, O), box2d.b2AddVV(F, O, G), p.SelfMulSub(a, G), u -= h * (box2d.b2CrossVV(A.rA, F) + box2d.b2CrossVV(T.rA, O)), b.SelfMulAdd(l, G), m += d * (box2d.b2CrossVV(A.rB, F) + box2d.b2CrossVV(T.rB, O)), A.normalImpulse = E.x, T.normalImpulse = E.y;
                    break
                }
                if (E.x = 0, E.y = 0, P = V.x, B = V.y, P >= 0 && B >= 0) {
                    box2d.b2SubVV(E, k, L), box2d.b2MulSV(L.x, y, F), box2d.b2MulSV(L.y, y, O), box2d.b2AddVV(F, O, G), p.SelfMulSub(a, G), u -= h * (box2d.b2CrossVV(A.rA, F) + box2d.b2CrossVV(T.rA, O)), b.SelfMulAdd(l, G), m += d * (box2d.b2CrossVV(A.rB, F) + box2d.b2CrossVV(T.rB, O)), A.normalImpulse = E.x, T.normalImpulse = E.y;
                    break
                }
                break
            }
        this.m_velocities[n].w = u, this.m_velocities[r].w = m
    }
}, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.StoreImpulses = function() {
    var t, e, i, o, s, n;
    for (t = 0, e = this.m_count; t < e; ++t)
        for (s = this.m_velocityConstraints[t], n = this.m_contacts[s.contactIndex].GetManifold(), i = 0, o = s.pointCount; i < o; ++i) n.points[i].normalImpulse = s.points[i].normalImpulse, n.points[i].tangentImpulse = s.points[i].tangentImpulse
}, box2d.b2PositionSolverManifold = function() {
    this.normal = new box2d.b2Vec2, this.point = new box2d.b2Vec2
}, box2d.b2PositionSolverManifold.prototype.normal = null, box2d.b2PositionSolverManifold.prototype.point = null, box2d.b2PositionSolverManifold.prototype.separation = 0, box2d.b2PositionSolverManifold.prototype.Initialize = function(t, e, i, o) {
    var s = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA,
        n = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB,
        r = box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint,
        a = box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint;
    switch (t.type) {
        case box2d.b2ManifoldType.e_circles:
            box2d.b2MulXV(e, t.localPoint, s), box2d.b2MulXV(i, t.localPoints[0], n), box2d.b2SubVV(n, s, this.normal).SelfNormalize(), box2d.b2MidVV(s, n, this.point), this.separation = box2d.b2DotVV(box2d.b2SubVV(n, s, box2d.b2Vec2.s_t0), this.normal) - t.radiusA - t.radiusB;
            break;
        case box2d.b2ManifoldType.e_faceA:
            box2d.b2MulRV(e.q, t.localNormal, this.normal), box2d.b2MulXV(e, t.localPoint, r), box2d.b2MulXV(i, t.localPoints[o], a), this.separation = box2d.b2DotVV(box2d.b2SubVV(a, r, box2d.b2Vec2.s_t0), this.normal) - t.radiusA - t.radiusB, this.point.Copy(a);
            break;
        case box2d.b2ManifoldType.e_faceB:
            box2d.b2MulRV(i.q, t.localNormal, this.normal), box2d.b2MulXV(i, t.localPoint, r), box2d.b2MulXV(e, t.localPoints[o], a), this.separation = box2d.b2DotVV(box2d.b2SubVV(a, r, box2d.b2Vec2.s_t0), this.normal) - t.radiusA - t.radiusB, this.point.Copy(a), this.normal.SelfNeg()
    }
}, box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2, box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2, box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2, box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolvePositionConstraints = function() {
    var t, e, i, o, s, n, r, a, h, l, d, c, p, u, b, m, y, f, g, x, _, v, w, C, S, A, T = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA,
        P = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB,
        B = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm,
        M = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA,
        I = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB,
        R = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P,
        D = 0;
    for (t = 0, e = this.m_count; t < e; ++t) {
        for (s = this.m_positionConstraints[t], n = s.indexA, r = s.indexB, a = s.localCenterA, h = s.invMassA, l = s.invIA, d = s.localCenterB, c = s.invMassB, p = s.invIB, u = s.pointCount, b = this.m_positions[n].c, m = this.m_positions[n].a, y = this.m_positions[r].c, f = this.m_positions[r].a, i = 0, o = u; i < o; ++i) T.q.SetAngleRadians(m), P.q.SetAngleRadians(f), box2d.b2SubVV(b, box2d.b2MulRV(T.q, a, box2d.b2Vec2.s_t0), T.p), box2d.b2SubVV(y, box2d.b2MulRV(P.q, d, box2d.b2Vec2.s_t0), P.p), B.Initialize(s, T, P, i), g = B.normal, x = B.point, _ = B.separation, box2d.b2SubVV(x, b, M), box2d.b2SubVV(x, y, I), D = box2d.b2Min(D, _), v = box2d.b2Clamp(box2d.b2_baumgarte * (_ + box2d.b2_linearSlop), -box2d.b2_maxLinearCorrection, 0), w = box2d.b2CrossVV(M, g), C = box2d.b2CrossVV(I, g), S = h + c + l * w * w + p * C * C, A = S > 0 ? -v / S : 0, box2d.b2MulSV(A, g, R), b.SelfMulSub(h, R), m -= l * box2d.b2CrossVV(M, R), y.SelfMulAdd(c, R), f += p * box2d.b2CrossVV(I, R);
        this.m_positions[n].a = m, this.m_positions[r].a = f
    }
    return D > -3 * box2d.b2_linearSlop
}, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA = new box2d.b2Transform, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB = new box2d.b2Transform, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm = new box2d.b2PositionSolverManifold, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints = function(t, e) {
    var i, o, s, n, r, a, h, l, d, c, p, u, b, m, y, f, g, x, _, v, w, C, S, A, T, P, B = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA,
        M = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB,
        I = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm,
        R = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA,
        D = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB,
        k = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P,
        V = 0;
    for (i = 0, o = this.m_count; i < o; ++i) {
        for (r = this.m_positionConstraints[i], a = r.indexA, h = r.indexB, l = r.localCenterA, d = r.localCenterB, c = r.pointCount, p = 0, u = 0, a !== t && a !== e || (p = r.invMassA, u = r.invIA), b = 0, m = 0, h !== t && h !== e || (b = r.invMassB, m = r.invIB), y = this.m_positions[a].c, f = this.m_positions[a].a, g = this.m_positions[h].c, x = this.m_positions[h].a, s = 0, n = c; s < n; ++s) B.q.SetAngleRadians(f), M.q.SetAngleRadians(x), box2d.b2SubVV(y, box2d.b2MulRV(B.q, l, box2d.b2Vec2.s_t0), B.p), box2d.b2SubVV(g, box2d.b2MulRV(M.q, d, box2d.b2Vec2.s_t0), M.p), I.Initialize(r, B, M, s), _ = I.normal, v = I.point, w = I.separation, box2d.b2SubVV(v, y, R), box2d.b2SubVV(v, g, D), V = box2d.b2Min(V, w), C = box2d.b2Clamp(box2d.b2_toiBaumgarte * (w + box2d.b2_linearSlop), -box2d.b2_maxLinearCorrection, 0), S = box2d.b2CrossVV(R, _), A = box2d.b2CrossVV(D, _), T = p + b + u * S * S + m * A * A, P = T > 0 ? -C / T : 0, box2d.b2MulSV(P, _, k), y.SelfMulSub(p, k), f -= u * box2d.b2CrossVV(R, k), g.SelfMulAdd(b, k), x += m * box2d.b2CrossVV(D, k);
        this.m_positions[a].a = f, this.m_positions[h].a = x
    }
    return V >= -1.5 * box2d.b2_linearSlop
}, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA = new box2d.b2Transform, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB = new box2d.b2Transform, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm = new box2d.b2PositionSolverManifold, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P = new box2d.b2Vec2, goog.provide("box2d.b2WorldCallbacks"), goog.require("box2d.b2Settings"), box2d.b2DestructionListener = function() {}, box2d.b2DestructionListener.prototype.SayGoodbyeJoint = function(t) {}, box2d.b2DestructionListener.prototype.SayGoodbyeFixture = function(t) {}, box2d.b2ContactFilter = function() {}, box2d.b2ContactFilter.prototype.ShouldCollide = function(t, e) {
    var i = t.GetFilterData(),
        o = e.GetFilterData();
    return i.groupIndex === o.groupIndex && 0 !== i.groupIndex ? i.groupIndex > 0 : 0 != (i.maskBits & o.categoryBits) && 0 != (i.categoryBits & o.maskBits)
}, box2d.b2ContactFilter.b2_defaultFilter = new box2d.b2ContactFilter, box2d.b2ContactImpulse = function() {
    this.normalImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints), this.tangentImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints)
}, box2d.b2ContactImpulse.prototype.normalImpulses = null, box2d.b2ContactImpulse.prototype.tangentImpulses = null, box2d.b2ContactImpulse.prototype.count = 0, box2d.b2ContactListener = function() {}, box2d.b2ContactListener.prototype.BeginContact = function(t) {}, box2d.b2ContactListener.prototype.EndContact = function(t) {}, box2d.b2ContactListener.prototype.PreSolve = function(t, e) {};
box2d.b2ContactListener.prototype.PostSolve = function(t, e) {}, box2d.b2ContactListener.b2_defaultListener = new box2d.b2ContactListener, box2d.b2QueryCallback = function() {}, box2d.b2QueryCallback.prototype.ReportFixture = function(t) {
        return !0
    }, box2d.b2RayCastCallback = function() {}, box2d.b2RayCastCallback.prototype.ReportFixture = function(t, e, i, o) {
        return o
    }, goog.provide("box2d.b2Island"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Timer"), goog.require("box2d.b2TimeStep"), goog.require("box2d.b2WorldCallbacks"), goog.require("box2d.b2ContactSolver"), box2d.b2Island = function() {
        this.m_bodies = new Array(1024), this.m_contacts = new Array(1024), this.m_joints = new Array(1024), this.m_positions = box2d.b2Position.MakeArray(1024), this.m_velocities = box2d.b2Velocity.MakeArray(1024)
    }, box2d.b2Island.prototype.m_allocator = null, box2d.b2Island.prototype.m_listener = null, box2d.b2Island.prototype.m_bodies = null, box2d.b2Island.prototype.m_contacts = null, box2d.b2Island.prototype.m_joints = null, box2d.b2Island.prototype.m_positions = null, box2d.b2Island.prototype.m_velocities = null, box2d.b2Island.prototype.m_bodyCount = 0, box2d.b2Island.prototype.m_jointCount = 0, box2d.b2Island.prototype.m_contactCount = 0, box2d.b2Island.prototype.m_bodyCapacity = 0, box2d.b2Island.prototype.m_contactCapacity = 0, box2d.b2Island.prototype.m_jointCapacity = 0, box2d.b2Island.prototype.Initialize = function(t, e, i, o, s) {
        for (this.m_bodyCapacity = t, this.m_contactCapacity = e, this.m_jointCapacity = i, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_allocator = o, this.m_listener = s; this.m_bodies.length < t;) this.m_bodies[this.m_bodies.length] = null;
        for (; this.m_contacts.length < e;) this.m_contacts[this.m_contacts.length] = null;
        for (; this.m_joints.length < i;) this.m_joints[this.m_joints.length] = null;
        if (this.m_positions.length < t)
            for (var n = box2d.b2Max(2 * this.m_positions.length, t); this.m_positions.length < n;) this.m_positions[this.m_positions.length] = new box2d.b2Position;
        if (this.m_velocities.length < t)
            for (var n = box2d.b2Max(2 * this.m_velocities.length, t); this.m_velocities.length < n;) this.m_velocities[this.m_velocities.length] = new box2d.b2Velocity
    }, box2d.b2Island.prototype.Clear = function() {
        this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0
    }, box2d.b2Island.prototype.AddBody = function(t) {
        t.m_islandIndex = this.m_bodyCount, this.m_bodies[this.m_bodyCount++] = t
    }, box2d.b2Island.prototype.AddContact = function(t) {
        this.m_contacts[this.m_contactCount++] = t
    }, box2d.b2Island.prototype.AddJoint = function(t) {
        this.m_joints[this.m_jointCount++] = t
    }, box2d.b2Island.prototype.Solve = function(t, e, i) {
        for (var o = t.dt, s = 0; s < this.m_bodyCount; ++s) {
            var n = this.m_bodies[s],
                r = this.m_positions[s].c.Copy(n.m_sweep.c),
                a = n.m_sweep.a,
                h = this.m_velocities[s].v.Copy(n.m_linearVelocity),
                l = n.m_angularVelocity;
            n.m_sweep.c0.Copy(n.m_sweep.c), n.m_sweep.a0 = n.m_sweep.a, n.m_type === box2d.b2BodyType.b2_dynamicBody && (h.x += o * (n.m_gravityScale * e.x + n.m_invMass * n.m_force.x), h.y += o * (n.m_gravityScale * e.y + n.m_invMass * n.m_force.y), l += o * n.m_invI * n.m_torque, h.SelfMul(1 / (1 + o * n.m_linearDamping)), l *= 1 / (1 + o * n.m_angularDamping)), this.m_positions[s].a = a, this.m_velocities[s].w = l
        }
        var d = box2d.b2Island.s_solverData;
        d.step.Copy(t), d.positions = this.m_positions, d.velocities = this.m_velocities;
        var c = box2d.b2Island.s_contactSolverDef;
        c.step.Copy(t), c.contacts = this.m_contacts, c.count = this.m_contactCount, c.positions = this.m_positions, c.velocities = this.m_velocities, c.allocator = this.m_allocator;
        var p = box2d.b2Island.s_contactSolver.Initialize(c);
        p.InitializeVelocityConstraints(), t.warmStarting && p.WarmStart();
        for (var s = 0; s < this.m_jointCount; ++s) this.m_joints[s].InitVelocityConstraints(d);
        for (var s = 0; s < t.velocityIterations; ++s) {
            for (var u = 0; u < this.m_jointCount; ++u) this.m_joints[u].SolveVelocityConstraints(d);
            p.SolveVelocityConstraints()
        }
        p.StoreImpulses();
        for (var s = 0; s < this.m_bodyCount; ++s) {
            var r = this.m_positions[s].c,
                a = this.m_positions[s].a,
                h = this.m_velocities[s].v,
                l = this.m_velocities[s].w,
                b = box2d.b2MulSV(o, h, box2d.b2Island.s_translation);
            if (box2d.b2DotVV(b, b) > box2d.b2_maxTranslationSquared) {
                var m = box2d.b2_maxTranslation / b.GetLength();
                h.SelfMul(m)
            }
            var y = o * l;
            if (y * y > box2d.b2_maxRotationSquared) {
                var m = box2d.b2_maxRotation / box2d.b2Abs(y);
                l *= m
            }
            r.x += o * h.x, r.y += o * h.y, a += o * l, this.m_positions[s].a = a, this.m_velocities[s].w = l
        }
        for (var f = !1, s = 0; s < t.positionIterations; ++s) {
            for (var g = p.SolvePositionConstraints(), x = !0, u = 0; u < this.m_jointCount; ++u) {
                var _ = this.m_joints[u].SolvePositionConstraints(d);
                x = x && _
            }
            if (g && x) {
                f = !0;
                break
            }
        }
        for (var s = 0; s < this.m_bodyCount; ++s) {
            var v = this.m_bodies[s];
            v.m_sweep.c.Copy(this.m_positions[s].c), v.m_sweep.a = this.m_positions[s].a, v.m_linearVelocity.Copy(this.m_velocities[s].v), v.m_angularVelocity = this.m_velocities[s].w, v.SynchronizeTransform()
        }
        if (this.Report(p.m_velocityConstraints), i) {
            for (var w = box2d.b2_maxFloat, C = box2d.b2_linearSleepTolerance * box2d.b2_linearSleepTolerance, S = box2d.b2_angularSleepTolerance * box2d.b2_angularSleepTolerance, s = 0; s < this.m_bodyCount; ++s) {
                var n = this.m_bodies[s];
                n.GetType() !== box2d.b2BodyType.b2_staticBody && (0 == (n.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) || n.m_angularVelocity * n.m_angularVelocity > S || box2d.b2DotVV(n.m_linearVelocity, n.m_linearVelocity) > C ? (n.m_sleepTime = 0, w = 0) : (n.m_sleepTime += o, w = box2d.b2Min(w, n.m_sleepTime)))
            }
            if (w >= box2d.b2_timeToSleep && f)
                for (var s = 0; s < this.m_bodyCount; ++s) {
                    var n = this.m_bodies[s];
                    n.SetAwake(!1)
                }
        }
    }, box2d.b2Island.prototype.SolveTOI = function(t, e, i) {
        for (var o = 0; o < this.m_bodyCount; ++o) {
            var s = this.m_bodies[o];
            this.m_positions[o].c.Copy(s.m_sweep.c), this.m_positions[o].a = s.m_sweep.a, this.m_velocities[o].v.Copy(s.m_linearVelocity), this.m_velocities[o].w = s.m_angularVelocity
        }
        var n = box2d.b2Island.s_contactSolverDef;
        n.contacts = this.m_contacts, n.count = this.m_contactCount, n.allocator = this.m_allocator, n.step.Copy(t), n.positions = this.m_positions, n.velocities = this.m_velocities;
        for (var r = box2d.b2Island.s_contactSolver.Initialize(n), o = 0; o < t.positionIterations; ++o) {
            if (r.SolveTOIPositionConstraints(e, i)) break
        }
        this.m_bodies[e].m_sweep.c0.Copy(this.m_positions[e].c), this.m_bodies[e].m_sweep.a0 = this.m_positions[e].a, this.m_bodies[i].m_sweep.c0.Copy(this.m_positions[i].c), this.m_bodies[i].m_sweep.a0 = this.m_positions[i].a, r.InitializeVelocityConstraints();
        for (var o = 0; o < t.velocityIterations; ++o) r.SolveVelocityConstraints();
        for (var a = t.dt, o = 0; o < this.m_bodyCount; ++o) {
            var h = this.m_positions[o].c,
                l = this.m_positions[o].a,
                d = this.m_velocities[o].v,
                c = this.m_velocities[o].w,
                p = box2d.b2MulSV(a, d, box2d.b2Island.s_translation);
            if (box2d.b2DotVV(p, p) > box2d.b2_maxTranslationSquared) {
                var u = box2d.b2_maxTranslation / p.GetLength();
                d.SelfMul(u)
            }
            var b = a * c;
            if (b * b > box2d.b2_maxRotationSquared) {
                var u = box2d.b2_maxRotation / box2d.b2Abs(b);
                c *= u
            }
            h.SelfMulAdd(a, d), l += a * c, this.m_positions[o].a = l, this.m_velocities[o].w = c;
            var m = this.m_bodies[o];
            m.m_sweep.c.Copy(h), m.m_sweep.a = l, m.m_linearVelocity.Copy(d), m.m_angularVelocity = c, m.SynchronizeTransform()
        }
        this.Report(r.m_velocityConstraints)
    }, box2d.b2Island.prototype.Report = function(t) {
        if (null !== this.m_listener)
            for (var e = 0; e < this.m_contactCount; ++e) {
                var i = this.m_contacts[e];
                if (i) {
                    var o = t[e],
                        s = box2d.b2Island.s_impulse;
                    s.count = o.pointCount;
                    for (var n = 0; n < o.pointCount; ++n) s.normalImpulses[n] = o.points[n].normalImpulse, s.tangentImpulses[n] = o.points[n].tangentImpulse;
                    this.m_listener.PostSolve(i, s)
                }
            }
    }, box2d.b2Island.s_timer = new box2d.b2Timer, box2d.b2Island.s_solverData = new box2d.b2SolverData, box2d.b2Island.s_contactSolverDef = new box2d.b2ContactSolverDef, box2d.b2Island.s_contactSolver = new box2d.b2ContactSolver, box2d.b2Island.s_translation = new box2d.b2Vec2, box2d.b2Island.s_impulse = new box2d.b2ContactImpulse, goog.provide("box2d.b2ContactFactory"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), box2d.b2ContactRegister = function() {}, box2d.b2ContactRegister.prototype.createFcn = null, box2d.b2ContactRegister.prototype.destroyFcn = null, box2d.b2ContactRegister.prototype.primary = !1, box2d.b2ContactFactory = function(t) {
        this.m_allocator = t, this.InitializeRegisters()
    }, box2d.b2ContactFactory.prototype.m_allocator = null, box2d.b2ContactFactory.prototype.AddType = function(t, e, i, o) {
        var s = box2d.b2MakeArray(256, function(e) {
                return t()
            }),
            n = function(e) {
                return s.length > 0 ? s.pop() : t(e)
            },
            r = function(t, e) {
                s.push(t)
            };
        this.m_registers[i][o].pool = s, this.m_registers[i][o].createFcn = n, this.m_registers[i][o].destroyFcn = r, this.m_registers[i][o].primary = !0, i !== o && (this.m_registers[o][i].pool = s, this.m_registers[o][i].createFcn = n, this.m_registers[o][i].destroyFcn = r, this.m_registers[o][i].primary = !1)
    }, box2d.b2ContactFactory.prototype.InitializeRegisters = function() {
        this.m_registers = new Array(box2d.b2ShapeType.e_shapeTypeCount);
        for (var t = 0; t < box2d.b2ShapeType.e_shapeTypeCount; t++) {
            this.m_registers[t] = new Array(box2d.b2ShapeType.e_shapeTypeCount);
            for (var e = 0; e < box2d.b2ShapeType.e_shapeTypeCount; e++) this.m_registers[t][e] = new box2d.b2ContactRegister
        }
        this.AddType(box2d.b2CircleContact.Create, box2d.b2CircleContact.Destroy, box2d.b2ShapeType.e_circleShape, box2d.b2ShapeType.e_circleShape), this.AddType(box2d.b2PolygonAndCircleContact.Create, box2d.b2PolygonAndCircleContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_circleShape), this.AddType(box2d.b2PolygonContact.Create, box2d.b2PolygonContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_polygonShape), this.AddType(box2d.b2EdgeAndCircleContact.Create, box2d.b2EdgeAndCircleContact.Destroy, box2d.b2ShapeType.e_edgeShape, box2d.b2ShapeType.e_circleShape), this.AddType(box2d.b2EdgeAndPolygonContact.Create, box2d.b2EdgeAndPolygonContact.Destroy, box2d.b2ShapeType.e_edgeShape, box2d.b2ShapeType.e_polygonShape), this.AddType(box2d.b2ChainAndCircleContact.Create, box2d.b2ChainAndCircleContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_circleShape), this.AddType(box2d.b2ChainAndPolygonContact.Create, box2d.b2ChainAndPolygonContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_polygonShape)
    }, box2d.b2ContactFactory.prototype.Create = function(t, e, i, o) {
        var s = t.GetType(),
            n = i.GetType(),
            r = this.m_registers[s][n],
            a = r.createFcn;
        if (null !== a) {
            if (r.primary) {
                var h = a(this.m_allocator);
                return h.Reset(t, e, i, o), h
            }
            var h = a(this.m_allocator);
            return h.Reset(i, o, t, e), h
        }
        return null
    }, box2d.b2ContactFactory.prototype.Destroy = function(t) {
        var e = t.m_fixtureA,
            i = t.m_fixtureB;
        t.m_manifold.pointCount > 0 && !1 === e.IsSensor() && !1 === i.IsSensor() && (e.GetBody().SetAwake(!0), i.GetBody().SetAwake(!0));
        var o = e.GetType(),
            s = i.GetType();
        (0, this.m_registers[o][s].destroyFcn)(t, this.m_allocator)
    }, goog.provide("box2d.b2GrowableStack"), goog.require("box2d.b2Settings"), box2d.b2GrowableStack = function(t) {
        this.m_stack = new Array(t)
    }, box2d.b2GrowableStack.prototype.m_stack = null, box2d.b2GrowableStack.prototype.m_count = 0, box2d.b2GrowableStack.prototype.Reset = function() {
        return this.m_count = 0, this
    }, box2d.b2GrowableStack.prototype.Push = function(t) {
        this.m_stack[this.m_count] = t, ++this.m_count
    }, box2d.b2GrowableStack.prototype.Pop = function() {
        --this.m_count;
        var t = this.m_stack[this.m_count];
        return this.m_stack[this.m_count] = null, t
    }, box2d.b2GrowableStack.prototype.GetCount = function() {
        return this.m_count
    }, goog.provide("box2d.b2DynamicTree"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Collision"), goog.require("box2d.b2GrowableStack"), box2d.b2TreeNode = function(t) {
        this.m_id = t || 0, this.aabb = new box2d.b2AABB
    }, box2d.b2TreeNode.prototype.m_id = 0, box2d.b2TreeNode.prototype.aabb = null, box2d.b2TreeNode.prototype.userData = null, box2d.b2TreeNode.prototype.parent = null, box2d.b2TreeNode.prototype.child1 = null, box2d.b2TreeNode.prototype.child2 = null, box2d.b2TreeNode.prototype.height = 0, box2d.b2TreeNode.prototype.IsLeaf = function() {
        return null === this.child1
    }, box2d.b2DynamicTree = function() {}, box2d.b2DynamicTree.prototype.m_root = null, box2d.b2DynamicTree.prototype.m_freeList = null, box2d.b2DynamicTree.prototype.m_path = 0, box2d.b2DynamicTree.prototype.m_insertionCount = 0, box2d.b2DynamicTree.s_stack = new box2d.b2GrowableStack(256), box2d.b2DynamicTree.s_r = new box2d.b2Vec2, box2d.b2DynamicTree.s_v = new box2d.b2Vec2, box2d.b2DynamicTree.s_abs_v = new box2d.b2Vec2, box2d.b2DynamicTree.s_segmentAABB = new box2d.b2AABB, box2d.b2DynamicTree.s_subInput = new box2d.b2RayCastInput, box2d.b2DynamicTree.s_combinedAABB = new box2d.b2AABB, box2d.b2DynamicTree.s_aabb = new box2d.b2AABB, box2d.b2DynamicTree.prototype.GetUserData = function(t) {
        return t.userData
    }, box2d.b2DynamicTree.prototype.GetFatAABB = function(t) {
        return t.aabb
    }, box2d.b2DynamicTree.prototype.Query = function(t, e) {
        if (null !== this.m_root) {
            var i = box2d.b2DynamicTree.s_stack.Reset();
            for (i.Push(this.m_root); i.GetCount() > 0;) {
                var o = i.Pop();
                if (null !== o && o.aabb.TestOverlap(e))
                    if (o.IsLeaf()) {
                        var s = t(o);
                        if (!1 === s) return
                    } else i.Push(o.child1), i.Push(o.child2)
            }
        }
    }, box2d.b2DynamicTree.prototype.RayCast = function(t, e) {
        if (null !== this.m_root) {
            var i = e.p1,
                o = e.p2,
                s = box2d.b2SubVV(o, i, box2d.b2DynamicTree.s_r);
            s.Normalize();
            var n = box2d.b2CrossOneV(s, box2d.b2DynamicTree.s_v),
                r = box2d.b2AbsV(n, box2d.b2DynamicTree.s_abs_v),
                a = e.maxFraction,
                h = box2d.b2DynamicTree.s_segmentAABB,
                l = i.x + a * (o.x - i.x),
                d = i.y + a * (o.y - i.y);
            h.lowerBound.x = box2d.b2Min(i.x, l), h.lowerBound.y = box2d.b2Min(i.y, d), h.upperBound.x = box2d.b2Max(i.x, l), h.upperBound.y = box2d.b2Max(i.y, d);
            var c = box2d.b2DynamicTree.s_stack.Reset();
            for (c.Push(this.m_root); c.GetCount() > 0;) {
                var p = c.Pop();
                if (null !== p && !1 !== box2d.b2TestOverlapAABB(p.aabb, h)) {
                    var u = p.aabb.GetCenter(),
                        b = p.aabb.GetExtents();
                    if (!(box2d.b2Abs(box2d.b2DotVV(n, box2d.b2SubVV(i, u, box2d.b2Vec2.s_t0))) - box2d.b2DotVV(r, b) > 0))
                        if (p.IsLeaf()) {
                            var m = box2d.b2DynamicTree.s_subInput;
                            m.p1.Copy(e.p1), m.p2.Copy(e.p2), m.maxFraction = a;
                            var y = t(m, p);
                            if (0 === y) return;
                            y > 0 && (a = y, l = i.x + a * (o.x - i.x), d = i.y + a * (o.y - i.y), h.lowerBound.x = box2d.b2Min(i.x, l), h.lowerBound.y = box2d.b2Min(i.y, d), h.upperBound.x = box2d.b2Max(i.x, l), h.upperBound.y = box2d.b2Max(i.y, d))
                        } else c.Push(p.child1), c.Push(p.child2)
                }
            }
        }
    }, box2d.b2DynamicTree.prototype.AllocateNode = function() {
        if (this.m_freeList) {
            var t = this.m_freeList;
            return this.m_freeList = t.parent, t.parent = null, t.child1 = null, t.child2 = null, t.height = 0, t.userData = null, t
        }
        return new box2d.b2TreeNode(box2d.b2DynamicTree.prototype.s_node_id++)
    }, box2d.b2DynamicTree.prototype.s_node_id = 0, box2d.b2DynamicTree.prototype.FreeNode = function(t) {
        t.parent = this.m_freeList, t.height = -1, this.m_freeList = t
    }, box2d.b2DynamicTree.prototype.CreateProxy = function(t, e) {
        var i = this.AllocateNode(),
            o = box2d.b2_aabbExtension,
            s = box2d.b2_aabbExtension;
        return i.aabb.lowerBound.x = t.lowerBound.x - o, i.aabb.lowerBound.y = t.lowerBound.y - s, i.aabb.upperBound.x = t.upperBound.x + o, i.aabb.upperBound.y = t.upperBound.y + s, i.userData = e, i.height = 0, this.InsertLeaf(i), i
    }, box2d.b2DynamicTree.prototype.DestroyProxy = function(t) {
        this.RemoveLeaf(t), this.FreeNode(t)
    }, box2d.b2DynamicTree.prototype.MoveProxy = function(t, e, i) {
        if (t.aabb.Contains(e)) return !1;
        this.RemoveLeaf(t);
        var o = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (i.x > 0 ? i.x : -i.x),
            s = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (i.y > 0 ? i.y : -i.y);
        return t.aabb.lowerBound.x = e.lowerBound.x - o, t.aabb.lowerBound.y = e.lowerBound.y - s, t.aabb.upperBound.x = e.upperBound.x + o, t.aabb.upperBound.y = e.upperBound.y + s, this.InsertLeaf(t), !0
    }, box2d.b2DynamicTree.prototype.InsertLeaf = function(t) {
        if (++this.m_insertionCount, null === this.m_root) return this.m_root = t, void(this.m_root.parent = null);
        for (var e, i, o = t.aabb, s = (o.GetCenter(), this.m_root); !1 === s.IsLeaf();) {
            e = s.child1, i = s.child2;
            var n = s.aabb.GetPerimeter(),
                r = box2d.b2DynamicTree.s_combinedAABB;
            r.Combine2(s.aabb, o);
            var a, h, l, d = r.GetPerimeter(),
                c = 2 * d,
                p = 2 * (d - n),
                u = box2d.b2DynamicTree.s_aabb;
            e.IsLeaf() ? (u.Combine2(o, e.aabb), a = u.GetPerimeter() + p) : (u.Combine2(o, e.aabb), h = e.aabb.GetPerimeter(), l = u.GetPerimeter(), a = l - h + p);
            var b;
            if (i.IsLeaf() ? (u.Combine2(o, i.aabb), b = u.GetPerimeter() + p) : (u.Combine2(o, i.aabb), h = i.aabb.GetPerimeter(), l = u.GetPerimeter(), b = l - h + p), c < a && c < b) break;
            s = a < b ? e : i
        }
        var m = s,
            y = m.parent,
            f = this.AllocateNode();
        for (f.parent = y, f.userData = null, f.aabb.Combine2(o, m.aabb), f.height = m.height + 1, y ? (y.child1 === m ? y.child1 = f : y.child2 = f, f.child1 = m, f.child2 = t, m.parent = f, t.parent = f) : (f.child1 = m, f.child2 = t, m.parent = f, t.parent = f, this.m_root = f), s = t.parent; null !== s;) s = this.Balance(s), e = s.child1, i = s.child2, s.height = 1 + box2d.b2Max(e.height, i.height), s.aabb.Combine2(e.aabb, i.aabb), s = s.parent
    }, box2d.b2DynamicTree.prototype.RemoveLeaf = function(t) {
        if (t === this.m_root) return void(this.m_root = null);
        var e, i = t.parent,
            o = i.parent;
        if (e = i.child1 === t ? i.child2 : i.child1, o) {
            o.child1 === i ? o.child1 = e : o.child2 = e, e.parent = o, this.FreeNode(i);
            for (var s = o; s;) {
                s = this.Balance(s);
                var n = s.child1,
                    r = s.child2;
                s.aabb.Combine2(n.aabb, r.aabb), s.height = 1 + box2d.b2Max(n.height, r.height), s = s.parent
            }
        } else this.m_root = e, e.parent = null, this.FreeNode(i)
    }, box2d.b2DynamicTree.prototype.Balance = function(t) {
        if (t.IsLeaf() || t.height < 2) return t;
        var e = t.child1,
            i = t.child2,
            o = i.height - e.height;
        if (o > 1) {
            var s = i.child1,
                n = i.child2;
            return i.child1 = t, i.parent = t.parent, t.parent = i, null !== i.parent ? i.parent.child1 === t ? i.parent.child1 = i : i.parent.child2 = i : this.m_root = i, s.height > n.height ? (i.child2 = s, t.child2 = n, n.parent = t, t.aabb.Combine2(e.aabb, n.aabb), i.aabb.Combine2(t.aabb, s.aabb), t.height = 1 + box2d.b2Max(e.height, n.height), i.height = 1 + box2d.b2Max(t.height, s.height)) : (i.child2 = n, t.child2 = s, s.parent = t, t.aabb.Combine2(e.aabb, s.aabb), i.aabb.Combine2(t.aabb, n.aabb), t.height = 1 + box2d.b2Max(e.height, s.height), i.height = 1 + box2d.b2Max(t.height, n.height)), i
        }
        if (o < -1) {
            var r = e.child1,
                a = e.child2;
            return e.child1 = t, e.parent = t.parent, t.parent = e, null !== e.parent ? e.parent.child1 === t ? e.parent.child1 = e : e.parent.child2 = e : this.m_root = e, r.height > a.height ? (e.child2 = r, t.child1 = a, a.parent = t, t.aabb.Combine2(i.aabb, a.aabb), e.aabb.Combine2(t.aabb, r.aabb), t.height = 1 + box2d.b2Max(i.height, a.height), e.height = 1 + box2d.b2Max(t.height, r.height)) : (e.child2 = a, t.child1 = r, r.parent = t, t.aabb.Combine2(i.aabb, r.aabb), e.aabb.Combine2(t.aabb, a.aabb), t.height = 1 + box2d.b2Max(i.height, r.height), e.height = 1 + box2d.b2Max(t.height, a.height)), e
        }
        return t
    }, box2d.b2DynamicTree.prototype.GetHeight = function() {
        return null === this.m_root ? 0 : this.m_root.height
    },
    box2d.b2DynamicTree.prototype.GetAreaRatio = function() {
        if (null === this.m_root) return 0;
        var t = this.m_root,
            e = t.aabb.GetPerimeter(),
            i = function(t) {
                if (null === t) return 0;
                if (t.IsLeaf()) return 0;
                var e = t.aabb.GetPerimeter();
                return e += i(t.child1), e += i(t.child2)
            };
        return i(this.m_root) / e
    }, box2d.b2DynamicTree.prototype.ComputeHeightNode = function(t) {
        if (t.IsLeaf()) return 0;
        var e = this.ComputeHeightNode(t.child1),
            i = this.ComputeHeightNode(t.child2);
        return 1 + box2d.b2Max(e, i)
    }, box2d.b2DynamicTree.prototype.ComputeHeight = function() {
        return this.ComputeHeightNode(this.m_root)
    }, box2d.b2DynamicTree.prototype.ValidateStructure = function(t) {
        if (null !== t) {
            var e = t,
                i = e.child1,
                o = e.child2;
            e.IsLeaf() || (this.ValidateStructure(i), this.ValidateStructure(o))
        }
    }, box2d.b2DynamicTree.prototype.ValidateMetrics = function(t) {
        if (null !== t) {
            var e = t,
                i = e.child1,
                o = e.child2;
            if (!e.IsLeaf()) {
                var s = i.height,
                    n = o.height;
                1 + box2d.b2Max(s, n);
                box2d.b2DynamicTree.s_aabb.Combine2(i.aabb, o.aabb), this.ValidateMetrics(i), this.ValidateMetrics(o)
            }
        }
    }, box2d.b2DynamicTree.prototype.Validate = function() {
        this.ValidateStructure(this.m_root), this.ValidateMetrics(this.m_root);
        for (var t = 0, e = this.m_freeList; null !== e;) e = e.parent, ++t
    }, box2d.b2DynamicTree.prototype.GetMaxBalance = function() {
        return function(t, e) {
            if (null === t) return e;
            if (t.height <= 1) return e;
            var i = t.child1,
                o = t.child2,
                s = box2d.b2Abs(o.height - i.height);
            return box2d.b2Max(e, s)
        }(this.m_root, 0)
    }, box2d.b2DynamicTree.prototype.RebuildBottomUp = function() {
        this.Validate()
    }, box2d.b2DynamicTree.prototype.ShiftOrigin = function(t) {
        var e = function(t, i) {
            if (null !== t && !(t.height <= 1)) {
                var o = t.child1,
                    s = t.child2;
                e(o, i), e(s, i), t.aabb.lowerBound.SelfSub(i), t.aabb.upperBound.SelfSub(i)
            }
        };
        e(this.m_root, t)
    }, goog.provide("box2d.b2BroadPhase"), goog.require("box2d.b2Settings"), goog.require("box2d.b2DynamicTree"), box2d.b2Pair = function() {}, box2d.b2Pair.prototype.proxyA = null, box2d.b2Pair.prototype.proxyB = null, box2d.b2BroadPhase = function() {
        this.m_tree = new box2d.b2DynamicTree, this.m_moveBuffer = new Array, this.m_pairBuffer = new Array
    }, box2d.b2BroadPhase.prototype.m_tree = null, box2d.b2BroadPhase.prototype.m_proxyCount = 0, box2d.b2BroadPhase.prototype.m_moveCount = 0, box2d.b2BroadPhase.prototype.m_moveBuffer = null, box2d.b2BroadPhase.prototype.m_pairCount = 0, box2d.b2BroadPhase.prototype.m_pairBuffer = null, box2d.b2BroadPhase.prototype.CreateProxy = function(t, e) {
        var i = this.m_tree.CreateProxy(t, e);
        return ++this.m_proxyCount, this.BufferMove(i), i
    }, box2d.b2BroadPhase.prototype.DestroyProxy = function(t) {
        this.UnBufferMove(t), --this.m_proxyCount, this.m_tree.DestroyProxy(t)
    }, box2d.b2BroadPhase.prototype.MoveProxy = function(t, e, i) {
        this.m_tree.MoveProxy(t, e, i) && this.BufferMove(t)
    }, box2d.b2BroadPhase.prototype.TouchProxy = function(t) {
        this.BufferMove(t)
    }, box2d.b2BroadPhase.prototype.GetFatAABB = function(t) {
        return this.m_tree.GetFatAABB(t)
    }, box2d.b2BroadPhase.prototype.GetUserData = function(t) {
        return this.m_tree.GetUserData(t)
    }, box2d.b2BroadPhase.prototype.TestOverlap = function(t, e) {
        var i = this.m_tree.GetFatAABB(t),
            o = this.m_tree.GetFatAABB(e);
        return box2d.b2TestOverlapAABB(i, o)
    }, box2d.b2BroadPhase.prototype.GetProxyCount = function() {
        return this.m_proxyCount
    }, box2d.b2BroadPhase.prototype.GetTreeHeight = function() {
        return this.m_tree.GetHeight()
    }, box2d.b2BroadPhase.prototype.GetTreeBalance = function() {
        return this.m_tree.GetMaxBalance()
    }, box2d.b2BroadPhase.prototype.GetTreeQuality = function() {
        return this.m_tree.GetAreaRatio()
    }, box2d.b2BroadPhase.prototype.ShiftOrigin = function(t) {
        this.m_tree.ShiftOrigin(t)
    }, box2d.b2BroadPhase.prototype.UpdatePairs = function(t) {
        this.m_pairCount = 0;
        for (var e = 0; e < this.m_moveCount; ++e) {
            var i = this.m_moveBuffer[e];
            if (null !== i) {
                var o = this,
                    s = function(t) {
                        if (t.m_id === i.m_id) return !0;
                        o.m_pairCount === o.m_pairBuffer.length && (o.m_pairBuffer[o.m_pairCount] = new box2d.b2Pair);
                        var e = o.m_pairBuffer[o.m_pairCount];
                        return t.m_id < i.m_id ? (e.proxyA = t, e.proxyB = i) : (e.proxyA = i, e.proxyB = t), ++o.m_pairCount, !0
                    },
                    n = this.m_tree.GetFatAABB(i);
                this.m_tree.Query(s, n)
            }
        }
        this.m_moveCount = 0, this.m_pairBuffer.length = this.m_pairCount, this.m_pairBuffer.sort(box2d.b2PairLessThan);
        for (var e = 0; e < this.m_pairCount;) {
            var r = this.m_pairBuffer[e],
                a = this.m_tree.GetUserData(r.proxyA),
                h = this.m_tree.GetUserData(r.proxyB);
            for (t.AddPair(a, h), ++e; e < this.m_pairCount;) {
                var l = this.m_pairBuffer[e];
                if (l.proxyA.m_id !== r.proxyA.m_id || l.proxyB.m_id !== r.proxyB.m_id) break;
                ++e
            }
        }
    }, box2d.b2BroadPhase.prototype.Query = function(t, e) {
        this.m_tree.Query(t, e)
    }, box2d.b2BroadPhase.prototype.RayCast = function(t, e) {
        this.m_tree.RayCast(t, e)
    }, box2d.b2BroadPhase.prototype.BufferMove = function(t) {
        this.m_moveBuffer[this.m_moveCount] = t, ++this.m_moveCount
    }, box2d.b2BroadPhase.prototype.UnBufferMove = function(t) {
        var e = this.m_moveBuffer.indexOf(t);
        this.m_moveBuffer[e] = null
    }, box2d.b2PairLessThan = function(t, e) {
        return t.proxyA.m_id === e.proxyA.m_id ? t.proxyB.m_id - e.proxyB.m_id : t.proxyA.m_id - e.proxyA.m_id
    }, goog.provide("box2d.b2ContactManager"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Collision"), goog.require("box2d.b2BroadPhase"), goog.require("box2d.b2ContactFactory"), box2d.b2ContactManager = function() {
        this.m_broadPhase = new box2d.b2BroadPhase, this.m_contactFactory = new box2d.b2ContactFactory(this.m_allocator)
    }, box2d.b2ContactManager.prototype.m_broadPhase = null, box2d.b2ContactManager.prototype.m_contactList = null, box2d.b2ContactManager.prototype.m_contactCount = 0, box2d.b2ContactManager.prototype.m_contactFilter = box2d.b2ContactFilter.b2_defaultFilter, box2d.b2ContactManager.prototype.m_contactListener = box2d.b2ContactListener.b2_defaultListener, box2d.b2ContactManager.prototype.m_allocator = null, box2d.b2ContactManager.prototype.m_contactFactory = null, box2d.b2ContactManager.prototype.Destroy = function(t) {
        var e = t.GetFixtureA(),
            i = t.GetFixtureB(),
            o = e.GetBody(),
            s = i.GetBody();
        this.m_contactListener && t.IsTouching() && this.m_contactListener.EndContact(t), t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t === this.m_contactList && (this.m_contactList = t.m_next), t.m_nodeA.prev && (t.m_nodeA.prev.next = t.m_nodeA.next), t.m_nodeA.next && (t.m_nodeA.next.prev = t.m_nodeA.prev), t.m_nodeA === o.m_contactList && (o.m_contactList = t.m_nodeA.next), t.m_nodeB.prev && (t.m_nodeB.prev.next = t.m_nodeB.next), t.m_nodeB.next && (t.m_nodeB.next.prev = t.m_nodeB.prev), t.m_nodeB === s.m_contactList && (s.m_contactList = t.m_nodeB.next), this.m_contactFactory.Destroy(t), --this.m_contactCount
    }, box2d.b2ContactManager.prototype.Collide = function() {
        for (var t = this.m_contactList; t;) {
            var e = t.GetFixtureA(),
                i = t.GetFixtureB(),
                o = t.GetChildIndexA(),
                s = t.GetChildIndexB(),
                n = e.GetBody(),
                r = i.GetBody();
            if (t.m_flags & box2d.b2ContactFlag.e_filterFlag) {
                if (!1 === r.ShouldCollide(n)) {
                    var a = t;
                    t = a.m_next, this.Destroy(a);
                    continue
                }
                if (this.m_contactFilter && !1 === this.m_contactFilter.ShouldCollide(e, i)) {
                    a = t, t = a.m_next, this.Destroy(a);
                    continue
                }
                t.m_flags &= ~box2d.b2ContactFlag.e_filterFlag
            }
            var h = n.IsAwake() && n.m_type !== box2d.b2BodyType.b2_staticBody,
                l = r.IsAwake() && r.m_type !== box2d.b2BodyType.b2_staticBody;
            if (!1 !== h || !1 !== l) {
                var d = e.m_proxies[o].proxy,
                    c = i.m_proxies[s].proxy;
                !1 !== this.m_broadPhase.TestOverlap(d, c) ? (t.Update(this.m_contactListener), t = t.m_next) : (a = t, t = a.m_next, this.Destroy(a))
            } else t = t.m_next
        }
    }, box2d.b2ContactManager.prototype.FindNewContacts = function() {
        this.m_broadPhase.UpdatePairs(this)
    }, box2d.b2ContactManager.prototype.AddPair = function(t, e) {
        var i = t,
            o = e,
            s = i.fixture,
            n = o.fixture,
            r = i.childIndex,
            a = o.childIndex,
            h = s.GetBody(),
            l = n.GetBody();
        if (h !== l) {
            for (var d = l.GetContactList(); d;) {
                if (d.other === h) {
                    var c = d.contact.GetFixtureA(),
                        p = d.contact.GetFixtureB(),
                        u = d.contact.GetChildIndexA(),
                        b = d.contact.GetChildIndexB();
                    if (c === s && p === n && u === r && b === a) return;
                    if (c === n && p === s && u === a && b === r) return
                }
                d = d.next
            }
            if (!1 !== l.ShouldCollide(h) && (!this.m_contactFilter || !1 !== this.m_contactFilter.ShouldCollide(s, n))) {
                var m = this.m_contactFactory.Create(s, r, n, a);
                null !== m && (s = m.GetFixtureA(), n = m.GetFixtureB(), r = m.GetChildIndexA(), a = m.GetChildIndexB(), h = s.m_body, l = n.m_body, m.m_prev = null, m.m_next = this.m_contactList, null !== this.m_contactList && (this.m_contactList.m_prev = m), this.m_contactList = m, m.m_nodeA.contact = m, m.m_nodeA.other = l, m.m_nodeA.prev = null, m.m_nodeA.next = h.m_contactList, null !== h.m_contactList && (h.m_contactList.prev = m.m_nodeA), h.m_contactList = m.m_nodeA, m.m_nodeB.contact = m, m.m_nodeB.other = h, m.m_nodeB.prev = null, m.m_nodeB.next = l.m_contactList, null !== l.m_contactList && (l.m_contactList.prev = m.m_nodeB), l.m_contactList = m.m_nodeB, !1 === s.IsSensor() && !1 === n.IsSensor() && (h.SetAwake(!0), l.SetAwake(!0)), ++this.m_contactCount)
            }
        }
    }, goog.provide("box2d.b2JointFactory"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Joint"), box2d.b2JointFactory.Create = function(t, e) {
        var i = null;
        switch (t.type) {
            case box2d.b2JointType.e_distanceJoint:
                i = new box2d.b2DistanceJoint(t instanceof box2d.b2DistanceJointDef ? t : null);
                break;
            case box2d.b2JointType.e_mouseJoint:
                i = new box2d.b2MouseJoint(t instanceof box2d.b2MouseJointDef ? t : null);
                break;
            case box2d.b2JointType.e_prismaticJoint:
                i = new box2d.b2PrismaticJoint(t instanceof box2d.b2PrismaticJointDef ? t : null);
                break;
            case box2d.b2JointType.e_revoluteJoint:
                i = new box2d.b2RevoluteJoint(t instanceof box2d.b2RevoluteJointDef ? t : null);
                break;
            case box2d.b2JointType.e_pulleyJoint:
                i = new box2d.b2PulleyJoint(t instanceof box2d.b2PulleyJointDef ? t : null);
                break;
            case box2d.b2JointType.e_gearJoint:
                i = new box2d.b2GearJoint(t instanceof box2d.b2GearJointDef ? t : null);
                break;
            case box2d.b2JointType.e_wheelJoint:
                i = new box2d.b2WheelJoint(t instanceof box2d.b2WheelJointDef ? t : null);
                break;
            case box2d.b2JointType.e_weldJoint:
                i = new box2d.b2WeldJoint(t instanceof box2d.b2WeldJointDef ? t : null);
                break;
            case box2d.b2JointType.e_frictionJoint:
                i = new box2d.b2FrictionJoint(t instanceof box2d.b2FrictionJointDef ? t : null);
                break;
            case box2d.b2JointType.e_ropeJoint:
                i = new box2d.b2RopeJoint(t instanceof box2d.b2RopeJointDef ? t : null);
                break;
            case box2d.b2JointType.e_motorJoint:
                i = new box2d.b2MotorJoint(t instanceof box2d.b2MotorJointDef ? t : null);
                break;
            case box2d.b2JointType.e_areaJoint:
                i = new box2d.b2AreaJoint(t instanceof box2d.b2AreaJointDef ? t : null)
        }
        return i
    }, box2d.b2JointFactory.Destroy = function(t, e) {}, goog.provide("box2d.b2Draw"), goog.require("box2d.b2Settings"), box2d.b2Color = function(t, e, i) {
        this.r = t, this.g = e, this.b = i
    }, box2d.b2Color.prototype.r = .5, box2d.b2Color.prototype.g = .5, box2d.b2Color.prototype.b = .5, box2d.b2Color.prototype.SetRGB = function(t, e, i) {
        return this.r = t, this.g = e, this.b = i, this
    }, box2d.b2Color.prototype.MakeStyleString = function(t) {
        var e = Math.round(Math.max(0, Math.min(255, 255 * this.r))),
            i = Math.round(Math.max(0, Math.min(255, 255 * this.g))),
            o = Math.round(Math.max(0, Math.min(255, 255 * this.b))),
            s = void 0 === t ? 1 : Math.max(0, Math.min(1, t));
        return box2d.b2Color.MakeStyleString(e, i, o, s)
    }, box2d.b2Color.MakeStyleString = function(t, e, i, o) {
        return o < 1 ? "rgba(" + t + "," + e + "," + i + "," + o + ")" : "rgb(" + t + "," + e + "," + i + ")"
    }, box2d.b2Color.RED = new box2d.b2Color(1, 0, 0), box2d.b2Color.GREEN = new box2d.b2Color(0, 1, 0), box2d.b2Color.BLUE = new box2d.b2Color(0, 0, 1), box2d.b2DrawFlags = {
        e_none: 0,
        e_shapeBit: 1,
        e_jointBit: 2,
        e_aabbBit: 4,
        e_pairBit: 8,
        e_centerOfMassBit: 16,
        e_controllerBit: 32,
        e_all: 63
    }, goog.exportProperty(box2d.b2DrawFlags, "e_none", box2d.b2DrawFlags.e_none), goog.exportProperty(box2d.b2DrawFlags, "e_shapeBit", box2d.b2DrawFlags.e_shapeBit), goog.exportProperty(box2d.b2DrawFlags, "e_jointBit", box2d.b2DrawFlags.e_jointBit), goog.exportProperty(box2d.b2DrawFlags, "e_aabbBit", box2d.b2DrawFlags.e_aabbBit), goog.exportProperty(box2d.b2DrawFlags, "e_pairBit", box2d.b2DrawFlags.e_pairBit), goog.exportProperty(box2d.b2DrawFlags, "e_centerOfMassBit", box2d.b2DrawFlags.e_centerOfMassBit), goog.exportProperty(box2d.b2DrawFlags, "e_controllerBit", box2d.b2DrawFlags.e_controllerBit), goog.exportProperty(box2d.b2DrawFlags, "e_all", box2d.b2DrawFlags.e_all), box2d.b2Draw = function() {}, box2d.b2Draw.prototype.m_drawFlags = box2d.b2DrawFlags.e_none, box2d.b2Draw.prototype.SetFlags = function(t) {
        this.m_drawFlags = t
    }, box2d.b2Draw.prototype.GetFlags = function() {
        return this.m_drawFlags
    }, box2d.b2Draw.prototype.AppendFlags = function(t) {
        this.m_drawFlags |= t
    }, box2d.b2Draw.prototype.ClearFlags = function(t) {
        this.m_drawFlags &= ~t
    }, box2d.b2Draw.prototype.PushTransform = function(t) {}, box2d.b2Draw.prototype.PopTransform = function(t) {}, box2d.b2Draw.prototype.DrawPolygon = function(t, e, i) {}, box2d.b2Draw.prototype.DrawSolidPolygon = function(t, e, i) {}, box2d.b2Draw.prototype.DrawCircle = function(t, e, i) {}, box2d.b2Draw.prototype.DrawSolidCircle = function(t, e, i, o) {}, box2d.b2Draw.prototype.DrawSegment = function(t, e, i) {};
box2d.b2Draw.prototype.DrawTransform = function(t) {}, goog.provide("box2d.b2Fixture"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Collision"), goog.require("box2d.b2Shape"), box2d.b2Filter = function() {}, box2d.b2Filter.prototype.categoryBits = 1, box2d.b2Filter.prototype.maskBits = 65535, box2d.b2Filter.prototype.groupIndex = 0, box2d.b2Filter.prototype.Clone = function() {
    return (new box2d.b2Filter).Copy(this)
}, box2d.b2Filter.prototype.Copy = function(t) {
    return this.categoryBits = t.categoryBits, this.maskBits = t.maskBits, this.groupIndex = t.groupIndex, this
}, box2d.b2FixtureDef = function() {
    this.filter = new box2d.b2Filter
}, box2d.b2FixtureDef.prototype.shape = null, box2d.b2FixtureDef.prototype.userData = null, box2d.b2FixtureDef.prototype.friction = .2, box2d.b2FixtureDef.prototype.restitution = 0, box2d.b2FixtureDef.prototype.density = 0, box2d.b2FixtureDef.prototype.isSensor = !1, box2d.b2FixtureDef.prototype.filter = null, box2d.b2FixtureProxy = function() {
    this.aabb = new box2d.b2AABB
}, box2d.b2FixtureProxy.prototype.aabb = null, box2d.b2FixtureProxy.prototype.fixture = null, box2d.b2FixtureProxy.prototype.childIndex = 0, box2d.b2FixtureProxy.prototype.proxy = null, box2d.b2FixtureProxy.MakeArray = function(t) {
    return box2d.b2MakeArray(t, function(t) {
        return new box2d.b2FixtureProxy
    })
}, box2d.b2Fixture = function() {
    this.m_proxyCount = 0, this.m_filter = new box2d.b2Filter
}, box2d.b2Fixture.prototype.m_density = 0, box2d.b2Fixture.prototype.m_next = null, box2d.b2Fixture.prototype.m_body = null, box2d.b2Fixture.prototype.m_shape = null, box2d.b2Fixture.prototype.m_friction = 0, box2d.b2Fixture.prototype.m_restitution = 0, box2d.b2Fixture.prototype.m_proxies = null, box2d.b2Fixture.prototype.m_proxyCount = 0, box2d.b2Fixture.prototype.m_filter = null, box2d.b2Fixture.prototype.m_isSensor = !1, box2d.b2Fixture.prototype.m_userData = null, box2d.b2Fixture.prototype.GetType = function() {
    return this.m_shape.GetType()
}, box2d.b2Fixture.prototype.GetShape = function() {
    return this.m_shape
}, box2d.b2Fixture.prototype.IsSensor = function() {
    return this.m_isSensor
}, box2d.b2Fixture.prototype.GetFilterData = function() {
    return this.m_filter
}, box2d.b2Fixture.prototype.GetUserData = function() {
    return this.m_userData
}, box2d.b2Fixture.prototype.SetUserData = function(t) {
    this.m_userData = t
}, box2d.b2Fixture.prototype.GetBody = function() {
    return this.m_body
}, box2d.b2Fixture.prototype.GetNext = function() {
    return this.m_next
}, box2d.b2Fixture.prototype.SetDensity = function(t) {
    this.m_density = t
}, box2d.b2Fixture.prototype.GetDensity = function() {
    return this.m_density
}, box2d.b2Fixture.prototype.GetFriction = function() {
    return this.m_friction
}, box2d.b2Fixture.prototype.SetFriction = function(t) {
    this.m_friction = t
}, box2d.b2Fixture.prototype.GetRestitution = function() {
    return this.m_restitution
}, box2d.b2Fixture.prototype.SetRestitution = function(t) {
    this.m_restitution = t
}, box2d.b2Fixture.prototype.TestPoint = function(t) {
    return this.m_shape.TestPoint(this.m_body.GetTransform(), t)
}, box2d.b2Fixture.prototype.RayCast = function(t, e, i) {
    return this.m_shape.RayCast(t, e, this.m_body.GetTransform(), i)
}, box2d.b2Fixture.prototype.GetMassData = function(t) {
    return t = t || new box2d.b2MassData, this.m_shape.ComputeMass(t, this.m_density), t
}, box2d.b2Fixture.prototype.GetAABB = function(t) {
    return this.m_proxies[t].aabb
}, box2d.b2Fixture.prototype.Create = function(t, e) {
    this.m_userData = e.userData, this.m_friction = e.friction, this.m_restitution = e.restitution, this.m_body = t, this.m_next = null, this.m_filter.Copy(e.filter), this.m_isSensor = e.isSensor, this.m_shape = e.shape.Clone(), this.m_proxies = box2d.b2FixtureProxy.MakeArray(this.m_shape.GetChildCount()), this.m_proxyCount = 0, this.m_density = e.density
}, box2d.b2Fixture.prototype.Destroy = function() {
    this.m_shape = null
}, box2d.b2Fixture.prototype.CreateProxies = function(t, e) {
    this.m_proxyCount = this.m_shape.GetChildCount();
    for (var i = 0; i < this.m_proxyCount; ++i) {
        var o = this.m_proxies[i];
        this.m_shape.ComputeAABB(o.aabb, e, i), o.proxy = t.CreateProxy(o.aabb, o), o.fixture = this, o.childIndex = i
    }
}, box2d.b2Fixture.prototype.DestroyProxies = function(t) {
    for (var e = 0; e < this.m_proxyCount; ++e) {
        var i = this.m_proxies[e];
        t.DestroyProxy(i.proxy), i.proxy = null
    }
    this.m_proxyCount = 0
}, box2d.b2Fixture.prototype.Synchronize = function(t, e, i) {
    if (0 !== this.m_proxyCount)
        for (var o = 0; o < this.m_proxyCount; ++o) {
            var s = this.m_proxies[o],
                n = box2d.b2Fixture.prototype.Synchronize.s_aabb1,
                r = box2d.b2Fixture.prototype.Synchronize.s_aabb2;
            this.m_shape.ComputeAABB(n, e, o), this.m_shape.ComputeAABB(r, i, o), s.aabb.Combine2(n, r);
            var a = box2d.b2SubVV(i.p, e.p, box2d.b2Fixture.prototype.Synchronize.s_displacement);
            t.MoveProxy(s.proxy, s.aabb, a)
        }
}, box2d.b2Fixture.prototype.Synchronize.s_aabb1 = new box2d.b2AABB, box2d.b2Fixture.prototype.Synchronize.s_aabb2 = new box2d.b2AABB, box2d.b2Fixture.prototype.Synchronize.s_displacement = new box2d.b2Vec2, box2d.b2Fixture.prototype.SetFilterData = function(t) {
    this.m_filter.Copy(t), this.Refilter()
}, box2d.b2Fixture.prototype.Refilter = function() {
    if (!this.m_body) {
        for (var t = this.m_body.GetContactList(); t;) {
            var e = t.contact,
                i = e.GetFixtureA(),
                o = e.GetFixtureB();
            i !== this && o !== this || e.FlagForFiltering(), t = t.next
        }
        var s = this.m_body.GetWorld();
        if (null !== s)
            for (var n = s.m_contactManager.m_broadPhase, r = 0; r < this.m_proxyCount; ++r) n.TouchProxy(this.m_proxies[r].proxy)
    }
}, box2d.b2Fixture.prototype.SetSensor = function(t) {
    t !== this.m_isSensor && (this.m_body.SetAwake(!0), this.m_isSensor = t)
}, box2d.b2Fixture.prototype.Dump = function(t) {}, goog.provide("box2d.b2Body"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Fixture"), box2d.b2BodyType = {
    b2_unknown: -1,
    b2_staticBody: 0,
    b2_kinematicBody: 1,
    b2_dynamicBody: 2,
    b2_bulletBody: 3
}, goog.exportProperty(box2d.b2BodyType, "b2_unknown", box2d.b2BodyType.b2_unknown), goog.exportProperty(box2d.b2BodyType, "b2_staticBody", box2d.b2BodyType.b2_staticBody), goog.exportProperty(box2d.b2BodyType, "b2_kinematicBody", box2d.b2BodyType.b2_kinematicBody), goog.exportProperty(box2d.b2BodyType, "b2_dynamicBody", box2d.b2BodyType.b2_dynamicBody), goog.exportProperty(box2d.b2BodyType, "b2_bulletBody", box2d.b2BodyType.b2_bulletBody), box2d.b2BodyDef = function() {
    this.position = new box2d.b2Vec2(0, 0), this.linearVelocity = new box2d.b2Vec2(0, 0)
}, box2d.b2BodyDef.prototype.type = box2d.b2BodyType.b2_staticBody, box2d.b2BodyDef.prototype.position = null, box2d.b2BodyDef.prototype.angle = 0, box2d.b2BodyDef.prototype.linearVelocity = null, box2d.b2BodyDef.prototype.angularVelocity = 0, box2d.b2BodyDef.prototype.linearDamping = 0, box2d.b2BodyDef.prototype.angularDamping = 0, box2d.b2BodyDef.prototype.allowSleep = !0, box2d.b2BodyDef.prototype.awake = !0, box2d.b2BodyDef.prototype.fixedRotation = !1, box2d.b2BodyDef.prototype.bullet = !1, box2d.b2BodyDef.prototype.active = !0, box2d.b2BodyDef.prototype.userData = null, box2d.b2BodyDef.prototype.gravityScale = 1, box2d.b2BodyFlag = {
    e_none: 0,
    e_islandFlag: 1,
    e_awakeFlag: 2,
    e_autoSleepFlag: 4,
    e_bulletFlag: 8,
    e_fixedRotationFlag: 16,
    e_activeFlag: 32,
    e_toiFlag: 64
}, goog.exportProperty(box2d.b2BodyFlag, "e_none", box2d.b2BodyFlag.e_none), goog.exportProperty(box2d.b2BodyFlag, "e_islandFlag", box2d.b2BodyFlag.e_islandFlag), goog.exportProperty(box2d.b2BodyFlag, "e_awakeFlag", box2d.b2BodyFlag.e_awakeFlag), goog.exportProperty(box2d.b2BodyFlag, "e_autoSleepFlag", box2d.b2BodyFlag.e_autoSleepFlag), goog.exportProperty(box2d.b2BodyFlag, "e_bulletFlag", box2d.b2BodyFlag.e_bulletFlag), goog.exportProperty(box2d.b2BodyFlag, "e_fixedRotationFlag", box2d.b2BodyFlag.e_fixedRotationFlag), goog.exportProperty(box2d.b2BodyFlag, "e_activeFlag", box2d.b2BodyFlag.e_activeFlag), goog.exportProperty(box2d.b2BodyFlag, "e_toiFlag", box2d.b2BodyFlag.e_toiFlag), box2d.b2Body = function(t, e) {
    this.m_xf = new box2d.b2Transform, this.m_out_xf = new box2d.b2Transform, this.m_sweep = new box2d.b2Sweep, this.m_out_sweep = new box2d.b2Sweep, this.m_linearVelocity = new box2d.b2Vec2, this.m_out_linearVelocity = new box2d.b2Vec2, this.m_force = new box2d.b2Vec2, this.m_flags = box2d.b2BodyFlag.e_none, t.bullet && (this.m_flags |= box2d.b2BodyFlag.e_bulletFlag), t.fixedRotation && (this.m_flags |= box2d.b2BodyFlag.e_fixedRotationFlag), t.allowSleep && (this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag), t.awake && (this.m_flags |= box2d.b2BodyFlag.e_awakeFlag), t.active && (this.m_flags |= box2d.b2BodyFlag.e_activeFlag), this.m_world = e, this.m_xf.p.Copy(t.position), this.m_xf.q.SetAngleRadians(t.angle), this.m_sweep.localCenter.SetZero(), this.m_sweep.c0.Copy(this.m_xf.p), this.m_sweep.c.Copy(this.m_xf.p), this.m_sweep.a0 = t.angle, this.m_sweep.a = t.angle, this.m_sweep.alpha0 = 0, this.m_linearVelocity.Copy(t.linearVelocity), this.m_angularVelocity = t.angularVelocity, this.m_linearDamping = t.linearDamping, this.m_angularDamping = t.angularDamping, this.m_gravityScale = t.gravityScale, this.m_force.SetZero(), this.m_torque = 0, this.m_sleepTime = 0, this.m_type = t.type, t.type === box2d.b2BodyType.b2_dynamicBody ? (this.m_mass = 1, this.m_invMass = 1) : (this.m_mass = 0, this.m_invMass = 0), this.m_I = 0, this.m_invI = 0, this.m_userData = t.userData, this.m_fixtureList = null, this.m_fixtureCount = 0, this.m_controllerList = null, this.m_controllerCount = 0
}, box2d.b2Body.prototype.m_flags = box2d.b2BodyFlag.e_none, box2d.b2Body.prototype.m_islandIndex = 0, box2d.b2Body.prototype.m_world = null, box2d.b2Body.prototype.m_xf = null, box2d.b2Body.prototype.m_out_xf = null, box2d.b2Body.prototype.m_sweep = null, box2d.b2Body.prototype.m_out_sweep = null, box2d.b2Body.prototype.m_jointList = null, box2d.b2Body.prototype.m_contactList = null, box2d.b2Body.prototype.m_prev = null, box2d.b2Body.prototype.m_next = null, box2d.b2Body.prototype.m_linearVelocity = null, box2d.b2Body.prototype.m_out_linearVelocity = null, box2d.b2Body.prototype.m_angularVelocity = 0, box2d.b2Body.prototype.m_linearDamping = 0, box2d.b2Body.prototype.m_angularDamping = 0, box2d.b2Body.prototype.m_gravityScale = 1, box2d.b2Body.prototype.m_force = null, box2d.b2Body.prototype.m_torque = 0, box2d.b2Body.prototype.m_sleepTime = 0, box2d.b2Body.prototype.m_type = box2d.b2BodyType.b2_staticBody, box2d.b2Body.prototype.m_mass = 1, box2d.b2Body.prototype.m_invMass = 1, box2d.b2Body.prototype.m_I = 0, box2d.b2Body.prototype.m_invI = 0, box2d.b2Body.prototype.m_userData = null, box2d.b2Body.prototype.m_fixtureList = null, box2d.b2Body.prototype.m_fixtureCount = 0, box2d.b2Body.prototype.m_controllerList = null, box2d.b2Body.prototype.m_controllerCount = 0, box2d.b2Body.prototype.CreateFixture = function(t) {
    if (!0 === this.m_world.IsLocked()) return null;
    var e = new box2d.b2Fixture;
    if (e.Create(this, t), this.m_flags & box2d.b2BodyFlag.e_activeFlag) {
        var i = this.m_world.m_contactManager.m_broadPhase;
        e.CreateProxies(i, this.m_xf)
    }
    return e.m_next = this.m_fixtureList, this.m_fixtureList = e, ++this.m_fixtureCount, e.m_body = this, e.m_density > 0 && this.ResetMassData(), this.m_world.m_flags |= box2d.b2WorldFlag.e_newFixture, e
}, box2d.b2Body.prototype.CreateFixture2 = function(t, e) {
    void 0 === e && (e = 0);
    var i = box2d.b2Body.prototype.CreateFixture2.s_def;
    return i.shape = t, i.density = e, this.CreateFixture(i)
}, box2d.b2Body.prototype.CreateFixture2.s_def = new box2d.b2FixtureDef, box2d.b2Body.prototype.DestroyFixture = function(t) {
    if (!0 !== this.m_world.IsLocked()) {
        for (var e = this.m_fixtureList, i = null; null !== e;) {
            if (e === t) {
                i ? i.m_next = t.m_next : this.m_fixtureList = t.m_next, !0;
                break
            }
            i = e, e = e.m_next
        }
        for (var o = this.m_contactList; o;) {
            var s = o.contact;
            o = o.next;
            var n = s.GetFixtureA(),
                r = s.GetFixtureB();
            t !== n && t !== r || this.m_world.m_contactManager.Destroy(s)
        }
        if (this.m_flags & box2d.b2BodyFlag.e_activeFlag) {
            var a = this.m_world.m_contactManager.m_broadPhase;
            t.DestroyProxies(a)
        }
        t.Destroy(), t.m_body = null, t.m_next = null, --this.m_fixtureCount, this.ResetMassData()
    }
}, box2d.b2Body.prototype.SetTransformVecRadians = function(t, e) {
    this.SetTransformXYRadians(t.x, t.y, e)
}, box2d.b2Body.prototype.SetTransformXYRadians = function(t, e, i) {
    if (!0 !== this.m_world.IsLocked() && (this.m_xf.p.x !== t || this.m_xf.p.y !== e || this.m_xf.q.GetAngleRadians() !== i)) {
        this.m_xf.q.SetAngleRadians(i), this.m_xf.p.SetXY(t, e), box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c), this.m_sweep.a = i, this.m_sweep.c0.Copy(this.m_sweep.c), this.m_sweep.a0 = i;
        for (var o = this.m_world.m_contactManager.m_broadPhase, s = this.m_fixtureList; s; s = s.m_next) s.Synchronize(o, this.m_xf, this.m_xf)
    }
}, box2d.b2Body.prototype.SetTransform = function(t) {
    this.SetTransformVecRadians(t.p, t.GetAngleRadians())
}, box2d.b2Body.prototype.GetTransform = function(t) {
    return t = t || this.m_out_xf, t.Copy(this.m_xf)
}, box2d.b2Body.prototype.GetPosition = function(t) {
    return t = t || this.m_out_xf.p, t.Copy(this.m_xf.p)
}, box2d.b2Body.prototype.SetPosition = function(t) {
    this.SetTransformVecRadians(t, this.GetAngleRadians())
}, box2d.b2Body.prototype.SetPositionXY = function(t, e) {
    this.SetTransformXYRadians(t, e, this.GetAngleRadians())
}, box2d.b2Body.prototype.GetAngle = function() {
    return this.m_sweep.a
}, box2d.b2Body.prototype.GetAngleRadians = box2d.b2Body.prototype.GetAngle, box2d.b2Body.prototype.GetAngleDegrees = function() {
    return box2d.b2RadToDeg(this.GetAngle())
}, box2d.b2Body.prototype.SetAngle = function(t) {
    this.SetTransformVecRadians(this.GetPosition(), t)
}, box2d.b2Body.prototype.SetAngleRadians = box2d.b2Body.prototype.SetAngle, box2d.b2Body.prototype.SetAngleDegrees = function(t) {
    this.SetAngle(box2d.b2DegToRad(t))
}, box2d.b2Body.prototype.GetWorldCenter = function(t) {
    return t = t || this.m_out_sweep.c, t.Copy(this.m_sweep.c)
}, box2d.b2Body.prototype.GetLocalCenter = function(t) {
    return t = t || this.m_out_sweep.localCenter, t.Copy(this.m_sweep.localCenter)
}, box2d.b2Body.prototype.SetLinearVelocity = function(t) {
    this.m_type !== box2d.b2BodyType.b2_staticBody && (box2d.b2DotVV(t, t) > 0 && this.SetAwake(!0), this.m_linearVelocity.Copy(t))
}, box2d.b2Body.prototype.GetLinearVelocity = function(t) {
    return t = t || this.m_out_linearVelocity, t.Copy(this.m_linearVelocity)
}, box2d.b2Body.prototype.SetAngularVelocity = function(t) {
    this.m_type !== box2d.b2BodyType.b2_staticBody && (t * t > 0 && this.SetAwake(!0), this.m_angularVelocity = t)
}, box2d.b2Body.prototype.GetAngularVelocity = function() {
    return this.m_angularVelocity
}, box2d.b2Body.prototype.GetDefinition = function(t) {
    return t.type = this.GetType(), t.allowSleep = (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) === box2d.b2BodyFlag.e_autoSleepFlag, t.angle = this.GetAngleRadians(), t.angularDamping = this.m_angularDamping, t.gravityScale = this.m_gravityScale, t.angularVelocity = this.m_angularVelocity, t.fixedRotation = (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag, t.bullet = (this.m_flags & box2d.b2BodyFlag.e_bulletFlag) === box2d.b2BodyFlag.e_bulletFlag, t.awake = (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === box2d.b2BodyFlag.e_awakeFlag, t.linearDamping = this.m_linearDamping, t.linearVelocity.Copy(this.GetLinearVelocity()), t.position.Copy(this.GetPosition()), t.userData = this.GetUserData(), t
}, box2d.b2Body.prototype.ApplyForce = function(t, e, i) {
    i = i || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (i && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_force.x += t.x, this.m_force.y += t.y, this.m_torque += (e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x))
}, box2d.b2Body.prototype.ApplyForceToCenter = function(t, e) {
    e = e || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (e && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_force.x += t.x, this.m_force.y += t.y))
}, box2d.b2Body.prototype.ApplyTorque = function(t, e) {
    e = e || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (e && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_torque += t))
}, box2d.b2Body.prototype.ApplyLinearImpulse = function(t, e, i) {
    i = i || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (i && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_linearVelocity.x += this.m_invMass * t.x, this.m_linearVelocity.y += this.m_invMass * t.y, this.m_angularVelocity += this.m_invI * ((e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x)))
}, box2d.b2Body.prototype.ApplyAngularImpulse = function(t, e) {
    e = e || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (e && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_angularVelocity += this.m_invI * t))
}, box2d.b2Body.prototype.GetMass = function() {
    return this.m_mass
}, box2d.b2Body.prototype.GetInertia = function() {
    return this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter)
}, box2d.b2Body.prototype.GetMassData = function(t) {
    return t.mass = this.m_mass, t.I = this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter), t.center.Copy(this.m_sweep.localCenter), t
}, box2d.b2Body.prototype.SetMassData = function(t) {
    if (!0 !== this.m_world.IsLocked() && this.m_type === box2d.b2BodyType.b2_dynamicBody) {
        this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_mass = t.mass, this.m_mass <= 0 && (this.m_mass = 1), this.m_invMass = 1 / this.m_mass, t.I > 0 && 0 == (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) && (this.m_I = t.I - this.m_mass * box2d.b2DotVV(t.center, t.center), this.m_invI = 1 / this.m_I);
        var e = box2d.b2Body.prototype.SetMassData.s_oldCenter.Copy(this.m_sweep.c);
        this.m_sweep.localCenter.Copy(t.center), box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c), this.m_sweep.c0.Copy(this.m_sweep.c), box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, e, box2d.b2Vec2.s_t0), this.m_linearVelocity)
    }
}, box2d.b2Body.prototype.SetMassData.s_oldCenter = new box2d.b2Vec2, box2d.b2Body.prototype.ResetMassData = function() {
    if (this.m_mass = 0, this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_sweep.localCenter.SetZero(), this.m_type === box2d.b2BodyType.b2_staticBody || this.m_type === box2d.b2BodyType.b2_kinematicBody) return this.m_sweep.c0.Copy(this.m_xf.p), this.m_sweep.c.Copy(this.m_xf.p), void(this.m_sweep.a0 = this.m_sweep.a);
    for (var t = box2d.b2Body.prototype.ResetMassData.s_localCenter.SetZero(), e = this.m_fixtureList; e; e = e.m_next)
        if (0 !== e.m_density) {
            var i = e.GetMassData(box2d.b2Body.prototype.ResetMassData.s_massData);
            this.m_mass += i.mass, t.x += i.center.x * i.mass, t.y += i.center.y * i.mass, this.m_I += i.I
        }
    this.m_mass > 0 ? (this.m_invMass = 1 / this.m_mass, t.x *= this.m_invMass, t.y *= this.m_invMass) : (this.m_mass = 1, this.m_invMass = 1), this.m_I > 0 && 0 == (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * box2d.b2DotVV(t, t), this.m_invI = 1 / this.m_I) : (this.m_I = 0, this.m_invI = 0);
    var o = box2d.b2Body.prototype.ResetMassData.s_oldCenter.Copy(this.m_sweep.c);
    this.m_sweep.localCenter.Copy(t), box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c), this.m_sweep.c0.Copy(this.m_sweep.c), box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, o, box2d.b2Vec2.s_t0), this.m_linearVelocity)
}, box2d.b2Body.prototype.ResetMassData.s_localCenter = new box2d.b2Vec2, box2d.b2Body.prototype.ResetMassData.s_oldCenter = new box2d.b2Vec2, box2d.b2Body.prototype.ResetMassData.s_massData = new box2d.b2MassData, box2d.b2Body.prototype.GetWorldPoint = function(t, e) {
    return box2d.b2MulXV(this.m_xf, t, e)
}, box2d.b2Body.prototype.GetWorldVector = function(t, e) {
    return box2d.b2MulRV(this.m_xf.q, t, e)
}, box2d.b2Body.prototype.GetLocalPoint = function(t, e) {
    return box2d.b2MulTXV(this.m_xf, t, e)
}, box2d.b2Body.prototype.GetLocalVector = function(t, e) {
    return box2d.b2MulTRV(this.m_xf.q, t, e)
}, box2d.b2Body.prototype.GetLinearVelocityFromWorldPoint = function(t, e) {
    return box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(t, this.m_sweep.c, box2d.b2Vec2.s_t0), e)
}, box2d.b2Body.prototype.GetLinearVelocityFromLocalPoint = function(t, e) {
    return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(t, e), e)
}, box2d.b2Body.prototype.GetLinearDamping = function() {
    return this.m_linearDamping
}, box2d.b2Body.prototype.SetLinearDamping = function(t) {
    this.m_linearDamping = t
}, box2d.b2Body.prototype.GetAngularDamping = function() {
    return this.m_angularDamping
}, box2d.b2Body.prototype.SetAngularDamping = function(t) {
    this.m_angularDamping = t
}, box2d.b2Body.prototype.GetGravityScale = function() {
    return this.m_gravityScale
}, box2d.b2Body.prototype.SetGravityScale = function(t) {
    this.m_gravityScale = t
}, box2d.b2Body.prototype.SetType = function(t) {
    if (!0 !== this.m_world.IsLocked() && this.m_type !== t) {
        this.m_type = t, this.ResetMassData(), this.m_type === box2d.b2BodyType.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_sweep.a0 = this.m_sweep.a, this.m_sweep.c0.Copy(this.m_sweep.c), this.SynchronizeFixtures()), this.SetAwake(!0), this.m_force.SetZero(), this.m_torque = 0;
        for (var e = this.m_contactList; e;) {
            var i = e;
            e = e.next, this.m_world.m_contactManager.Destroy(i.contact)
        }
        this.m_contactList = null;
        for (var o = this.m_world.m_contactManager.m_broadPhase, s = this.m_fixtureList; s; s = s.m_next)
            for (var n = s.m_proxyCount, r = 0; r < n; ++r) o.TouchProxy(s.m_proxies[r].proxy)
    }
}, box2d.b2Body.prototype.GetType = function() {
    return this.m_type
}, box2d.b2Body.prototype.SetBullet = function(t) {
    t ? this.m_flags |= box2d.b2BodyFlag.e_bulletFlag : this.m_flags &= ~box2d.b2BodyFlag.e_bulletFlag
}, box2d.b2Body.prototype.IsBullet = function() {
    return (this.m_flags & box2d.b2BodyFlag.e_bulletFlag) === box2d.b2BodyFlag.e_bulletFlag
}, box2d.b2Body.prototype.SetSleepingAllowed = function(t) {
    t ? this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag : (this.m_flags &= ~box2d.b2BodyFlag.e_autoSleepFlag, this.SetAwake(!0))
}, box2d.b2Body.prototype.IsSleepingAllowed = function() {
    return (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) === box2d.b2BodyFlag.e_autoSleepFlag
}, box2d.b2Body.prototype.SetAwake = function(t) {
    t ? 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && (this.m_flags |= box2d.b2BodyFlag.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~box2d.b2BodyFlag.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0)
}, box2d.b2Body.prototype.IsAwake = function() {
    return (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === box2d.b2BodyFlag.e_awakeFlag
}, box2d.b2Body.prototype.SetActive = function(t) {
    if (t !== this.IsActive())
        if (t) {
            this.m_flags |= box2d.b2BodyFlag.e_activeFlag;
            for (var e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.CreateProxies(e, this.m_xf)
        } else {
            this.m_flags &= ~box2d.b2BodyFlag.e_activeFlag;
            for (var e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.DestroyProxies(e);
            for (var o = this.m_contactList; o;) {
                var s = o;
                o = o.next, this.m_world.m_contactManager.Destroy(s.contact)
            }
            this.m_contactList = null
        }
}, box2d.b2Body.prototype.IsActive = function() {
    return (this.m_flags & box2d.b2BodyFlag.e_activeFlag) === box2d.b2BodyFlag.e_activeFlag
}, box2d.b2Body.prototype.SetFixedRotation = function(t) {
    (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag !== t && (t ? this.m_flags |= box2d.b2BodyFlag.e_fixedRotationFlag : this.m_flags &= ~box2d.b2BodyFlag.e_fixedRotationFlag, this.m_angularVelocity = 0, this.ResetMassData())
}, box2d.b2Body.prototype.IsFixedRotation = function() {
    return (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag
}, box2d.b2Body.prototype.GetFixtureList = function() {
    return this.m_fixtureList
}, box2d.b2Body.prototype.GetJointList = function() {
    return this.m_jointList
}, box2d.b2Body.prototype.GetContactList = function() {
    return this.m_contactList
}, box2d.b2Body.prototype.GetNext = function() {
    return this.m_next
}, box2d.b2Body.prototype.GetUserData = function() {
    return this.m_userData
}, box2d.b2Body.prototype.SetUserData = function(t) {
    this.m_userData = t
};
box2d.b2Body.prototype.GetWorld = function() {
    return this.m_world
}, box2d.b2Body.prototype.SynchronizeFixtures = function() {
    var t = box2d.b2Body.prototype.SynchronizeFixtures.s_xf1;
    t.q.SetAngleRadians(this.m_sweep.a0), box2d.b2MulRV(t.q, this.m_sweep.localCenter, t.p), box2d.b2SubVV(this.m_sweep.c0, t.p, t.p);
    for (var e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.Synchronize(e, t, this.m_xf)
}, box2d.b2Body.prototype.SynchronizeFixtures.s_xf1 = new box2d.b2Transform, box2d.b2Body.prototype.SynchronizeTransform = function() {
    this.m_xf.q.SetAngleRadians(this.m_sweep.a), box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p), box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p)
}, box2d.b2Body.prototype.ShouldCollide = function(t) {
    if (this.m_type !== box2d.b2BodyType.b2_dynamicBody && t.m_type !== box2d.b2BodyType.b2_dynamicBody) return !1;
    for (var e = this.m_jointList; e; e = e.next)
        if (e.other === t && !1 === e.joint.m_collideConnected) return !1;
    return !0
}, box2d.b2Body.prototype.Advance = function(t) {
    this.m_sweep.Advance(t), this.m_sweep.c.Copy(this.m_sweep.c0), this.m_sweep.a = this.m_sweep.a0, this.m_xf.q.SetAngleRadians(this.m_sweep.a), box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p), box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p)
}, box2d.b2Body.prototype.Dump = function() {}, box2d.b2Body.prototype.GetControllerList = function() {
    return this.m_controllerList
}, box2d.b2Body.prototype.GetControllerCount = function() {
    return this.m_controllerCount
}, goog.provide("box2d.b2World"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Draw"), goog.require("box2d.b2ContactManager"), goog.require("box2d.b2ContactSolver"), goog.require("box2d.b2Island"), goog.require("box2d.b2Body"), goog.require("box2d.b2Math"), goog.require("box2d.b2Collision"), goog.require("box2d.b2TimeStep"), goog.require("box2d.b2WorldCallbacks"), goog.require("box2d.b2JointFactory"), box2d.b2WorldFlag = {
    e_none: 0,
    e_newFixture: 1,
    e_locked: 2,
    e_clearForces: 4
}, goog.exportProperty(box2d.b2WorldFlag, "e_none", box2d.b2WorldFlag.e_none), goog.exportProperty(box2d.b2WorldFlag, "e_newFixture", box2d.b2WorldFlag.e_newFixture), goog.exportProperty(box2d.b2WorldFlag, "e_locked", box2d.b2WorldFlag.e_locked), goog.exportProperty(box2d.b2WorldFlag, "e_clearForces", box2d.b2WorldFlag.e_clearForces), box2d.b2World = function(t) {
    this.m_flags = box2d.b2WorldFlag.e_clearForces, this.m_contactManager = new box2d.b2ContactManager, this.m_gravity = t.Clone(), this.m_out_gravity = new box2d.b2Vec2, this.m_allowSleep = !0, this.m_destructionListener = null, this.m_debugDraw = null, this.m_warmStarting = !0, this.m_continuousPhysics = !0, this.m_subStepping = !1, this.m_stepComplete = !0, this.m_island = new box2d.b2Island, this.s_stack = new Array
}, box2d.b2World.prototype.m_flags = box2d.b2WorldFlag.e_none, box2d.b2World.prototype.m_contactManager = null, box2d.b2World.prototype.m_bodyList = null, box2d.b2World.prototype.m_jointList = null, box2d.b2World.prototype.m_bodyCount = 0, box2d.b2World.prototype.m_jointCount = 0, box2d.b2World.prototype.m_gravity = null, box2d.b2World.prototype.m_out_gravity = null, box2d.b2World.prototype.m_allowSleep = !0, box2d.b2World.prototype.m_destructionListener = null, box2d.b2World.prototype.m_debugDraw = null, box2d.b2World.prototype.m_inv_dt0 = 0, box2d.b2World.prototype.m_warmStarting = !0, box2d.b2World.prototype.m_continuousPhysics = !0, box2d.b2World.prototype.m_subStepping = !1, box2d.b2World.prototype.m_stepComplete = !0, box2d.b2World.prototype.m_island = null, box2d.b2World.prototype.s_stack = null, box2d.b2World.prototype.m_controllerList = null, box2d.b2World.prototype.m_controllerCount = 0, box2d.b2World.prototype.SetAllowSleeping = function(t) {
    if (t !== this.m_allowSleep && (this.m_allowSleep = t, !1 === this.m_allowSleep))
        for (var e = this.m_bodyList; e; e = e.m_next) e.SetAwake(!0)
}, box2d.b2World.prototype.GetAllowSleeping = function() {
    return this.m_allowSleep
}, box2d.b2World.prototype.SetWarmStarting = function(t) {
    this.m_warmStarting = t
}, box2d.b2World.prototype.GetWarmStarting = function() {
    return this.m_warmStarting
}, box2d.b2World.prototype.SetContinuousPhysics = function(t) {
    this.m_continuousPhysics = t
}, box2d.b2World.prototype.GetContinuousPhysics = function() {
    return this.m_continuousPhysics
}, box2d.b2World.prototype.SetSubStepping = function(t) {
    this.m_subStepping = t
}, box2d.b2World.prototype.GetSubStepping = function() {
    return this.m_subStepping
}, box2d.b2World.prototype.GetBodyList = function() {
    return this.m_bodyList
}, box2d.b2World.prototype.GetJointList = function() {
    return this.m_jointList
}, box2d.b2World.prototype.GetContactList = function() {
    return this.m_contactManager.m_contactList
}, box2d.b2World.prototype.GetBodyCount = function() {
    return this.m_bodyCount
}, box2d.b2World.prototype.GetJointCount = function() {
    return this.m_jointCount
}, box2d.b2World.prototype.GetContactCount = function() {
    return this.m_contactManager.m_contactCount
}, box2d.b2World.prototype.SetGravity = function(t, e) {
    if (e = e || !0, (this.m_gravity.x !== t.x || this.m_gravity.y !== t.y) && (this.m_gravity.Copy(t), e))
        for (var i = this.m_bodyList; i; i = i.m_next) i.SetAwake(!0)
}, box2d.b2World.prototype.GetGravity = function(t) {
    return t = t || this.m_out_gravity, t.Copy(this.m_gravity)
}, box2d.b2World.prototype.IsLocked = function() {
    return (this.m_flags & box2d.b2WorldFlag.e_locked) > 0
}, box2d.b2World.prototype.SetAutoClearForces = function(t) {
    t ? this.m_flags |= box2d.b2WorldFlag.e_clearForces : this.m_flags &= ~box2d.b2WorldFlag.e_clearForces
}, box2d.b2World.prototype.GetAutoClearForces = function() {
    return (this.m_flags & box2d.b2WorldFlag.e_clearForces) === box2d.b2WorldFlag.e_clearForces
}, box2d.b2World.prototype.GetContactManager = function() {
    return this.m_contactManager
}, box2d.b2World.prototype.SetDestructionListener = function(t) {
    this.m_destructionListener = t
}, box2d.b2World.prototype.SetContactFilter = function(t) {
    this.m_contactManager.m_contactFilter = t
}, box2d.b2World.prototype.SetContactListener = function(t) {
    this.m_contactManager.m_contactListener = t
}, box2d.b2World.prototype.SetDebugDraw = function(t) {
    this.m_debugDraw = t
}, box2d.b2World.prototype.CreateBody = function(t) {
    if (this.IsLocked()) return null;
    var e = new box2d.b2Body(t, this);
    return e.m_prev = null, e.m_next = this.m_bodyList, this.m_bodyList && (this.m_bodyList.m_prev = e), this.m_bodyList = e, ++this.m_bodyCount, e
}, box2d.b2World.prototype.DestroyBody = function(t) {
    if (!this.IsLocked()) {
        for (var e = t.m_jointList; e;) {
            var i = e;
            e = e.next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(i.joint), this.DestroyJoint(i.joint), t.m_jointList = e
        }
        t.m_jointList = null;
        for (var o = t.m_controllerList; o;) {
            var s = o;
            o = o.nextController, s.controller.RemoveBody(t)
        }
        for (var n = t.m_contactList; n;) {
            var r = n;
            n = n.next, this.m_contactManager.Destroy(r.contact)
        }
        t.m_contactList = null;
        for (var a = t.m_fixtureList; a;) {
            var h = a;
            a = a.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(h), h.DestroyProxies(this.m_contactManager.m_broadPhase), h.Destroy(), t.m_fixtureList = a, t.m_fixtureCount -= 1
        }
        t.m_fixtureList = null, t.m_fixtureCount = 0, t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t === this.m_bodyList && (this.m_bodyList = t.m_next), --this.m_bodyCount
    }
}, box2d.b2World.prototype.CreateJoint = function(t) {
    if (this.IsLocked()) return null;
    var e = box2d.b2JointFactory.Create(t, null);
    e.m_prev = null, e.m_next = this.m_jointList, this.m_jointList && (this.m_jointList.m_prev = e), this.m_jointList = e, ++this.m_jointCount, e.m_edgeA.joint = e, e.m_edgeA.other = e.m_bodyB, e.m_edgeA.prev = null, e.m_edgeA.next = e.m_bodyA.m_jointList, e.m_bodyA.m_jointList && (e.m_bodyA.m_jointList.prev = e.m_edgeA), e.m_bodyA.m_jointList = e.m_edgeA, e.m_edgeB.joint = e, e.m_edgeB.other = e.m_bodyA, e.m_edgeB.prev = null, e.m_edgeB.next = e.m_bodyB.m_jointList, e.m_bodyB.m_jointList && (e.m_bodyB.m_jointList.prev = e.m_edgeB), e.m_bodyB.m_jointList = e.m_edgeB;
    var i = t.bodyA,
        o = t.bodyB;
    if (!1 === t.collideConnected)
        for (var s = o.GetContactList(); s;) s.other === i && s.contact.FlagForFiltering(), s = s.next;
    return e
}, box2d.b2World.prototype.DestroyJoint = function(t) {
    if (!this.IsLocked()) {
        var e = t.m_collideConnected;
        t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t === this.m_jointList && (this.m_jointList = t.m_next);
        var i = t.m_bodyA,
            o = t.m_bodyB;
        if (i.SetAwake(!0), o.SetAwake(!0), t.m_edgeA.prev && (t.m_edgeA.prev.next = t.m_edgeA.next), t.m_edgeA.next && (t.m_edgeA.next.prev = t.m_edgeA.prev), t.m_edgeA === i.m_jointList && (i.m_jointList = t.m_edgeA.next), t.m_edgeA.prev = null, t.m_edgeA.next = null, t.m_edgeB.prev && (t.m_edgeB.prev.next = t.m_edgeB.next), t.m_edgeB.next && (t.m_edgeB.next.prev = t.m_edgeB.prev), t.m_edgeB === o.m_jointList && (o.m_jointList = t.m_edgeB.next), t.m_edgeB.prev = null, t.m_edgeB.next = null, box2d.b2JointFactory.Destroy(t, null), --this.m_jointCount, !1 === e)
            for (var s = o.GetContactList(); s;) s.other === i && s.contact.FlagForFiltering(), s = s.next
    }
}, box2d.b2World.prototype.Solve = function(t) {
    for (var e = this.m_controllerList; e; e = e.m_next) e.Step(t);
    var i = this.m_island;
    i.Initialize(this.m_bodyCount, this.m_contactManager.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener);
    for (var o = this.m_bodyList; o; o = o.m_next) o.m_flags &= ~box2d.b2BodyFlag.e_islandFlag;
    for (var s = this.m_contactManager.m_contactList; s; s = s.m_next) s.m_flags &= ~box2d.b2ContactFlag.e_islandFlag;
    for (var n = this.m_jointList; n; n = n.m_next) n.m_islandFlag = !1;
    for (var r = (this.m_bodyCount, this.s_stack), a = this.m_bodyList; a; a = a.m_next)
        if (!(a.m_flags & box2d.b2BodyFlag.e_islandFlag) && !1 !== a.IsAwake() && !1 !== a.IsActive() && a.GetType() !== box2d.b2BodyType.b2_staticBody) {
            i.Clear();
            var h = 0;
            for (r[h++] = a, a.m_flags |= box2d.b2BodyFlag.e_islandFlag; h > 0;) {
                var o = r[--h];
                if (i.AddBody(o), o.SetAwake(!0), o.GetType() !== box2d.b2BodyType.b2_staticBody) {
                    for (var l = o.m_contactList; l; l = l.next) {
                        var d = l.contact;
                        if (!(d.m_flags & box2d.b2ContactFlag.e_islandFlag) && (!1 !== d.IsEnabled() && !1 !== d.IsTouching())) {
                            var c = d.m_fixtureA.m_isSensor,
                                p = d.m_fixtureB.m_isSensor;
                            if (!c && !p) {
                                i.AddContact(d), d.m_flags |= box2d.b2ContactFlag.e_islandFlag;
                                var u = l.other;
                                u.m_flags & box2d.b2BodyFlag.e_islandFlag || (r[h++] = u, u.m_flags |= box2d.b2BodyFlag.e_islandFlag)
                            }
                        }
                    }
                    for (var b = o.m_jointList; b; b = b.next)
                        if (!0 !== b.joint.m_islandFlag) {
                            var u = b.other;
                            !1 !== u.IsActive() && (i.AddJoint(b.joint), b.joint.m_islandFlag = !0, u.m_flags & box2d.b2BodyFlag.e_islandFlag || (r[h++] = u, u.m_flags |= box2d.b2BodyFlag.e_islandFlag))
                        }
                }
            }
            i.Solve(t, this.m_gravity, this.m_allowSleep);
            for (var m = 0; m < i.m_bodyCount; ++m) {
                var o = i.m_bodies[m];
                o.GetType() === box2d.b2BodyType.b2_staticBody && (o.m_flags &= ~box2d.b2BodyFlag.e_islandFlag)
            }
        }
    for (var m = 0; m < r.length && r[m]; ++m) r[m] = null;
    for (var o = this.m_bodyList; o; o = o.m_next) 0 != (o.m_flags & box2d.b2BodyFlag.e_islandFlag) && o.GetType() !== box2d.b2BodyType.b2_staticBody && o.SynchronizeFixtures();
    this.m_contactManager.FindNewContacts()
}, box2d.b2World.prototype.SolveTOI = function(t) {
    var e = this.m_island;
    if (e.Initialize(2 * box2d.b2_maxTOIContacts, box2d.b2_maxTOIContacts, 0, null, this.m_contactManager.m_contactListener), this.m_stepComplete) {
        for (var i = this.m_bodyList; i; i = i.m_next) i.m_flags &= ~box2d.b2BodyFlag.e_islandFlag, i.m_sweep.alpha0 = 0;
        for (var o = this.m_contactManager.m_contactList; o; o = o.m_next) o.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag), o.m_toiCount = 0, o.m_toi = 1
    }
    for (;;) {
        for (var s = null, n = 1, o = this.m_contactManager.m_contactList; o; o = o.m_next)
            if (!1 !== o.IsEnabled() && !(o.m_toiCount > box2d.b2_maxSubSteps)) {
                var r = 1;
                if (o.m_flags & box2d.b2ContactFlag.e_toiFlag) r = o.m_toi;
                else {
                    var a = o.GetFixtureA(),
                        h = o.GetFixtureB();
                    if (a.IsSensor() || h.IsSensor()) continue;
                    var l = a.GetBody(),
                        d = h.GetBody(),
                        c = l.m_type,
                        p = d.m_type,
                        u = l.IsAwake() && c !== box2d.b2BodyType.b2_staticBody,
                        b = d.IsAwake() && p !== box2d.b2BodyType.b2_staticBody;
                    if (!1 === u && !1 === b) continue;
                    var m = l.IsBullet() || c !== box2d.b2BodyType.b2_dynamicBody,
                        y = d.IsBullet() || p !== box2d.b2BodyType.b2_dynamicBody;
                    if (!1 === m && !1 === y) continue;
                    var f = l.m_sweep.alpha0;
                    l.m_sweep.alpha0 < d.m_sweep.alpha0 ? (f = d.m_sweep.alpha0, l.m_sweep.Advance(f)) : d.m_sweep.alpha0 < l.m_sweep.alpha0 && (f = l.m_sweep.alpha0, d.m_sweep.Advance(f));
                    var g = o.GetChildIndexA(),
                        x = o.GetChildIndexB(),
                        _ = box2d.b2World.prototype.SolveTOI.s_toi_input;
                    _.proxyA.SetShape(a.GetShape(), g), _.proxyB.SetShape(h.GetShape(), x), _.sweepA.Copy(l.m_sweep), _.sweepB.Copy(d.m_sweep), _.tMax = 1;
                    var v = box2d.b2World.prototype.SolveTOI.s_toi_output;
                    box2d.b2TimeOfImpact(v, _);
                    var w = v.t;
                    r = v.state === box2d.b2TOIOutputState.e_touching ? box2d.b2Min(f + (1 - f) * w, 1) : 1, o.m_toi = r, o.m_flags |= box2d.b2ContactFlag.e_toiFlag
                }
                r < n && (s = o, n = r)
            }
        if (null === s || 1 - 10 * box2d.b2_epsilon < n) {
            this.m_stepComplete = !0;
            break
        }
        var a = s.GetFixtureA(),
            h = s.GetFixtureB(),
            l = a.GetBody(),
            d = h.GetBody(),
            C = box2d.b2World.prototype.SolveTOI.s_backup1.Copy(l.m_sweep),
            S = box2d.b2World.prototype.SolveTOI.s_backup2.Copy(d.m_sweep);
        if (l.Advance(n), d.Advance(n), s.Update(this.m_contactManager.m_contactListener), s.m_flags &= ~box2d.b2ContactFlag.e_toiFlag, ++s.m_toiCount, !1 !== s.IsEnabled() && !1 !== s.IsTouching()) {
            l.SetAwake(!0), d.SetAwake(!0), e.Clear(), e.AddBody(l), e.AddBody(d), e.AddContact(s), l.m_flags |= box2d.b2BodyFlag.e_islandFlag, d.m_flags |= box2d.b2BodyFlag.e_islandFlag, s.m_flags |= box2d.b2ContactFlag.e_islandFlag;
            for (var A = 0; A < 2; ++A) {
                var T = 0 === A ? l : d;
                if (T.m_type === box2d.b2BodyType.b2_dynamicBody)
                    for (var P = T.m_contactList; P && e.m_bodyCount !== e.m_bodyCapacity && e.m_contactCount !== e.m_contactCapacity; P = P.next) {
                        var B = P.contact;
                        if (!(B.m_flags & box2d.b2ContactFlag.e_islandFlag)) {
                            var M = P.other;
                            if (M.m_type !== box2d.b2BodyType.b2_dynamicBody || !1 !== T.IsBullet() || !1 !== M.IsBullet()) {
                                var I = B.m_fixtureA.m_isSensor,
                                    R = B.m_fixtureB.m_isSensor;
                                if (!I && !R) {
                                    var D = box2d.b2World.prototype.SolveTOI.s_backup.Copy(M.m_sweep);
                                    0 == (M.m_flags & box2d.b2BodyFlag.e_islandFlag) && M.Advance(n), B.Update(this.m_contactManager.m_contactListener), !1 !== B.IsEnabled() && !1 !== B.IsTouching() ? (B.m_flags |= box2d.b2ContactFlag.e_islandFlag, e.AddContact(B), M.m_flags & box2d.b2BodyFlag.e_islandFlag || (M.m_flags |= box2d.b2BodyFlag.e_islandFlag, M.m_type !== box2d.b2BodyType.b2_staticBody && M.SetAwake(!0), e.AddBody(M))) : (M.m_sweep.Copy(D), M.SynchronizeTransform())
                                }
                            }
                        }
                    }
            }
            var k = box2d.b2World.prototype.SolveTOI.s_subStep;
            k.dt = (1 - n) * t.dt, k.inv_dt = 1 / k.dt, k.dtRatio = 1, k.positionIterations = 20, k.velocityIterations = t.velocityIterations, k.warmStarting = !1, e.SolveTOI(k, l.m_islandIndex, d.m_islandIndex);
            for (var A = 0; A < e.m_bodyCount; ++A) {
                var T = e.m_bodies[A];
                if (T.m_flags &= ~box2d.b2BodyFlag.e_islandFlag, T.m_type === box2d.b2BodyType.b2_dynamicBody) {
                    T.SynchronizeFixtures();
                    for (var P = T.m_contactList; P; P = P.next) P.contact.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag)
                }
            }
            if (this.m_contactManager.FindNewContacts(), this.m_subStepping) {
                this.m_stepComplete = !1;
                break
            }
        } else s.SetEnabled(!1), l.m_sweep.Copy(C), d.m_sweep.Copy(S), l.SynchronizeTransform(), d.SynchronizeTransform()
    }
}, box2d.b2World.prototype.SolveTOI.s_subStep = new box2d.b2TimeStep, box2d.b2World.prototype.SolveTOI.s_backup = new box2d.b2Sweep, box2d.b2World.prototype.SolveTOI.s_backup1 = new box2d.b2Sweep, box2d.b2World.prototype.SolveTOI.s_backup2 = new box2d.b2Sweep, box2d.b2World.prototype.SolveTOI.s_toi_input = new box2d.b2TOIInput, box2d.b2World.prototype.SolveTOI.s_toi_output = new box2d.b2TOIOutput, box2d.b2World.prototype.Step = function(t, e, i) {
    this.m_flags & box2d.b2WorldFlag.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~box2d.b2WorldFlag.e_newFixture), this.m_flags |= box2d.b2WorldFlag.e_locked;
    var o = box2d.b2World.prototype.Step.s_step;
    o.dt = t, o.velocityIterations = e, o.positionIterations = i, o.inv_dt = t > 0 ? 1 / t : 0, o.dtRatio = this.m_inv_dt0 * t, o.warmStarting = this.m_warmStarting, this.m_contactManager.Collide(), this.m_stepComplete && o.dt > 0 && this.Solve(o), this.m_continuousPhysics && o.dt > 0 && this.SolveTOI(o), o.dt > 0 && (this.m_inv_dt0 = o.inv_dt), this.m_flags & box2d.b2WorldFlag.e_clearForces && this.ClearForces(), this.m_flags &= ~box2d.b2WorldFlag.e_locked
}, box2d.b2World.prototype.Step.s_step = new box2d.b2TimeStep, box2d.b2World.prototype.ClearForces = function() {
    for (var t = this.m_bodyList; t; t = t.m_next) t.m_force.SetZero(), t.m_torque = 0
}, box2d.b2World.prototype.QueryAABB = function(t, e) {
    var i = this.m_contactManager.m_broadPhase,
        o = function(e) {
            var o = i.GetUserData(e),
                s = o.fixture;
            o.childIndex;
            return t instanceof box2d.b2QueryCallback ? t.ReportFixture(s) : t(s)
        };
    i.Query(o, e)
}, box2d.b2World.prototype.QueryShape = function(t, e, i) {
    var o = this.m_contactManager.m_broadPhase,
        s = function(s) {
            var n = o.GetUserData(s),
                r = n.fixture;
            n.childIndex;
            return !box2d.b2TestOverlapShape(e, 0, r.GetShape(), 0, i, r.GetBody().GetTransform()) || (t instanceof box2d.b2QueryCallback ? t.ReportFixture(r) : t(r))
        },
        n = box2d.b2World.prototype.QueryShape.s_aabb;
    e.ComputeAABB(n, i, 0), o.Query(s, n)
}, box2d.b2World.prototype.QueryShape.s_aabb = new box2d.b2AABB, box2d.b2World.prototype.QueryPoint = function(t, e) {
    var i = this.m_contactManager.m_broadPhase,
        o = function(o) {
            var s = i.GetUserData(o),
                n = s.fixture;
            s.childIndex;
            return !n.TestPoint(e) || (t instanceof box2d.b2QueryCallback ? t.ReportFixture(n) : t(n))
        },
        s = box2d.b2World.prototype.QueryPoint.s_aabb;
    s.lowerBound.SetXY(e.x - box2d.b2_linearSlop, e.y - box2d.b2_linearSlop), s.upperBound.SetXY(e.x + box2d.b2_linearSlop, e.y + box2d.b2_linearSlop), i.Query(o, s)
}, box2d.b2World.prototype.QueryPoint.s_aabb = new box2d.b2AABB, box2d.b2World.prototype.RayCast = function(t, e, i) {
    var o = this.m_contactManager.m_broadPhase,
        s = function(s, n) {
            var r = o.GetUserData(n),
                a = r.fixture,
                h = r.childIndex,
                l = box2d.b2World.prototype.RayCast.s_output;
            if (a.RayCast(l, s, h)) {
                var d = l.fraction,
                    c = box2d.b2World.prototype.RayCast.s_point;
                return c.SetXY((1 - d) * e.x + d * i.x, (1 - d) * e.y + d * i.y), t instanceof box2d.b2RayCastCallback ? t.ReportFixture(a, c, l.normal, d) : t(a, c, l.normal, d)
            }
            return s.maxFraction
        },
        n = box2d.b2World.prototype.RayCast.s_input;
    n.maxFraction = 1, n.p1.Copy(e), n.p2.Copy(i), o.RayCast(s, n)
}, box2d.b2World.prototype.RayCast.s_input = new box2d.b2RayCastInput, box2d.b2World.prototype.RayCast.s_output = new box2d.b2RayCastOutput, box2d.b2World.prototype.RayCast.s_point = new box2d.b2Vec2, box2d.b2World.prototype.RayCastOne = function(t, e) {
    function i(t, e, i, n) {
        return n < s && (s = n, o = t), s
    }
    var o = null,
        s = 1;
    return this.RayCast(i, t, e), o
}, box2d.b2World.prototype.RayCastAll = function(t, e, i) {
    function o(t, e, o, s) {
        return i.push(t), 1
    }
    return i.length = 0, this.RayCast(o, t, e), i
}, box2d.b2World.prototype.DrawShape = function(t, e) {
    var i = t.GetShape();
    switch (i.m_type) {
        case box2d.b2ShapeType.e_circleShape:
            var o = i instanceof box2d.b2CircleShape ? i : null,
                s = o.m_p,
                n = o.m_radius,
                r = box2d.b2Vec2.UNITX;
            this.m_debugDraw.DrawSolidCircle(s, n, r, e);
            break;
        case box2d.b2ShapeType.e_edgeShape:
            var a = i instanceof box2d.b2EdgeShape ? i : null,
                h = a.m_vertex1,
                l = a.m_vertex2;
            this.m_debugDraw.DrawSegment(h, l, e);
            break;
        case box2d.b2ShapeType.e_chainShape:
            for (var d = i instanceof box2d.b2ChainShape ? i : null, c = d.m_count, p = d.m_vertices, h = p[0], u = 0; u < c; ++u) {
                var l = p[u];
                this.m_debugDraw.DrawSegment(h, l, e), this.m_debugDraw.DrawCircle(l, .05, e), h = l
            }
            break;
        case box2d.b2ShapeType.e_polygonShape:
            var b = i instanceof box2d.b2PolygonShape ? i : null,
                m = b.m_count,
                p = b.m_vertices;
            this.m_debugDraw.DrawSolidPolygon(p, m, e)
    }
}, box2d.b2World.prototype.DrawJoint = function(t) {
    var e = t.GetBodyA(),
        i = t.GetBodyB(),
        o = e.m_xf,
        s = i.m_xf,
        n = o.p,
        r = s.p,
        a = t.GetAnchorA(box2d.b2World.prototype.DrawJoint.s_p1),
        h = t.GetAnchorB(box2d.b2World.prototype.DrawJoint.s_p2),
        l = box2d.b2World.prototype.DrawJoint.s_color.SetRGB(.5, .8, .8);
    switch (t.m_type) {
        case box2d.b2JointType.e_distanceJoint:
            this.m_debugDraw.DrawSegment(a, h, l);
            break;
        case box2d.b2JointType.e_pulleyJoint:
            var d = t instanceof box2d.b2PulleyJoint ? t : null,
                c = d.GetGroundAnchorA(box2d.b2World.prototype.DrawJoint.s_s1),
                p = d.GetGroundAnchorB(box2d.b2World.prototype.DrawJoint.s_s2);
            this.m_debugDraw.DrawSegment(c, a, l), this.m_debugDraw.DrawSegment(p, h, l), this.m_debugDraw.DrawSegment(c, p, l);
            break;
        case box2d.b2JointType.e_mouseJoint:
            this.m_debugDraw.DrawSegment(a, h, l);
            break;
        default:
            this.m_debugDraw.DrawSegment(n, a, l), this.m_debugDraw.DrawSegment(a, h, l), this.m_debugDraw.DrawSegment(r, h, l)
    }
}, box2d.b2World.prototype.DrawJoint.s_p1 = new box2d.b2Vec2, box2d.b2World.prototype.DrawJoint.s_p2 = new box2d.b2Vec2, box2d.b2World.prototype.DrawJoint.s_color = new box2d.b2Color(.5, .8, .8), box2d.b2World.prototype.DrawJoint.s_s1 = new box2d.b2Vec2, box2d.b2World.prototype.DrawJoint.s_s2 = new box2d.b2Vec2, box2d.b2World.prototype.DrawDebugData = function() {
    if (null !== this.m_debugDraw) {
        var t = this.m_debugDraw.GetFlags(),
            e = box2d.b2World.prototype.DrawDebugData.s_color.SetRGB(0, 0, 0);
        if (t & box2d.b2DrawFlags.e_shapeBit)
            for (var i = this.m_bodyList; i; i = i.m_next) {
                var o = i.m_xf;
                this.m_debugDraw.PushTransform(o);
                for (var s = i.GetFixtureList(); s; s = s.m_next) !1 === i.IsActive() ? (e.SetRGB(.5, .5, .3), this.DrawShape(s, e)) : i.GetType() === box2d.b2BodyType.b2_staticBody ? (e.SetRGB(.5, .9, .5), this.DrawShape(s, e)) : i.GetType() === box2d.b2BodyType.b2_kinematicBody ? (e.SetRGB(.5, .5, .9), this.DrawShape(s, e)) : !1 === i.IsAwake() ? (e.SetRGB(.6, .6, .6), this.DrawShape(s, e)) : (e.SetRGB(.9, .7, .7), this.DrawShape(s, e));
                this.m_debugDraw.PopTransform(o)
            }
        if (t & box2d.b2DrawFlags.e_jointBit)
            for (var n = this.m_jointList; n; n = n.m_next) this.DrawJoint(n);
        if (t & box2d.b2DrawFlags.e_aabbBit) {
            e.SetRGB(.9, .3, .9);
            for (var r = this.m_contactManager.m_broadPhase, a = box2d.b2World.prototype.DrawDebugData.s_vs, i = this.m_bodyList; i; i = i.m_next)
                if (!1 !== i.IsActive())
                    for (var s = i.GetFixtureList(); s; s = s.m_next)
                        for (var h = 0; h < s.m_proxyCount; ++h) {
                            var l = s.m_proxies[h],
                                d = r.GetFatAABB(l.proxy);
                            a[0].SetXY(d.lowerBound.x, d.lowerBound.y), a[1].SetXY(d.upperBound.x, d.lowerBound.y), a[2].SetXY(d.upperBound.x, d.upperBound.y), a[3].SetXY(d.lowerBound.x, d.upperBound.y), this.m_debugDraw.DrawPolygon(a, 4, e)
                        }
        }
        if (t & box2d.b2DrawFlags.e_centerOfMassBit)
            for (var i = this.m_bodyList; i; i = i.m_next) {
                var o = box2d.b2World.prototype.DrawDebugData.s_xf;
                o.q.Copy(i.m_xf.q), o.p.Copy(i.GetWorldCenter()), this.m_debugDraw.DrawTransform(o)
            }
        if (t & box2d.b2DrawFlags.e_controllerBit)
            for (var c = this.m_controllerList; c; c = c.m_next) c.Draw(this.m_debugDraw)
    }
}, box2d.b2World.prototype.DrawDebugData.s_color = new box2d.b2Color(0, 0, 0), box2d.b2World.prototype.DrawDebugData.s_vs = box2d.b2Vec2.MakeArray(4), box2d.b2World.prototype.DrawDebugData.s_xf = new box2d.b2Transform, box2d.b2World.prototype.SetBroadPhase = function(t) {
    var e = this.m_contactManager.m_broadPhase;
    this.m_contactManager.m_broadPhase = t;
    for (var i = this.m_bodyList; i; i = i.m_next)
        for (var o = i.m_fixtureList; o; o = o.m_next) o.m_proxy = t.CreateProxy(e.GetFatAABB(o.m_proxy), o)
}, box2d.b2World.prototype.GetProxyCount = function() {
    return this.m_contactManager.m_broadPhase.GetProxyCount()
}, box2d.b2World.prototype.GetTreeHeight = function() {
    return this.m_contactManager.m_broadPhase.GetTreeHeight()
}, box2d.b2World.prototype.GetTreeBalance = function() {
    return this.m_contactManager.m_broadPhase.GetTreeBalance()
}, box2d.b2World.prototype.GetTreeQuality = function() {
    return this.m_contactManager.m_broadPhase.GetTreeQuality()
}, box2d.b2World.prototype.ShiftOrigin = function(t) {
    if (!this.IsLocked()) {
        for (var e = this.m_bodyList; e; e = e.m_next) e.m_xf.p.SelfSub(t), e.m_sweep.c0.SelfSub(t), e.m_sweep.c.SelfSub(t);
        for (var i = this.m_jointList; i; i = i.m_next) i.ShiftOrigin(t);
        this.m_contactManager.m_broadPhase.ShiftOrigin(t)
    }
}, box2d.b2World.prototype.Dump = function() {}, box2d.b2World.prototype.AddController = function(t) {
    return t.m_world = this, t.m_next = this.m_controllerList, t.m_prev = null, this.m_controllerList && (this.m_controllerList.m_prev = t), this.m_controllerList = t, ++this.m_controllerCount, t
}, box2d.b2World.prototype.RemoveController = function(t) {
    t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), this.m_controllerList === t && (this.m_controllerList = t.m_next), --this.m_controllerCount, t.m_prev = null, t.m_next = null, t.m_world = null
}, goog.provide("box2d.b2AreaJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2AreaJointDef = function() {
    goog.base(this, box2d.b2JointType.e_areaJoint), this.bodies = new Array
}, goog.inherits(box2d.b2AreaJointDef, box2d.b2JointDef), box2d.b2AreaJointDef.prototype.world = null, box2d.b2AreaJointDef.prototype.bodies = null, box2d.b2AreaJointDef.prototype.frequencyHz = 0, box2d.b2AreaJointDef.prototype.dampingRatio = 0, box2d.b2AreaJointDef.prototype.AddBody = function(t) {
    this.bodies.push(t), 1 === this.bodies.length ? this.bodyA = t : 2 === this.bodies.length && (this.bodyB = t)
}, box2d.b2AreaJoint = function(t) {
    goog.base(this, t), this.m_bodies = t.bodies, this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_targetLengths = box2d.b2MakeNumberArray(t.bodies.length), this.m_normals = box2d.b2Vec2.MakeArray(t.bodies.length), this.m_joints = new Array(t.bodies.length), this.m_deltas = box2d.b2Vec2.MakeArray(t.bodies.length), this.m_delta = new box2d.b2Vec2;
    var e = new box2d.b2DistanceJointDef;
    e.frequencyHz = t.frequencyHz, e.dampingRatio = t.dampingRatio, this.m_targetArea = 0;
    for (var i = 0, o = this.m_bodies.length; i < o; ++i) {
        var s = this.m_bodies[i],
            n = this.m_bodies[(i + 1) % o],
            r = s.GetWorldCenter(),
            a = n.GetWorldCenter();
        this.m_targetLengths[i] = box2d.b2DistanceVV(r, a), this.m_targetArea += box2d.b2CrossVV(r, a), e.Initialize(s, n, r, a), this.m_joints[i] = t.world.CreateJoint(e)
    }
    this.m_targetArea *= .5
}, goog.inherits(box2d.b2AreaJoint, box2d.b2Joint), box2d.b2AreaJoint.prototype.m_bodies = null, box2d.b2AreaJoint.prototype.m_frequencyHz = 0, box2d.b2AreaJoint.prototype.m_dampingRatio = 0, box2d.b2AreaJoint.prototype.m_impulse = 0, box2d.b2AreaJoint.prototype.m_targetLengths = null, box2d.b2AreaJoint.prototype.m_targetArea = 0, box2d.b2AreaJoint.prototype.m_normals = null, box2d.b2AreaJoint.prototype.m_joints = null, box2d.b2AreaJoint.prototype.m_deltas = null, box2d.b2AreaJoint.prototype.m_delta = null, box2d.b2AreaJoint.prototype.GetAnchorA = function(t) {
    return t.SetZero()
}, box2d.b2AreaJoint.prototype.GetAnchorB = function(t) {
    return t.SetZero()
}, box2d.b2AreaJoint.prototype.GetReactionForce = function(t, e) {
    return e.SetZero()
}, box2d.b2AreaJoint.prototype.GetReactionTorque = function(t) {
    return 0
}, box2d.b2AreaJoint.prototype.SetFrequency = function(t) {
    this.m_frequencyHz = t;
    for (var e = 0, i = this.m_joints.length; e < i; ++e) this.m_joints[e].SetFrequency(t)
}, box2d.b2AreaJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
}, box2d.b2AreaJoint.prototype.SetDampingRatio = function(t) {
    this.m_dampingRatio = t;
    for (var e = 0, i = this.m_joints.length; e < i; ++e) this.m_joints[e].SetDampingRatio(t)
}, box2d.b2AreaJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
}, box2d.b2AreaJoint.prototype.Dump = function() {}, box2d.b2AreaJoint.prototype.InitVelocityConstraints = function(t) {
    for (var e = 0, i = this.m_bodies.length; e < i; ++e) {
        var o = this.m_bodies[(e + i - 1) % i],
            s = this.m_bodies[(e + 1) % i],
            n = t.positions[o.m_islandIndex].c,
            r = t.positions[s.m_islandIndex].c,
            a = this.m_deltas[e];
        box2d.b2SubVV(r, n, a)
    }
    if (t.step.warmStarting) {
        this.m_impulse *= t.step.dtRatio;
        for (var e = 0, i = this.m_bodies.length; e < i; ++e) {
            var h = this.m_bodies[e],
                l = t.velocities[h.m_islandIndex].v,
                a = this.m_deltas[e];
            l.x += h.m_invMass * a.y * .5 * this.m_impulse, l.y += h.m_invMass * -a.x * .5 * this.m_impulse
        }
    } else this.m_impulse = 0
}, box2d.b2AreaJoint.prototype.SolveVelocityConstraints = function(t) {
    for (var e = 0, i = 0, o = 0, s = this.m_bodies.length; o < s; ++o) {
        var n = this.m_bodies[o],
            r = t.velocities[n.m_islandIndex].v,
            a = this.m_deltas[o];
        e += a.GetLengthSquared() / n.GetMass(), i += box2d.b2CrossVV(r, a)
    }
    var h = -2 * i / e;
    this.m_impulse += h;
    for (var o = 0, s = this.m_bodies.length; o < s; ++o) {
        var n = this.m_bodies[o],
            r = t.velocities[n.m_islandIndex].v,
            a = this.m_deltas[o];
        r.x += n.m_invMass * a.y * .5 * h, r.y += n.m_invMass * -a.x * .5 * h
    }
}, box2d.b2AreaJoint.prototype.SolvePositionConstraints = function(t) {
    for (var e = 0, i = 0, o = 0, s = this.m_bodies.length; o < s; ++o) {
        var n = this.m_bodies[o],
            r = this.m_bodies[(o + 1) % s],
            a = t.positions[n.m_islandIndex].c,
            h = t.positions[r.m_islandIndex].c,
            l = box2d.b2SubVV(h, a, this.m_delta),
            d = l.GetLength();
        d < box2d.b2_epsilon && (d = 1), this.m_normals[o].x = l.y / d, this.m_normals[o].y = -l.x / d, e += d, i += box2d.b2CrossVV(a, h)
    }
    i *= .5;
    for (var c = this.m_targetArea - i, p = .5 * c / e, u = !0, o = 0, s = this.m_bodies.length; o < s; ++o) {
        var n = this.m_bodies[o],
            a = t.positions[n.m_islandIndex].c,
            b = (o + 1) % s,
            l = box2d.b2AddVV(this.m_normals[o], this.m_normals[b], this.m_delta);
        l.SelfMul(p);
        var m = l.GetLengthSquared();
        m > box2d.b2Sq(box2d.b2_maxLinearCorrection) && l.SelfMul(box2d.b2_maxLinearCorrection / box2d.b2Sqrt(m)), m > box2d.b2Sq(box2d.b2_linearSlop) && (u = !1), a.x += l.x, a.y += l.y
    }
    return u
}, goog.provide("box2d.b2BuoyancyController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), goog.require("box2d.b2WorldCallbacks"), box2d.b2BuoyancyController = function() {
    goog.base(this), this.normal = new box2d.b2Vec2(0, 1), this.velocity = new box2d.b2Vec2(0, 0), this.gravity = new box2d.b2Vec2(0, 0)
}, goog.inherits(box2d.b2BuoyancyController, box2d.b2Controller), box2d.b2BuoyancyController.prototype.normal = null, box2d.b2BuoyancyController.prototype.offset = 0, box2d.b2BuoyancyController.prototype.density = 0, box2d.b2BuoyancyController.prototype.velocity = null, box2d.b2BuoyancyController.prototype.linearDrag = 0, box2d.b2BuoyancyController.prototype.angularDrag = 0, box2d.b2BuoyancyController.prototype.useDensity = !1, box2d.b2BuoyancyController.prototype.useWorldGravity = !0, box2d.b2BuoyancyController.prototype.gravity = null, box2d.b2BuoyancyController.prototype.Step = function(t) {
    if (this.m_bodyList) {
        this.useWorldGravity && this.gravity.Copy(this.GetWorld().GetGravity());
        for (var e = this.m_bodyList; e; e = e.nextBody) {
            var i = e.body;
            if (!1 !== i.IsAwake()) {
                for (var o = new box2d.b2Vec2, s = new box2d.b2Vec2, n = 0, r = 0, a = i.GetFixtureList(); a; a = a.m_next) {
                    var h = new box2d.b2Vec2,
                        l = a.GetShape().ComputeSubmergedArea(this.normal, this.offset, i.GetTransform(), h);
                    n += l, o.x += l * h.x, o.y += l * h.y;
                    var d = 0;
                    d = this.useDensity ? a.GetDensity() : 1, r += l * d, s.x += l * h.x * d, s.y += l * h.y * d
                }
                if (o.x /= n, o.y /= n, s.x /= r, s.y /= r, !(n < box2d.b2_epsilon)) {
                    var c = box2d.b2NegV(this.gravity, new box2d.b2Vec2);
                    c.SelfMul(this.density * n), i.ApplyForce(c, s);
                    var p = i.GetLinearVelocityFromWorldPoint(o, new box2d.b2Vec2);
                    p.SelfSub(this.velocity), p.SelfMul(-this.linearDrag * n), i.ApplyForce(p, o), i.ApplyTorque(-i.GetInertia() / i.GetMass() * n * i.GetAngularVelocity() * this.angularDrag)
                }
            }
        }
    }
}, box2d.b2BuoyancyController.prototype.Draw = function(t) {
    var e = 100,
        i = new box2d.b2Vec2,
        o = new box2d.b2Vec2;
    i.x = this.normal.x * this.offset + this.normal.y * e, i.y = this.normal.y * this.offset - this.normal.x * e, o.x = this.normal.x * this.offset - this.normal.y * e, o.y = this.normal.y * this.offset + this.normal.x * e;
    var s = new box2d.b2Color(0, 0, .8);
    t.DrawSegment(i, o, s)
}, goog.provide("box2d.b2TensorDampingController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), box2d.b2TensorDampingController = function() {
    goog.base(this), this.T = new box2d.b2Mat22, this.maxTimestep = 0
}, goog.inherits(box2d.b2TensorDampingController, box2d.b2Controller), box2d.b2TensorDampingController.prototype.T = new box2d.b2Mat22, box2d.b2TensorDampingController.prototype.maxTimestep = 0, box2d.b2TensorDampingController.prototype.Step = function(t) {
    var e = t.dt;
    if (!(e <= box2d.b2_epsilon)) {
        e > this.maxTimestep && this.maxTimestep > 0 && (e = this.maxTimestep);
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var o = i.body;
            if (o.IsAwake()) {
                var s = o.GetWorldVector(box2d.b2MulMV(this.T, o.GetLocalVector(o.GetLinearVelocity(), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1), box2d.b2TensorDampingController.prototype.Step.s_damping);
                o.SetLinearVelocity(box2d.b2AddVV(o.GetLinearVelocity(), box2d.b2MulSV(e, s, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1))
            }
        }
    }
}, box2d.b2TensorDampingController.prototype.Step.s_damping = new box2d.b2Vec2, box2d.b2TensorDampingController.prototype.SetAxisAligned = function(t, e) {
    this.T.ex.x = -t, this.T.ex.y = 0, this.T.ey.x = 0, this.T.ey.y = -e, this.maxTimestep = t > 0 || e > 0 ? 1 / box2d.b2Max(t, e) : 0
}, goog.provide("box2d.b2DistanceJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2DistanceJointDef = function() {
    goog.base(this, box2d.b2JointType.e_distanceJoint), this.localAnchorA = new box2d.b2Vec2, this.localAnchorB = new box2d.b2Vec2
}, goog.inherits(box2d.b2DistanceJointDef, box2d.b2JointDef), box2d.b2DistanceJointDef.prototype.localAnchorA = null, box2d.b2DistanceJointDef.prototype.localAnchorB = null, box2d.b2DistanceJointDef.prototype.length = 1, box2d.b2DistanceJointDef.prototype.frequencyHz = 0, box2d.b2DistanceJointDef.prototype.dampingRatio = 0, box2d.b2DistanceJointDef.prototype.Initialize = function(t, e, i, o) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(o, this.localAnchorB), this.length = box2d.b2DistanceVV(i, o), this.frequencyHz = 0, this.dampingRatio = 0
}, box2d.b2DistanceJoint = function(t) {
    goog.base(this, t), this.m_u = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_length = t.length
}, goog.inherits(box2d.b2DistanceJoint, box2d.b2Joint), box2d.b2DistanceJoint.prototype.m_frequencyHz = 0, box2d.b2DistanceJoint.prototype.m_dampingRatio = 0, box2d.b2DistanceJoint.prototype.m_bias = 0, box2d.b2DistanceJoint.prototype.m_localAnchorA = null, box2d.b2DistanceJoint.prototype.m_localAnchorB = null;
box2d.b2DistanceJoint.prototype.m_gamma = 0, box2d.b2DistanceJoint.prototype.m_impulse = 0, box2d.b2DistanceJoint.prototype.m_length = 0, box2d.b2DistanceJoint.prototype.m_indexA = 0, box2d.b2DistanceJoint.prototype.m_indexB = 0, box2d.b2DistanceJoint.prototype.m_u = null, box2d.b2DistanceJoint.prototype.m_rA = null, box2d.b2DistanceJoint.prototype.m_rB = null, box2d.b2DistanceJoint.prototype.m_localCenterA = null, box2d.b2DistanceJoint.prototype.m_localCenterB = null, box2d.b2DistanceJoint.prototype.m_invMassA = 0, box2d.b2DistanceJoint.prototype.m_invMassB = 0, box2d.b2DistanceJoint.prototype.m_invIA = 0, box2d.b2DistanceJoint.prototype.m_invIB = 0, box2d.b2DistanceJoint.prototype.m_mass = 0, box2d.b2DistanceJoint.prototype.m_qA = null, box2d.b2DistanceJoint.prototype.m_qB = null, box2d.b2DistanceJoint.prototype.m_lalcA = null, box2d.b2DistanceJoint.prototype.m_lalcB = null, box2d.b2DistanceJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2DistanceJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2DistanceJoint.prototype.GetReactionForce = function(t, e) {
    return e.SetXY(t * this.m_impulse * this.m_u.x, t * this.m_impulse * this.m_u.y)
}, box2d.b2DistanceJoint.prototype.GetReactionTorque = function(t) {
    return 0
}, box2d.b2DistanceJoint.prototype.GetLocalAnchorA = function(t) {
    return t.Copy(this.m_localAnchorA)
}, box2d.b2DistanceJoint.prototype.GetLocalAnchorB = function(t) {
    return t.Copy(this.m_localAnchorB)
}, box2d.b2DistanceJoint.prototype.SetLength = function(t) {
    this.m_length = t
}, box2d.b2DistanceJoint.prototype.GetLength = function() {
    return this.m_length
}, box2d.b2DistanceJoint.prototype.SetFrequency = function(t) {
    this.m_frequencyHz = t
}, box2d.b2DistanceJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
}, box2d.b2DistanceJoint.prototype.SetDampingRatio = function(t) {
    this.m_dampingRatio = t
}, box2d.b2DistanceJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
}, box2d.b2DistanceJoint.prototype.Dump = function() {}, box2d.b2DistanceJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        s = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        d = this.m_qB.SetAngleRadians(r);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(l, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(d, this.m_lalcB, this.m_rB), this.m_u.x = n.x + this.m_rB.x - e.x - this.m_rA.x, this.m_u.y = n.y + this.m_rB.y - e.y - this.m_rA.y;
    var c = this.m_u.GetLength();
    c > box2d.b2_linearSlop ? this.m_u.SelfMul(1 / c) : this.m_u.SetZero();
    var p = box2d.b2CrossVV(this.m_rA, this.m_u),
        u = box2d.b2CrossVV(this.m_rB, this.m_u),
        b = this.m_invMassA + this.m_invIA * p * p + this.m_invMassB + this.m_invIB * u * u;
    if (this.m_mass = 0 !== b ? 1 / b : 0, this.m_frequencyHz > 0) {
        var m = c - this.m_length,
            y = 2 * box2d.b2_pi * this.m_frequencyHz,
            f = 2 * this.m_mass * this.m_dampingRatio * y,
            g = this.m_mass * y * y,
            x = t.step.dt;
        this.m_gamma = x * (f + x * g), this.m_gamma = 0 !== this.m_gamma ? 1 / this.m_gamma : 0, this.m_bias = m * x * g * this.m_gamma, b += this.m_gamma, this.m_mass = 0 !== b ? 1 / b : 0
    } else this.m_gamma = 0, this.m_bias = 0;
    if (t.step.warmStarting) {
        this.m_impulse *= t.step.dtRatio;
        var _ = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P);
        o.SelfMulSub(this.m_invMassA, _), s -= this.m_invIA * box2d.b2CrossVV(this.m_rA, _), a.SelfMulAdd(this.m_invMassB, _), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, _)
    } else this.m_impulse = 0;
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = h
}, box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA),
        r = box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB),
        a = box2d.b2DotVV(this.m_u, box2d.b2SubVV(r, n, box2d.b2Vec2.s_t0)),
        h = -this.m_mass * (a + this.m_bias + this.m_gamma * this.m_impulse);
    this.m_impulse += h;
    var l = box2d.b2MulSV(h, this.m_u, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P);
    e.SelfMulSub(this.m_invMassA, l), i -= this.m_invIA * box2d.b2CrossVV(this.m_rA, l), o.SelfMulAdd(this.m_invMassB, l), s += this.m_invIB * box2d.b2CrossVV(this.m_rB, l), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2DistanceJoint.prototype.SolvePositionConstraints = function(t) {
    if (this.m_frequencyHz > 0) return !0;
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        s = t.positions[this.m_indexB].a,
        n = (this.m_qA.SetAngleRadians(i), this.m_qB.SetAngleRadians(s), box2d.b2MulRV(this.m_qA, this.m_lalcA, this.m_rA)),
        r = box2d.b2MulRV(this.m_qB, this.m_lalcB, this.m_rB),
        a = this.m_u;
    a.x = o.x + r.x - e.x - n.x, a.y = o.y + r.y - e.y - n.y;
    var h = this.m_u.Normalize(),
        l = h - this.m_length;
    l = box2d.b2Clamp(l, -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection);
    var d = -this.m_mass * l,
        c = box2d.b2MulSV(d, a, box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P);
    return e.SelfMulSub(this.m_invMassA, c), i -= this.m_invIA * box2d.b2CrossVV(n, c), o.SelfMulAdd(this.m_invMassB, c), s += this.m_invIB * box2d.b2CrossVV(r, c), t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = s, box2d.b2Abs(l) < box2d.b2_linearSlop
}, box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, goog.provide("box2d.b2FrictionJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2FrictionJointDef = function() {
    goog.base(this, box2d.b2JointType.e_frictionJoint), this.localAnchorA = new box2d.b2Vec2, this.localAnchorB = new box2d.b2Vec2
}, goog.inherits(box2d.b2FrictionJointDef, box2d.b2JointDef), box2d.b2FrictionJointDef.prototype.localAnchorA = null, box2d.b2FrictionJointDef.prototype.localAnchorB = null, box2d.b2FrictionJointDef.prototype.maxForce = 0, box2d.b2FrictionJointDef.prototype.maxTorque = 0, box2d.b2FrictionJointDef.prototype.Initialize = function(t, e, i) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB)
}, box2d.b2FrictionJoint = function(t) {
    goog.base(this, t), this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_linearImpulse = (new box2d.b2Vec2).SetZero(), this.m_maxForce = t.maxForce, this.m_maxTorque = t.maxTorque, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_linearMass = (new box2d.b2Mat22).SetZero(), this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_K = new box2d.b2Mat22
}, goog.inherits(box2d.b2FrictionJoint, box2d.b2Joint), box2d.b2FrictionJoint.prototype.m_localAnchorA = null, box2d.b2FrictionJoint.prototype.m_localAnchorB = null, box2d.b2FrictionJoint.prototype.m_linearImpulse = null, box2d.b2FrictionJoint.prototype.m_angularImpulse = 0, box2d.b2FrictionJoint.prototype.m_maxForce = 0, box2d.b2FrictionJoint.prototype.m_maxTorque = 0, box2d.b2FrictionJoint.prototype.m_indexA = 0, box2d.b2FrictionJoint.prototype.m_indexB = 0, box2d.b2FrictionJoint.prototype.m_rA = null, box2d.b2FrictionJoint.prototype.m_rB = null, box2d.b2FrictionJoint.prototype.m_localCenterA = null, box2d.b2FrictionJoint.prototype.m_localCenterB = null, box2d.b2FrictionJoint.prototype.m_invMassA = 0, box2d.b2FrictionJoint.prototype.m_invMassB = 0, box2d.b2FrictionJoint.prototype.m_invIA = 0, box2d.b2FrictionJoint.prototype.m_invIB = 0, box2d.b2FrictionJoint.prototype.m_linearMass = null, box2d.b2FrictionJoint.prototype.m_angularMass = 0, box2d.b2FrictionJoint.prototype.m_qA = null, box2d.b2FrictionJoint.prototype.m_qB = null, box2d.b2FrictionJoint.prototype.m_lalcA = null, box2d.b2FrictionJoint.prototype.m_lalcB = null, box2d.b2FrictionJoint.prototype.m_K = null, box2d.b2FrictionJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].a,
        i = t.velocities[this.m_indexA].v,
        o = t.velocities[this.m_indexA].w,
        s = t.positions[this.m_indexB].a,
        n = t.velocities[this.m_indexB].v,
        r = t.velocities[this.m_indexB].w,
        a = this.m_qA.SetAngleRadians(e),
        h = this.m_qB.SetAngleRadians(s);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var l = box2d.b2MulRV(a, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var d = box2d.b2MulRV(h, this.m_lalcB, this.m_rB),
        c = this.m_invMassA,
        p = this.m_invMassB,
        u = this.m_invIA,
        b = this.m_invIB,
        m = this.m_K;
    if (m.ex.x = c + p + u * l.y * l.y + b * d.y * d.y, m.ex.y = -u * l.x * l.y - b * d.x * d.y, m.ey.x = m.ex.y, m.ey.y = c + p + u * l.x * l.x + b * d.x * d.x, m.GetInverse(this.m_linearMass), this.m_angularMass = u + b, this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass), t.step.warmStarting) {
        this.m_linearImpulse.SelfMul(t.step.dtRatio), this.m_angularImpulse *= t.step.dtRatio;
        var y = this.m_linearImpulse;
        i.SelfMulSub(c, y), o -= u * (box2d.b2CrossVV(this.m_rA, y) + this.m_angularImpulse), n.SelfMulAdd(p, y), r += b * (box2d.b2CrossVV(this.m_rB, y) + this.m_angularImpulse)
    } else this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0;
    t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = r
}, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB,
        l = t.step.dt,
        d = s - i,
        c = -this.m_angularMass * d,
        p = this.m_angularImpulse,
        u = l * this.m_maxTorque;
    this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + c, -u, u), c = this.m_angularImpulse - p, i -= a * c, s += h * c;
    var d = box2d.b2SubVV(box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot),
        b = box2d.b2MulMV(this.m_linearMass, d, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV).SelfNeg(),
        m = box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV.Copy(this.m_linearImpulse);
    this.m_linearImpulse.SelfAdd(b);
    var u = l * this.m_maxForce;
    this.m_linearImpulse.GetLengthSquared() > u * u && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.SelfMul(u)), box2d.b2SubVV(this.m_linearImpulse, m, b), e.SelfMulSub(n, b), i -= a * box2d.b2CrossVV(this.m_rA, b), o.SelfMulAdd(r, b), s += h * box2d.b2CrossVV(this.m_rB, b), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV = new box2d.b2Vec2, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV = new box2d.b2Vec2, box2d.b2FrictionJoint.prototype.SolvePositionConstraints = function(t) {
    return !0
}, box2d.b2FrictionJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
}, box2d.b2FrictionJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2FrictionJoint.prototype.GetReactionForce = function(t, e) {
    return e.SetXY(t * this.m_linearImpulse.x, t * this.m_linearImpulse.y)
}, box2d.b2FrictionJoint.prototype.GetReactionTorque = function(t) {
    return t * this.m_angularImpulse
}, box2d.b2FrictionJoint.prototype.GetLocalAnchorA = function(t) {
    return t.Copy(this.m_localAnchorA)
}, box2d.b2FrictionJoint.prototype.GetLocalAnchorB = function(t) {
    return t.Copy(this.m_localAnchorB)
}, box2d.b2FrictionJoint.prototype.SetMaxForce = function(t) {
    this.m_maxForce = t
}, box2d.b2FrictionJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
}, box2d.b2FrictionJoint.prototype.SetMaxTorque = function(t) {
    this.m_maxTorque = t
}, box2d.b2FrictionJoint.prototype.GetMaxTorque = function() {
    return this.m_maxTorque
}, box2d.b2FrictionJoint.prototype.Dump = function() {}, goog.provide("box2d.b2MouseJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2MouseJointDef = function() {
    goog.base(this, box2d.b2JointType.e_mouseJoint), this.target = new box2d.b2Vec2
}, goog.inherits(box2d.b2MouseJointDef, box2d.b2JointDef), box2d.b2MouseJointDef.prototype.target = null, box2d.b2MouseJointDef.prototype.maxForce = 0, box2d.b2MouseJointDef.prototype.frequencyHz = 5, box2d.b2MouseJointDef.prototype.dampingRatio = .7, box2d.b2MouseJoint = function(t) {
    goog.base(this, t), this.m_localAnchorB = new box2d.b2Vec2, this.m_targetA = new box2d.b2Vec2, this.m_impulse = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_mass = new box2d.b2Mat22, this.m_C = new box2d.b2Vec2, this.m_qB = new box2d.b2Rot, this.m_lalcB = new box2d.b2Vec2, this.m_K = new box2d.b2Mat22, this.m_targetA.Copy(t.target), box2d.b2MulTXV(this.m_bodyB.GetTransform(), this.m_targetA, this.m_localAnchorB), this.m_maxForce = t.maxForce, this.m_impulse.SetZero(), this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_beta = 0, this.m_gamma = 0
}, goog.inherits(box2d.b2MouseJoint, box2d.b2Joint), box2d.b2MouseJoint.prototype.m_localAnchorB = null, box2d.b2MouseJoint.prototype.m_targetA = null, box2d.b2MouseJoint.prototype.m_frequencyHz = 0, box2d.b2MouseJoint.prototype.m_dampingRatio = 0, box2d.b2MouseJoint.prototype.m_beta = 0, box2d.b2MouseJoint.prototype.m_impulse = null, box2d.b2MouseJoint.prototype.m_maxForce = 0, box2d.b2MouseJoint.prototype.m_gamma = 0, box2d.b2MouseJoint.prototype.m_indexA = 0, box2d.b2MouseJoint.prototype.m_indexB = 0, box2d.b2MouseJoint.prototype.m_rB = null, box2d.b2MouseJoint.prototype.m_localCenterB = null, box2d.b2MouseJoint.prototype.m_invMassB = 0, box2d.b2MouseJoint.prototype.m_invIB = 0, box2d.b2MouseJoint.prototype.m_mass = null, box2d.b2MouseJoint.prototype.m_C = null, box2d.b2MouseJoint.prototype.m_qB = null, box2d.b2MouseJoint.prototype.m_lalcB = null, box2d.b2MouseJoint.prototype.m_K = null, box2d.b2MouseJoint.prototype.SetTarget = function(t) {
    !1 === this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(!0), this.m_targetA.Copy(t)
}, box2d.b2MouseJoint.prototype.GetTarget = function(t) {
    return t.Copy(this.m_targetA)
}, box2d.b2MouseJoint.prototype.SetMaxForce = function(t) {
    this.m_maxForce = t
}, box2d.b2MouseJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
}, box2d.b2MouseJoint.prototype.SetFrequency = function(t) {
    this.m_frequencyHz = t
}, box2d.b2MouseJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
}, box2d.b2MouseJoint.prototype.SetDampingRatio = function(t) {
    this.m_dampingRatio = t
}, box2d.b2MouseJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
}, box2d.b2MouseJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexB].c,
        i = t.positions[this.m_indexB].a,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = this.m_qB.SetAngleRadians(i),
        r = this.m_bodyB.GetMass(),
        a = 2 * box2d.b2_pi * this.m_frequencyHz,
        h = 2 * r * this.m_dampingRatio * a,
        l = r * (a * a),
        d = t.step.dt;
    this.m_gamma = d * (h + d * l), 0 !== this.m_gamma && (this.m_gamma = 1 / this.m_gamma), this.m_beta = d * l * this.m_gamma, box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(n, this.m_lalcB, this.m_rB);
    var c = this.m_K;
    c.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma, c.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y, c.ey.x = c.ex.y, c.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma, c.GetInverse(this.m_mass), this.m_C.x = e.x + this.m_rB.x - this.m_targetA.x, this.m_C.y = e.y + this.m_rB.y - this.m_targetA.y, this.m_C.SelfMul(this.m_beta), s *= .98, t.step.warmStarting ? (this.m_impulse.SelfMul(t.step.dtRatio), o.x += this.m_invMassB * this.m_impulse.x, o.y += this.m_invMassB * this.m_impulse.y, s += this.m_invIB * box2d.b2CrossVV(this.m_rB, this.m_impulse)) : this.m_impulse.SetZero(), t.velocities[this.m_indexB].w = s
}, box2d.b2MouseJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexB].v,
        i = t.velocities[this.m_indexB].w,
        o = box2d.b2AddVCrossSV(e, i, this.m_rB, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot),
        s = box2d.b2MulMV(this.m_mass, box2d.b2AddVV(o, box2d.b2AddVV(this.m_C, box2d.b2MulSV(this.m_gamma, this.m_impulse, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0).SelfNeg(), box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse),
        n = box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_impulse);
    this.m_impulse.SelfAdd(s);
    var r = t.step.dt * this.m_maxForce;
    this.m_impulse.GetLengthSquared() > r * r && this.m_impulse.SelfMul(r / this.m_impulse.GetLength()), box2d.b2SubVV(this.m_impulse, n, s), e.SelfMulAdd(this.m_invMassB, s), i += this.m_invIB * box2d.b2CrossVV(this.m_rB, s), t.velocities[this.m_indexB].w = i
}, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2, box2d.b2MouseJoint.prototype.SolvePositionConstraints = function(t) {
    return !0
}, box2d.b2MouseJoint.prototype.GetAnchorA = function(t) {
    return t.Copy(this.m_targetA)
}, box2d.b2MouseJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
}, box2d.b2MouseJoint.prototype.GetReactionForce = function(t, e) {
    return box2d.b2MulSV(t, this.m_impulse, e)
}, box2d.b2MouseJoint.prototype.GetReactionTorque = function(t) {
    return 0
}, box2d.b2MouseJoint.prototype.Dump = function() {}, box2d.b2MouseJoint.prototype.ShiftOrigin = function(t) {
    this.m_targetA.SelfSub(t)
}, goog.provide("box2d.b2ConstantForceController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), box2d.b2ConstantForceController = function() {
    goog.base(this), this.F = new box2d.b2Vec2(0, 0)
}, goog.inherits(box2d.b2ConstantForceController, box2d.b2Controller), box2d.b2ConstantAccelController.prototype.F = null, box2d.b2ConstantForceController.prototype.Step = function(t) {
    for (var e = this.m_bodyList; e; e = e.nextBody) {
        var i = e.body;
        i.IsAwake() && i.ApplyForce(this.F, i.GetWorldCenter())
    }
}, goog.provide("box2d.b2PulleyJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2_minPulleyLength = 2, box2d.b2PulleyJointDef = function() {
    goog.base(this, box2d.b2JointType.e_pulleyJoint), this.collideConnected = !0, this.groundAnchorA = new box2d.b2Vec2(-1, 1), this.groundAnchorB = new box2d.b2Vec2(1, 1), this.localAnchorA = new box2d.b2Vec2(-1, 0), this.localAnchorB = new box2d.b2Vec2(1, 0)
}, goog.inherits(box2d.b2PulleyJointDef, box2d.b2JointDef), box2d.b2PulleyJointDef.prototype.groundAnchorA = null, box2d.b2PulleyJointDef.prototype.groundAnchorB = null, box2d.b2PulleyJointDef.prototype.localAnchorA = null, box2d.b2PulleyJointDef.prototype.localAnchorB = null, box2d.b2PulleyJointDef.prototype.lengthA = 0, box2d.b2PulleyJointDef.prototype.lengthB = 0, box2d.b2PulleyJointDef.prototype.ratio = 1, box2d.b2PulleyJointDef.prototype.Initialize = function(t, e, i, o, s, n, r) {
    this.bodyA = t, this.bodyB = e, this.groundAnchorA.Copy(i), this.groundAnchorB.Copy(o), this.bodyA.GetLocalPoint(s, this.localAnchorA), this.bodyB.GetLocalPoint(n, this.localAnchorB), this.lengthA = box2d.b2DistanceVV(s, i), this.lengthB = box2d.b2DistanceVV(n, o), this.ratio = r
}, box2d.b2PulleyJoint = function(t) {
    goog.base(this, t), this.m_groundAnchorA = new box2d.b2Vec2, this.m_groundAnchorB = new box2d.b2Vec2, this.m_localAnchorA = new box2d.b2Vec2, this.m_localAnchorB = new box2d.b2Vec2, this.m_uA = new box2d.b2Vec2, this.m_uB = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_groundAnchorA.Copy(t.groundAnchorA), this.m_groundAnchorB.Copy(t.groundAnchorB), this.m_localAnchorA.Copy(t.localAnchorA), this.m_localAnchorB.Copy(t.localAnchorB), this.m_lengthA = t.lengthA, this.m_lengthB = t.lengthB, this.m_ratio = t.ratio, this.m_constant = t.lengthA + this.m_ratio * t.lengthB, this.m_impulse = 0
}, goog.inherits(box2d.b2PulleyJoint, box2d.b2Joint), box2d.b2PulleyJoint.prototype.m_groundAnchorA = null, box2d.b2PulleyJoint.prototype.m_groundAnchorB = null, box2d.b2PulleyJoint.prototype.m_lengthA = 0, box2d.b2PulleyJoint.prototype.m_lengthB = 0, box2d.b2PulleyJoint.prototype.m_localAnchorA = null, box2d.b2PulleyJoint.prototype.m_localAnchorB = null, box2d.b2PulleyJoint.prototype.m_constant = 0, box2d.b2PulleyJoint.prototype.m_ratio = 0, box2d.b2PulleyJoint.prototype.m_impulse = 0, box2d.b2PulleyJoint.prototype.m_indexA = 0, box2d.b2PulleyJoint.prototype.m_indexB = 0, box2d.b2PulleyJoint.prototype.m_uA = null, box2d.b2PulleyJoint.prototype.m_uB = null, box2d.b2PulleyJoint.prototype.m_rA = null, box2d.b2PulleyJoint.prototype.m_rB = null, box2d.b2PulleyJoint.prototype.m_localCenterA = null, box2d.b2PulleyJoint.prototype.m_localCenterB = null, box2d.b2PulleyJoint.prototype.m_invMassA = 0, box2d.b2PulleyJoint.prototype.m_invMassB = 0, box2d.b2PulleyJoint.prototype.m_invIA = 0, box2d.b2PulleyJoint.prototype.m_invIB = 0, box2d.b2PulleyJoint.prototype.m_mass = 0, box2d.b2PulleyJoint.prototype.m_qA = null, box2d.b2PulleyJoint.prototype.m_qB = null, box2d.b2PulleyJoint.prototype.m_lalcA = null, box2d.b2PulleyJoint.prototype.m_lalcB = null, box2d.b2PulleyJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        s = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        d = this.m_qB.SetAngleRadians(r);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(l, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(d, this.m_lalcB, this.m_rB), this.m_uA.Copy(e).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA), this.m_uB.Copy(n).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);
    var c = this.m_uA.GetLength(),
        p = this.m_uB.GetLength();
    c > 10 * box2d.b2_linearSlop ? this.m_uA.SelfMul(1 / c) : this.m_uA.SetZero(), p > 10 * box2d.b2_linearSlop ? this.m_uB.SelfMul(1 / p) : this.m_uB.SetZero();
    var u = box2d.b2CrossVV(this.m_rA, this.m_uA),
        b = box2d.b2CrossVV(this.m_rB, this.m_uB),
        m = this.m_invMassA + this.m_invIA * u * u,
        y = this.m_invMassB + this.m_invIB * b * b;
    if (this.m_mass = m + this.m_ratio * this.m_ratio * y, this.m_mass > 0 && (this.m_mass = 1 / this.m_mass), t.step.warmStarting) {
        this.m_impulse *= t.step.dtRatio;
        var f = box2d.b2MulSV(-this.m_impulse, this.m_uA, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA),
            g = box2d.b2MulSV(-this.m_ratio * this.m_impulse, this.m_uB, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB);
        o.SelfMulAdd(this.m_invMassA, f), s += this.m_invIA * box2d.b2CrossVV(this.m_rA, f), a.SelfMulAdd(this.m_invMassB, g), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, g)
    } else this.m_impulse = 0;
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = h
}, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA),
        r = box2d.b2AddVCrossSV(o, s, this.m_rB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB),
        a = -box2d.b2DotVV(this.m_uA, n) - this.m_ratio * box2d.b2DotVV(this.m_uB, r),
        h = -this.m_mass * a;
    this.m_impulse += h;
    var l = box2d.b2MulSV(-h, this.m_uA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA),
        d = box2d.b2MulSV(-this.m_ratio * h, this.m_uB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB);
    e.SelfMulAdd(this.m_invMassA, l), i += this.m_invIA * box2d.b2CrossVV(this.m_rA, l), o.SelfMulAdd(this.m_invMassB, d), s += this.m_invIB * box2d.b2CrossVV(this.m_rB, d), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolvePositionConstraints = function(t) {
        var e = t.positions[this.m_indexA].c,
            i = t.positions[this.m_indexA].a,
            o = t.positions[this.m_indexB].c,
            s = t.positions[this.m_indexB].a,
            n = this.m_qA.SetAngleRadians(i),
            r = this.m_qB.SetAngleRadians(s);
        box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
        var a = box2d.b2MulRV(n, this.m_lalcA, this.m_rA);
        box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
        var h = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
            l = this.m_uA.Copy(e).SelfAdd(a).SelfSub(this.m_groundAnchorA),
            d = this.m_uB.Copy(o).SelfAdd(h).SelfSub(this.m_groundAnchorB),
            c = l.GetLength(),
            p = d.GetLength();
        c > 10 * box2d.b2_linearSlop ? l.SelfMul(1 / c) : l.SetZero(), p > 10 * box2d.b2_linearSlop ? d.SelfMul(1 / p) : d.SetZero();
        var u = box2d.b2CrossVV(a, l),
            b = box2d.b2CrossVV(h, d),
            m = this.m_invMassA + this.m_invIA * u * u,
            y = this.m_invMassB + this.m_invIB * b * b,
            f = m + this.m_ratio * this.m_ratio * y;
        f > 0 && (f = 1 / f);
        var g = this.m_constant - c - this.m_ratio * p,
            x = box2d.b2Abs(g),
            _ = -f * g,
            v = box2d.b2MulSV(-_, l, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA),
            w = box2d.b2MulSV(-this.m_ratio * _, d, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB);
        return e.SelfMulAdd(this.m_invMassA, v), i += this.m_invIA * box2d.b2CrossVV(a, v), o.SelfMulAdd(this.m_invMassB, w), s += this.m_invIB * box2d.b2CrossVV(h, w), t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = s, x < box2d.b2_linearSlop
    }, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.GetAnchorA = function(t) {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
    }, box2d.b2PulleyJoint.prototype.GetAnchorB = function(t) {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
    }, box2d.b2PulleyJoint.prototype.GetReactionForce = function(t, e) {
        return e.SetXY(t * this.m_impulse * this.m_uB.x, t * this.m_impulse * this.m_uB.y)
    }, box2d.b2PulleyJoint.prototype.GetReactionTorque = function(t) {
        return 0
    }, box2d.b2PulleyJoint.prototype.GetGroundAnchorA = function(t) {
        return t.Copy(this.m_groundAnchorA)
    }, box2d.b2PulleyJoint.prototype.GetGroundAnchorB = function(t) {
        return t.Copy(this.m_groundAnchorB)
    }, box2d.b2PulleyJoint.prototype.GetLengthA = function() {
        return this.m_lengthA
    }, box2d.b2PulleyJoint.prototype.GetLengthB = function() {
        return this.m_lengthB
    }, box2d.b2PulleyJoint.prototype.GetRatio = function() {
        return this.m_ratio
    }, box2d.b2PulleyJoint.prototype.GetCurrentLengthA = function() {
        var t = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p),
            e = this.m_groundAnchorA;
        return box2d.b2DistanceVV(t, e)
    }, box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p = new box2d.b2Vec2,
    box2d.b2PulleyJoint.prototype.GetCurrentLengthB = function() {
        var t = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p),
            e = this.m_groundAnchorB;
        return box2d.b2DistanceVV(t, e)
    }, box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.Dump = function() {}, box2d.b2PulleyJoint.prototype.ShiftOrigin = function(t) {
        this.m_groundAnchorA.SelfSub(t), this.m_groundAnchorB.SelfSub(t)
    }, goog.provide("box2d.b2CircleShape"), goog.require("box2d.b2Shape"), box2d.b2CircleShape = function(t) {
        goog.base(this, box2d.b2ShapeType.e_circleShape, t || 0), this.m_p = new box2d.b2Vec2
    }, goog.inherits(box2d.b2CircleShape, box2d.b2Shape), box2d.b2CircleShape.prototype.m_p = null, box2d.b2CircleShape.prototype.Clone = function() {
        return (new box2d.b2CircleShape).Copy(this)
    }, box2d.b2CircleShape.prototype.Copy = function(t) {
        return goog.base(this, "Copy", t), this.m_p.Copy(t.m_p), this
    }, box2d.b2CircleShape.prototype.GetChildCount = function() {
        return 1
    }, box2d.b2CircleShape.prototype.TestPoint = function(t, e) {
        var i = box2d.b2MulXV(t, this.m_p, box2d.b2CircleShape.prototype.TestPoint.s_center),
            o = box2d.b2SubVV(e, i, box2d.b2CircleShape.prototype.TestPoint.s_d);
        return box2d.b2DotVV(o, o) <= box2d.b2Sq(this.m_radius)
    }, box2d.b2CircleShape.prototype.TestPoint.s_center = new box2d.b2Vec2, box2d.b2CircleShape.prototype.TestPoint.s_d = new box2d.b2Vec2, box2d.b2CircleShape.prototype.RayCast = function(t, e, i, o) {
        var s = box2d.b2MulXV(i, this.m_p, box2d.b2CircleShape.prototype.RayCast.s_position),
            n = box2d.b2SubVV(e.p1, s, box2d.b2CircleShape.prototype.RayCast.s_s),
            r = box2d.b2DotVV(n, n) - box2d.b2Sq(this.m_radius),
            a = box2d.b2SubVV(e.p2, e.p1, box2d.b2CircleShape.prototype.RayCast.s_r),
            h = box2d.b2DotVV(n, a),
            l = box2d.b2DotVV(a, a),
            d = h * h - l * r;
        if (d < 0 || l < box2d.b2_epsilon) return !1;
        var c = -(h + box2d.b2Sqrt(d));
        return 0 <= c && c <= e.maxFraction * l && (c /= l, t.fraction = c, box2d.b2AddVMulSV(n, c, a, t.normal).SelfNormalize(), !0)
    }, box2d.b2CircleShape.prototype.RayCast.s_position = new box2d.b2Vec2, box2d.b2CircleShape.prototype.RayCast.s_s = new box2d.b2Vec2, box2d.b2CircleShape.prototype.RayCast.s_r = new box2d.b2Vec2, box2d.b2CircleShape.prototype.ComputeAABB = function(t, e, i) {
        var o = box2d.b2MulXV(e, this.m_p, box2d.b2CircleShape.prototype.ComputeAABB.s_p);
        t.lowerBound.SetXY(o.x - this.m_radius, o.y - this.m_radius), t.upperBound.SetXY(o.x + this.m_radius, o.y + this.m_radius)
    }, box2d.b2CircleShape.prototype.ComputeAABB.s_p = new box2d.b2Vec2, box2d.b2CircleShape.prototype.ComputeMass = function(t, e) {
        var i = box2d.b2Sq(this.m_radius);
        t.mass = e * box2d.b2_pi * i, t.center.Copy(this.m_p), t.I = t.mass * (.5 * i + box2d.b2DotVV(this.m_p, this.m_p))
    }, box2d.b2CircleShape.prototype.SetupDistanceProxy = function(t, e) {
        t.m_vertices = new Array(1, !0), t.m_vertices[0] = this.m_p, t.m_count = 1, t.m_radius = this.m_radius
    }, box2d.b2CircleShape.prototype.ComputeSubmergedArea = function(t, e, i, o) {
        var s = box2d.b2MulXV(i, this.m_p, new box2d.b2Vec2),
            n = -(box2d.b2DotVV(t, s) - e);
        if (n < -this.m_radius + box2d.b2_epsilon) return 0;
        if (n > this.m_radius) return o.Copy(s), box2d.b2_pi * this.m_radius * this.m_radius;
        var r = this.m_radius * this.m_radius,
            a = n * n,
            h = r * (box2d.b2Asin(n / this.m_radius) + box2d.b2_pi / 2) + n * box2d.b2Sqrt(r - a),
            l = -2 / 3 * box2d.b2Pow(r - a, 1.5) / h;
        return o.x = s.x + t.x * l, o.y = s.y + t.y * l, h
    }, box2d.b2CircleShape.prototype.Dump = function() {
        box2d.b2Log("    /*box2d.b2CircleShape*/ var shape = new box2d.b2CircleShape();\n"), box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius), box2d.b2Log("    shape.m_p.SetXY(%.15f, %.15f);\n", this.m_p.x, this.m_p.y)
    }, goog.provide("box2d.b2Rope"), goog.require("box2d.b2Math"), goog.require("box2d.b2Draw"), box2d.b2RopeDef = function() {
        this.vertices = new Array, this.masses = new Array, this.gravity = new box2d.b2Vec2
    }, box2d.b2RopeDef.prototype.vertices = null, box2d.b2RopeDef.prototype.count = 0, box2d.b2RopeDef.prototype.masses = null, box2d.b2RopeDef.prototype.gravity = null, box2d.b2RopeDef.prototype.damping = .1, box2d.b2RopeDef.prototype.k2 = .9, box2d.b2RopeDef.prototype.k3 = .1, box2d.b2Rope = function() {
        this.m_gravity = new box2d.b2Vec2
    }, box2d.b2Rope.prototype.m_count = 0, box2d.b2Rope.prototype.m_ps = null, box2d.b2Rope.prototype.m_p0s = null, box2d.b2Rope.prototype.m_vs = null, box2d.b2Rope.prototype.m_ims = null, box2d.b2Rope.prototype.m_Ls = null, box2d.b2Rope.prototype.m_as = null, box2d.b2Rope.prototype.m_gravity = null, box2d.b2Rope.prototype.m_damping = 0, box2d.b2Rope.prototype.m_k2 = 1, box2d.b2Rope.prototype.m_k3 = .1, box2d.b2Rope.prototype.GetVertexCount = function() {
        return this.m_count
    }, box2d.b2Rope.prototype.GetVertices = function() {
        return this.m_ps
    }, box2d.b2Rope.prototype.Initialize = function(t) {
        this.m_count = t.count, this.m_ps = box2d.b2Vec2.MakeArray(this.m_count), this.m_p0s = box2d.b2Vec2.MakeArray(this.m_count), this.m_vs = box2d.b2Vec2.MakeArray(this.m_count), this.m_ims = box2d.b2MakeNumberArray(this.m_count);
        for (var e = 0; e < this.m_count; ++e) {
            this.m_ps[e].Copy(t.vertices[e]), this.m_p0s[e].Copy(t.vertices[e]), this.m_vs[e].SetZero();
            var i = t.masses[e];
            this.m_ims[e] = i > 0 ? 1 / i : 0
        }
        var o = this.m_count - 1,
            s = this.m_count - 2;
        this.m_Ls = box2d.b2MakeNumberArray(o), this.m_as = box2d.b2MakeNumberArray(s);
        for (var e = 0; e < o; ++e) {
            var n = this.m_ps[e],
                r = this.m_ps[e + 1];
            this.m_Ls[e] = box2d.b2DistanceVV(n, r)
        }
        for (var e = 0; e < s; ++e) {
            var n = this.m_ps[e],
                r = this.m_ps[e + 1],
                a = this.m_ps[e + 2],
                h = box2d.b2SubVV(r, n, box2d.b2Vec2.s_t0),
                l = box2d.b2SubVV(a, r, box2d.b2Vec2.s_t1),
                d = box2d.b2CrossVV(h, l),
                c = box2d.b2DotVV(h, l);
            this.m_as[e] = box2d.b2Atan2(d, c)
        }
        this.m_gravity.Copy(t.gravity), this.m_damping = t.damping, this.m_k2 = t.k2, this.m_k3 = t.k3
    }, box2d.b2Rope.prototype.Step = function(t, e) {
        if (0 !== t) {
            for (var i = Math.exp(-t * this.m_damping), o = 0; o < this.m_count; ++o) this.m_p0s[o].Copy(this.m_ps[o]), this.m_ims[o] > 0 && this.m_vs[o].SelfMulAdd(t, this.m_gravity), this.m_vs[o].SelfMul(i), this.m_ps[o].SelfMulAdd(t, this.m_vs[o]);
            for (var o = 0; o < e; ++o) this.SolveC2(), this.SolveC3(), this.SolveC2();
            for (var s = 1 / t, o = 0; o < this.m_count; ++o) box2d.b2MulSV(s, box2d.b2SubVV(this.m_ps[o], this.m_p0s[o], box2d.b2Vec2.s_t0), this.m_vs[o])
        }
    }, box2d.b2Rope.prototype.SolveC2 = function() {
        for (var t = this.m_count - 1, e = 0; e < t; ++e) {
            var i = this.m_ps[e],
                o = this.m_ps[e + 1],
                s = box2d.b2SubVV(o, i, box2d.b2Rope.s_d),
                n = s.Normalize(),
                r = this.m_ims[e],
                a = this.m_ims[e + 1];
            if (r + a !== 0) {
                var h = r / (r + a),
                    l = a / (r + a);
                i.SelfMulSub(this.m_k2 * h * (this.m_Ls[e] - n), s), o.SelfMulAdd(this.m_k2 * l * (this.m_Ls[e] - n), s)
            }
        }
    }, box2d.b2Rope.s_d = new box2d.b2Vec2, box2d.b2Rope.prototype.SetAngleRadians = function(t) {
        for (var e = this.m_count - 2, i = 0; i < e; ++i) this.m_as[i] = t
    }, box2d.b2Rope.prototype.SolveC3 = function() {
        for (var t = this.m_count - 2, e = 0; e < t; ++e) {
            var i = this.m_ps[e],
                o = this.m_ps[e + 1],
                s = this.m_ps[e + 2],
                n = this.m_ims[e],
                r = this.m_ims[e + 1],
                a = this.m_ims[e + 2],
                h = box2d.b2SubVV(o, i, box2d.b2Rope.s_d1),
                l = box2d.b2SubVV(s, o, box2d.b2Rope.s_d2),
                d = h.GetLengthSquared(),
                c = l.GetLengthSquared();
            if (d * c != 0) {
                var p = box2d.b2CrossVV(h, l),
                    u = box2d.b2DotVV(h, l),
                    b = box2d.b2Atan2(p, u),
                    m = box2d.b2MulSV(-1 / d, h.SelfSkew(), box2d.b2Rope.s_Jd1),
                    y = box2d.b2MulSV(1 / c, l.SelfSkew(), box2d.b2Rope.s_Jd2),
                    f = box2d.b2NegV(m, box2d.b2Rope.s_J1),
                    g = box2d.b2SubVV(m, y, box2d.b2Rope.s_J2),
                    x = y,
                    _ = n * box2d.b2DotVV(f, f) + r * box2d.b2DotVV(g, g) + a * box2d.b2DotVV(x, x);
                if (0 !== _) {
                    _ = 1 / _;
                    for (var v = b - this.m_as[e]; v > box2d.b2_pi;) b -= 2 * box2d.b2_pi, v = b - this.m_as[e];
                    for (; v < -box2d.b2_pi;) b += 2 * box2d.b2_pi, v = b - this.m_as[e];
                    var w = -this.m_k3 * _ * v;
                    i.SelfMulAdd(n * w, f), o.SelfMulAdd(r * w, g), s.SelfMulAdd(a * w, x)
                }
            }
        }
    }, box2d.b2Rope.s_d1 = new box2d.b2Vec2, box2d.b2Rope.s_d2 = new box2d.b2Vec2, box2d.b2Rope.s_Jd1 = new box2d.b2Vec2, box2d.b2Rope.s_Jd2 = new box2d.b2Vec2, box2d.b2Rope.s_J1 = new box2d.b2Vec2, box2d.b2Rope.s_J2 = new box2d.b2Vec2, box2d.b2Rope.prototype.Draw = function(t) {
        for (var e = new box2d.b2Color(.4, .5, .7), i = 0; i < this.m_count - 1; ++i) t.DrawSegment(this.m_ps[i], this.m_ps[i + 1], e)
    }, goog.provide("box2d.b2WheelJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), box2d.b2WheelJointDef = function() {
        goog.base(this, box2d.b2JointType.e_wheelJoint), this.localAnchorA = new box2d.b2Vec2(0, 0), this.localAnchorB = new box2d.b2Vec2(0, 0), this.localAxisA = new box2d.b2Vec2(1, 0)
    }, goog.inherits(box2d.b2WheelJointDef, box2d.b2JointDef), box2d.b2WheelJointDef.prototype.localAnchorA = null, box2d.b2WheelJointDef.prototype.localAnchorB = null, box2d.b2WheelJointDef.prototype.localAxisA = null, box2d.b2WheelJointDef.prototype.enableMotor = !1, box2d.b2WheelJointDef.prototype.maxMotorTorque = 0, box2d.b2WheelJointDef.prototype.motorSpeed = 0, box2d.b2WheelJointDef.prototype.frequencyHz = 2, box2d.b2WheelJointDef.prototype.dampingRatio = .7, box2d.b2WheelJointDef.prototype.Initialize = function(t, e, i, o) {
        this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB), this.bodyA.GetLocalVector(o, this.localAxisA)
    }, box2d.b2WheelJoint = function(t) {
        goog.base(this, t), this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_localXAxisA = t.localAxisA.Clone(), this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2), this.m_maxMotorTorque = t.maxMotorTorque, this.m_motorSpeed = t.motorSpeed, this.m_enableMotor = t.enableMotor, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_ax = new box2d.b2Vec2, this.m_ay = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_ax.SetZero(), this.m_ay.SetZero()
    }, goog.inherits(box2d.b2WheelJoint, box2d.b2Joint), box2d.b2WheelJoint.prototype.m_frequencyHz = 0, box2d.b2WheelJoint.prototype.m_dampingRatio = 0, box2d.b2WheelJoint.prototype.m_localAnchorA = null, box2d.b2WheelJoint.prototype.m_localAnchorB = null, box2d.b2WheelJoint.prototype.m_localXAxisA = null, box2d.b2WheelJoint.prototype.m_localYAxisA = null, box2d.b2WheelJoint.prototype.m_impulse = 0, box2d.b2WheelJoint.prototype.m_motorImpulse = 0, box2d.b2WheelJoint.prototype.m_springImpulse = 0, box2d.b2WheelJoint.prototype.m_maxMotorTorque = 0, box2d.b2WheelJoint.prototype.m_motorSpeed = 0, box2d.b2WheelJoint.prototype.m_enableMotor = !1, box2d.b2WheelJoint.prototype.m_indexA = 0, box2d.b2WheelJoint.prototype.m_indexB = 0, box2d.b2WheelJoint.prototype.m_localCenterA = null, box2d.b2WheelJoint.prototype.m_localCenterB = null, box2d.b2WheelJoint.prototype.m_invMassA = 0, box2d.b2WheelJoint.prototype.m_invMassB = 0, box2d.b2WheelJoint.prototype.m_invIA = 0, box2d.b2WheelJoint.prototype.m_invIB = 0, box2d.b2WheelJoint.prototype.m_ax = null, box2d.b2WheelJoint.prototype.m_ay = null, box2d.b2WheelJoint.prototype.m_sAx = 0, box2d.b2WheelJoint.prototype.m_sBx = 0, box2d.b2WheelJoint.prototype.m_sAy = 0, box2d.b2WheelJoint.prototype.m_sBy = 0, box2d.b2WheelJoint.prototype.m_mass = 0, box2d.b2WheelJoint.prototype.m_motorMass = 0, box2d.b2WheelJoint.prototype.m_springMass = 0, box2d.b2WheelJoint.prototype.m_bias = 0, box2d.b2WheelJoint.prototype.m_gamma = 0, box2d.b2WheelJoint.prototype.m_qA = null, box2d.b2WheelJoint.prototype.m_qB = null, box2d.b2WheelJoint.prototype.m_lalcA = null, box2d.b2WheelJoint.prototype.m_lalcB = null, box2d.b2WheelJoint.prototype.m_rA = null, box2d.b2WheelJoint.prototype.m_rB = null, box2d.b2WheelJoint.prototype.GetMotorSpeed = function() {
        return this.m_motorSpeed
    }, box2d.b2WheelJoint.prototype.GetMaxMotorTorque = function() {
        return this.m_maxMotorTorque
    }, box2d.b2WheelJoint.prototype.SetSpringFrequencyHz = function(t) {
        this.m_frequencyHz = t
    }, box2d.b2WheelJoint.prototype.GetSpringFrequencyHz = function() {
        return this.m_frequencyHz
    }, box2d.b2WheelJoint.prototype.SetSpringDampingRatio = function(t) {
        this.m_dampingRatio = t
    }, box2d.b2WheelJoint.prototype.GetSpringDampingRatio = function() {
        return this.m_dampingRatio
    }, box2d.b2WheelJoint.prototype.InitVelocityConstraints = function(t) {
        this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
        var e = this.m_invMassA,
            i = this.m_invMassB,
            o = this.m_invIA,
            s = this.m_invIB,
            n = t.positions[this.m_indexA].c,
            r = t.positions[this.m_indexA].a,
            a = t.velocities[this.m_indexA].v,
            h = t.velocities[this.m_indexA].w,
            l = t.positions[this.m_indexB].c,
            d = t.positions[this.m_indexB].a,
            c = t.velocities[this.m_indexB].v,
            p = t.velocities[this.m_indexB].w,
            u = this.m_qA.SetAngleRadians(r),
            b = this.m_qB.SetAngleRadians(d);
        box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
        var m = box2d.b2MulRV(u, this.m_lalcA, this.m_rA);
        box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
        var y = box2d.b2MulRV(b, this.m_lalcB, this.m_rB),
            f = box2d.b2SubVV(box2d.b2AddVV(l, y, box2d.b2Vec2.s_t0), box2d.b2AddVV(n, m, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d);
        if (box2d.b2MulRV(u, this.m_localYAxisA, this.m_ay), this.m_sAy = box2d.b2CrossVV(box2d.b2AddVV(f, m, box2d.b2Vec2.s_t0), this.m_ay), this.m_sBy = box2d.b2CrossVV(y, this.m_ay), this.m_mass = e + i + o * this.m_sAy * this.m_sAy + s * this.m_sBy * this.m_sBy, this.m_mass > 0 && (this.m_mass = 1 / this.m_mass), this.m_springMass = 0, this.m_bias = 0, this.m_gamma = 0, this.m_frequencyHz > 0) {
            box2d.b2MulRV(u, this.m_localXAxisA, this.m_ax), this.m_sAx = box2d.b2CrossVV(box2d.b2AddVV(f, m, box2d.b2Vec2.s_t0), this.m_ax), this.m_sBx = box2d.b2CrossVV(y, this.m_ax);
            var g = e + i + o * this.m_sAx * this.m_sAx + s * this.m_sBx * this.m_sBx;
            if (g > 0) {
                this.m_springMass = 1 / g;
                var x = box2d.b2DotVV(f, this.m_ax),
                    _ = 2 * box2d.b2_pi * this.m_frequencyHz,
                    v = 2 * this.m_springMass * this.m_dampingRatio * _,
                    w = this.m_springMass * _ * _,
                    C = t.step.dt;
                this.m_gamma = C * (v + C * w), this.m_gamma > 0 && (this.m_gamma = 1 / this.m_gamma), this.m_bias = x * C * w * this.m_gamma, this.m_springMass = g + this.m_gamma, this.m_springMass > 0 && (this.m_springMass = 1 / this.m_springMass)
            }
        } else this.m_springImpulse = 0;
        if (this.m_enableMotor ? (this.m_motorMass = o + s, this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass)) : (this.m_motorMass = 0, this.m_motorImpulse = 0), t.step.warmStarting) {
            this.m_impulse *= t.step.dtRatio, this.m_springImpulse *= t.step.dtRatio, this.m_motorImpulse *= t.step.dtRatio;
            var S = box2d.b2AddVV(box2d.b2MulSV(this.m_impulse, this.m_ay, box2d.b2Vec2.s_t0), box2d.b2MulSV(this.m_springImpulse, this.m_ax, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P),
                A = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse,
                T = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;
            a.SelfMulSub(this.m_invMassA, S), h -= this.m_invIA * A, c.SelfMulAdd(this.m_invMassB, S), p += this.m_invIB * T
        } else this.m_impulse = 0, this.m_springImpulse = 0, this.m_motorImpulse = 0;
        t.velocities[this.m_indexA].w = h, t.velocities[this.m_indexB].w = p
    }, box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.SolveVelocityConstraints = function(t) {
        var e = this.m_invMassA,
            i = this.m_invMassB,
            o = this.m_invIA,
            s = this.m_invIB,
            n = t.velocities[this.m_indexA].v,
            r = t.velocities[this.m_indexA].w,
            a = t.velocities[this.m_indexB].v,
            h = t.velocities[this.m_indexB].w,
            l = box2d.b2DotVV(this.m_ax, box2d.b2SubVV(a, n, box2d.b2Vec2.s_t0)) + this.m_sBx * h - this.m_sAx * r,
            d = -this.m_springMass * (l + this.m_bias + this.m_gamma * this.m_springImpulse);
        this.m_springImpulse += d;
        var c = box2d.b2MulSV(d, this.m_ax, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P),
            p = d * this.m_sAx,
            u = d * this.m_sBx;
        n.SelfMulSub(e, c), r -= o * p, a.SelfMulAdd(i, c), h += s * u;
        var l = h - r - this.m_motorSpeed,
            d = -this.m_motorMass * l,
            b = this.m_motorImpulse,
            m = t.step.dt * this.m_maxMotorTorque;
        this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + d, -m, m), d = this.m_motorImpulse - b, r -= o * d, h += s * d;
        var l = box2d.b2DotVV(this.m_ay, box2d.b2SubVV(a, n, box2d.b2Vec2.s_t0)) + this.m_sBy * h - this.m_sAy * r,
            d = -this.m_mass * l;
        this.m_impulse += d;
        var c = box2d.b2MulSV(d, this.m_ay, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P),
            p = d * this.m_sAy,
            u = d * this.m_sBy;
        n.SelfMulSub(e, c), r -= o * p, a.SelfMulAdd(i, c), h += s * u, t.velocities[this.m_indexA].w = r, t.velocities[this.m_indexB].w = h
    }, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.SolvePositionConstraints = function(t) {
        var e = t.positions[this.m_indexA].c,
            i = t.positions[this.m_indexA].a,
            o = t.positions[this.m_indexB].c,
            s = t.positions[this.m_indexB].a,
            n = this.m_qA.SetAngleRadians(i),
            r = this.m_qB.SetAngleRadians(s);
        box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
        var a = box2d.b2MulRV(n, this.m_lalcA, this.m_rA);
        box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
        var h, l = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
            d = box2d.b2AddVV(box2d.b2SubVV(o, e, box2d.b2Vec2.s_t0), box2d.b2SubVV(l, a, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d),
            c = box2d.b2MulRV(n, this.m_localYAxisA, this.m_ay),
            p = box2d.b2CrossVV(box2d.b2AddVV(d, a, box2d.b2Vec2.s_t0), c),
            u = box2d.b2CrossVV(l, c),
            b = box2d.b2DotVV(d, this.m_ay),
            m = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
        h = 0 !== m ? -b / m : 0;
        var y = box2d.b2MulSV(h, c, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P),
            f = h * p,
            g = h * u;
        return e.SelfMulSub(this.m_invMassA, y), i -= this.m_invIA * f, o.SelfMulAdd(this.m_invMassB, y), s += this.m_invIB * g, t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = s, box2d.b2Abs(b) <= box2d.b2_linearSlop
    }, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.GetDefinition = function(t) {
        return t
    }, box2d.b2WheelJoint.prototype.GetAnchorA = function(t) {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t)
    }, box2d.b2WheelJoint.prototype.GetAnchorB = function(t) {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t)
    }, box2d.b2WheelJoint.prototype.GetReactionForce = function(t, e) {
        return e.x = t * (this.m_impulse * this.m_ay.x + this.m_springImpulse * this.m_ax.x), e.y = t * (this.m_impulse * this.m_ay.y + this.m_springImpulse * this.m_ax.y), e
    }, box2d.b2WheelJoint.prototype.GetReactionTorque = function(t) {
        return t * this.m_motorImpulse
    }, box2d.b2WheelJoint.prototype.GetLocalAnchorA = function(t) {
        return t.Copy(this.m_localAnchorA)
    }, box2d.b2WheelJoint.prototype.GetLocalAnchorB = function(t) {
        return t.Copy(this.m_localAnchorB)
    }, box2d.b2WheelJoint.prototype.GetLocalAxisA = function(t) {
        return t.Copy(this.m_localXAxisA)
    }, box2d.b2WheelJoint.prototype.GetJointTranslation = function() {
        var t = this.m_bodyA,
            e = this.m_bodyB,
            i = t.GetWorldPoint(this.m_localAnchorA, new box2d.b2Vec2),
            o = e.GetWorldPoint(this.m_localAnchorB, new box2d.b2Vec2),
            s = box2d.b2SubVV(o, i, new box2d.b2Vec2),
            n = t.GetWorldVector(this.m_localXAxisA, new box2d.b2Vec2);
        return box2d.b2DotVV(s, n)
    }, box2d.b2WheelJoint.prototype.GetJointSpeed = function() {
        var t = this.m_bodyA.m_angularVelocity;
        return this.m_bodyB.m_angularVelocity - t
    }, box2d.b2WheelJoint.prototype.IsMotorEnabled = function() {
        return this.m_enableMotor
    }, box2d.b2WheelJoint.prototype.EnableMotor = function(t) {
        this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t
    }, box2d.b2WheelJoint.prototype.SetMotorSpeed = function(t) {
        this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t
    }, box2d.b2WheelJoint.prototype.SetMaxMotorTorque = function(t) {
        this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorTorque = t
    }, box2d.b2WheelJoint.prototype.GetMotorTorque = function(t) {
        return t * this.m_motorImpulse
    }, box2d.b2WheelJoint.prototype.Dump = function() {}, goog.provide("box2d.b2MotorJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), box2d.b2MotorJointDef = function() {
        goog.base(this, box2d.b2JointType.e_motorJoint), this.linearOffset = new box2d.b2Vec2(0, 0)
    }, goog.inherits(box2d.b2MotorJointDef, box2d.b2JointDef), box2d.b2MotorJointDef.prototype.linearOffset = null, box2d.b2MotorJointDef.prototype.angularOffset = 0, box2d.b2MotorJointDef.prototype.maxForce = 1, box2d.b2MotorJointDef.prototype.maxTorque = 1, box2d.b2MotorJointDef.prototype.correctionFactor = .3, box2d.b2MotorJointDef.prototype.Initialize = function(t, e) {
        this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(this.bodyB.GetPosition(), this.linearOffset);
        var i = this.bodyA.GetAngleRadians(),
            o = this.bodyB.GetAngleRadians();
        this.angularOffset = o - i
    }, box2d.b2MotorJoint = function(t) {
        goog.base(this, t), this.m_linearOffset = t.linearOffset.Clone(), this.m_linearImpulse = new box2d.b2Vec2(0, 0), this.m_maxForce = t.maxForce, this.m_maxTorque = t.maxTorque, this.m_correctionFactor = t.correctionFactor, this.m_rA = new box2d.b2Vec2(0, 0), this.m_rB = new box2d.b2Vec2(0, 0), this.m_localCenterA = new box2d.b2Vec2(0, 0), this.m_localCenterB = new box2d.b2Vec2(0, 0), this.m_linearError = new box2d.b2Vec2(0, 0), this.m_linearMass = new box2d.b2Mat22, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_K = new box2d.b2Mat22
    }, goog.inherits(box2d.b2MotorJoint, box2d.b2Joint), box2d.b2MotorJoint.prototype.m_linearOffset = null, box2d.b2MotorJoint.prototype.m_angularOffset = 0, box2d.b2MotorJoint.prototype.m_linearImpulse = null, box2d.b2MotorJoint.prototype.m_angularImpulse = 0, box2d.b2MotorJoint.prototype.m_maxForce = 0, box2d.b2MotorJoint.prototype.m_maxTorque = 0, box2d.b2MotorJoint.prototype.m_correctionFactor = .3, box2d.b2MotorJoint.prototype.m_indexA = 0, box2d.b2MotorJoint.prototype.m_indexB = 0, box2d.b2MotorJoint.prototype.m_rA = null, box2d.b2MotorJoint.prototype.m_rB = null, box2d.b2MotorJoint.prototype.m_localCenterA = null, box2d.b2MotorJoint.prototype.m_localCenterB = null, box2d.b2MotorJoint.prototype.m_linearError = null, box2d.b2MotorJoint.prototype.m_angularError = 0, box2d.b2MotorJoint.prototype.m_invMassA = 0, box2d.b2MotorJoint.prototype.m_invMassB = 0, box2d.b2MotorJoint.prototype.m_invIA = 0, box2d.b2MotorJoint.prototype.m_invIB = 0, box2d.b2MotorJoint.prototype.m_linearMass = null, box2d.b2MotorJoint.prototype.m_angularMass = 0, box2d.b2MotorJoint.prototype.m_qA = null, box2d.b2MotorJoint.prototype.m_qB = null, box2d.b2MotorJoint.prototype.m_K = null;
box2d.b2MotorJoint.prototype.GetAnchorA = function(t) {
    return this.m_bodyA.GetPosition(t)
}, box2d.b2MotorJoint.prototype.GetAnchorB = function(t) {
    return this.m_bodyB.GetPosition(t)
}, box2d.b2MotorJoint.prototype.GetReactionForce = function(t, e) {
    return box2d.b2MulSV(t, this.m_linearImpulse, e)
}, box2d.b2MotorJoint.prototype.GetReactionTorque = function(t) {
    return t * this.m_angularImpulse
}, box2d.b2MotorJoint.prototype.SetCorrectionFactor = function(t) {
    this._correctionFactor = t
}, box2d.b2MotorJoint.prototype.GetCorrectionFactor = function() {
    return this.m_correctionFactor
}, box2d.b2MotorJoint.prototype.SetLinearOffset = function(t) {
    box2d.b2IsEqualToV(t, this.m_linearOffset) || (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_linearOffset.Copy(t))
}, box2d.b2MotorJoint.prototype.GetLinearOffset = function(t) {
    return t.Copy(this.m_linearOffset)
}, box2d.b2MotorJoint.prototype.SetAngularOffset = function(t) {
    t !== this.m_angularOffset && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_angularOffset = t)
}, box2d.b2MotorJoint.prototype.GetAngularOffset = function() {
    return this.m_angularOffset
}, box2d.b2MotorJoint.prototype.SetMaxForce = function(t) {
    this.m_maxForce = t
}, box2d.b2MotorJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
}, box2d.b2MotorJoint.prototype.SetMaxTorque = function(t) {
    this.m_maxTorque = t
}, box2d.b2MotorJoint.prototype.GetMaxTorque = function() {
    return this.m_maxTorque
}, box2d.b2MotorJoint.prototype.InitVelocityConstraints = function(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        s = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        d = this.m_qB.SetAngleRadians(r),
        c = box2d.b2MulRV(l, box2d.b2NegV(this.m_localCenterA, box2d.b2Vec2.s_t0), this.m_rA),
        p = box2d.b2MulRV(d, box2d.b2NegV(this.m_localCenterB, box2d.b2Vec2.s_t0), this.m_rB),
        u = this.m_invMassA,
        b = this.m_invMassB,
        m = this.m_invIA,
        y = this.m_invIB,
        f = this.m_K;
    if (f.ex.x = u + b + m * c.y * c.y + y * p.y * p.y, f.ex.y = -m * c.x * c.y - y * p.x * p.y, f.ey.x = f.ex.y, f.ey.y = u + b + m * c.x * c.x + y * p.x * p.x, f.GetInverse(this.m_linearMass), this.m_angularMass = m + y, this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass), box2d.b2SubVV(box2d.b2SubVV(box2d.b2AddVV(n, p, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, c, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), box2d.b2MulRV(l, this.m_linearOffset, box2d.b2Vec2.s_t3), this.m_linearError), this.m_angularError = r - i - this.m_angularOffset, t.step.warmStarting) {
        this.m_linearImpulse.SelfMul(t.step.dtRatio), this.m_angularImpulse *= t.step.dtRatio;
        var g = this.m_linearImpulse;
        o.SelfMulSub(u, g), s -= m * (box2d.b2CrossVV(c, g) + this.m_angularImpulse), a.SelfMulAdd(b, g), h += y * (box2d.b2CrossVV(p, g) + this.m_angularImpulse)
    } else this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0;
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = h
}, box2d.b2MotorJoint.prototype.SolveVelocityConstraints = function(t) {
    var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        s = t.velocities[this.m_indexB].w,
        n = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB,
        l = t.step.dt,
        d = t.step.inv_dt,
        c = s - i + d * this.m_correctionFactor * this.m_angularError,
        p = -this.m_angularMass * c,
        u = this.m_angularImpulse,
        b = l * this.m_maxTorque;
    this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + p, -b, b), p = this.m_angularImpulse - u, i -= a * p, s += h * p;
    var m = this.m_rA,
        y = this.m_rB,
        c = box2d.b2AddVV(box2d.b2SubVV(box2d.b2AddVV(o, box2d.b2CrossSV(s, y, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2AddVV(e, box2d.b2CrossSV(i, m, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), box2d.b2MulSV(d * this.m_correctionFactor, this.m_linearError, box2d.b2Vec2.s_t3), box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot),
        p = box2d.b2MulMV(this.m_linearMass, c, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg(),
        u = box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_linearImpulse);
    this.m_linearImpulse.SelfAdd(p);
    var b = l * this.m_maxForce;
    this.m_linearImpulse.GetLengthSquared() > b * b && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.SelfMul(b)), box2d.b2SubVV(this.m_linearImpulse, u, p), e.SelfMulSub(n, p), i -= a * box2d.b2CrossVV(m, p), o.SelfMulAdd(r, p), s += h * box2d.b2CrossVV(y, p), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = s
}, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2, box2d.b2MotorJoint.prototype.SolvePositionConstraints = function(t) {
    return !0
}, box2d.b2MotorJoint.prototype.Dump = function() {}, goog.provide("box2d"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Draw"), goog.require("box2d.b2Timer"), goog.require("box2d.b2CircleShape"), goog.require("box2d.b2EdgeShape"), goog.require("box2d.b2ChainShape"), goog.require("box2d.b2PolygonShape"), goog.require("box2d.b2BroadPhase"), goog.require("box2d.b2Distance"), goog.require("box2d.b2DynamicTree"), goog.require("box2d.b2TimeOfImpact"), goog.require("box2d.b2Body"), goog.require("box2d.b2Fixture"), goog.require("box2d.b2WorldCallbacks"), goog.require("box2d.b2TimeStep"), goog.require("box2d.b2World"), goog.require("box2d.b2Contact"), goog.require("box2d.b2AreaJoint"), goog.require("box2d.b2DistanceJoint"), goog.require("box2d.b2FrictionJoint"), goog.require("box2d.b2GearJoint"), goog.require("box2d.b2MotorJoint"), goog.require("box2d.b2MouseJoint"), goog.require("box2d.b2PrismaticJoint"), goog.require("box2d.b2PulleyJoint"), goog.require("box2d.b2RevoluteJoint"), goog.require("box2d.b2RopeJoint"), goog.require("box2d.b2WeldJoint"), goog.require("box2d.b2WheelJoint"), goog.require("box2d.b2Rope"), goog.require("box2d.b2BuoyancyController"), goog.require("box2d.b2ConstantAccelController"), goog.require("box2d.b2ConstantForceController"), goog.require("box2d.b2GravityController"), goog.require("box2d.b2TensorDampingController"), Phaser.Physics.Box2D = function(t, e) {
    this.game = t, this.version = "1.0.2", this.ptmRatio = 50, this.world = new box2d.b2World(new box2d.b2Vec2(0, 0)), this.debugDraw = new Phaser.Physics.Box2D.DefaultDebugDraw(this.mpx(1)), this.world.SetDebugDraw(this.debugDraw), this.contactListener = new Phaser.Physics.Box2D.DefaultContactListener, this.world.SetContactListener(this.contactListener), this.nextBodyId = 0, this.nextFixtureId = 0, this.gravity = new Phaser.Physics.Box2D.PointProxy(this, this.world, this.world.GetGravity, this.world.SetGravity), this.friction = .2, this.restitution = 0, this.density = 1, this.frameRate = 1 / 60, this.velocityIterations = 8, this.positionIterations = 3, this.useElapsedTime = !1, this.paused = !1, this.particleSystem = null;
    var i = new box2d.b2BodyDef;
    this.mouseJointBody = this.world.CreateBody(i), this.mouseJoint = null, e.hasOwnProperty("mpx") && e.hasOwnProperty("pxm") && (this.mpx = e.mpx, this.pxm = e.pxm), this.walls = {
        left: null,
        right: null,
        top: null,
        bottom: null
    }, this.onBodyAdded = new Phaser.Signal, this.onBodyRemoved = new Phaser.Signal, this._toRemove = []
}, Phaser.Physics.Box2D.worldBoundsFilterCategory = 32768, Phaser.Physics.Box2D.prototype = {
    getNextBodyId: function() {
        var t = this.nextBodyId;
        return this.nextBodyId += 1, t
    },
    getNextFixtureId: function() {
        var t = this.nextFixtureId;
        return this.nextFixtureId += 1, t
    },
    removeBodyNextStep: function(t) {
        this._toRemove.push(t)
    },
    preUpdate: function() {
        for (var t = this._toRemove.length; t--;) this.removeBody(this._toRemove[t]);
        this._toRemove.length = 0
    },
    enable: function(t, e) {
        void 0 === e && (e = !0);
        var i = 1;
        if (Array.isArray(t))
            for (i = t.length; i--;) t[i] instanceof Phaser.Group ? this.enable(t[i].children, e) : (this.enableBody(t[i]), e && t[i].hasOwnProperty("children") && t[i].children.length > 0 && this.enable(t[i], !0));
        else t instanceof Phaser.Group ? this.enable(t.children, e) : (this.enableBody(t), e && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, !0))
    },
    enableBody: function(t) {
        t.hasOwnProperty("body") && null === t.body && (t.body = new Phaser.Physics.Box2D.Body(this.game, t, t.position.x, t.position.y, 2), t.anchor.set(.5))
    },
    setBoundsToWorld: function(t, e, i, o, s, n) {
        void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === o && (o = !0), void 0 === s && (s = 1), void 0 === n && (s = 4294967295), this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, t, e, i, o, s, n)
    },
    setBounds: function(t, e, i, o, s, n, r, a, h, l) {
        void 0 === s && (s = !0), void 0 === n && (n = !0), void 0 === r && (r = !0), void 0 === a && (a = !0), void 0 === h && (h = 1), void 0 === l && (l = 4294967295), this.walls.left && this.removeBody(this.walls.left), this.walls.right && this.removeBody(this.walls.right), this.walls.top && this.removeBody(this.walls.top), this.walls.bottom && this.removeBody(this.walls.bottom);
        var d = new box2d.b2PolygonShape,
            c = new box2d.b2FixtureDef;
        c.shape = d, c.filter.categoryBits = Phaser.Physics.Box2D.worldBoundsFilterCategory, c.filter.maskBits = 65535;
        var p = this.pxm(100),
            u = this.game.world.bounds;
        if (s) {
            this.walls.left = this.createBody(0, 0, 0), d.SetAsOrientedBox(p, this.pxm(u.height) + p, new box2d.b2Vec2(p, 0), 0);
            var b = this.walls.left.data.CreateFixture(c);
            b.id = this.getNextFixtureId()
        }
        if (n) {
            this.walls.right = this.createBody(0, 0, 0), d.SetAsOrientedBox(p, this.pxm(u.height) + p, new box2d.b2Vec2(this.pxm(-u.width) - p, 0), 0);
            var b = this.walls.right.data.CreateFixture(c);
            b.id = this.getNextFixtureId()
        }
        if (r) {
            this.walls.top = this.createBody(0, 0, 0), d.SetAsOrientedBox(this.pxm(u.width) + p, p, new box2d.b2Vec2(0, p), 0);
            var b = this.walls.top.data.CreateFixture(c);
            b.id = this.getNextFixtureId()
        }
        if (a) {
            this.walls.bottom = this.createBody(0, 0, 0), d.SetAsOrientedBox(this.pxm(u.width) + p, p, new box2d.b2Vec2(0, this.pxm(-u.height) - p), 0);
            var b = this.walls.bottom.data.CreateFixture(c);
            b.id = this.getNextFixtureId()
        }
    },
    pause: function() {
        this.paused = !0
    },
    resume: function() {
        this.paused = !1
    },
    update: function() {
        this.paused || (this.useElapsedTime ? this.world.Step(this.game.time.physicsElapsed, this.velocityIterations, this.positionIterations) : this.world.Step(this.frameRate, this.velocityIterations, this.positionIterations))
    },
    reset: function() {
        this.clear()
    },
    clear: function() {
        var t = this.world.GetGravity().Clone();
        this.world = new box2d.b2World(t), this.world.SetDebugDraw(this.debugDraw), this.world.SetContactListener(this.contactListener), this._toRemove = []
    },
    destroy: function() {
        this.clear(), this.gravity = null, this.world = null, this.game = null
    },
    createBody: function(t, e, i) {
        return new Phaser.Physics.Box2D.Body(this.game, null, t, e, i, this)
    },
    createCircle: function(t, e, i, o, s) {
        return this.createBody(t, e, 2).setCircle(i, o, s)
    },
    createRectangle: function(t, e, i, o, s, n, r) {
        return this.createBody(t, e, 2).setRectangle(i, o, s, n, r)
    },
    createPolygon: function(t, e, i, o, s) {
        return this.createBody(t, e, 2).setPolygon(i, o, s)
    },
    addBody: function(t) {
        return !t.data.world && (t.data = this.world.CreateBody(t.bodyDef), t.data.world = this.world, t.data.parent = t, this.onBodyAdded.dispatch(t), !0)
    },
    removeBody: function(t) {
        return t.data.world == this.world && (this.world.DestroyBody(t.data), this.onBodyRemoved.dispatch(t)), t
    },
    getBodies: function() {
        for (var t = [], e = this.world.GetBodyList(); e; e = e.GetNext()) t.push(e);
        return t
    },
    getBody: function(t) {
        return t instanceof box2d.b2Body ? t : t instanceof Phaser.Physics.Box2D.Body ? t.data : t.body && t.body.type === Phaser.Physics.BOX2D ? t.body.data : null
    },
    toJSON: function() {
        return this.world.toJSON()
    },
    mpx: function(t) {
        return t *= this.ptmRatio
    },
    pxm: function(t) {
        return t / this.ptmRatio
    },
    renderDebugDraw: function(t) {
        if (this.game.physics.box2d) {
            var e = this.game.physics.box2d;
            e.debugDraw.start(t), e.world.DrawDebugData(), e.debugDraw.stop()
        }
    },
    renderBodyInfo: function(t, e) {
        t.line("Position: x: " + e.x.toFixed(3) + " y: " + e.y.toFixed(3)), t.line("Rotation: " + e.rotation.toFixed(3) + " degrees"), t.line("Velocity: x: " + e.velocity.x.toFixed(3) + " y: " + e.velocity.y.toFixed(3)), t.line("Angular velocity: " + e.angularVelocity.toFixed(3) + " degrees/sec")
    },
    getFixturesAtPoint: function(t, e, i, o) {
        void 0 === i && (i = !1), void 0 === o && (o = !1);
        var s = this.pxm(-t),
            n = this.pxm(-e),
            r = new box2d.b2Vec2(s, n),
            a = new box2d.b2AABB,
            h = new box2d.b2Vec2;
        h.SetXY(.001, .001), box2d.b2SubVV(r, h, a.lowerBound), box2d.b2AddVV(r, h, a.upperBound);
        var l = [],
            d = function(t) {
                return !(!o || t.GetBody().GetType() === box2d.b2BodyType.b2_dynamicBody) || (!t.TestPoint(r) || (l.push(t), !i))
            };
        return this.world.QueryAABB(d, a), l
    },
    getBodiesAtPoint: function(t, e, i, o) {
        void 0 === i && (i = !1), void 0 === o && (o = !1);
        var s = this.getFixturesAtPoint(t, e, i, o);
        if (s.length < 1) return s;
        for (var n = [], r = 0; r < s.length; r++) n.push(s[r].GetBody().parent);
        return n.filter(function(t, e) {
            return n.indexOf(t) === e
        }), n
    },
    mouseDragStart: function(t) {
        this.mouseDragEnd();
        var e = this.getFixturesAtPoint(t.x, t.y, !0, !0);
        if (!(e.length < 1)) {
            var i = this.pxm(-t.x),
                o = this.pxm(-t.y),
                s = new box2d.b2Vec2(i, o),
                n = new box2d.b2MouseJointDef;
            n.bodyA = this.mouseJointBody, n.bodyB = e[0].GetBody(), n.target.Copy(s), n.maxForce = 1e3 * n.bodyB.GetMass(), this.mouseJoint = this.world.CreateJoint(n), n.bodyB.SetAwake(!0)
        }
    },
    mouseDragMove: function(t) {
        if (this.mouseJoint) {
            var e = this.pxm(-t.x),
                i = this.pxm(-t.y),
                o = new box2d.b2Vec2(e, i);
            this.mouseJoint.SetTarget(o)
        }
    },
    mouseDragEnd: function() {
        this.mouseJoint && (this.world.DestroyJoint(this.mouseJoint), this.mouseJoint = null)
    },
    distanceJoint: function(t, e, i, o, s, n, r, a, h) {
        void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), o = this.pxm(-o), s = this.pxm(-s), n = this.pxm(-n), r = this.pxm(-r), t.body && (t = t.body), e.body && (e = e.body);
        var l = new box2d.b2DistanceJointDef;
        if (l.bodyA = t.data, l.bodyB = e.data, l.localAnchorA.SetXY(o, s), l.localAnchorB.SetXY(n, r), null === i || void 0 === i) {
            var d = new box2d.b2Vec2,
                c = new box2d.b2Vec2;
            l.bodyA.GetWorldPoint(l.localAnchorA, d), l.bodyB.GetWorldPoint(l.localAnchorB, c), d.SelfSub(c), i = d.Length()
        } else i = this.pxm(i);
        return l.length = i, l.frequencyHz = a, l.dampingRatio = h, this.world.CreateJoint(l)
    },
    ropeJoint: function(t, e, i, o, s, n, r) {
        void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), o = this.pxm(-o), s = this.pxm(-s), n = this.pxm(-n), r = this.pxm(-r), t.body && (t = t.body), e.body && (e = e.body);
        var a = new box2d.b2RopeJointDef;
        if (a.bodyA = t.data, a.bodyB = e.data, a.localAnchorA.SetXY(o, s), a.localAnchorB.SetXY(n, r), null === i || void 0 === i) {
            var h = new box2d.b2Vec2,
                l = new box2d.b2Vec2;
            a.bodyA.GetWorldPoint(a.localAnchorA, h), a.bodyB.GetWorldPoint(a.localAnchorB, l), h.SelfSub(l), i = h.Length()
        } else i = this.pxm(i);
        return a.maxLength = i, this.world.CreateJoint(a)
    },
    revoluteJoint: function(t, e, i, o, s, n, r, a, h, l, d, c) {
        void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = !1), void 0 === l && (l = 0), void 0 === d && (d = 0), void 0 === c && (c = !1), i = this.pxm(-i), o = this.pxm(-o), s = this.pxm(-s), n = this.pxm(-n), t.body && (t = t.body), e.body && (e = e.body);
        var p = new box2d.b2RevoluteJointDef;
        return p.bodyA = t.data, p.bodyB = e.data, p.localAnchorA.SetXY(i, o), p.localAnchorB.SetXY(s, n), p.motorSpeed = Phaser.Math.degToRad(-r), p.maxMotorTorque = a, p.enableMotor = h, p.lowerAngle = Phaser.Math.degToRad(l), p.upperAngle = Phaser.Math.degToRad(d), p.enableLimit = c, this.world.CreateJoint(p)
    },
    prismaticJoint: function(t, e, i, o, s, n, r, a, h, l, d, c, p, u, b) {
        void 0 === i && (i = 1), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), void 0 === l && (l = 0), void 0 === c && (c = 0), void 0 === p && (p = 0), void 0 === u && (u = !1), void 0 === d && (d = !1), void 0 === b && (b = 0), i *= -1, o *= -1, s = this.pxm(-s), n = this.pxm(-n), r = this.pxm(-r), a = this.pxm(-a), h = this.pxm(h), c = this.pxm(c), p = this.pxm(p), t.body && (t = t.body), e.body && (e = e.body);
        var m = new box2d.b2PrismaticJointDef;
        return m.bodyA = t.data, m.bodyB = e.data, m.localAxisA.SetXY(i, o), m.localAnchorA.SetXY(s, n), m.localAnchorB.SetXY(r, a), m.motorSpeed = h, m.maxMotorForce = l, m.enableMotor = d, m.lowerTranslation = c, m.upperTranslation = p, m.enableLimit = u, m.referenceAngle = Phaser.Math.degToRad(-b), this.world.CreateJoint(m)
    },
    frictionJoint: function(t, e, i, o, s, n, r, a) {
        void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), s = this.pxm(-s), n = this.pxm(-n), r = this.pxm(-r), a = this.pxm(-a), t.body && (t = t.body), e.body && (e = e.body);
        var h = new box2d.b2FrictionJointDef;
        return h.bodyA = t.data, h.bodyB = e.data, h.localAnchorA.SetXY(s, n), h.localAnchorB.SetXY(r, a), h.maxForce = i, h.maxTorque = o, this.world.CreateJoint(h)
    },
    weldJoint: function(t, e, i, o, s, n, r, a) {
        void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), i = this.pxm(-i), o = this.pxm(-o), s = this.pxm(-s), n = this.pxm(-n), t.body && (t = t.body), e.body && (e = e.body);
        var h = new box2d.b2WeldJointDef;
        return h.bodyA = t.data, h.bodyB = e.data, h.localAnchorA.SetXY(i, o), h.localAnchorB.SetXY(s, n), h.frequencyHz = r, h.dampingRatio = a, this.world.CreateJoint(h)
    },
    motorJoint: function(t, e, i, o, s, n, r, a) {
        void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 1), n = this.pxm(-n), r = this.pxm(-r), t.body && (t = t.body), e.body && (e = e.body);
        var h = new box2d.b2MotorJointDef;
        return h.bodyA = t.data, h.bodyB = e.data, h.linearOffset.SetXY(n, r), h.maxForce = i, h.maxTorque = o, h.angularOffset = Phaser.Math.degToRad(-a), h.correctionFactor = s, this.world.CreateJoint(h)
    },
    wheelJoint: function(t, e, i, o, s, n, r, a, h, l, d, c, p) {
        void 0 === r && (r = 0), void 0 === a && (a = 1), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === d && (d = 0), void 0 === c && (c = 0), void 0 === p && (p = !1), void 0 === h && (h = 0), void 0 === l && (l = 0), r *= -1, a *= -1, i = this.pxm(-i), o = this.pxm(-o), s = this.pxm(-s), n = this.pxm(-n), t.body && (t = t.body), e.body && (e = e.body);
        var u = new box2d.b2WheelJointDef;
        return u.bodyA = t.data, u.bodyB = e.data, u.localAxisA.SetXY(r, a), u.localAnchorA.SetXY(i, o), u.localAnchorB.SetXY(s, n), u.motorSpeed = Phaser.Math.degToRad(-d), u.maxMotorTorque = c, u.enableMotor = p, u.frequencyHz = h, u.dampingRatio = l, this.world.CreateJoint(u)
    },
    pulleyJoint: function(t, e, i, o, s, n, r, a, h, l, d, c, p) {
        void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), void 0 === l && (l = 0), void 0 === d && (d = 1), void 0 === c && (c = 100), void 0 === p && (p = 100), i = this.pxm(-i), o = this.pxm(-o), s = this.pxm(-s), n = this.pxm(-n), r = this.pxm(-r), a = this.pxm(-a), h = this.pxm(-h), l = this.pxm(-l), c = this.pxm(c), p = this.pxm(p), t.body && (t = t.body), e.body && (e = e.body);
        var u = new box2d.b2PulleyJointDef;
        return u.bodyA = t.data, u.bodyB = e.data, u.localAnchorA.SetXY(i, o), u.localAnchorB.SetXY(s, n), u.groundAnchorA.SetXY(r, a), u.groundAnchorB.SetXY(h, l), u.lengthA = c, u.lengthB = p, u.ratio = d, this.world.CreateJoint(u)
    },
    gearJoint: function(t, e, i) {
        void 0 === i && (i = 1);
        var o = new box2d.b2GearJointDef;
        return o.joint1 = t, o.joint2 = e, o.ratio = -i, o.bodyA = t.GetBodyA(), o.bodyB = e.GetBodyB(), this.world.CreateJoint(o)
    },
    clearTilemapLayerBodies: function(t, e) {
        e = t.getLayer(e);
        for (var i = t.layers[e].bodies.length; i--;) t.layers[e].bodies[i].destroy();
        t.layers[e].bodies.length = 0
    },
    convertTilemap: function(t, e, i, o) {
        e = t.getLayer(e), void 0 === i && (i = !0), void 0 === o && (o = !0), this.clearTilemapLayerBodies(t, e);
        for (var s = 0, n = 0, r = 0, a = 0, h = t.layers[e].height; a < h; a++) {
            s = 0;
            for (var l = 0, d = t.layers[e].width; l < d; l++) {
                var c = t.layers[e].data[a][l];
                if (c && c.index > -1 && c.collides)
                    if (o) {
                        var p = t.getTileRight(e, l, a);
                        if (0 === s && (n = c.x * c.width, r = c.y * c.height, s = c.width), p && p.collides) s += c.width;
                        else {
                            var u = new Phaser.Physics.Box2D.Body(this.game, null, n, r, 0);
                            u.addRectangle(s, c.height, s / 2, c.height / 2, 0), i && this.addBody(u), t.layers[e].bodies.push(u), s = 0
                        }
                    } else {
                        var u = this.createBody(c.x * c.width, c.y * c.height, 0, !1);
                        u.addRectangle(c.width, c.height, c.width / 2, c.height / 2, 0), i && this.addBody(u), t.layers[e].bodies.push(u)
                    }
            }
        }
        return t.layers[e].bodies
    },
    raycast: function(t, e, i, o, s, n) {
        void 0 === s && (s = !0), void 0 === n && (n = null), t = this.pxm(-t), e = this.pxm(-e), i = this.pxm(-i), o = this.pxm(-o);
        var r = new box2d.b2Vec2(t, e),
            a = new box2d.b2Vec2(i, o),
            h = [],
            l = new Phaser.Physics.Box2D.RayCastCallback(this, s, n);
        this.world.RayCast(l, r, a);
        for (var d = 0; d < l.hits.length; d++) {
            var c = l.hits[d];
            c.point = {
                x: this.mpx(-c.point.x),
                y: this.mpx(-c.point.y)
            }, c.normal = {
                x: -c.normal.x,
                y: -c.normal.y
            }, h.push(c)
        }
        return h
    },
    queryAABB: function(t, e, i, o) {
        t = this.pxm(-t), e = this.pxm(-e), i = this.pxm(i), o = this.pxm(o);
        var s = new box2d.b2AABB;
        s.lowerBound.SetXY(t - i, e - o), s.upperBound.SetXY(t, e);
        var n = new Phaser.Physics.Box2D.QueryCallback(this);
        return this.world.QueryAABB(n, s), n.hits
    },
    queryFixture: function(t) {
        var e = new Phaser.Physics.Box2D.QueryCallback(this);
        return this.world.QueryShape(e, t.GetShape(), t.GetBody().GetTransform()), e.hits
    },
    setPTMRatio: function(t) {
        this.ptmRatio = t, this.debugDraw = new Phaser.Physics.Box2D.DefaultDebugDraw(this.ptmRatio), this.world.SetDebugDraw(this.debugDraw)
    }
}, Phaser.Physics.Box2D.RayCastCallback = function(t, e, i) {
    this.world = t, this.closestHitOnly = e, this.filterFunction = i, this.hits = []
}, goog.inherits(Phaser.Physics.Box2D.RayCastCallback, box2d.b2RayCastCallback), Phaser.Physics.Box2D.RayCastCallback.prototype.ReportFixture = function(t, e, i, o) {
    if (null !== this.filterFunction) {
        var s = {
                x: this.world.mpx(-e.x),
                y: this.world.mpx(-e.y)
            },
            n = {
                x: -i.x,
                y: -i.y
            },
            r = t.GetBody().parent;
        if (!this.filterFunction.call(this, r, t, s, n)) return -1
    }
    this.closestHitOnly && (this.hits = []);
    var a = {};
    return a.body = t.GetBody().parent, a.fixture = t, a.point = {
        x: e.x,
        y: e.y
    }, a.normal = {
        x: i.x,
        y: i.y
    }, this.hits.push(a), this.closestHitOnly ? o : 1
}, Phaser.Physics.Box2D.QueryCallback = function(t) {
    this.world = t, this.hits = []
}, goog.inherits(Phaser.Physics.Box2D.QueryCallback, box2d.b2QueryCallback), Phaser.Physics.Box2D.QueryCallback.prototype.ReportFixture = function(t) {
    var e = {};
    return e.body = t.GetBody().parent, e.fixture = t, this.hits.push(e), !0
}, Phaser.Physics.Box2D.renderBody = function(t, e, i, o) {
    i = i || "rgb(255,255,255)", void 0 === o && (o = !0);
    var s = e.data,
        n = s.GetTransform(),
        r = e.world;
    n.p.x += -e.game.camera.x / r.ptmRatio, n.p.y -= -e.game.camera.y / r.ptmRatio, r.debugDraw.start(t), r.debugDraw.PushTransform(n);
    var a = Phaser.Color.webToColor(i),
        h = r.debugDraw.color;
    h.r = a.r / 255, h.g = a.g / 255, h.b = a.b / 255;
    for (var l = s.GetFixtureList(); l; l = l.GetNext()) r.world.DrawShape(l, h);
    r.debugDraw.PopTransform(), r.debugDraw.stop()
}, Phaser.Physics.Box2D.Body = function(t, e, i, o, s, n) {
    void 0 === e && (e = null), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 2), void 0 === n && (n = t.physics.box2d), this.game = t, this.world = n, this.id = this.world.getNextBodyId(), this.sprite = e, this.type = Phaser.Physics.BOX2D, this.offset = new Phaser.Point, this.bodyDef = new box2d.b2BodyDef, this.bodyDef.position.SetXY(-this.world.pxm(i), -this.world.pxm(o)), 0 === s ? this.bodyDef.type = box2d.b2BodyType.b2_staticBody : 1 === s ? this.bodyDef.type = box2d.b2BodyType.b2_kinematicBody : 2 === s ? this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody : 3 === s && (this.bodyDef.type = box2d.b2BodyType.b2_bulletBody), this.data = this.world.world.CreateBody(this.bodyDef), this.data.world = this.world.world, this.data.parent = this, this.velocity = new Phaser.Physics.Box2D.PointProxy(this.world, this.data, this.data.GetLinearVelocity, this.data.SetLinearVelocity), this.removeNextStep = !1, this._fixtureContactCallbacks = {}, this._fixtureContactCallbackContext = {}, this._bodyContactCallbacks = {}, this._bodyContactCallbackContext = {}, this._categoryContactCallbacks = {}, this._categoryContactCallbackContext = {}, this._fixturePresolveCallbacks = {}, this._fixturePresolveCallbackContext = {}, this._bodyPresolveCallbacks = {}, this._bodyPresolveCallbackContext = {}, this._categoryPresolveCallbacks = {}, this._categoryPresolveCallbackContext = {}, this._fixturePostsolveCallbacks = {}, this._fixturePostsolveCallbackContext = {}, this._bodyPostsolveCallbacks = {}, this._bodyPostsolveCallbackContext = {}, this._categoryPostsolveCallbacks = {}, this._categoryPostsolveCallbackContext = {}, e && this.setRectangleFromSprite(e)
}, Phaser.Physics.Box2D.Body.prototype = {
    setBodyContactCallback: function(t, e, i) {
        var o = -1;
        t.id ? o = t.id : t.body && (o = t.body.id), o > -1 && (null === e ? (delete this._bodyContactCallbacks[o], delete this._bodyContactCallbackContext[o]) : (this._bodyContactCallbacks[o] = e, this._bodyContactCallbackContext[o] = i))
    },
    setFixtureContactCallback: function(t, e, i) {
        var o = t.id;
        o > -1 && (null === e ? (delete this._fixtureContactCallbacks[o], delete this._fixtureContactCallbackContext[o]) : (this._fixtureContactCallbacks[o] = e, this._fixtureContactCallbackContext[o] = i))
    },
    setCategoryContactCallback: function(t, e, i) {
        null === e ? (delete this._categoryContactCallbacks[t], delete this._categoryContactCallbacksContext[t]) : (this._categoryContactCallbacks[t] = e, this._categoryContactCallbackContext[t] = i)
    },
    setBodyPresolveCallback: function(t, e, i) {
        var o = -1;
        t.id ? o = t.id : t.body && (o = t.body.id), o > -1 && (null === e ? (delete this._bodyPresolveCallbacks[o], delete this._bodyPresolveCallbackContext[o]) : (this._bodyPresolveCallbacks[o] = e, this._bodyPresolveCallbackContext[o] = i))
    },
    setFixturePresolveCallback: function(t, e, i) {
        var o = t.id;
        o > -1 && (null === e ? (delete this._fixturePresolveCallbacks[o], delete this._fixturePresolveCallbackContext[o]) : (this._fixturePresolveCallbacks[o] = e, this._fixturePresolveCallbackContext[o] = i))
    },
    setCategoryPresolveCallback: function(t, e, i) {
        null === e ? (delete this._categoryPresolveCallbacks[t], delete this._categoryPresolveCallbacksContext[t]) : (this._categoryPresolveCallbacks[t] = e, this._categoryPresolveCallbackContext[t] = i)
    },
    setBodyPostsolveCallback: function(t, e, i) {
        var o = -1;
        t.id ? o = t.id : t.body && (o = t.body.id), o > -1 && (null === e ? (delete this._bodyPostsolveCallbacks[o], delete this._bodyPostsolveCallbackContext[o]) : (this._bodyPostsolveCallbacks[o] = e, this._bodyPostsolveCallbackContext[o] = i))
    },
    setFixturePostsolveCallback: function(t, e, i) {
        var o = t.id;
        o > -1 && (null === e ? (delete this._fixturePostsolveCallbacks[o], delete this._fixturePostsolveCallbackContext[o]) : (this._fixturePostsolveCallbacks[o] = e, this._fixturePostsolveCallbackContext[o] = i))
    },
    setCategoryPostsolveCallback: function(t, e, i) {
        null === e ? (delete this._categoryPostsolveCallbacks[t], delete this._categoryPostsolveCallbacksContext[t]) : (this._categoryPostsolveCallbacks[t] = e, this._categoryPostsolveCallbackContext[t] = i)
    },
    setCollisionCategory: function(t, e) {
        if (void 0 === e)
            for (var i = this.data.GetFixtureList(); i; i = i.GetNext()) {
                var o = i.GetFilterData();
                o.categoryBits = t
            } else {
                var o = e.GetFilterData();
                o.categoryBits = t
            }
    },
    setCollisionMask: function(t, e) {
        if (void 0 === e)
            for (var i = this.data.GetFixtureList(); i; i = i.GetNext()) {
                var o = i.GetFilterData();
                o.maskBits = t
            } else {
                var o = e.GetFilterData();
                o.maskBits = t
            }
    },
    applyForce: function(t, e) {
        this.data.ApplyForce(new box2d.b2Vec2(-t, -e), this.data.GetWorldCenter(), !0)
    },
    setZeroRotation: function() {
        this.data.SetAngularVelocity(0)
    },
    setZeroVelocity: function() {
        this.data.SetLinearVelocity(box2d.b2Vec2.ZERO)
    },
    setZeroDamping: function() {
        this.data.SetLinearDamping(0), this.data.SetAngularDamping(0)
    },
    toLocalPoint: function(t, e) {
        return t.x = this.world.pxm(-e.x), t.y = this.world.pxm(-e.y), this.data.GetLocalPoint(t, t), t.x = this.world.mpx(-t.x), t.y = this.world.mpx(-t.y), t
    },
    toWorldPoint: function(t, e) {
        return t.x = this.world.pxm(-e.x), t.y = this.world.pxm(-e.y), this.data.GetWorldPoint(t, t), t.x = this.world.mpx(-t.x), t.y = this.world.mpx(-t.y), t
    },
    toLocalVector: function(t, e) {
        return t.x = this.world.pxm(-e.x), t.y = this.world.pxm(-e.y), this.data.GetLocalVector(t, t), t.x = this.world.mpx(-t.x), t.y = this.world.mpx(-t.y), t
    },
    toWorldVector: function(t, e) {
        t.x = this.world.pxm(-e.x), t.y = this.world.pxm(-e.y), this.data.GetWorldVector(t, t), t.x = this.world.mpx(-t.x), t.y = this.world.mpx(-t.y)
    },
    rotateLeft: function(t) {
        this.data.SetAngularVelocity(this.world.pxm(-t))
    },
    rotateRight: function(t) {
        this.data.SetAngularVelocity(this.world.pxm(t))
    },
    moveForward: function(t) {
        var e = this.world.pxm(t),
            i = new box2d.b2Vec2;
        this.toWorldVector(i, {
            x: 0,
            y: e
        }), this.data.SetLinearVelocity(i)
    },
    moveBackward: function(t) {
        var e = this.world.pxm(-t),
            i = new box2d.b2Vec2;
        this.toWorldVector(i, {
            x: 0,
            y: e
        }), this.data.SetLinearVelocity(i)
    },
    thrust: function(t) {
        var e = this.world.pxm(t) * this.data.GetMass(),
            i = new box2d.b2Vec2;
        this.toWorldVector(i, {
            x: 0,
            y: e
        }), this.data.ApplyForce(i, this.data.GetWorldCenter(), !0)
    },
    reverse: function(t) {
        var e = -this.world.pxm(t) * this.data.GetMass(),
            i = new box2d.b2Vec2;
        this.toWorldVector(i, {
            x: 0,
            y: e
        }), this.data.ApplyForce(i, this.data.GetWorldCenter(), !0)
    },
    moveLeft: function(t) {
        this.velocity.x = -t
    },
    moveRight: function(t) {
        this.velocity.x = t
    },
    moveUp: function(t) {
        this.velocity.y = -t
    },
    moveDown: function(t) {
        this.velocity.y = t
    },
    preUpdate: function() {
        this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1)
    },
    postUpdate: function() {
        if (this.sprite) {
            var t = this.data.m_xf.p;
            this.sprite.position.x = this.world.mpx(-t.x), this.sprite.position.y = this.world.mpx(-t.y), this.sprite.rotation = this.data.GetAngle()
        }
    },
    kill: function() {
        this.data.SetActive(!1)
    },
    reset: function(t, e) {
        this.data.SetPositionXY(this.world.pxm(-t), this.world.pxm(-e)), this.data.SetActive(!0)
    },
    removeFromWorld: function() {
        this.data.world === this.game.physics.box2d.world && this.game.physics.box2d.removeBodyNextStep(this)
    },
    destroy: function() {
        this.removeFromWorld(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._categoryCallbacks = {}, this._categoryCallbackContext = {}, this.sprite = null
    },
    clearFixtures: function() {
        for (var t = [], e = this.data.GetFixtureList(); e; e = e.GetNext()) t.push(e);
        for (var i = t.length; i--;) this.data.DestroyFixture(t[i])
    },
    addCircle: function(t, e, i) {
        var o = new box2d.b2CircleShape(this.world.pxm(t));
        o.m_p.SetXY(this.world.pxm(-e), this.world.pxm(-i));
        var s = new box2d.b2FixtureDef;
        s.shape = o, s.friction = this.world.friction, s.restitution = this.world.restitution, s.density = this.world.density;
        var n = this.data.CreateFixture(s);
        return n.id = this.world.getNextFixtureId(), n
    },
    addRectangle: function(t, e, i, o, s) {
        void 0 === t && (t = 16), void 0 === e && (e = 16), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), t = this.world.pxm(t), e = this.world.pxm(e);
        var n = new box2d.b2PolygonShape;
        n.SetAsOrientedBox(.5 * t, .5 * e, new box2d.b2Vec2(this.world.pxm(-i), this.world.pxm(-o)), s);
        var r = new box2d.b2FixtureDef;
        r.shape = n, r.friction = this.world.friction, r.restitution = this.world.restitution, r.density = this.world.density;
        var a = this.data.CreateFixture(r);
        return a.id = this.world.getNextFixtureId(), a
    },
    addEdge: function(t, e, i, o) {
        var s = new box2d.b2EdgeShape;
        s.Set(new box2d.b2Vec2(this.world.pxm(-t), this.world.pxm(-e)), new box2d.b2Vec2(this.world.pxm(-i), this.world.pxm(-o)));
        var n = new box2d.b2FixtureDef;
        n.shape = s, n.friction = this.world.friction, n.restitution = this.world.restitution, n.density = this.world.density;
        var r = this.data.CreateFixture(n);
        return r.id = this.world.getNextFixtureId(), r
    },
    addChain: function(t, e, i, o) {
        if (void 0 === t) return null;
        if (t.length < 4) return null;
        void 0 === e && (e = 0), void 0 === i && (i = (t.length - e) / 2);
        for (var s = [], n = e; n < e + i; n++) s.push(new box2d.b2Vec2(this.world.pxm(-t[2 * n]), this.world.pxm(-t[2 * n + 1])));
        var r = new box2d.b2ChainShape;
        o ? r.CreateLoop(s, s.length) : r.CreateChain(s, s.length);
        var a = new box2d.b2FixtureDef;
        a.shape = r, a.friction = this.world.friction, a.restitution = this.world.restitution, a.density = this.world.density;
        var h = this.data.CreateFixture(a);
        return h.id = this.world.getNextFixtureId(), h
    },
    addLoop: function(t, e, i) {
        return this.addChain(t, e, i, !0)
    },
    addPolygon: function(t, e, i) {
        if (void 0 === t) return null;
        if (t.length < 6) return null;
        void 0 === e && (e = 0), void 0 === i && (i = (t.length - e) / 2);
        for (var o = [], s = e; s < e + i; s++) o.push({
            x: this.world.pxm(-t[2 * s]),
            y: this.world.pxm(-t[2 * s + 1])
        });
        var n = new Phaser.Physics.Box2D.Polygon;
        n.setFromXYObjects(o);
        for (var r = n.decompose(o), a = null, s = 0; s < r.length; s++) {
            var h = new box2d.b2PolygonShape;
            h.Set(r[s], r[s].length);
            var l = new box2d.b2FixtureDef;
            l.shape = h, l.friction = this.world.friction, l.restitution = this.world.restitution, l.density = this.world.density, a = this.data.CreateFixture(l), a.id = this.world.getNextFixtureId()
        }
        return a
    },
    removeFixture: function(t) {
        return t.GetBody() == this.data && (this.data.DestroyFixture(t), !0)
    },
    setCircle: function(t, e, i) {
        return void 0 === t && (t = 32), void 0 === e && (e = 0), void 0 === i && (i = 0), this.clearFixtures(), this.addCircle(t, e, i)
    },
    setRectangle: function(t, e, i, o, s) {
        return this.clearFixtures(), this.addRectangle(t, e, i, o, s)
    },
    setRectangleFromSprite: function(t) {
        return void 0 === t && (t = this.sprite), this.clearFixtures(), this.addRectangle(t.width, t.height, 0, 0, t.rotation)
    },
    setEdge: function(t, e, i, o) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), this.clearFixtures(), this.addEdge(t, e, i, o)
    },
    setChain: function(t, e, i, o) {
        return void 0 === t ? null : t.length < 4 ? null : (void 0 === e && (e = 0), void 0 === i && (i = (t.length - e) / 2), this.clearFixtures(), this.addChain(t, e, i, o))
    },
    setLoop: function(t, e, i) {
        return this.setChain(t, e, i, !0)
    },
    setPolygon: function(t, e, i) {
        return void 0 === t ? null : t.length < 4 ? null : (void 0 === e && (e = 0), void 0 === i && (i = (t.length - e) / 2), this.clearFixtures(), this.addPolygon(t, e, i))
    },
    loadPolygon: function(t, e, i) {
        void 0 === i && (i = null);
        for (var o = this.game.cache.getPhysicsData(t, e), s = 0; s < o.length; s++) {
            for (var n = [], r = 0; r < o[s].shape.length; r += 2) n.push(new box2d.b2Vec2(this.world.pxm(-o[s].shape[r]), this.world.pxm(-o[s].shape[r + 1])));
            if (i)
                for (var a = this.world.pxm(-.5 * i.width), h = this.world.pxm(-.5 * i.height), l = 0; l < n.length; l++) n[l].x -= a, n[l].y -= h;
            var d = new box2d.b2PolygonShape;
            d.Set(n, n.length);
            var c = new box2d.b2FixtureDef;
            c.shape = d, c.friction = o[s].friction, c.restitution = o[s].bounce, c.density = o[s].density, c.filter.categoryBits = o[s].filter.categoryBits, c.filter.maskBits = o[s].filter.maskBits;
            this.data.CreateFixture(c).id = this.world.getNextFixtureId()
        }
        return !0
    },
    containsPoint: function(t) {
        for (var e = this.world.pxm(-t.x), i = this.world.pxm(-t.y), o = new box2d.b2Vec2(e, i), s = this.data.GetFixtureList(); s; s = s.GetNext())
            if (s.TestPoint(o)) return !0;
        return !1
    }
}, Phaser.Physics.Box2D.Body.prototype.constructor = Phaser.Physics.Box2D.Body, Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "static", {
    get: function() {
        return this.data.GetType() === box2d.b2BodyType.b2_staticBody
    },
    set: function(t) {
        t && this.data.GetType() !== box2d.b2BodyType.b2_staticBody ? this.data.SetType(box2d.b2BodyType.b2_staticBody) : t || this.data.GetType() !== box2d.b2BodyType.b2_staticBody || this.data.SetType(box2d.b2BodyType.b2_dynamicBody)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "dynamic", {
    get: function() {
        return this.data.GetType() === box2d.b2BodyType.b2_dynamicBody
    },
    set: function(t) {
        t && this.data.GetType() !== box2d.b2BodyType.b2_dynamicBody ? this.data.SetType(box2d.b2BodyType.b2_dynamicBody) : t || this.data.GetType() !== box2d.b2BodyType.b2_dynamicBody || this.data.SetType(box2d.b2BodyType.b2_staticBody)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "kinematic", {
    get: function() {
        return this.data.GetType() === box2d.b2BodyType.b2_kinematicBody
    },
    set: function(t) {
        t && this.data.GetType() !== box2d.b2BodyType.b2_kinematicBody ? this.data.SetType(box2d.b2BodyType.b2_kinematicBody) : t || this.data.GetType() !== box2d.b2BodyType.b2_kinematicBody || this.data.SetType(box2d.b2BodyType.b2_staticBody)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "angle", {
    get: function() {
        return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.data.GetAngle()))
    },
    set: function(t) {
        this.data.SetAngle(Phaser.Math.degToRad(Phaser.Math.wrapAngle(t)))
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "linearDamping", {
    get: function() {
        return this.data.GetLinearDamping()
    },
    set: function(t) {
        this.data.SetLinearDamping(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "angularDamping", {
    get: function() {
        return this.data.GetAngularDamping()
    },
    set: function(t) {
        this.data.SetAngularDamping(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "angularVelocity", {
    get: function() {
        return this.data.GetAngularVelocity()
    },
    set: function(t) {
        this.data.SetAngularVelocity(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "fixedRotation", {
    get: function() {
        return this.data.IsFixedRotation()
    },
    set: function(t) {
        this.data.SetFixedRotation(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "gravityScale", {
    get: function() {
        return this.data.GetGravityScale()
    },
    set: function(t) {
        this.data.SetGravityScale(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "friction", {
    get: function() {
        var t = this.data.GetFixtureList();
        return t ? t.GetFriction() : 0
    },
    set: function(t) {
        for (var e = this.data.GetFixtureList(); e; e = e.GetNext()) e.SetFriction(t), e.Refilter()
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "restitution", {
    get: function() {
        var t = this.data.GetFixtureList();
        return t ? t.GetRestitution() : 0
    },
    set: function(t) {
        for (var e = this.data.GetFixtureList(); e; e = e.GetNext()) e.SetRestitution(t), e.Refilter()
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "sensor", {
    get: function() {
        var t = this.data.GetFixtureList();
        return t ? t.IsSensor() : 0
    },
    set: function(t) {
        for (var e = this.data.GetFixtureList(); e; e = e.GetNext()) e.SetSensor(t), e.Refilter()
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "bullet", {
    get: function() {
        return this.data.IsBullet()
    },
    set: function(t) {
        this.data.SetBullet(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "mass", {
    get: function() {
        return this.data.GetMass()
    },
    set: function(t) {
        if (0 === t) this.data.SetType(box2d.b2BodyType.b2_staticBody);
        else {
            this.data.GetType() !== box2d.b2BodyType.b2_dynamicBody && this.data.SetType(box2d.b2BodyType.b2_dynamicBody);
            for (var e = this.data.GetMass(), i = t / e, o = this.data.GetFixtureList(); o; o = o.GetNext()) {
                var s = o.GetDensity();
                o.SetDensity(s * i)
            }
            this.data.ResetMassData()
        }
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "rotation", {
    get: function() {
        return this.data.GetAngle()
    },
    set: function(t) {
        this.data.SetAngle(t)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "x", {
    get: function() {
        return this.world.mpx(-this.data.GetPosition().x)
    },
    set: function(t) {
        this.data.SetPositionXY(this.world.pxm(-t), this.data.GetPosition().y)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "y", {
    get: function() {
        return this.world.mpx(-this.data.GetPosition().y)
    },
    set: function(t) {
        this.data.SetPositionXY(this.data.GetPosition().x, this.world.pxm(-t))
    }
}), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "collideWorldBounds", {
    get: function() {
        for (var t = this.data.GetFixtureList(); t; t = t.GetNext()) {
            if (t.GetFilterData().maskBits & Phaser.Physics.Box2D.worldBoundsFilterCategory) return !0
        }
        return !1
    },
    set: function(t) {
        for (var e = this.data.GetFixtureList(); e; e = e.GetNext()) {
            var i = e.GetFilterData();
            t ? i.maskBits |= Phaser.Physics.Box2D.worldBoundsFilterCategory : i.maskBits &= ~Phaser.Physics.Box2D.worldBoundsFilterCategory
        }
    }
}), Phaser.Physics.Box2D.PointProxy = function(t, e, i, o) {
    this.world = t, this.object = e, this.gettor = i, this.settor = o
}, Phaser.Physics.Box2D.PointProxy.prototype.constructor = Phaser.Physics.Box2D.PointProxy, Object.defineProperty(Phaser.Physics.Box2D.PointProxy.prototype, "x", {
    get: function() {
        return this.world.mpx(-this.gettor.call(this.object).x)
    },
    set: function(t) {
        var e = this.gettor.call(this.object);
        e.x = this.world.pxm(-t), this.settor.call(this.object, e)
    }
}), Object.defineProperty(Phaser.Physics.Box2D.PointProxy.prototype, "y", {
    get: function() {
        return this.world.mpx(-this.gettor.call(this.object).y)
    },
    set: function(t) {
        var e = this.gettor.call(this.object);
        e.y = this.world.pxm(-t), this.settor.call(this.object, e)
    }
}), Phaser.Physics.Box2D.DefaultDebugDraw = function(t) {
    this.context = null, this.pixelsPerMeter = t, this.flags = box2d.b2DrawFlags.e_shapeBit
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.color = new box2d.b2Color(1, 1, 1), Phaser.Physics.Box2D.DefaultDebugDraw.prototype.SetFlags = function(t) {
    this.flags = t
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.GetFlags = function() {
    return this.flags
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.start = function(t) {
    this.context = t, this.context.save(), this.context.scale(-1, -1), this.context.scale(this.pixelsPerMeter, this.pixelsPerMeter)
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.stop = function() {
    this.context.restore()
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.PushTransform = function(t) {
    var e = this.context;
    e.save(), e.translate(t.p.x, t.p.y), e.rotate(t.q.GetAngleRadians())
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.PopTransform = function() {
    this.context.restore()
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawPolygon = function(t, e, i) {
    if (e) {
        var o = this.context;
        o.lineWidth = 1 / this.pixelsPerMeter, o.beginPath(), o.moveTo(t[0].x, t[0].y);
        for (var s = 1; s < e; s++) o.lineTo(t[s].x, t[s].y);
        o.closePath(), o.strokeStyle = i.MakeStyleString(1), o.stroke()
    }
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSolidPolygon = function(t, e, i) {
    if (e) {
        var o = this.context;
        o.lineWidth = 1 / this.pixelsPerMeter, o.beginPath(), o.moveTo(t[0].x, t[0].y);
        for (var s = 1; s < e; s++) o.lineTo(t[s].x, t[s].y);
        o.closePath(), o.fillStyle = i.MakeStyleString(.5), o.fill(), o.strokeStyle = i.MakeStyleString(1), o.stroke()
    }
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawCircle = function(t, e, i) {
    if (e) {
        var o = this.context;
        o.beginPath(), o.arc(t.x, t.y, e, 0, 2 * Math.PI, !0), o.strokeStyle = i.MakeStyleString(1), o.stroke()
    }
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSolidCircle = function(t, e, i, o) {
    if (e) {
        var s = this.context;
        s.lineWidth = 1 / this.pixelsPerMeter;
        var n = t.x,
            r = t.y;
        s.beginPath(), s.arc(n, r, e, 0, 2 * Math.PI, !0), s.moveTo(n, r), s.lineTo(n + i.x * e, r + i.y * e), s.fillStyle = o.MakeStyleString(.5), s.fill(), s.strokeStyle = o.MakeStyleString(1), s.stroke()
    }
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSegment = function(t, e, i) {
    var o = this.context;
    o.lineWidth = 1 / this.pixelsPerMeter, o.beginPath(), o.moveTo(t.x, t.y), o.lineTo(e.x, e.y), o.strokeStyle = i.MakeStyleString(1), o.stroke()
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawTransform = function(t) {
    var e = this.context;
    e.lineWidth = 1 / this.pixelsPerMeter, this.PushTransform(t), e.beginPath(), e.moveTo(0, 0), e.lineTo(1, 0), e.strokeStyle = box2d.b2Color.RED.MakeStyleString(1), e.stroke(), e.beginPath(), e.moveTo(0, 0), e.lineTo(0, 1), e.strokeStyle = box2d.b2Color.GREEN.MakeStyleString(1), e.stroke(), this.PopTransform(t)
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawPoint = function(t, e, i) {
    var o = this.context;
    o.fillStyle = i.MakeStyleString();
    var s = e / 2;
    o.fillRect(t.x - s, t.y - s, e, e)
}, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawAABB = function(t, e) {
    var i = this.context;
    i.strokeStyle = e.MakeStyleString();
    var o = t.lowerBound.x,
        s = t.lowerBound.y,
        n = t.upperBound.x - t.lowerBound.x,
        r = t.upperBound.y - t.lowerBound.y;
    i.strokeRect(o, s, n, r)
}, Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "shapes", {
    get: function() {
        return this.flags & box2d.b2DrawFlags.e_shapeBit
    },
    set: function(t) {
        t ? this.flags |= box2d.b2DrawFlags.e_shapeBit : this.flags &= ~box2d.b2DrawFlags.e_shapeBit
    }
}), Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "joints", {
    get: function() {
        return this.flags & box2d.b2DrawFlags.e_jointBit
    },
    set: function(t) {
        t ? this.flags |= box2d.b2DrawFlags.e_jointBit : this.flags &= ~box2d.b2DrawFlags.e_jointBit
    }
}), Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "aabbs", {
    get: function() {
        return this.flags & box2d.b2DrawFlags.e_aabbBit
    },
    set: function(t) {
        t ? this.flags |= box2d.b2DrawFlags.e_aabbBit : this.flags &= ~box2d.b2DrawFlags.e_aabbBit
    }
}), Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "pairs", {
    get: function() {
        return this.flags & box2d.b2DrawFlags.e_pairBit
    },
    set: function(t) {
        t ? this.flags |= box2d.b2DrawFlags.e_pairBit : this.flags &= ~box2d.b2DrawFlags.e_pairBit
    }
}), Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "centerOfMass", {
    get: function() {
        return this.flags & box2d.b2DrawFlags.e_centerOfMassBit
    },
    set: function(t) {
        t ? this.flags |= box2d.b2DrawFlags.e_centerOfMassBit : this.flags &= ~box2d.b2DrawFlags.e_centerOfMassBit
    }
}), Phaser.Physics.Box2D.DefaultContactListener = function() {}, Phaser.Physics.Box2D.DefaultContactListener.prototype.BeginContact = function(t) {
    this.handleContactBeginOrEnd(t, !0)
}, Phaser.Physics.Box2D.DefaultContactListener.prototype.EndContact = function(t) {
    this.handleContactBeginOrEnd(t, !1)
}, Phaser.Physics.Box2D.DefaultContactListener.prototype.handleContactBeginOrEnd = function(t, e) {
    var i = t.GetFixtureA(),
        o = t.GetFixtureB(),
        s = i.GetBody(),
        n = o.GetBody(),
        r = i.GetFilterData().categoryBits,
        a = o.GetFilterData().categoryBits,
        h = s.parent,
        l = n.parent;
    if (void 0 !== h && void 0 !== l) {
        var d = h.id,
            c = l.id;
        h._bodyContactCallbacks[c] && h._bodyContactCallbacks[c].call(h._bodyContactCallbackContext[c], h, l, i, o, e, t), l._bodyContactCallbacks[d] && l._bodyContactCallbacks[d].call(l._bodyContactCallbackContext[d], l, h, o, i, e, t), h._fixtureContactCallbacks[o.id] && h._fixtureContactCallbacks[o.id].call(h._fixtureContactCallbackContext[o.id], h, l, i, o, e, t), l._fixtureContactCallbacks[i.id] && l._fixtureContactCallbacks[i.id].call(l._fixtureContactCallbackContext[i.id], l, h, o, i, e, t), h._fixtureContactCallbacks[i.id] && h._fixtureContactCallbacks[i.id].call(h._fixtureContactCallbackContext[i.id], h, l, i, o, e, t), l._fixtureContactCallbacks[o.id] && l._fixtureContactCallbacks[o.id].call(l._fixtureContactCallbackContext[o.id], l, h, o, i, e, t), h._categoryContactCallbacks[a] && h._categoryContactCallbacks[a].call(h._categoryContactCallbackContext[a], h, l, i, o, e, t), l._categoryContactCallbacks[r] && l._categoryContactCallbacks[r].call(l._categoryContactCallbackContext[r], l, h, o, i, e, t), h._categoryContactCallbacks[r] && h._categoryContactCallbacks[r].call(h._categoryContactCallbackContext[r], h, l, i, o, e, t), l._categoryContactCallbacks[a] && l._categoryContactCallbacks[a].call(l._categoryContactCallbackContext[a], l, h, o, i, e, t)
    }
}, Phaser.Physics.Box2D.DefaultContactListener.prototype.PreSolve = function(t, e) {
    var i = t.GetFixtureA(),
        o = t.GetFixtureB(),
        s = i.GetBody(),
        n = o.GetBody(),
        r = i.GetFilterData().categoryBits,
        a = o.GetFilterData().categoryBits,
        h = s.parent,
        l = n.parent;
    if (void 0 !== h && void 0 !== l) {
        var d = h.id,
            c = l.id;
        h._bodyPresolveCallbacks[c] && h._bodyPresolveCallbacks[c].call(h._bodyPresolveCallbackContext[c], h, l, i, o, t, e), l._bodyPresolveCallbacks[d] && l._bodyPresolveCallbacks[d].call(l._bodyPresolveCallbackContext[d], l, h, o, i, t, e), h._fixturePresolveCallbacks[o.id] && h._fixturePresolveCallbacks[o.id].call(h._fixturePresolveCallbackContext[o.id], h, l, i, o, t, e), l._fixturePresolveCallbacks[i.id] && l._fixturePresolveCallbacks[i.id].call(l._fixturePresolveCallbackContext[i.id], l, h, o, i, t, e), h._categoryPresolveCallbacks[a] && h._categoryPresolveCallbacks[a].call(h._categoryPresolveCallbackContext[a], h, l, i, o, t, e), l._categoryPresolveCallbacks[r] && l._categoryPresolveCallbacks[r].call(l._categoryPresolveCallbackContext[r], l, h, o, i, t, e)
    }
}, Phaser.Physics.Box2D.DefaultContactListener.prototype.PostSolve = function(t, e) {
    var i = t.GetFixtureA(),
        o = t.GetFixtureB(),
        s = i.GetBody(),
        n = o.GetBody(),
        r = i.GetFilterData().categoryBits,
        a = o.GetFilterData().categoryBits,
        h = s.parent,
        l = n.parent;
    if (void 0 !== h && void 0 !== l) {
        var d = h.id,
            c = l.id;
        h._bodyPostsolveCallbacks[c] && h._bodyPostsolveCallbacks[c].call(h._bodyPostsolveCallbackContext[c], h, l, i, o, t, e), l._bodyPostsolveCallbacks[d] && l._bodyPostsolveCallbacks[d].call(l._bodyPostsolveCallbackContext[d], l, h, o, i, t, e), h._fixturePostsolveCallbacks[o.id] && h._fixturePostsolveCallbacks[o.id].call(h._fixturePostsolveCallbackContext[o.id], h, l, i, o, t, e), l._fixturePostsolveCallbacks[i.id] && l._fixturePostsolveCallbacks[i.id].call(l._fixturePostsolveCallbackContext[i.id], l, h, o, i, t, e), h._categoryPostsolveCallbacks[a] && h._categoryPostsolveCallbacks[a].call(h._categoryPostsolveCallbackContext[a], h, l, i, o, t, e), l._categoryPostsolveCallbacks[r] && l._categoryPostsolveCallbacks[r].call(l._categoryPostsolveCallbackContext[r], l, h, o, i, t, e)
    }
}, Phaser.Physics.Box2D.Polygon = function() {
    this.vertices = []
}, Phaser.Physics.Box2D.Polygon.prototype.setFromFlatXYCoords = function(t) {
    this.vertices = [];
    for (var e = 0; e < t.length / 2; e++) this.vertices.push({
        x: t[2 * e],
        y: t[2 * e + 1]
    })
}, Phaser.Physics.Box2D.Polygon.prototype.setFromXYObjects = function(t) {
    this.vertices = t.concat()
}, Phaser.Physics.Box2D.Polygon.prototype.addVertex = function(t) {
    this.vertices.push(t)
}, Phaser.Physics.Box2D.Polygon.prototype.at = function(t) {
    var e = this.vertices.length;
    return this.vertices[t < 0 ? t % e + e : t % e]
}, Phaser.Physics.Box2D.Polygon.prototype.indicesAreAdjacent = function(t, e) {
    if (t %= this.vertices.length, e %= this.vertices.length, t == e) return !0;
    var i = Math.abs(t - e);
    return i < 2 || i == this.vertices.length - 1
}, Phaser.Physics.Box2D.Polygon.prototype.areaInTriangle = function(t, e, i) {
    return t = this.at(t), e = this.at(e), i = this.at(i), .5 * ((e.x - t.x) * (i.y - t.y) - (i.x - t.x) * (e.y - t.y))
}, Phaser.Physics.Box2D.Polygon.prototype.left = function(t, e, i) {
    return this.areaInTriangle(t, e, i) > 0
}, Phaser.Physics.Box2D.Polygon.prototype.leftOn = function(t, e, i) {
    return this.areaInTriangle(t, e, i) >= 0
}, Phaser.Physics.Box2D.Polygon.prototype.right = function(t, e, i) {
    return this.areaInTriangle(t, e, i) < 0
}, Phaser.Physics.Box2D.Polygon.prototype.rightOn = function(t, e, i) {
    return this.areaInTriangle(t, e, i) <= 0
}, Phaser.Physics.Box2D.Polygon.sqdist = function(t, e) {
    var i = e.x - t.x,
        o = e.y - t.y;
    return i * i + o * o
}, Phaser.Physics.Box2D.Polygon.prototype.makeCCW = function() {
    for (var t = 0, e = 1, i = this.vertices.length; e < i; e++)(this.at(e).y < this.at(t).y || this.at(e).y === this.at(t).y && this.at(e).x > this.at(t).x) && (t = e);
    return !this.left(t - 1, t, t + 1) && (this.vertices.reverse(), !0)
}, Phaser.Physics.Box2D.Polygon.prototype.isConvex = function() {
    for (var t = !1, e = !1, i = 0, o = this.vertices.length; i < o; i++) {
        var s = i,
            n = (i + 1) % o,
            r = (i + 2) % o;
        this.areaInTriangle(this.vertices[s], this.vertices[n], this.vertices[r]) > 0 ? t = !0 : e = !0
    }
    return e ^ t
}, Phaser.Physics.Box2D.Polygon.prototype.isReflex = function(t) {
    return this.right(t - 1, t, t + 1)
}, Phaser.Physics.Box2D.Polygon.areVecsEqual = function(t, e) {
    return t.x == e.x && t.y == e.y
}, Phaser.Physics.Box2D.Polygon.linesCross = function(t, e, i, o) {
    if (Phaser.Physics.Box2D.Polygon.areVecsEqual(e, i) || Phaser.Physics.Box2D.Polygon.areVecsEqual(t, i) || Phaser.Physics.Box2D.Polygon.areVecsEqual(e, o) || Phaser.Physics.Box2D.Polygon.areVecsEqual(t, o)) return null;
    var s = {};
    box2d.b2SubVV(e, t, s), box2d.b2CrossVS(s, 1, s);
    var n = box2d.b2DotVV(s, t),
        r = box2d.b2DotVV(s, i),
        a = box2d.b2DotVV(s, o);
    if (r > n && a > n) return null;
    if (r < n && a < n) return null;
    var h = {};
    box2d.b2SubVV(o, i, h), box2d.b2CrossVS(h, 1, h);
    var r = box2d.b2DotVV(h, i),
        n = box2d.b2DotVV(h, t),
        l = box2d.b2DotVV(h, e);
    if (n > r && l > r) return null;
    if (n < r && l < r) return null;
    var d = (r - n) / (l - n);
    return {
        x: t.x + d * (e.x - t.x),
        y: t.y + d * (e.y - t.y)
    }
}, Phaser.Physics.Box2D.Polygon.prototype.canSee = function(t, e) {
    if (this.indicesAreAdjacent(t, e)) return !1;
    if (this.leftOn(t + 1, t, e) && this.rightOn(t - 1, t, e)) return !1;
    for (var i = 0; i < this.vertices.length; ++i)
        if ((i + 1) % this.vertices.length != t && i != t && this.leftOn(t, e, i + 1) && this.rightOn(t, e, i) && Phaser.Physics.Box2D.Polygon.linesCross(this.at(t), this.at(e), this.at(i), this.at(i + 1))) return !1;
    return !0
}, Phaser.Physics.Box2D.Polygon.prototype.subPolygon = function(t, e) {
    var i = new Phaser.Physics.Box2D.Polygon;
    if (t < e)
        for (var o = t; o < e + 1; o++) i.addVertex(this.at(o));
    else {
        for (var o = t; o < this.vertices.length; o++) i.addVertex(this.at(o));
        for (var o = 0; o < e + 1; o++) i.addVertex(this.at(o))
    }
    return i
}, Phaser.Physics.Box2D.Polygon.prototype.decomposeOptimal = function(t) {
    if (void 0 === t && (t = 0), t > 1) return this.vertices;
    this.makeCCW();
    for (var e = [], i = [], o = [], s = Number.MAX_VALUE, n = 0; n < this.vertices.length; n++)
        if (this.isReflex(n))
            for (var r = 0; r < this.vertices.length; r++) this.canSee(n, r) && (i = this.subPolygon(n, r).decompose(t + 1), o = this.subPolygon(r, n).decompose(t + 1), i.length + o.length < s && (e = i.concat(o), s = e.length));
    return 0 === e.length && e.push(this.vertices), e
}, Phaser.Physics.Box2D.Polygon.prototype.decompose = function(t) {
    void 0 === t && (t = 0), this.makeCCW();
    for (var e, i, o = [], s = Number.MAX_VALUE, n = !1, r = 0; r < this.vertices.length; r++)
        if (this.isReflex(r)) {
            n = !0;
            for (var a = this.at(r), h = 0; h < this.vertices.length; h++)
                if (this.canSee(r, h)) {
                    var l = this.at(h),
                        d = l.x - a.x,
                        c = l.y - a.y,
                        p = d * d * (c * c);
                    p < s && (e = r, i = h, s = p)
                }
        }
    if (!n && this.vertices.length > 8 && (e = 0, i = Math.floor(this.vertices.length / 2), n = !0), n) {
        var u = this.subPolygon(e, i).decompose(t + 1),
            b = this.subPolygon(i, e).decompose(t + 1);
        o = u.concat(b)
    }
    return 0 === o.length && o.push(this.vertices), o
};
var EasyStar = function(t) {
    function e(o) {
        if (i[o]) return i[o].exports;
        var s = i[o] = {
            exports: {},
            id: o,
            loaded: !1
        };
        return t[o].call(s.exports, s, s.exports, e), s.loaded = !0, s.exports
    }
    var i = {};
    return e.m = t, e.c = i, e.p = "", e(0)
}([function(t, e, i) {
    var o = {},
        s = i(1),
        n = i(2),
        r = i(3);
    t.exports = o;
    var a = 1;
    o.js = function() {
        var t, e, i, h = !1,
            l = {},
            d = {},
            c = {},
            p = {},
            u = !0,
            b = {},
            m = [],
            y = Number.MAX_VALUE,
            f = !1;
        this.setAcceptableTiles = function(t) {
            t instanceof Array ? i = t : !isNaN(parseFloat(t)) && isFinite(t) && (i = [t])
        }, this.enableSync = function() {
            h = !0
        }, this.disableSync = function() {
            h = !1
        }, this.enableDiagonals = function() {
            f = !0
        }, this.disableDiagonals = function() {
            f = !1
        }, this.setGrid = function(e) {
            t = e;
            for (var i = 0; i < t.length; i++)
                for (var o = 0; o < t[0].length; o++) d[t[i][o]] || (d[t[i][o]] = 1)
        }, this.setTileCost = function(t, e) {
            d[t] = e
        }, this.setAdditionalPointCost = function(t, e, i) {
            void 0 === c[e] && (c[e] = {}), c[e][t] = i
        }, this.removeAdditionalPointCost = function(t, e) {
            void 0 !== c[e] && delete c[e][t]
        }, this.removeAllAdditionalPointCosts = function() {
            c = {}
        }, this.setDirectionalCondition = function(t, e, i) {
            void 0 === p[e] && (p[e] = {}), p[e][t] = i
        }, this.removeAllDirectionalConditions = function() {
            p = {}
        }, this.setIterationsPerCalculation = function(t) {
            y = t
        }, this.avoidAdditionalPoint = function(t, e) {
            void 0 === l[e] && (l[e] = {}), l[e][t] = 1
        }, this.stopAvoidingAdditionalPoint = function(t, e) {
            void 0 !== l[e] && delete l[e][t]
        }, this.enableCornerCutting = function() {
            u = !0
        }, this.disableCornerCutting = function() {
            u = !1
        }, this.stopAvoidingAllAdditionalPoints = function() {
            l = {}
        }, this.findPath = function(e, o, n, l, d) {
            var c = function(t) {
                h ? d(t) : setTimeout(d.bind(null, t))
            };
            if (void 0 === i) throw new Error("You can't set a path without first calling setAcceptableTiles() on EasyStar.");
            if (void 0 === t) throw new Error("You can't set a path without first calling setGrid() on EasyStar.");
            if (e < 0 || o < 0 || n < 0 || l < 0 || e > t[0].length - 1 || o > t.length - 1 || n > t[0].length - 1 || l > t.length - 1) throw new Error("Your start or end point is outside the scope of your grid.");
            if (e === n && o === l) return void c([]);
            for (var p = t[l][n], u = !1, y = 0; y < i.length; y++)
                if (p === i[y]) {
                    u = !0;
                    break
                }
            if (!1 === u) return void c(null);
            var f = new s;
            f.openList = new r(function(t, e) {
                return t.bestGuessDistance() - e.bestGuessDistance()
            }), f.isDoneCalculating = !1, f.nodeHash = {}, f.startX = e, f.startY = o, f.endX = n, f.endY = l, f.callback = c, f.openList.push(w(f, f.startX, f.startY, null, 1));
            var g = a++;
            return b[g] = f, m.push(g), g
        }, this.cancelPath = function(t) {
            return t in b && (delete b[t], !0)
        }, this.calculate = function() {
            if (0 !== m.length && void 0 !== t && void 0 !== i)
                for (e = 0; e < y; e++) {
                    if (0 === m.length) return;
                    h && (e = 0);
                    var o = m[0],
                        s = b[o];
                    if (void 0 !== s)
                        if (0 !== s.openList.size()) {
                            var n = s.openList.pop();
                            if (s.endX !== n.x || s.endY !== n.y) n.list = 0, n.y > 0 && g(s, n, 0, -1, 1 * v(n.x, n.y - 1)), n.x < t[0].length - 1 && g(s, n, 1, 0, 1 * v(n.x + 1, n.y)), n.y < t.length - 1 && g(s, n, 0, 1, 1 * v(n.x, n.y + 1)), n.x > 0 && g(s, n, -1, 0, 1 * v(n.x - 1, n.y)), f && (n.x > 0 && n.y > 0 && (u || x(t, i, n.x, n.y - 1) && x(t, i, n.x - 1, n.y)) && g(s, n, -1, -1, 1.4 * v(n.x - 1, n.y - 1)), n.x < t[0].length - 1 && n.y < t.length - 1 && (u || x(t, i, n.x, n.y + 1) && x(t, i, n.x + 1, n.y)) && g(s, n, 1, 1, 1.4 * v(n.x + 1, n.y + 1)), n.x < t[0].length - 1 && n.y > 0 && (u || x(t, i, n.x, n.y - 1) && x(t, i, n.x + 1, n.y)) && g(s, n, 1, -1, 1.4 * v(n.x + 1, n.y - 1)), n.x > 0 && n.y < t.length - 1 && (u || x(t, i, n.x, n.y + 1) && x(t, i, n.x - 1, n.y)) && g(s, n, -1, 1, 1.4 * v(n.x - 1, n.y + 1)));
                            else {
                                var r = [];
                                r.push({
                                    x: n.x,
                                    y: n.y
                                });
                                for (var a = n.parent; null != a;) r.push({
                                    x: a.x,
                                    y: a.y
                                }), a = a.parent;
                                r.reverse();
                                var l = r;
                                s.callback(l), delete b[o], m.shift()
                            }
                        } else s.callback(null), delete b[o], m.shift();
                    else m.shift()
                }
        };
        var g = function(e, o, s, n, r) {
                var a = o.x + s,
                    h = o.y + n;
                if ((void 0 === l[h] || void 0 === l[h][a]) && x(t, i, a, h, o)) {
                    var d = w(e, a, h, o, r);
                    void 0 === d.list ? (d.list = 1, e.openList.push(d)) : o.costSoFar + r < d.costSoFar && (d.costSoFar = o.costSoFar + r, d.parent = o, e.openList.updateItem(d))
                }
            },
            x = function(t, e, i, o, s) {
                var n = p[o] && p[o][i];
                if (n) {
                    var r = _(s.x - i, s.y - o);
                    if (! function() {
                            for (var t = 0; t < n.length; t++)
                                if (n[t] === r) return !0;
                            return !1
                        }()) return !1
                }
                for (var a = 0; a < e.length; a++)
                    if (t[o][i] === e[a]) return !0;
                return !1
            },
            _ = function(t, e) {
                if (0 === t && -1 === e) return o.TOP;
                if (1 === t && -1 === e) return o.TOP_RIGHT;
                if (1 === t && 0 === e) return o.RIGHT;
                if (1 === t && 1 === e) return o.BOTTOM_RIGHT;
                if (0 === t && 1 === e) return o.BOTTOM;
                if (-1 === t && 1 === e) return o.BOTTOM_LEFT;
                if (-1 === t && 0 === e) return o.LEFT;
                if (-1 === t && -1 === e) return o.TOP_LEFT;
                throw new Error("These differences are not valid: " + t + ", " + e)
            },
            v = function(e, i) {
                return c[i] && c[i][e] || d[t[i][e]]
            },
            w = function(t, e, i, o, s) {
                if (void 0 !== t.nodeHash[i]) {
                    if (void 0 !== t.nodeHash[i][e]) return t.nodeHash[i][e]
                } else t.nodeHash[i] = {};
                var r = C(e, i, t.endX, t.endY);
                if (null !== o) var a = o.costSoFar + s;
                else a = 0;
                var h = new n(o, e, i, a, r);
                return t.nodeHash[i][e] = h, h
            },
            C = function(t, e, i, o) {
                if (f) {
                    var s = Math.abs(t - i),
                        n = Math.abs(e - o);
                    return s < n ? 1.4 * s + n : 1.4 * n + s
                }
                var s = Math.abs(t - i),
                    n = Math.abs(e - o);
                return s + n
            }
    }, o.TOP = "TOP", o.TOP_RIGHT = "TOP_RIGHT", o.RIGHT = "RIGHT", o.BOTTOM_RIGHT = "BOTTOM_RIGHT", o.BOTTOM = "BOTTOM", o.BOTTOM_LEFT = "BOTTOM_LEFT", o.LEFT = "LEFT", o.TOP_LEFT = "TOP_LEFT"
}, function(t, e) {
    t.exports = function() {
        this.pointsToAvoid = {}, this.startX = 0, this.callback = null, this.startY = 0, this.endX = 0, this.endY = 0, this.nodeHash = {}, this.openList = null
    }
}, function(t, e) {
    t.exports = function(t, e, i, o, s) {
        this.parent = t, this.x = e, this.y = i, this.costSoFar = o, this.simpleDistanceToTarget = s, this.bestGuessDistance = function() {
            return this.costSoFar + this.simpleDistanceToTarget
        }
    }
}, function(t, e, i) {
    t.exports = i(4)
}, function(t, e, i) {
    var o, s, n;
    (function() {
        var i, r, a, h, l, d, c, p, u, b, m, y, f, g, x;
        a = Math.floor, b = Math.min, r = function(t, e) {
                return t < e ? -1 : t > e ? 1 : 0
            }, u = function(t, e, i, o, s) {
                var n;
                if (null == i && (i = 0), null == s && (s = r), i < 0) throw new Error("lo must be non-negative");
                for (null == o && (o = t.length); i < o;) n = a((i + o) / 2), s(e, t[n]) < 0 ? o = n : i = n + 1;
                return [].splice.apply(t, [i, i - i].concat(e)), e
            }, d = function(t, e, i) {
                return null == i && (i = r), t.push(e), g(t, 0, t.length - 1, i)
            }, l = function(t, e) {
                var i, o;
                return null == e && (e = r), i = t.pop(), t.length ? (o = t[0], t[0] = i, x(t, 0, e)) : o = i, o
            }, p = function(t, e, i) {
                var o;
                return null == i && (i = r), o = t[0], t[0] = e, x(t, 0, i), o
            }, c = function(t, e, i) {
                var o;
                return null == i && (i = r), t.length && i(t[0], e) < 0 && (o = [t[0], e], e = o[0], t[0] = o[1], x(t, 0, i)), e
            }, h = function(t, e) {
                var i, o, s, n, h, l;
                for (null == e && (e = r), n = function() {
                        l = [];
                        for (var e = 0, i = a(t.length / 2); 0 <= i ? e < i : e > i; 0 <= i ? e++ : e--) l.push(e);
                        return l
                    }.apply(this).reverse(), h = [], o = 0, s = n.length; o < s; o++) i = n[o], h.push(x(t, i, e));
                return h
            }, f = function(t, e, i) {
                var o;
                if (null == i && (i = r), -1 !== (o = t.indexOf(e))) return g(t, 0, o, i), x(t, o, i)
            }, m = function(t, e, i) {
                var o, s, n, a, l;
                if (null == i && (i = r), s = t.slice(0, e), !s.length) return s;
                for (h(s, i), l = t.slice(e), n = 0, a = l.length; n < a; n++) o = l[n], c(s, o, i);
                return s.sort(i).reverse()
            }, y = function(t, e, i) {
                var o, s, n, a, d, c, p, m, y;
                if (null == i && (i = r), 10 * e <= t.length) {
                    if (n = t.slice(0, e).sort(i), !n.length) return n;
                    for (s = n[n.length - 1], p = t.slice(e), a = 0, c = p.length; a < c; a++) o = p[a], i(o, s) < 0 && (u(n, o, 0, null, i), n.pop(), s = n[n.length - 1]);
                    return n
                }
                for (h(t, i), y = [], d = 0, m = b(e, t.length); 0 <= m ? d < m : d > m; 0 <= m ? ++d : --d) y.push(l(t, i));
                return y
            }, g = function(t, e, i, o) {
                var s, n, a;
                for (null == o && (o = r), s = t[i]; i > e && (a = i - 1 >> 1, n = t[a], o(s, n) < 0);) t[i] = n, i = a;
                return t[i] = s
            }, x = function(t, e, i) {
                var o, s, n, a, h;
                for (null == i && (i = r), s = t.length, h = e, n = t[e], o = 2 * e + 1; o < s;) a = o + 1, a < s && !(i(t[o], t[a]) < 0) && (o = a), t[e] = t[o], e = o, o = 2 * e + 1;
                return t[e] = n, g(t, h, e, i)
            }, i = function() {
                function t(t) {
                    this.cmp = null != t ? t : r, this.nodes = []
                }
                return t.push = d, t.pop = l, t.replace = p, t.pushpop = c, t.heapify = h, t.updateItem = f, t.nlargest = m, t.nsmallest = y, t.prototype.push = function(t) {
                    return d(this.nodes, t, this.cmp)
                }, t.prototype.pop = function() {
                    return l(this.nodes, this.cmp)
                }, t.prototype.peek = function() {
                    return this.nodes[0]
                }, t.prototype.contains = function(t) {
                    return -1 !== this.nodes.indexOf(t)
                }, t.prototype.replace = function(t) {
                    return p(this.nodes, t, this.cmp)
                }, t.prototype.pushpop = function(t) {
                    return c(this.nodes, t, this.cmp)
                }, t.prototype.heapify = function() {
                    return h(this.nodes, this.cmp)
                }, t.prototype.updateItem = function(t) {
                    return f(this.nodes, t, this.cmp)
                }, t.prototype.clear = function() {
                    return this.nodes = []
                }, t.prototype.empty = function() {
                    return 0 === this.nodes.length
                }, t.prototype.size = function() {
                    return this.nodes.length
                }, t.prototype.clone = function() {
                    var e;
                    return e = new t, e.nodes = this.nodes.slice(0), e
                }, t.prototype.toArray = function() {
                    return this.nodes.slice(0)
                }, t.prototype.insert = t.prototype.push, t.prototype.top = t.prototype.peek, t.prototype.front = t.prototype.peek, t.prototype.has = t.prototype.contains, t.prototype.copy = t.prototype.clone, t
            }(),
            function(i, r) {
                s = [], o = r, void 0 !== (n = "function" == typeof o ? o.apply(e, s) : o) && (t.exports = n)
            }(0, function() {
                return i
            })
    }).call(this)
}]);
! function() {
    "use strict";
    window.AT.SETTINGS = {
        ACHIEVEMENTS_LIMITS: {
            hunter: 15,
            destroyer: 80,
            dodger: 15,
            treasurer: 35,
            ultracombo: 1,
            gotcha: 15,
            fired: 15,
            nailed: 1,
            survivor: 1
        },
        AMMO_LIMITS: {
            shotgun: 105,
            ricochet: 50,
            flamethrower: 236,
            cannon: 105,
            shock: 1500,
            rockets: 45,
            laser: 1500,
            railgun: 105,
            mines: 20
        },
        PRICES: {
            speed: [500, 600, 700, 800, 900],
            turret: [500, 600, 700, 800, 900],
            sight: [500, 600, 700, 800, 900],
            armor: [2e3, 4e3, 8e3, 16e3, 2e4],
            minigun: [0, 200, 300, 400, 500, 600],
            shotgun: [2750, 500, 900, 1300, 1700, 2100],
            ricochet: [8e3, 2500, 3e3, 3500, 4e3, 4500],
            flamethrower: [1e4, 3e3, 4e3, 5e3, 6e3, 7e3],
            cannon: [1e4, 3e3, 4e3, 5e3, 6e3, 7e3],
            shock: [1e4, 3e3, 4e3, 5e3, 6e3, 7e3],
            rockets: [1e4, 3e3, 4e3, 5e3, 6e3, 7e3],
            laser: [28e3, 11e3, 12e3, 13e3, 14e3, 15e3],
            railgun: [28e3, 11e3, 12e3, 13e3, 14e3, 15e3],
            mines: [8e3, 2500, 3e3, 3500, 4e3, 4500]
        },
        AMMO_PRICES: {
            shotgun: 50,
            ricochet: 100,
            flamethrower: 200,
            cannon: 200,
            shock: 200,
            rockets: 200,
            laser: 300,
            railgun: 400,
            mines: 300
        },
        AMMO_AMOUNT: {
            shotgun: 21,
            ricochet: 10,
            flamethrower: 48,
            cannon: 21,
            shock: 300,
            rockets: 9,
            laser: 300,
            railgun: 21,
            mines: 4
        }
    }
}(),
function() {
    "use strict";

    function t(t, e) {
        return (t % e + e) % e
    }

    function e(t, e, i, o, s) {
        return o + (t - e) * (s - o) / (i - e)
    }

    function i(t, e, i) {
        var o = (e - t.rotation) % (2 * Math.PI);
        return o !== o % Math.PI && (o = o < 0 ? o + 2 * Math.PI : o - 2 * Math.PI), Math.abs(o) <= i / 180 * Math.PI ? (t.rotation = e, !0) : (t.rotation += i / 180 * Math.PI * Math.sign(o), !1)
    }

    function o(t, e, o, s) {
        return i(t, Math.atan2(o.y - e.y, o.x - e.x), s)
    }

    function s(t, e, o) {
        return i(t, Math.atan2(e.y, e.x), o)
    }

    function n(t, e, i) {
        var o = Math.sqrt(t.x * t.x + t.y * t.y);
        o && (o > i ? (t.x /= o / i, t.y /= o / i) : o < e && (t.x /= o / e, t.y /= o / e))
    }

    function r(t, e) {
        return e ? (255 * (1 - ((16711680 & t) >> 16) / 255 * e) << 16) + (255 * (1 - ((65280 & t) >> 8) / 255 * e) << 8) + 255 * (1 - (255 & t) / 255 * e) : 16777215
    }

    function a(t) {
        var e = {
                hit: 1
            },
            i = t.game.add.tween(e).to({
                hit: 0
            }, 250, Phaser.Easing.Linear.None, !0, 0);
        return i.onUpdateCallback(function() {
            t.tint = r(16777215, e.hit)
        }, null), i.onComplete.add(function() {
            t.tint = 16777215
        }, null), i
    }

    function h(t, e, i) {
        for (var o = new Array(e), s = 0; s < e; s++)
            if (o[s] = new Array(t), void 0 !== i)
                for (var n = 0; n < t; n++) o[s][n] = i;
        return o
    }

    function l(t, e) {
        function i() {
            return s <= 0 ? (s = -1 === s ? Math.floor(Math.random() * (e + 1)) : e, o = t.apply(this, arguments)) : s -= 1, o
        }
        var o, s = -1;
        return i
    }

    function d(t, e, i) {
        for (var o = 1 / 0, s = -1, n = 0; n < t.length; n++) {
            var r = Phaser.Math.distanceSq(e, i, t[n].x, t[n].y);
            r < o && (o = r, s = n)
        }
        return s
    }

    function c(t, e, i, o, s, n, r, a) {
        var h = window.AT.audio,
            l = t.make.button(e, i, o, n, r, s + "_hover.png", s + "_normal.png", s + "_down.png", s + "_normal.png");
        return l.onInputDown.add(h.playButtonDown), l.onInputUp.add(h.playButtonUp), a && a.add ? a.add(l) : a && a.addChild && a.addChild(l), l
    }

    function p(t, e, i, o, s, n, r, a) {
        var h = window.AT.audio,
            l = t.make.button(e, i, o, n, r, s + "/x_hover.png", s + "/x_normal.png", s + "/x_normal.png", s + "/x_hover.png");
        return l.onInputDown.add(h.playButtonDown), l.onInputUp.add(h.playButtonUp), a && a.add ? a.add(l) : a && a.addChild && a.addChild(l), l
    }

    function u(t) {
        if (t) {
            if (Array.isArray(t)) {
                for (var e = 0, i = 0; i < t.length; i++) e += u(t[i]);
                return e
            }
            if (t.children && 0 !== t.children.length) {
                for (var e = 1, i = 0; i < t.children.length; i++) e += u(t.children[i]);
                return e
            }
            return 1
        }
        return 0
    }

    function b(t) {
        if (t) {
            if (Array.isArray(t)) {
                for (var e = 0, i = 0; i < t.length; i++) e += b(t[i]);
                return e
            }
            if (t.children && 0 !== t.children.length) {
                var e = t.visible;
                if (e)
                    for (var i = 0; i < t.children.length; i++) e += b(t.children[i]);
                return e
            }
            return t.visible
        }
        return 0
    }

    function m(t, e) {
        var i;
        if (i = e ? ["--".repeat(e - 1) + "- " + (t.name || "element")] : [t.name || "element"], !t.children || !t.children.length) return i;
        for (var o = 0; o < t.children.length; o++) i = i.concat(m(t.children[o], e + 1));
        return i
    }

    function y(t) {
        console.table(m(t, 0))
    }

    function f(t) {
        t.x += 1, t.y += 1, t.width -= 2, t.height -= 2, t.sourceSizeW -= 2, t.sourceSizeH -= 2, t.right -= 1, t.bottom -= 1
    }

    function g(t) {
        var e = "",
            i = "",
            o = "";
        return t >= 1e6 && (e = Math.floor(t / 1e6) + " ", t -= 1e6 * Math.floor(t / 1e6)), t >= 1e3 && (i = Math.floor(t / 1e3) + " ", e.length && (2 === i.length ? i = "00" + i : 3 === i.length && (i = "0" + i)), t -= 1e3 * Math.floor(t / 1e3)), o = String(Math.floor(t % 1e3)), i.length && (1 === o.length ? o = "00" + o : 2 === o.length && (o = "0" + o)), e + i + o
    }

    function x(t) {
        return "$" + g(t)
    }

    function _(t) {
        for (var e = 0, i = 0; e < t.length; i += t[e++]);
        for (var o = Math.random() * i; e > 0 && i >= o; i -= t[--e]);
        return e
    }
    var v = {
            WALL: 1,
            PLAYER: 2,
            PROJECTILE: 8,
            OBSTACLE: 16,
            ENEMY_SPAWNER: 32,
            ENEMY: 64
        },
        w = {
            PLAYER: 1,
            CPU: 2
        };
    window.AT.common = {
        COLLISION_GROUPS: v,
        TEAMS: w,
        mod: t,
        scale: e,
        rotate: i,
        rotateToPoint: o,
        rotateToVector: s,
        clampVector: n,
        calculateHitColor: r,
        flashElement: a,
        create2DArray: h,
        debounceCalls: l,
        findClosestTileOnPath: d,
        button: c,
        closeButton: p,
        countDisplayObjects: u,
        countVisibleDisplayObjects: b,
        displayRenderTree: y,
        padTileFrame: f,
        formatNumber: g,
        formatMoney: x,
        weightedChoice: _
    }
}(),
function() {
    "use strict";

    function t() {
        try {
            l = JSON.parse(window.localStorage.getItem("AWESOME-TANKS-2"))
        } catch (t) {}
        l ? (delete l.helpShootingShown, "helpWeaponsShown" in l.game || (l.game.helpWeaponsShown = h.game.helpWeaponsShown), "helpMinesShown" in l.game || (l.game.helpMinesShown = h.game.helpMinesShown), "helpMinesBought" in l.game || (l.game.helpMinesBought = h.game.helpMinesBought), "helpWeaponBought" in l.game || (l.game.helpWeaponBought = h.game.helpWeaponBought), "refillHintDiscarded" in l.game || (l.game.refillHintDiscarded = h.game.refillHintDiscarded)) : l = JSON.parse(JSON.stringify(h))
    }

    function e() {
        l = JSON.parse(JSON.stringify(h)), i()
    }

    function i() {
        try {
            window.localStorage.setItem("AWESOME-TANKS-2", JSON.stringify(l))
        } catch (t) {}
    }

    function o(t) {
        return l.achievements[t] >= a.ACHIEVEMENTS_LIMITS[t]
    }

    function s(t) {
        return l.achievements[t] += 1, l.achievements[t] === a.ACHIEVEMENTS_LIMITS[t]
    }

    function n(t) {
        return l.game[t + "Ammo"] / a.AMMO_LIMITS[t]
    }

    function r() {
        for (var t = 0, e = 0; e < l.game.points.length; e++) t += l.game.points[e];
        return t
    }
    var a = window.AT.SETTINGS,
        h = {
            achievements: {
                hunter: 0,
                destroyer: 0,
                dodger: 0,
                treasurer: 0,
                ultracombo: 0,
                gotcha: 0,
                fired: 0,
                nailed: 0,
                survivor: 0
            },
            stats: {
                tanksDestroyed: 0,
                turretsDestroyed: 0,
                spawnersDestroyed: 0,
                wallsDestroyed: 0,
                coinsCollected: 0,
                barrelsExploded: 0,
                cratesDestroyed: 0,
                moneyEarned: 0
            },
            game: {
                sound: !0,
                music: !0,
                completed: !1,
                helpMovingShown: !1,
                helpWeaponBought: !1,
                helpMinesBought: !1,
                helpWeaponsShown: !1,
                helpMinesShown: !1,
                weaponTabOpened: !1,
                refillHintDiscarded: !1,
                levels: 0,
                points: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                difficulty: -1,
                money: 0,
                speed: 0,
                turret: 0,
                sight: 0,
                armor: 0,
                minigunLevel: 0,
                shotgunLevel: -1,
                shotgunAmmo: a.AMMO_LIMITS.shotgun,
                ricochetLevel: -1,
                ricochetAmmo: a.AMMO_LIMITS.ricochet,
                flamethrowerLevel: -1,
                flamethrowerAmmo: a.AMMO_LIMITS.flamethrower,
                cannonLevel: -1,
                cannonAmmo: a.AMMO_LIMITS.cannon,
                shockLevel: -1,
                shockAmmo: a.AMMO_LIMITS.shock,
                rocketsLevel: -1,
                rocketsAmmo: a.AMMO_LIMITS.rockets,
                laserLevel: -1,
                laserAmmo: a.AMMO_LIMITS.laser,
                railgunLevel: -1,
                railgunAmmo: a.AMMO_LIMITS.railgun,
                minesLevel: -1,
                minesAmmo: a.AMMO_LIMITS.mines
            }
        },
        l = null;
    window.AT.profile = {
        DEFAULT: h,
        load: t,
        reset: e,
        save: i,
        isAchievementCompleted: o,
        increaseAchievement: s,
        getAmmoPercent: n,
        getTotalPoints: r
    }, Object.defineProperty(window.AT.profile, "current", {
        get: function() {
            return l
        }
    })
}(),
function() {
    "use strict";

    function t(t) {
        S = t.sound, S.muteOnPause = !1
    }

    function e() {
        S._sounds.splice(S._sounds.indexOf(this), 1)
    }

    function i(t, i) {
        if (C.current.game.sound) {
            var o = S.play(t, null == i ? 1 : i / 1.3, !1);
            return o.onStop.addOnce(e, o), o
        }
        return null
    }

    function o() {
        i("button_on.mp3")
    }

    function s() {
        i("button_off.mp3")
    }

    function n() {
        var t = 3 * Math.random();
        t < 1 ? i("enemy_hit_1.mp3", .23) : t < 2 ? i("enemy_hit_2.mp3", .23) : t < 3 && i("enemy_hit_3.mp3", .23)
    }

    function r() {
        var t = 3 * Math.random();
        t < 1 ? i("spawner_hit_1.mp3", .3) : t < 2 ? i("spawner_hit_2.mp3", .3) : t < 3 && i("spawner_hit_3.mp3", .3)
    }

    function a() {
        C.current.game.sound && (B ? B.play(void 0, 0, 1, !0, !1) : B = S.play("laser_loop.mp3", 1, !0)), M += 1
    }

    function h() {
        0 === (M = Math.max(0, M - 1)) && B && B.stop()
    }

    function l() {
        M = 0, B && B.stop()
    }

    function d() {
        C.current.game.sound && (I ? I.play(void 0, 0, 1, !0, !1) : I = S.play("ricochet_loop.mp3", 1, !0))
    }

    function c() {
        I && I.stop()
    }

    function p() {
        C.current.game.sound && (D ? D.play(void 0, 0, 1, !0, !1) : D = S.play("flame_loop.mp3", 1, !0)), k += 1
    }

    function u() {
        0 === (k -= 1) && D && D.stop()
    }

    function b() {
        C.current.game.sound && (R ? R.play(void 0, 0, 1, !0, !1) : R = S.play("shock_loop.mp3", 1, !0))
    }

    function m() {
        R && R.stop()
    }

    function y(t, i) {
        t !== A && (T && (T.fadeOut(200), T.onStop.addOnce(e, T)), A = t, P = i || 1, C.current.game.music && (T = S.add(t, 0), T.play("", 0, 0, !0), T.fadeTo(200, P)))
    }

    function f() {
        T || A && (T = S.add(A, 0), T.play("", 0, 0, !0), T.fadeTo(200, P))
    }

    function g() {
        T && (T.mute = !0)
    }

    function x() {
        T && (T.mute = !1)
    }

    function _(t) {
        T && (T.fadeOut(t || 200), S.remove(T), T = null)
    }

    function v(t) {
        t || h(), C.current.game.sound = t, C.save()
    }

    function w(t) {
        t ? f() : _(), C.current.game.music = t, C.save()
    }
    var C = window.AT.profile,
        S = null,
        A = null,
        T = null,
        P = 0,
        B = null,
        M = 0,
        I = null,
        R = null,
        D = null,
        k = 0;
    window.AT.audio = {
        init: t,
        playSound: i,
        playButtonDown: o,
        playButtonUp: s,
        playEnemyHit: n,
        playSpawnerHit: r,
        playLaserLoop: a,
        stopLaserLoop: h,
        cancelLaserLoop: l,
        playRicochetLoop: d,
        stopRicochetLoop: c,
        playFlameLoop: p,
        stopFlameLoop: u,
        playShockLoop: b,
        stopShockLoop: m,
        playMusic: y,
        resumeMusic: f,
        muteMusic: g,
        unmuteMusic: x,
        stopMusic: _,
        toggleSound: v,
        toggleMusic: w
    }
}(),
function() {
    "use strict";

    function t(e, i, o) {
        var s = new Function("return function " + i + "(machine) {this.machine = machine;this.init(machine.owner);};")();
        e && (s.prototype = Object.create(e)), s.prototype.constructor = s;
        for (var n in o) s.prototype[n] = o[n];
        return s.extend = t.bind(null, s.prototype), s
    }

    function e(t) {
        this.owner = t, this.previous = null, this.current = null, this.time = 0
    }
    var i = t(null, "State", {
        init: function() {},
        enter: function() {},
        update: function() {},
        exit: function() {}
    });
    i.extend = t.bind(null, i.prototype), e.prototype.message = function(t) {
        if (this.current && t in this.current) {
            var e = Array.prototype.slice.call(arguments);
            e[0] = this.owner, this.current[t].apply(this.current, e)
        }
    }, e.prototype.change = function(t) {
        if (this.previous = this.current, null !== this.current && this.current.exit(this.owner), this.time = 0, t) {
            this.current = new t(this);
            var e = Array.prototype.slice.call(arguments);
            e[0] = this.owner, this.current.enter.apply(this.current, e)
        } else this.current = null
    }, e.prototype.idle = function() {
        this.change(null)
    }, e.prototype.update = function() {
        null !== this.current && (this.time += this.owner.game.time.physicsElapsed, this.current.update(this.owner))
    }, window.AT.states = {
        State: i,
        StateMachine: e
    }
}(),
function() {
    "use strict";
    var t = window.AT.common.rotate,
        e = window.AT.common.findClosestTileOnPath,
        i = window.AT.states.State,
        o = i.extend("GoTo", {
            init: function(t) {
                this.pathInstanceId = -1, this.path = null, this.nextTileIndex = -1, this.onPathFound = this.onPathFound.bind(this, t), this.target = new Phaser.Point
            },
            enter: function(t, e, i) {
                this.target.set(e, i)
            },
            findPath: function(t, e) {
                e || (this.path = null, this.nextTileIndex = -1), -1 === this.pathInstanceId && (this.pathInstanceId = t.findPath(this.target.x, this.target.y, this.onPathFound))
            },
            onPathFound: function(t, i) {
                this.path = i && i.length > 0 ? i : null, this.pathInstanceId = -1, this.nextTileIndex = i && i.length > 0 ? Math.min(i.length - 1, e(i, t.tileX, t.tileY) + 1) : -1
            },
            isPathFree: function(t, e, i) {
                i = null == i ? this.path.length : Math.min(i, this.path.length);
                for (var o = t.level.grid, s = e || 0; s < i; s++) {
                    var n = this.path[s].x,
                        r = this.path[s].y;
                    if (0 !== o[r][n] && (t.tileX !== n || t.tileY !== r)) return !1
                }
                return !0
            },
            tileReached: function(t) {
                this.isPathFree(t, this.nextTileIndex + 1, this.nextTileIndex + 5) ? this.nextTileIndex += 1 : this.findPath(t, !0)
            },
            targetReached: function(t) {},
            update: function(e) {
                if (this.target.x === e.tileX && this.target.y === e.tileY) return void this.targetReached(e);
                if (null === this.path) this.findPath(e, !0);
                else {
                    var i = this.path[this.nextTileIndex],
                        o = e.level.tileToPx(i.x) - e.bodyX,
                        s = e.level.tileToPx(i.y) - e.bodyY,
                        n = Math.sqrt(o * o + s * s);
                    n < 30 && this.nextTileIndex < this.path.length - 1 ? this.tileReached(e) : (n >= 30 || this.nextTileIndex !== this.path.length - 1) && e.body.applyForce(o / n * e.body.mass * 50, s / n * e.body.mass * 50), t(e.body, Math.atan2(s, o), 4)
                }
            },
            exit: function(t) {
                -1 !== this.pathInstanceId && t.level.easystar.cancelPath(this.pathInstanceId)
            }
        }),
        s = i.extend("Spawn", {
            init: function(t) {
                this.target = new Phaser.Point, this.freeTileFound = !1
            },
            enter: function(t, e) {
                t.hit = 1, t.hitColor = 16777215, t.spawner = e
            },
            tileReached: function(t) {
                this.machine.change(r)
            },
            onFreeze: function(t) {
                this.machine.change(n)
            },
            onPlayerInSight: function(t) {
                this.machine.change(h)
            },
            update: function(e) {
                if (this.machine.time >= 5) return void this.machine.change(r);
                if (this.machine.time >= .5 && e.searchForPlayer(!1)) return void this.machine.change(l);
                if (!this.freeTileFound) return void(e.level.getRandomFreeTileAround(e.tileX, e.tileY, this.target) && (this.freeTileFound = !0));
                if (this.machine.time >= 1) {
                    var i = e.level.tileToPx(this.target.x) - e.bodyX,
                        o = e.level.tileToPx(this.target.y) - e.bodyY,
                        s = Math.sqrt(i * i + o * o);
                    s < 10 ? this.tileReached(e) : (e.body.applyForce(i / s * e.body.mass * 8, o / s * e.body.mass * 8), t(e.body, Math.atan2(o, i), 4))
                }
            }
        }),
        n = i.extend("Spawn", {
            enter: function(t) {
                t.fire && (t.fire.time = 0), t.addChild(t.ice), t.level.spawnIce(t.bodyX, t.bodyY), t.weapon && t.weapon.stopFire()
            },
            onFreeze: function(t) {
                t.level.spawnIce(t.bodyX, t.bodyY)
            },
            onUnfreeze: function(t) {
                this.machine.change(r)
            },
            exit: function(t) {
                t.removeChild(t.ice), t.level.spawnIce(t.bodyX, t.bodyY)
            }
        }),
        r = i.extend("Idle", {
            init: function(t) {
                this.target = new Phaser.Point, this.offset = new Phaser.Point, this.delay = 1 + 5 * Math.random()
            },
            enter: function(t) {
                this.target.set(t.tileX, t.tileY)
            },
            onFreeze: function(t) {
                this.machine.change(n)
            },
            onPlayerInSight: function(t) {
                this.machine.change(h)
            },
            onSoundEmitted: function(t, e, i) {
                this.machine.change(h)
            },
            tileReached: function(t) {
                var e = t.level.rnd.integerInRange(0, 3) * Math.PI * .5,
                    i = Math.round(t.tileX + Math.cos(e)),
                    o = Math.round(t.tileY + Math.sin(e));
                t.level.isTileFree(i, o) && null === t.level.objects[o][i] && (this.delay = 3 + Math.random(), this.target.set(i, o), this.offset.set(3 * (2 * Math.random() - 1), 3 * (2 * Math.random() - 1)))
            },
            update: function(e) {
                if (e.patrol(e.alerted)) return e.alertOthers(), void this.machine.change(l);
                this.delay -= e.game.time.physicsElapsed;
                var i = e.level.tileToPx(this.target.x) - e.bodyX + this.offset.x,
                    o = e.level.tileToPx(this.target.y) - e.bodyY + this.offset.y,
                    s = Math.sqrt(i * i + o * o);
                s < 5 || this.delay <= -1 ? this.delay <= 0 && this.tileReached(e) : (e.body.applyForce(i / s * e.body.mass * 15, o / s * e.body.mass * 15), t(e.body, Math.atan2(o, i), 4))
            }
        }),
        a = o.extend("GoToSound", {
            enter: function(t, e, i) {
                this.target.set(e, i)
            },
            onFreeze: function(t) {
                this.machine.change(n)
            },
            targetReached: function(t) {
                this.machine.change(r)
            },
            update: function(t) {
                return !t.level.player.alive || this.machine.time >= 10 ? void this.machine.change(r) : t.patrol(!1) ? void this.machine.change(l) : void o.prototype.update.call(this, t)
            }
        }),
        h = o.extend("GoToPlayer", {
            enter: function(t) {
                this.target.set(t.level.player.tileX, t.level.player.tileY)
            },
            onFreeze: function(t) {
                this.machine.change(n)
            },
            targetReached: function(t) {
                this.machine.change(r)
            },
            update: function(t) {
                return !t.level.player.alive || this.machine.time >= 10 ? void this.machine.change(r) : t.patrol(!1) ? void this.machine.change(l) : void o.prototype.update.call(this, t)
            }
        }),
        l = o.extend("FollowPlayer", {
            init: function(t) {
                o.prototype.init.call(this, t), this.forgetTime = 0
            },
            enter: function(t) {
                this.target.set(t.level.player.tileX, t.level.player.tileY), this.forgetTime = 0
            },
            onFreeze: function(t) {
                this.machine.change(n)
            },
            pathNeedsUpdate: function(t) {
                var e = t.level.player;
                return Math.abs(this.target.x - e.tileX) > 1 || Math.abs(this.target.y - e.tileY) > 1 || null === this.path || !this.isPathFree(t, this.nextTileIndex + 1, this.nextTileIndex + 5)
            },
            tileReached: function(t) {
                this.pathNeedsUpdate(t) ? (this.target.set(t.level.player.tileX, t.level.player.tileY), this.findPath(t, !0)) : this.nextTileIndex += 1
            },
            update: function(t) {
                if (!t.level.player.alive || this.forgetTime >= 4) return void this.machine.change(r);
                var e = t.patrol(!1);
                (!e || t.distanceToPlayer > t.shootRange) && (this.pathNeedsUpdate(t) && (this.target.set(t.level.player.tileX, t.level.player.tileY), this.findPath(t, !0)), o.prototype.update.call(this, t)), this.forgetTime = e ? 0 : this.forgetTime + t.game.time.physicsElapsed
            }
        });
    window.AT.ai = {
        GoTo: o,
        Spawn: s,
        Frozen: n,
        Idle: r,
        GoToSound: a,
        GoToPlayer: h,
        FollowPlayer: l
    }
}(),
function() {
    "use strict";

    function t(t, e, i, o, s) {
        Phaser.Particle.call(this, t, e, i, o, s)
    }

    function e(e, i, o, s) {
        Phaser.Particles.Arcade.Emitter.call(this, e, i, o, s), this.particleClass = t
    }
    t.prototype = Object.create(Phaser.Particle.prototype), t.prototype.preUpdate = function() {
        return !(!this.preUpdatePhysics() || !this.preUpdateLifeSpan()) && this.preUpdateCore()
    }, t.prototype.update = function() {
        this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1), this._exists && this.body.postUpdate()
    }, t.prototype.postUpdate = function() {}, e.prototype = Object.create(Phaser.Particles.Arcade.Emitter.prototype), e.prototype.postUpdate = function() {}, window.AT.particles = {
        Emitter: e
    }
}(),
function() {
    "use strict";

    function t(t, e, i) {
        Phaser.Image.call(this, t.game, 0, 0, "game.png", "game/lifebar/background.png"), this.name = "lifebar", this._permanent = !1, this.owner = t, this.level = t.game.state.getCurrentState(), this.scale.set(.5, .5), this.anchor.set(.5, 0), this.pivot.set(e, i), this.alpha = 0, this.visible = !1, this.bar = t.game.make.image(-47.5, 0, "game.png", "game/lifebar/foreground.png"), this.bar.anchor.set(0, 0), this.bar.crop(new Phaser.Rectangle(0, 0, 95, 15)), this.addChild(this.bar), this.lastHealth = t.health, this.idleTime = 0, this.showTween = null, this.hideTween = null
    }
    t.prototype = Object.create(Phaser.Image.prototype), t.prototype.show = function() {
        this.showTween || (this.hideTween && (this.hideTween.stop(), this.hideTween = null), this.idleTime = 0, this.visible = !0, this.parent || this.owner.addChild(this), this.showTween = this.game.add.tween(this).to({
            alpha: 1
        }, 200, Phaser.Easing.Linear.None, !0))
    }, t.prototype.makeInvisible = function() {
        this.visible = !1, this.parent && this.parent.removeChild(this)
    }, t.prototype.hide = function() {
        this.hideTween || (this.showTween && (this.showTween.stop(), this.showTween = null), this.hideTween = this.game.add.tween(this).to({
            alpha: 0
        }, 200, Phaser.Easing.Linear.None, !0), this.hideTween.onComplete.add(this.makeInvisible, this))
    }, t.prototype.postUpdate = function() {
        this.rotation = -this.parent.rotation, this.parent.health <= 0 ? this.hide() : this.parent.health !== this.lastHealth && this.lastHealth > 0 || this.level.showHealth ? this.parent.health !== this.lastHealth && (this.bar.cropRect.width = Math.max(0, this.parent.health / this.parent.maxHealth * 95), this.bar.updateCrop(), this.lastHealth = this.parent.health) : this.idleTime < .833 && !this._permanent && (this.idleTime += this.game.time.physicsElapsed, this.idleTime >= .833 && this.hide())
    }, Object.defineProperty(t.prototype, "permanent", {
        get: function() {
            return this._permanent
        },
        set: function(t) {
            t !== this._permanent && (this._permanent = t, t && this.show())
        }
    }), window.AT.Lifebar = t
}(),
function() {
    "use strict";

    function t(t, i, o) {
        Phaser.Sprite.call(this, t, i, o, "game.png"), this.animations.add("explode", e, 45)
    }
    var e = Phaser.Animation.generateFrameNames("game/particles/explosion_", 0, 14, ".png", 0);
    t.prototype = Object.create(Phaser.Sprite.prototype), t.prototype.onEmit = function() {
        this.animations.stop("explode", !0), this.animations.play("explode"), this.anchor.set(.5, .55)
    }, window.AT.explosion = t
}(),
function() {
    "use strict";

    function t(t, i, o, s) {
        Phaser.Sprite.call(this, t, i, o, "game.png"), this.team = s, this.animations.add("rocket", r, 30, !0), this.animations.play("rocket"), this.anchor.set(.5, .5), this.smokeTime = 0, this.speed = 0, s === e.PLAYER ? (this.acceleration = 18.36, this.maxSpeed = 204) : (this.acceleration = 15.12, this.maxSpeed = 168), this.requestKill = !1, this.touch = !1
    }
    var e = window.AT.common.TEAMS,
        i = window.AT.common.COLLISION_GROUPS,
        o = window.AT.common.rotate,
        s = window.AT.common.rotateToPoint,
        n = window.AT.profile,
        r = Phaser.Animation.generateFrameNames("game/projectiles/rocket_", 0, 2, ".png", 0);
    t.prototype = Object.create(Phaser.Sprite.prototype), t.collisionFilterCPU = function(t, e, o, s) {
        var n = e.GetFilterData().categoryBits;
        return n !== i.PROJECTILE && n !== i.ENEMY_SPAWNER && n !== i.ENEMY
    }, t.prototype.followMouse = function() {
        var t = this.game.input.mousePointer,
            e = t.worldX - this.world.x,
            i = t.worldY - this.world.y;
        if (Math.abs(e) > 2 && Math.abs(i) > 2) {
            var o = Math.atan2(i, e) - this.body.rotation;
            o !== o % Math.PI && (o += o < 0 ? 2 * Math.PI : 2 * -Math.PI), this.body.rotation += .2 * Math.min(Math.abs(o), .3 * Math.PI) * Math.sign(o), this.body.rotation %= 2 * Math.PI
        }
    }, t.prototype.followFinger = function() {
        var t = this.game.state.getCurrentState().aimPointer;
        if (t) {
            var e = t.x - t.positionDown.x,
                i = t.y - t.positionDown.y;
            if (Math.abs(e) > 1 || Math.abs(i) > 1) {
                var s = Math.sqrt(e * e + i * i);
                s > 50 && (t.positionDown.x += e * (s - 50) / s, t.positionDown.y += i * (s - 50) / s), e = Phaser.Math.clamp(e, -50, 50) / 50, i = Phaser.Math.clamp(i, -50, 50) / 50, o(this.body, Math.atan2(i, e), 5)
            }
        } else this.alive && (this.requestKill = !0)
    }, t.prototype.followPlayer = function() {
        var e = this.game.state.getCurrentState(),
            i = e.player,
            o = e.physics.box2d.raycast(this.body.x, this.body.y, i.body.x, i.body.y, !0, t.collisionFilterCPU);
        return !(o && o.length > 0 && o[0].body !== this.body && o[0].body !== i.body) && (s(this.body, this.body, i.body, 5), !0)
    }, t.prototype.kill = function() {
        this.team === e.CPU && this.lifespan <= 0 && n.increaseAchievement("dodger") && this.game.state.getCurrentState().achievements.show("dodger"), Phaser.Sprite.prototype.kill.call(this)
    }, t.prototype.update = function() {
        if (this.alive) {
            var t = this.game.time.physicsElapsed,
                i = this.game.state.getCurrentState();
            if (this.smokeTime -= t, this.smokeTime <= 0) {
                var o = this.body.x - 5 * Math.cos(this.body.rotation),
                    s = this.body.y - 5 * Math.sin(this.body.rotation);
                i.smokeEmitter.emitParticle(o, s), this.smokeTime += 1 / 6
            }
            this.team === e.PLAYER ? i.aimPointer || this.touch ? (this.followFinger(), this.touch = !0) : this.followMouse() : this.followPlayer(), this.speed += this.acceleration * t, this.speed > this.maxSpeed && (this.speed = this.maxSpeed), this.body.applyForce(Math.cos(this.body.rotation) * this.speed * t, Math.sin(this.body.rotation) * this.speed * t);
            var n = this.body.velocity,
                r = Math.sqrt(n.x * n.x + n.y * n.y);
            r > this.maxSpeed && (n.x = n.x / r * this.maxSpeed, n.y = n.y / r * this.maxSpeed)
        }
    }, t.prototype.postUpdate = function() {
        Phaser.Sprite.prototype.postUpdate.call(this), this.requestKill && this.alive && this.kill()
    }, window.AT.Rocket = t
}(),
function() {
    "use strict";

    function t(t, e, i) {
        Phaser.Image.call(this, t, e, i, "game.png", "game/projectiles/laser.png"), this.anchor.set(0, .65)
    }
    var e = (window.AT.common.COLLISION_GROUPS, ["game/particles/spark_0.png", "game/particles/spark_1.png"]);
    t.prototype = Object.create(Phaser.Image.prototype), t.prototype.hide = function() {
        this.width = 0
    }, t.prototype.show = function(t, i, o, s, n) {
        this.x = t, this.y = i, this.rotation = n;
        var r = this.game.state.getCurrentState(),
            a = r.sparkEmitter;
        a.setXSpeed(-100, 100), a.setYSpeed(-100, 100), a.emitParticle(o, s, "game.png", r.rnd.pick(e)), this.width = Phaser.Math.distance(t, i, o, s)
    }, t.prototype.update = function() {
        this.alpha = .3 + .7 * Math.random()
    }, window.AT.Laser = t
}(),
function() {
    "use strict";

    function t(t, e, i) {
        Phaser.Image.call(this, t, e, i, "game.png", "game/projectiles/shock_long_0.png"), this.anchor.set(0, .5), this.rayLength = 0
    }
    window.AT.common.COLLISION_GROUPS;
    t.prototype = Object.create(Phaser.Image.prototype), t.prototype.show = function(t, e, i, o, s) {
        this.x = t, this.y = e, this.rotation = null != s ? s : Math.atan2(o - e, i - t);
        var n = this.game.state.getCurrentState(),
            r = n.sparkEmitter;
        r.setXSpeed(-100, 100), r.setYSpeed(-100, 100), r.emitParticle(i, o, "game.png", "game/particles/spark_3.png");
        var a, h = Phaser.Math.distance(t, e, i, o);
        a = h > 300 ? Math.random() < .5 ? "game/projectiles/shock_long_0.png" : "game/projectiles/shock_long_1.png" : h > 100 ? Math.random() < .5 ? "game/projectiles/shock_medium_0.png" : "game/projectiles/shock_medium_1.png" : Math.random() < .5 ? "game/projectiles/shock_short_0.png" : "game/projectiles/shock_short_1.png", this.loadTexture("game.png", a), this.width = h
    }, t.prototype.update = function() {
        this.scale.y = 1.5 * Math.random() + .5, Math.random() > .5 && (this.scale.y *= -1), this.alpha = .5 + .5 * Math.random()
    }, window.AT.Shock = t
}(),
function() {
    "use strict";

    function t(t) {
        Phaser.Sprite.call(this, t), this.team = 0, this.time = 0, this.hitColor = 16777215, this.circle = t.make.image(0, 0, "game.png", "game/particles/explosion_circle.png"), this.circle.anchor.set(.5, .5), this.addChild(this.circle), this.fire = t.make.sprite(0, 0, "game.png"), this.fire.animations.add("explode", n, 45), this.fire.anchor.set(.5, .55), this.addChild(this.fire), this._x = 0, this._y = 0, this._damage = 0, this._radius = 0, this.damaged = !1, this.circleStartScale = 0, this.circleEndScale = 0, this.circleBody = null, this.circleFixture = null
    }

    function e(t, e) {
        Phaser.Group.call(this, t, e, "explosions");
        for (var i = 0; i < 10; i++) this.createExplosion().kill()
    }
    var i = window.AT.common.COLLISION_GROUPS,
        o = window.AT.common.TEAMS,
        s = window.AT.audio,
        n = Phaser.Animation.generateFrameNames("game/particles/explosion_", 0, 14, ".png", 0);
    t.collisionFilter = function(t, e, o, s) {
        return e.GetFilterData().categoryBits !== i.PROJECTILE
    }, t.prototype = Object.create(Phaser.Sprite.prototype), t.prototype.startAnimation = function(t, e, i) {
        this.time = 0, this.reset(t, e), this.fire.visible = !0, this.fire.animations.stop("explode", !0), this.fire.animations.play("explode"), this.circleStartScale = 2 * i / 192 * .9, this.circleEndScale = this.circleStartScale * Math.pow(.9, 20), this.circle.scale.set(this.circleStartScale, this.circleStartScale), this.circle.alpha = 1
    }, t.prototype.startWave = function(t, e, i) {
        this.time = 0, this.reset(t, e), this.fire.visible = !1, this.circleStartScale = 2 * i / 192 * .9, this.circleEndScale = this.circleStartScale * Math.pow(.9, 20), this.circle.scale.set(this.circleStartScale, this.circleStartScale), this.circle.alpha = 1
    }, t.prototype.explode = function(t, e, i, o, s) {
        this.team = s, this.damaged = !1, this.startAnimation(t, e, i), this._x = t, this._y = e, this._radius = this.game.physics.box2d.pxm(i), this._damage = o, this.game.state.getCurrentState().alertSound(t, e, i)
    }, t.prototype.silentExplode = function(t, e, i, o, s) {
        this.team = s, this.damaged = !1, this.time = 0, this.reset(t, e), this._x = t, this._y = e, this._radius = this.game.physics.box2d.pxm(i), this._damage = o, this.game.state.getCurrentState().alertSound(t, e, i)
    }, t.prototype.wave = function(t, e, i) {
        this.team = 0, this.damaged = !1, this.startWave(t, e, i), this._x = t, this._y = e, this._radius = this.game.physics.box2d.pxm(i), this._damage = 0
    }, t.prototype.damageObject = function(e) {
        var o = e.sprite;
        if (o && o.onBulletHit) {
            var s = e.data.GetFixtureList().GetFilterData().categoryBits;
            if (s === i.PLAYER || s === i.OBSTACLE || s === i.ENEMY_SPAWNER || s === i.ENEMY) {
                var n = this.game.physics.box2d.pxm(Phaser.Math.distance(e.x, e.y, this._x, this._y));
                if (!(n >= this._radius)) {
                    var r = this.game.physics.box2d.raycast(this._x, this._y, e.x, e.y, !0, t.collisionFilter);
                    r && r.length > 0 && r[0].body !== e || o.onBulletHit(this._damage * (this._radius - n) / this._radius, this, this, !0)
                }
            }
        }
    }, t.prototype.update = function() {
        if (this.alive) {
            if (null === this.circleBody && this._damage) this.circleBody = new Phaser.Physics.Box2D.Body(this.game, null, 0, 0, 0), this.circleBody.sensor = !0, this.circleBody.kill(), this.circleFixture = this.circleBody.setCircle(1);
            else if (!this.damaged && this._damage) {
                var t = this.game.physics.box2d;
                this.circleBody.data.SetPositionXY(t.pxm(-this._x), t.pxm(-this._y)), this.circleFixture.GetShape().m_radius = this._radius;
                for (var e = t.queryFixture(this.circleFixture), i = 0; i < e.length; i++) this.damageObject(e[i].body);
                this.damaged = !0
            }
            this.time += this.game.time.physicsElapsed;
            var o = this.circleStartScale + (this.circleEndScale - this.circleStartScale) * Math.min(1, this.time / .333333);
            this.circle.scale.set(o, o), this.circle.alpha = 1 - Math.min(1, this.time / .333333), this.time >= .4 && this.kill()
        }
    }, e.prototype = Object.create(Phaser.Group.prototype), e.prototype.createExplosion = function() {
        var e = new t(this.game);
        return this.add(e), e
    }, e.prototype.getExplosion = function() {
        for (var t = 0; t < this.children.length; t++)
            if (!this.children[t].alive) return this.children[t];
        return this.createExplosion()
    }, e.prototype.explode = function(t, e, i, o, n) {
        var r = this.getExplosion();
        return r.explode(t, e, i, o, n), s.playSound("explosion.mp3", 1.25), r
    }, e.prototype.doubleExplode = function(t, e, i, n, r, a) {
        var h = this.getExplosion();
        return h.explode(t, e, i, n, o.CPU), h.silentExplode(t, e, r, a, o.PLAYER), s.playSound("explosion.mp3", 1.25), h
    }, e.prototype.wave = function(t, e, i) {
        var o = this.getExplosion();
        return o.wave(t, e, i), o
    }, window.AT.explosions = {
        Explosion: t,
        ExplosionManager: e
    }
}(),
function() {
    "use strict";

    function t(t, e, i, o) {
        Phaser.Sprite.call(this, t, e, i, "game.png", o), this.player = t.state.getCurrentState().player, this.anchor.set(.5, .5), this.lifespan = 9833 + 833 * Math.random(), this.attracted = !1, this.velocity = new Phaser.Point(0, 0)
    }

    function e(i, o, s) {
        t.call(this, i, o, s, e.FRAME_NAME)
    }

    function i(e, o, s) {
        t.call(this, e, o, s, i.FRAME_NAME)
    }

    function o(e, i, s) {
        t.call(this, e, i, s, o.FRAME_NAME);
        var n = 1.2 + .7 * Math.random();
        this.scale.set(n, n), this.rotation = Math.random() * Math.PI * 2, this.velocity.x = 300 * (2 * Math.random() - 1), this.velocity.y = 300 * (2 * Math.random() - 1)
    }

    function s(e, i) {
        function o(o, s, n) {
            t.call(this, o, s, n, i), this.ammo = e
        }
        return o.FRAME_NAME = i, o.prototype = Object.create(t.prototype), o.prototype.constructor = o, o
    }

    function n(t, e, i) {
        Phaser.Sprite.call(this, t, e, i, "game.png", n.FRAME_NAME), this.anchor.set(.5, .5), this.lifespan = 1e3, this.fire = t.make.image(9, -13, "game.png", "game/bonuses/bomb_fire.png"), this.fire.anchor.set(.5, .5), this.addChild(this.fire), l.playSound("bomb.mp3", .75)
    }

    function r() {
        if (!_) {
            var t = window.AT.tanks.MinigunTank,
                e = window.AT.tanks.ShotgunTank,
                i = window.AT.tanks.CannonTank,
                o = window.AT.tanks.RocketsTank,
                s = window.AT.tanks.LaserTank,
                n = window.AT.tanks.RicochetTank,
                r = window.AT.tanks.RailgunTank,
                a = window.AT.tanks.KamikazeTank,
                h = window.AT.tanks.FlamethrowerTank;
            _ = {
                1: [t, e, n],
                3: [e, n, h],
                5: [n, h, i],
                7: [h, i, o],
                9: [i, o, a],
                11: [o, a, s],
                13: [a, s, r]
            }
        }
        return _
    }

    function a(t) {
        var e, i = t.state.getCurrentState(),
            o = r();
        return e = i.number >= 13 ? o[13] : i.number >= 11 ? o[11] : i.number >= 9 ? o[9] : i.number >= 7 ? o[7] : i.number >= 5 ? o[5] : i.number >= 3 ? o[3] : o[1], e[h(x)]
    }
    var h = (window.AT.common.COLLISION_GROUPS, window.AT.common.weightedChoice),
        l = window.AT.audio;
    t.prototype = Object.create(Phaser.Sprite.prototype), t.prototype.constructor = t, t.prototype.onPlayerHit = function() {
        this.player.onBonusHit(this), this.kill()
    }, t.prototype.kill = function() {
        this.parent.removeChild(this), Phaser.Sprite.prototype.kill.call(this)
    }, t.prototype.update = function() {
        if (this.lifespan >= 0 && this.lifespan <= 333 && (this.alpha = this.lifespan / 333), this.player.alive) {
            var t = this.position.x - this.player.position.x,
                e = this.position.y - this.player.position.y,
                i = t * t + e * e,
                o = 0 === this.player.level.enemiesAlive ? 4e6 : 3600;
            i < 900 ? this.onPlayerHit() : i < o && i > 0 ? (i = Math.sqrt(i), this.velocity.x = -t / i * 300, this.velocity.y = -e / i * 300, this.attracted = !0) : this.attracted && (this.velocity.x = this.velocity.y = 0)
        }
        var s = this.game.time.physicsElapsed;
        this.position.x += this.velocity.x * s, this.position.y += this.velocity.y * s
    }, e.FRAME_NAME = "game/bonuses/health.png", e.prototype = Object.create(t.prototype), e.prototype.constructor = e, i.FRAME_NAME = "game/bonuses/freeze.png", i.prototype = Object.create(t.prototype), i.prototype.constructor = i, i.prototype.onPlayerHit = function() {
        t.prototype.onPlayerHit.call(this);
        var e = this.game.state.getCurrentState();
        e.spawnIce(this.position.x, this.position.y), e.shakeCamera(6), e.freezeEnemies()
    }, o.FRAME_NAME = "game/bonuses/coin.png", o.prototype = Object.create(t.prototype), o.prototype.constructor = o, o.prototype.update = function() {
        t.prototype.update.call(this), this.velocity.x *= .75, this.velocity.y *= .75
    };
    var d = s(31, "game/bonuses/ammo_shotgun.png"),
        c = s(10, "game/bonuses/ammo_ricochet.png"),
        p = s(31, "game/bonuses/ammo_cannon.png"),
        u = s(9, "game/bonuses/ammo_rockets.png"),
        b = s(300, "game/bonuses/ammo_laser.png"),
        m = s(50, "game/bonuses/ammo_flamethrower.png"),
        y = s(18, "game/bonuses/ammo_mines.png"),
        f = s(300, "game/bonuses/ammo_laser.png"),
        g = s(31, "game/bonuses/ammo_railgun.png");
    n.FRAME_NAME = "game/bonuses/bomb.png", n.prototype = Object.create(t.prototype), n.prototype.constructor = n, n.prototype.kill = function() {
        this.game.state.getCurrentState().explosions.explode(this.position.x, this.position.y, 200, 150, 200, 150), this.parent.removeChild(this), Phaser.Sprite.prototype.kill.call(this)
    }, n.prototype.update = function() {
        this.fire.rotation = Math.random() * Math.PI * 2, this.fire.alpha = .5 + .5 * Math.random(), this.fire.scale.x = .5 + Math.random(), this.fire.scale.y = .5 + Math.random()
    };
    var x = [1, 1, 1],
        _ = null;
    window.AT.bonus = {
        Bonus: t,
        Health: e,
        Freeze: i,
        Coin: o,
        ShotgunAmmo: d,
        RicochetAmmo: c,
        CannonAmmo: p,
        RocketsAmmo: u,
        LaserAmmo: b,
        FlamethrowerAmmo: m,
        RailgunAmmo: g,
        MinesAmmo: y,
        ShockAmmo: f,
        Bomb: n,
        SmallEnemy: a
    }
}(),
function() {
    "use strict";

    function t(t, i, o) {
        Phaser.Image.call(this, t.game, 0, 0, "game.png", e[0]), this.anchor.set(.5, .5), this.step = 0, this.time = null != o ? o : (85 + 30 * Math.random()) / 60, this.spreadTimer = .9 + .2 * Math.random(), this.hitColor = 16755200, this.damage = i, t.addChild(this)
    }
    var e = ["game/fire_0.png", "game/fire_1.png", "game/fire_2.png", "game/fire_3.png"];
    t.prototype = Object.create(Phaser.Image.prototype), t.prototype.spread = function() {
        var t = window.AT.Wood,
            e = this.game.state.getCurrentState(),
            i = e.pxToTile(this.parent.position.x),
            o = e.pxToTile(this.parent.position.y),
            s = e.getObject(i - 1, o),
            n = e.getObject(i + 1, o),
            r = e.getObject(i, o - 1),
            a = e.getObject(i, o + 1);
        s && s instanceof t && s.onBulletHit(1, this, this, !0), n && n instanceof t && n.onBulletHit(1, this, this, !0), r && r instanceof t && r.onBulletHit(1, this, this, !0), a && a instanceof t && a.onBulletHit(1, this, this, !0)
    }, t.prototype.update = function() {
        if (this.time -= this.game.time.physicsElapsed, this.parent) {
            if (this.time <= 0) return void this.parent.removeChild(this);
            this.parent.onBulletHit(this.damage, this, this, !0)
        }
        0 === this.step ? (this.alpha = (.5 + .5 * Math.random()) * Math.min(1, this.time / .2), this.rotation = Math.random() * Math.PI * 2, this.anchor.set(.45 + .1 * Math.random(), .45 + .1 * Math.random()), this.loadTexture("game.png", e[Math.floor(Math.random() * e.length)]), this.step = 1) : this.step -= 1, this.spreadTimer -= this.game.time.physicsElapsed, this.spreadTimer <= 0 && (this.spread(), this.spreadTimer = 1)
    }, window.AT.Fire = t
}(),
function() {
    "use strict";

    function t(t, i, s, n) {
        Phaser.Sprite.call(this, t, i, s, "game.png", n), this.level = t.state.getCurrentState(), this.tileX = this.level.pxToTile(i), this.tileY = this.level.pxToTile(s), this.name = "obstacle", this.anchor.set(.5, .5), t.physics.box2d.enableBody(this), this.body.static = !0, this.body.setCollisionCategory(e.OBSTACLE), this.body.setCollisionMask(e.PLAYER | e.PROJECTILE | e.ENEMY), this.hit = 0, this.hitColor = 0, this.killDelay = 2 / 60, this.fire = null, this.lifebar = new o(this, 0, 60)
    }
    var e = window.AT.common.COLLISION_GROUPS,
        i = window.AT.common.calculateHitColor,
        o = window.AT.Lifebar,
        s = window.AT.explosions.Explosion;
    t.prototype = Object.create(Phaser.Sprite.prototype), t.prototype.kill = function() {
        var t = this.game.state.getCurrentState();
        t.spawnSmoke(this.body.x, this.body.y, 3), t.removeObjectAtPosition(this.body.x, this.body.y), this.body.kill(), this.body.world.removeBody(this.body), this.parent && this.parent.removeChild(this), Phaser.Sprite.prototype.kill.call(this)
    }, t.prototype.setHealth = function(t) {
        this.lifebar.lastHealth = this.health = this.maxHealth = t
    }, t.prototype.onBulletHit = function(t, e, i, o) {
        o && (e instanceof s ? this.health -= t / 3 : (this.health -= t, this.game.state.getCurrentState().revealFogAtLocation(this.body)), this.lifebar.show()), this.hit = 1, this.hitColor = e.hitColor
    }, t.prototype.update = function() {
        this.health <= 0 ? (this.killDelay -= this.game.time.physicsElapsed, this.hit = 1, this.killDelay <= 0 && this.parent && this.kill()) : this.hit > 0 && (this.hit = Math.max(0, this.hit - this.game.time.physicsElapsed / .2), this.tint = i(this.hitColor, this.hit)), this.fire && (this.fire.update(), this.fire.time <= 0 && (this.fire = null)), this.visible = this.level.isTileVisible(this.position.x, this.position.y, this.tileX, this.tileY)
    }, window.AT.Obstacle = t
}(),
function() {
    "use strict";

    function t(t, e, i, s) {
        o.call(this, t, e, i, s ? "game/bricks_1.png" : "game/bricks_0.png"), this.name = "bricks";
        var n = t.state.getCurrentState();
        this.setHealth(s ? 75 + 30 * n.number : 25 + 10 * n.number)
    }
    var e = window.AT.profile,
        i = window.AT.audio,
        o = window.AT.Obstacle;
    t.prototype = Object.create(o.prototype), t.prototype.onBulletHit = function(t, e, i, s) {
        e instanceof window.AT.weapon.Flamethrower && (t = 1), o.prototype.onBulletHit.call(this, t, e, i, s)
    }, t.prototype.kill = function() {
        var t = this.game.state.getCurrentState();
        t.shakeCamera(4), t.explosionEmitter.emitParticle(this.body.x, this.body.y), e.current.stats.wallsDestroyed += 1, e.increaseAchievement("destroyer") && t.achievements.show("destroyer"), o.prototype.kill.call(this), i.playSound("bricks.mp3")
    }, window.AT.Bricks = t
}(),
function() {
    "use strict";

    function t(t, e, i, s) {
        o.call(this, t, e, i, "game/wood.png");
        var n = t.state.getCurrentState();
        this.setHealth(25 + 10 * n.number), this.fire = null
    }
    var e = window.AT.profile,
        i = window.AT.audio,
        o = window.AT.Obstacle,
        s = window.AT.Fire;
    t.prototype = Object.create(o.prototype), t.prototype.onBulletHit = function(t, e, i, n) {
        n && !this.fire && (e instanceof window.AT.weapon.Flamethrower || e instanceof s) && (this.fire = new s(this, .25 * t)), o.prototype.onBulletHit.call(this, t, e, i, n)
    }, t.prototype.kill = function() {
        var t = this.game.state.getCurrentState();
        t.shakeCamera(4), t.explosionEmitter.emitParticle(this.body.x, this.body.y), e.current.stats.wallsDestroyed += 1, e.increaseAchievement("destroyer") && t.achievements.show("destroyer"), o.prototype.kill.call(this), i.playSound("bricks.mp3")
    }, window.AT.Wood = t
}(),
function() {
    "use strict";

    function t(t, e, i, s) {
        o.call(this, t, e, i, "game/secret.png");
        var n = t.state.getCurrentState();
        this.setHealth(25 + 10 * n.number)
    }
    var e = window.AT.profile,
        i = window.AT.audio,
        o = window.AT.Obstacle;
    t.prototype = Object.create(o.prototype), t.prototype.kill = function() {
        var t = this.game.state.getCurrentState();
        t.shakeCamera(4), t.explosionEmitter.emitParticle(this.body.x, this.body.y), e.current.stats.wallsDestroyed += 1, e.increaseAchievement("destroyer") && t.achievements.show("destroyer"), o.prototype.kill.call(this), i.playSound("bricks.mp3")
    }, window.AT.Secret = t
}(),
function() {
    "use strict";

    function t(t, e, i) {
        o.call(this, t, e, i, "game/gate.png"), this.name = "gate";
        var s = t.state.getCurrentState();
        this.setHealth(25 + 10 * s.number), this.gateLeft = null, this.gateRight = null, this.gateUp = null, this.gateDown = null
    }
    var e = window.AT.profile,
        i = window.AT.audio,
        o = window.AT.Obstacle;
    t.prototype = Object.create(o.prototype), t.prototype.kill = function() {
        var t = this.gateLeft;
        t && (this.gateLeft = t.gateRight = null, t.kill());
        var s = this.gateRight;
        s && (this.gateRight = s.gateLeft = null, s.kill());
        var n = this.gateUp;
        n && (this.gateUp = n.gateDown = null, n.kill());
        var r = this.gateDown;
        r && (this.gateDown = r.gateUp = null, r.kill());
        var a = this.game.state.getCurrentState();
        a.shakeCamera(4), a.explosionEmitter.emitParticle(this.body.x, this.body.y), e.increaseAchievement("destroyer") && a.achievements.show("destroyer"), o.prototype.kill.call(this), i.playSound("bricks.mp3")
    }, window.AT.Gate = t
}(),
function() {
    "use strict";

    function t(t, e, o) {
        i.call(this, t, e, o, "game/barrel.png"), this.name = "barrel", this.body.setCircle(18), this.body.rotation = Math.PI * Math.random() * 2, this.body.setCollisionCategory(16), this.setHealth(25 + 4 * this.level.index), this.killDelay = 8 / 60, this.conductsCurrent = !0
    }
    var e = window.AT.profile,
        i = window.AT.Obstacle,
        o = window.AT.explosions.Explosion,
        s = window.AT.Fire;
    t.prototype = Object.create(i.prototype), t.prototype.onBulletHit = function(t, e, i, n) {
        n && (!this.fire && (e instanceof window.AT.weapon.Flamethrower || e instanceof s) && (this.fire = new s(this, 1)), this.health -= t, e instanceof o || this.game.state.getCurrentState().revealFogAtLocation(this.body), this.lifebar.show()), this.hit = 1, this.hitColor = e.hitColor
    }, t.prototype.kill = function() {
        var t = this.game.state.getCurrentState();
        t.spawnHole(this.body.x, this.body.y), t.explosions.explode(this.body.x, this.body.y, 150, 100 + 15 * t.number), t.shakeCamera(4), e.current.stats.barrelsExploded += 1, i.prototype.kill.call(this)
    }, window.AT.Barrel = t
}(),
function() {
    "use strict";

    function t(t, i, o, s) {
        n.call(this, t, i, o, "game/crate.png"), this.name = "crate", this.body.setCollisionCategory(e.ENEMY), this.setHealth(20 + 8 * this.level.index)
    }
    var e = window.AT.common.COLLISION_GROUPS,
        i = window.AT.common.weightedChoice,
        o = window.AT.profile,
        s = window.AT.audio,
        n = window.AT.Obstacle,
        r = window.AT.bonus.Health,
        a = window.AT.bonus.Freeze,
        h = window.AT.bonus.Coin,
        l = window.AT.bonus.ShotgunAmmo,
        d = window.AT.bonus.RicochetAmmo,
        c = window.AT.bonus.FlamethrowerAmmo,
        p = window.AT.bonus.CannonAmmo,
        u = window.AT.bonus.MinesAmmo,
        b = window.AT.bonus.ShockAmmo,
        m = window.AT.bonus.RailgunAmmo,
        y = window.AT.bonus.RocketsAmmo,
        f = window.AT.bonus.LaserAmmo,
        g = window.AT.bonus.Bomb,
        x = window.AT.bonus.SmallEnemy,
        _ = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .1, 1],
        v = [];
    v[0] = r, v[1] = a, v[2] = h, v[3] = l, v[4] = d, v[5] = c, v[6] = p, v[7] = b, v[8] = y, v[9] = f, v[10] = m, v[11] = u, v[12] = g, v[13] = x, t.prototype = Object.create(n.prototype), t.prototype.ammoWeightFor = function(t) {
        return t && t.ammo !== 1 / 0 ? 2 * (1 - t.ammo / t.maxAmmo) : 0
    }, t.prototype.getRandomBonus = function() {
        var t = this.game.state.getCurrentState(),
            e = t.player;
        if (!t.enemiesAlive) return h;
        if (e.health / e.maxHealth < .25) return r;
        var o = e.health / e.maxHealth;
        return _[0] = o < .75 ? 2 * (1 - o) : 0, _[3] = this.ammoWeightFor(e.weapons[1]), _[4] = this.ammoWeightFor(e.weapons[2]), _[5] = this.ammoWeightFor(e.weapons[3]), _[6] = this.ammoWeightFor(e.weapons[4]), _[7] = this.ammoWeightFor(e.weapons[5]), _[8] = this.ammoWeightFor(e.weapons[6]), _[9] = this.ammoWeightFor(e.weapons[7]), _[10] = this.ammoWeightFor(e.weapons[8]), _[11] = this.ammoWeightFor(e.mines), _[12] = 1 === t.number ? 0 : .1, _[13] = .1, v[i(_)]
    }, t.prototype.onBulletHit = function(t, e, i, o) {
        o && s.playSound("crate_hit.mp3", .65), n.prototype.onBulletHit.call(this, t, e, i, o)
    }, t.prototype.kill = function() {
        for (var t = this.game.state.getCurrentState(), e = this.body.x, i = this.body.y, r = 0; r < 6; r++) {
            var a = 2 * Math.PI / 6 * r,
                h = Math.cos(a),
                l = Math.sin(a);
            t.boardEmitter.setXSpeed(h * (80 + 30 * Math.random()), h * (80 + 30 * Math.random())), t.boardEmitter.setYSpeed(l * (80 + 30 * Math.random()), l * (80 + 30 * Math.random())), t.boardEmitter.emitParticle(e + h * Math.random() * 8, i + l * Math.random() * 8)
        }
        t.explosionEmitter.emitParticle(this.body.x, this.body.y), t.shakeCamera(4), t.spawnBonus(this.getRandomBonus(), this.body.x, this.body.y, 15), o.current.stats.cratesDestroyed += 1, o.increaseAchievement("treasurer") && t.achievements.show("treasurer"), s.playSound("crate_kill.mp3", 1.25), n.prototype.kill.call(this)
    }, window.AT.Crate = t
}(),
function() {
    "use strict";

    function t(t) {
        if (t in o) return o[t];
        throw new Error("Unknown tile: " + t)
    }

    function e(e) {
        for (var o = e[0].length + 2, s = e.length + 2, n = new Array(s), r = 0; r < e.length; r++) n[r + 1] = i.WALL + e[r].map(t).join("") + i.WALL;
        return n[0] = n[r + 1] = i.WALL.repeat(o), n
    }
    var i = {
            EMPTY: " ",
            WALL: "█",
            SECRET: "▓",
            BRICKS_2: "▒",
            BRICKS_1: "░",
            GATE: "◘",
            WOOD: "#",
            PLAYER: "☻",
            BARREL: "○",
            CRATE: "□",
            SPAWNER_1: "1",
            SPAWNER_2: "2",
            SPAWNER_3: "3",
            SPAWNER_4: "4",
            SPAWNER_5: "5",
            SPAWNER_6: "6",
            SPAWNER_7: "7",
            TURRET_MINIGUN: "m",
            TURRET_SHOTGUN: "s",
            TURRET_CANNON: "c",
            TURRET_ROCKETS: "r",
            TURRET_LASER: "l",
            TURRET_FLAMETHROWER: "f",
            TURRET_RAILGUN: "x",
            TURRET_RICOCHET: "t",
            BOSS_SHOTGUN: "S",
            BOSS_CANNON: "C",
            BOSS_ROCKETS: "R",
            BOSS_LASER: "L",
            BOSS_RICOCHET: "T",
            BOSS_FLAMETHROWER: "F",
            BOSS_RAILGUN: "X",
            TANK_MINIGUN: "❶",
            TANK_SHOTGUN: "❷",
            TANK_CANNON: "❸",
            TANK_ROCKETS: "❹",
            TANK_LASER: "❺",
            TANK_RICOCHET: "❻",
            TANK_FLAMETHROWER: "❼",
            TANK_RAILGUN: "❽",
            TANK_KAMIKAZE: "❾"
        },
        o = {
            1: i.EMPTY,
            2: i.BRICKS_1,
            3: i.BRICKS_2,
            4: i.WALL,
            5: i.CRATE,
            6: i.PLAYER,
            7: i.GATE,
            8: i.BARREL,
            9: i.SPAWNER_1,
            10: i.SPAWNER_2,
            11: i.SPAWNER_3,
            12: i.SPAWNER_4,
            13: i.SPAWNER_5,
            14: i.SPAWNER_6,
            15: i.SPAWNER_7,
            16: i.TURRET_MINIGUN,
            17: i.TURRET_SHOTGUN,
            18: i.TURRET_CANNON,
            19: i.TURRET_ROCKETS,
            20: i.TURRET_LASER,
            21: i.TURRET_FLAMETHROWER,
            22: i.TURRET_RAILGUN,
            23: i.TURRET_RICOCHET,
            24: i.BOSS_SHOTGUN,
            25: i.BOSS_CANNON,
            26: i.BOSS_ROCKETS,
            27: i.BOSS_LASER,
            28: i.BOSS_RICOCHET,
            29: i.BOSS_FLAMETHROWER,
            30: i.BOSS_RAILGUN,
            31: i.WOOD,
            32: i.SECRET
        };
    window.AT.LEVELS = [
        ["Level 1", "grass", "███████████", "█    □    █", "█ ##   ░░ █", "█ #     ░ █", "█         █", "█    1    █", "█      ○  █", "█ #     ░ █", "█ #○   ░░ █", "█         █", "█         █", "███     ███", "███     ███", "███     ███", "██□     □██", "██       ██", "██   ☻   ██", "███████████"],
        ["Level 2", "snow", "█████████████████", "███████   ███████", "███████ ☻ ███████", "█   ███   ███   █", "█ # ███   ███ □ █", "█   █○     ○█   █", "█1○ ◘       ◘ ○S█", "█   ◘       ◘   █", "█ # █       █ ░ █", "█   ███◘◘◘███   █", "█   █       █   █", "█##██ □   □ ██░░█", "█  ██       ██  █", "█  ████###████  █", "█               █", "█□  ○   ○   ○   █", "█████████████████"],
        ["Level 3", "desert", "█████████████████", "█               █", "█    # ○▒○ #    █", "█  1 #  ▒  # 2  █", "█     ○ □ ○     █", "█               █", "█◘◘◘███   ███◘◘◘█", "█    □█◘◘◘█□    █", "█     █   █     █", "████  █   █  ████", "████         ████", "████    ☻    ████", "████         ████", "█████████████████"],
        ["Level 4", "grass", "████████████████████", "█████□         █████", "█████    ░ ░ 1 █████", "█████          █████", "█████     ○        █", "█████    ███ ## ## █", "█████    ███     # █", "█   ◘    ███  ▒▒C  █", "█ ☻ ◘    ███       █", "█   ◘    ███ ░░ ░░ █", "█████    ███     ░ █", "█████    ███  ▒▒   █", "█████     ○       □█", "█████          █████", "█████    # # 2 █████", "█████□         █████", "████████████████████"],
        ["Level 5", "snow", "██████████████", "█    ◘     ███", "█    ◘     █□█", "█  2 ◘ ### ▓ █", "█ ░░○◘  #3 █□█", "█    █     ███", "█    █████████", "█   □████   ██", "█◘◘◘█████ ☻ ██", "█   █████   ██", "█     ○     ██", "█ #   m   ░ ██", "█   □       ██", "██████████████"],
        ["Level 6", "desert", "██████████████████████████", "███████       ◘    ███████", "█        □    ◘          █", "█      ○   ○  ◘    ##░ ▒ █", "█    █   ░    ███    ░   █", "█ ☻  █  ░░░ 3 ███s 3   ▒R█", "█    █   ░    ███    ░   █", "█      ○   ○  ◘ □  ##░ ▒ █", "█        □    ◘          █", "███████       ◘    ███████", "██████████████████████████"],
        ["Level 7", "grass", "██████████████████", "█        ◘       █", "█ 3 ██ 3 ◘ 4   □ █", "█        ◘       █", "█ ##○ ## ◘    ○  █", "█        #       █", "█ ##  ░░ #  c    █", "█        # ███ ○ █", "█ □# ○#□ # █     █", "█        #    #  █", "█ ░░  ░░ # □ ##  █", "█        #       █", "█ ##○    #       █", "█           ██████", "██████      ██████", "██████      ██████", "████████◘◘◘███████", "████████   ███████", "████████ ☻ ███████", "██████████████████"],
        ["Level 8", "snow", "█████████████████████", "█████████     ███████", "█████████  ☻  ███████", "█████████     ███████", "███    ██◘◘◘◘◘██    █", "███ 4  █       █  3 █", "███    ◘       ◘    █", "███ ▒▒ ◘  ░░   ◘ ░░ █", "███    █○ ░  ○ █    █", "███ #  █     ░ █  ░ █", "███    ◘   ░   ◘    █", "███  # ◘  □░   ◘ ░  █", "███    █    ## █    █", "█□█ ▒▒ █  #### █ ## █", "█ ▓    ◘  r#   ◘    █", "█□█ □  ◘  ## ○ ◘  4 █", "███    █       █    █", "████████◘◘███◘◘██████", "██████           ████", "██████ # ○ # ○ ▒ ████", "██████           ████", "██████L  # ○ ▒  □████", "█████████████████████"],
        ["Level 9", "desert", "█████████████████████", "█░░       3     ░  ○█", "█    ##             █", "█  ████  ▒▒▒  ████  █", "█  ████      □████# █", "█  ██████   ██████# █", "█  ██████   ██████  █", "█   ○████◘◘◘████    █", "█    ███□    ███    █", "█  # ███     ███ ▒  █", "█5 #   ◘     ◘ ○ ▒  █", "█  #   ◘  ☻  ◘   ▒ 4█", "█  # ███     ███ ▒  █", "█    ███    ○███    █", "█  □ ████◘◘◘████    █", "█  ██████   ██████ ░█", "█░ ██████   ██████ ░█", "█░ ████       ████  █", "█  ████  ▒l▒  ████  █", "█  ○           ##   █", "█         4        □█", "█████████████████████"],
        ["Level 10", "grass", "███████████████████", "█      ◘ T ◘      █", "█ 5 ▒▒ ◘   ◘ ## 4 █", "█    ▒ ◘◘◘◘◘ #    █", "█ ##           ▒▒ █", "█  # ○       ○ ▒  █", "█        □        █", "█□                █", "████◘◘██◘◘◘██◘◘████", "█                 █", "█ 5 ░   ○l##  ░ 5 █", "█      ░░  # ░░   █", "█ ○ ░░ ░          █", "█ # □░    ░░   f  █", "█       # ░□  ##███", "█     ###       █□█", "█  ░        ░   ▓ █", "█ ░░        ░░  █□█", "████◘◘◘◘███████████", "████        ███████", "████      ☻ ███████", "████        ███████", "███████████████████"],
        ["Level 11", "snow", "███████████████████", "█   █□ ◘    □█    █", "█      ◘     █  6 █", "█ ☻    ◘ ○   █    █", "█      ▒     ◘  # █", "█   █  ▒###  ◘  # █", "█████  ▒     █    █", "█□ ██  ▒○    █    █", "█□  ▓f     5 █░░  █", "█████        █○   █", "███████◘◘█████    █", "█████        ░  ##█", "█████ ▒▒▒    x  □ █", "█████ ▒f▒ ○  ░    █", "█████           ░ █", "█████             █", "█████ 5 ○##  ░  6 █", "█████        ░○   █", "███████████████████"],
        ["Level 12", "desert", "███████████████████████", "█       █     █   □   █", "█ 6   ░ █  ☻  █     5 █", "█     ░ █     █       █", "█   ▒ ░ █◘◘█◘◘█ ▒▒ #  █", "█   ▒   #     ▒    ## █", "█       #     ▒       █", "█ ## ▒  #   ▒ ▒ ○     █", "█    ○          #  ░░ █", "█         ░         ░ █", "█    ▒▒ ▒     #  #    █", "█    □      ░         █", "█◘◘██████ ◘◘◘ ██████◘◘█", "█  ██████◘◘x◘◘██████  █", "█  ██████ ◘◘◘ ██████  █", "█◘◘██████     ██████◘◘█", "█                     █", "█ 5  ##       ####  6 █", "█    f#        #○#    █", "█ ░░    ░             █", "█    ░         ░t  ○  █", "█ □░    ○░◘◘◘░        █", "█      ░░░   ░░░  ##  █", "█      ░□  F  □░      █", "███████████████████████"],
        ["Level 13", "grass", "█████████████████████████", "███████████████      ████", "███████████           ███", "███████□         #○#   ██", "████      ░  6          █", "███       ○         7   █", "███  f    ░░░░  x       █", "███                    □█", "██  ○░ ████████   ○░░░  █", "██     █□     █      ░  █", "██     █    ☻ █#       ██", "█      █      █#○  5   ██", "█  5 # █      █##      ██", "█    # █      █       ███", "█   ## █◘◘◘████       ███", "██     ░         t ░  ███", "███  ○ ▒   ░░  ○   ░ ████", "███   ▒▒ ░     #  ░░ ████", "███   l▒ ░░  6 #     ████", "████   ▒ □░         █████", "████     ○░        ██████", "█████           ██▓█□████", "████████    █████□   ████", "█████████████████████████"],
        ["Level 14", "snow", "█████████████████████████", "█                ▒□█    █", "█ 6     ○   ###  ▒▒█  ☻ █", "█       ▒          █    █", "█ ▒▒████████████  x█◘◘◘◘█", "█   █  ▒f     ○█   █□   █", "█   █  ▒       █   █    █", "█   █          █○  █    █", "█ ▒□█ # ████  □█○  █ ○▒ █", "█ ▒▒█ ##█X █ ##█▒  █    █", "█   █  □█  █  x█   █    █", "█▒  █   █  █   █   █ ## █", "█○  █   █◘◘█   █▒▒ █ 7  █", "█▒  █   █      █□▒ █ ▒  █", "█   █○▒ █      █   █ ▒  █", "█   █▒▒ █○□○ ○○█ ##█    █", "█   █   ████████   █    █", "█  #█     t▒□▒     █ # t█", "█  #█      ▒▒▒   7 █ #  █", "█  □█          ○   █    █", "█   ████████████████ ▒▒ █", "█      ○○            □▒ █", "█ 6  ▒      ▒▒   6      █", "█                  ○    █", "█████████████████████████"],
        ["Level 15", "desert", "█████████████████████████", "█  S             □   x  █", "█    □█        ###      █", "█  ████ m   ○           █", "█           █   C   ▒   █", "█     # █████     ○ ▒▒  █", "█   ○ # █□     ████     █", "█   ░     ▒▒▒▒ □     s  █", "█  R░                   █", "█   ██  ▒ ◘◘◘◘◘ #       █", "█   ██ f▒ ◘   ◘ # t ███ █", "█  □█   ▒ ◘ ☻ ◘ #   ○□  █", "█ ○██░░░▒ ◘   ◘ #       █", "█         ◘◘◘◘◘ #█      █", "█▒              #█  L   █", "█▒  T  ○███      █      █", "█▒        █  ○   ███○   █", "█       c   ████    □  ▒█", "█  ○███           l    ▒█", "█    □█ ▒▒  F       ░   █", "█                   ░   █", "█  r     █    ○  ████   █", "█    #   ██████     ○   █", "█#####                X █", "█████████████████████████"],
        ["Fog Test", "snow", "███████████████████", "█                 █", "█ ☻               █", "█                 █", "█                 █", "█                 █", "█                 █", "█                 █", "█                 █", "█                 █", "█                 █", "█                 █", "█                 █", "█                 █", "█                 █", "█                 █", "█                 █", "█                 █", "███████████████████"],
        ["Tanks: Minigun (yellow)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     ❶ █", "█                         █", "█                         █", "███████████████████████████"],
        ["Tanks: Shotgun (purple)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     ❷ █", "█                         █", "█                         █", "███████████████████████████"],
        ["Tanks: Cannon (green)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     ❸ █", "█                         █", "█                         █", "███████████████████████████"],
        ["Tanks: Flamethrower (green)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     ❼ █", "█                         █", "█                         █", "███████████████████████████"],
        ["Tanks: Rockets (red)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     ❹ █", "█                         █", "█                         █", "███████████████████████████"],
        ["Tanks: Laser (cyan)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     ❺ █", "█                         █", "█                         █", "███████████████████████████"],
        ["Tanks: Ricochet (blue)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     ❻ █", "█                         █", "█                         █", "███████████████████████████"],
        ["Tanks: Railgun (blue)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     ❽ █", "█                         █", "█                         █", "███████████████████████████"],
        ["Tanks: Kamikaze (orange)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     ❾ █", "█                         █", "█                         █", "███████████████████████████"],
        ["Turrets: Minigun (yellow)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     m █", "█                         █", "█                         █", "███████████████████████████"],
        ["Turrets: Shotgun (purple)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     s █", "█                         █", "█                         █", "███████████████████████████"],
        ["Turrets: Cannon (green)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     c █", "█                         █", "█                         █", "███████████████████████████"],
        ["Turrets: Flamethrower (green)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     f █", "█                         █", "█                         █", "███████████████████████████"],
        ["Turrets: Rockets (red)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     r █", "█                         █", "█                         █", "███████████████████████████"],
        ["Turrets: Laser (cyan)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     l █", "█                         █", "█                         █", "███████████████████████████"],
        ["Turrets: Ricochet (blue)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     t █", "█                         █", "█                         █", "███████████████████████████"],
        ["Turrets: Railgun (blue)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     x █", "█                         █", "█                         █", "███████████████████████████"],
        ["Bosses: Shotgun (purple)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     S █", "█                         █", "█                         █", "███████████████████████████"],
        ["Bosses: Cannon (green)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     C █", "█                         █", "█                         █", "███████████████████████████"],
        ["Bosses: Flamethrower (green)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     F █", "█                         █", "█                         █", "███████████████████████████"],
        ["Bosses: Rockets (red)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     R █", "█                         █", "█                         █", "███████████████████████████"],
        ["Bosses: Laser (cyan)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     L █", "█                         █", "█                         █", "███████████████████████████"],
        ["Bosses: Ricochet (blue)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     T █", "█                         █", "█                         █", "███████████████████████████"],
        ["Bosses: Railgun (blue)", "grass", "███████████████████████████", "█                         █", "█                         █", "█ ☻                     X █", "█                         █", "█                         █", "███████████████████████████"],
        ["Performance Test 1", "grass", "███████████████████", "█                 █", "█ ☻ ○ ○ ○ ○ ○ ○ ○ █", "█  □ □ □ □ □ □ □  █", "█ ○ ○ ○ ○ ○ ○ ○ ○ █", "█  □ □ □ □ □ □ □  █", "█ ○ ○ ○ ○ ○ ○ ○ ○ █", "█  □ □ □ □ □ □ □  █", "█ ○ ○ ○ ○ ○ ○ ○ ○ █", "█  □ □ □ □ □ □ □  █", "█ ○ ○ ○ ○ ○ ○ ○ ○ █", "█  □ □ □ □ □ □ □  █", "█ ○ ○ ○ ○ ○ ○ ○ ○ █", "█  □ □ □ □ □ □ □  █", "█ ○ ○ ○ ○ ○ ○ ○ ○ █", "█  □ □ □ □ □ □ □  █", "█ ○ ○ ○ ○ ○ ○ ○ ○ █", "█                 █", "███████████████████"],
        ["Performance Test 2", "grass", "███████████████████", "█                 █", "█ ☻ R S C R L S C █", "█  L S C R L S C  █", "█ S C R L S C R L █", "█  L S C R L S C  █", "█ S C R L S C R L █", "█  L S C R L S C  █", "█ S C R L S C R L █", "█  L S C R L S C  █", "█ S C R L S C R L █", "█  L S C R L S C  █", "█ S C R L S C R L █", "█  L S C R L S C  █", "█ S C R L S C R L █", "█  L S C R L S C  █", "█ S C R L S C R L █", "█                 █", "███████████████████"]
    ], window.AT.TILES = i, window.AT.convertLevel = e
}(),
function() {
    "use strict";

    function t(t, e) {
        Phaser.Group.call(this, t.game), this.spawnsChildren = !0, this.tank = t, this.team = e.team, this.id = e.id, this.ammo = "ammo" in e ? e.ammo : 1 / 0, this.maxAmmo = "maxAmmo" in e ? e.maxAmmo : this.ammo, this.damage = e.damage, this.rate = e.rate, this.life = e.life, this.spawnDistance = e.spawnDistance, this.spawnCount = e.spawnCount || 1, this.spread = 0, this.velocity = e.velocity, this.bulletFrameName = e.frameName, this.bulletClass = e.bulletClass || Phaser.Sprite, this.hitColor = 16777215, this.damage = e.damage, this.soundAlertRadius = e.soundAlertRadius || 0, this.onShot = e.onShot || function() {}, this.onOutOfAmmo = e.onOutOfAmmo || function() {}, this._fire = !1, this.fireDelay = 0
    }

    function e(e, i) {
        t.call(this, e, i), this.velocity = 690, this.bulletFrameName = "game/projectiles/minigun.png"
    }

    function i(e, i) {
        t.call(this, e, i), this.spread = Math.PI / 5, this.velocity = 0, this.bulletFrameName = "game/projectiles/shotgun.png"
    }

    function o(e, i) {
        t.call(this, e, i), this.spawnCount = 1, this.spread = 0, this.velocity = 480, this.bulletFrameName = i.frameName || "game/projectiles/plasma.png", this.rate = this.team === p.PLAYER ? 0 : i.rate, this.charge = 0
    }

    function s(e, i) {
        t.call(this, e, i), this.spawnCount = 1, this.spread = 0, this.velocity = 900, this.bulletFrameName = "game/projectiles/cannon.png"
    }

    function n(e, i) {
        t.call(this, e, i), this.spawnCount = 1, this.spread = 0, this.velocity = 60 * (i.velocity || .5), this.bulletFrameName = null, this.bulletClass = f, this.smokeTime = 0, this.fireDelay = i.team === p.PLAYER ? 1 / 0 : 0, this.radius = i.radius
    }

    function r(e, i) {
        t.call(this, e, i), this.raycast = b(r.prototype.raycast, 1), this.spawnCount = 1, this.spread = 0, this.velocity = 0, this.bulletFrameName = null, this.rate = 0, this.life = 1 / 0, this.bulletClass = window.AT.Laser, this.hitColor = 16711680, this.soundAlertRadius && (this._alert = b(this._alert, 14)), this.add(this.createBullet())
    }

    function a(e, i) {
        t.call(this, e, i), this.spawnCount = 1, this.spread = 0, this.velocity = 0, this.bulletFrameName = "game/projectiles/mine.png", this.smokeTime = 0, this.fireDelay = 1 / 0, this.radius = i.radius
    }

    function h(e, i) {
        t.call(this, e, i), this.raycast = h.prototype.raycast, this.spawnCount = 1, this.spread = 0, this.velocity = 0, this.bulletFrameName = "game/projectiles/railgun_0.png", this.life = .15, this.hitColor = 6605822
    }

    function l(e, i) {
        t.call(this, e, i), this.raycast = l.prototype.raycast, this.spawnCount = 1, this.spread = 0, this.velocity = 0, this.bulletFrameName = null, this.rate = 0, this.life = 1 / 0, this.bulletClass = window.AT.Shock, this.targets = []
    }

    function d(e, i) {
        t.call(this, e, i), this.velocity = 240, this.spread = .025 * Math.PI, this.bulletFrameName = "game/projectiles/flame_0.png", this.hitColor = 16755200
    }
    var c = window.AT.common.COLLISION_GROUPS,
        p = window.AT.common.TEAMS,
        u = window.AT.common.scale,
        b = window.AT.common.debounceCalls,
        m = window.AT.profile,
        y = window.AT.audio,
        f = window.AT.Rocket;
    t.prototype = Object.create(Phaser.Group.prototype), t.prototype.destroy = function() {
        this.stopFire(), Phaser.Group.prototype.destroy.call(this)
    }, t.prototype.activate = function() {}, t.prototype.deactivate = function() {
        this.stopFire()
    }, t.prototype.update = function() {
        Phaser.Group.prototype.update.call(this), this.fireDelay > 0 && (this.fireDelay -= this.game.time.physicsElapsed), this._fire && this.fireDelay <= 0 && (this.ammo > 0 && this.shoot(), this.rate && (this.fireDelay += 1 / this.rate));
        for (var t = 0; t < this.children.length; t++) !this.children[t].alive && this.children[t].body && this.children[t].body.kill()
    }, t.prototype.startFire = function() {
        this.ammo > 0 && (this._fire = !0)
    }, t.prototype.stopFire = function() {
        this._fire = !1
    }, t.prototype.shoot = function() {
        for (var t = this.tank.turretRotation, e = 0; e < this.spawnCount; e++) {
            var i = 1 === this.spawnCount ? .5 : e / (this.spawnCount - 1);
            this.spawnBullet(i, 1 === this.spawnCount ? t + Math.random() * this.spread - this.spread / 2 : t - this.spread / 2 + i * this.spread)
        }
        this.ammo -= 1, this.onShot(this), 0 === this.ammo && this.onOutOfAmmo(this)
    }, t.prototype.onBulletKilled = function(t) {
        t.lifespan <= 0 && t.body && (t.body.kill(), t.body.setZeroVelocity(), this.game.state.getCurrentState().disappearingEmitter.emitParticle(t.body.x, t.body.y))
    }, t.prototype.onBulletHitWall = function(t, e, i, o, s, n) {
        if (s && t.sprite.alive) {
            var r = this.game.state.getCurrentState();
            r.starEmitter.emitParticle(t.x, t.y, "game.png", "game/particles/star_object.png"), this.soundAlertRadius && r.alertSound(t.x, t.y, this.soundAlertRadius), t.sprite.kill(), t.setZeroVelocity()
        }
    }, t.prototype.onBulletHitObject = function(t, e, i, o, s, n) {
        e !== this.tank.body && (t.sprite.alive && e.sprite && e.sprite.onBulletHit && e.sprite.onBulletHit(this.damage, this, t, s), this.onBulletHitWall(t, e, i, o, s, n))
    }, t.prototype.newBullet = function() {
        return new this.bulletClass(this.game, 0, 0, "game.png", this.bulletFrameName)
    }, t.prototype.createBullet = function() {
        var t = this.newBullet();
        t.events.onKilled.add(this.onBulletKilled, this), this.game.physics.box2d.enableBody(t), t.body.setCircle(5), t.body.sensor = !0, t.body.friction = 0, t.body.setCollisionCategory(c.PROJECTILE), t.body.setCategoryContactCallback(c.WALL, this.onBulletHitWall, this), t.body.setCategoryContactCallback(c.OBSTACLE, this.onBulletHitObject, this);
        var e = c.WALL | c.OBSTACLE;
        return this.team === p.PLAYER ? (e += c.ENEMY + c.ENEMY_SPAWNER, t.body.setCategoryContactCallback(c.ENEMY_SPAWNER, this.onBulletHitObject, this), t.body.setCategoryContactCallback(c.ENEMY, this.onBulletHitObject, this)) : (e += c.PLAYER + c.ENEMY, t.body.setCategoryContactCallback(c.PLAYER, this.onBulletHitObject, this), t.body.setCategoryContactCallback(c.ENEMY, this.onBulletHitObject, this)), t.body.setCollisionMask(e), t
    }, t.prototype.getBullet = function() {
        for (var t = 0; t < this.children.length; t++)
            if (!this.children[t].alive) return this.children[t].reset(), this.children[t];
        var e = this.createBullet();
        return this.add(e), e
    }, t.prototype.spawnBullet = function(t, e) {
        var i = Math.cos(e),
            o = Math.sin(e),
            s = this.getBullet();
        return s.body.x = this.tank.body.x + i * this.spawnDistance, s.body.y = this.tank.body.y + o * this.spawnDistance, s.body.velocity.x = i * this.velocity, s.body.velocity.y = o * this.velocity, s.body.rotation = e, s.lifespan = 1e3 * this.life, s
    }, e.prototype = Object.create(t.prototype), e.prototype.spawnBullet = function(e, i) {
        var o = t.prototype.spawnBullet.call(this, e, i);
        this.game.state.getCurrentState().spawnSparks(o.body.x + 10 * Math.cos(i), o.body.y + 10 * Math.sin(i), i, .15 * Math.PI, 250, 2), this.tank.recoil = 3, y.playSound("minigun.mp3", .8)
    }, e.prototype.onBulletHitWall = function(e, i, o, s, n) {
        n && e.sprite.alive && (this.game.state.getCurrentState().spawnSparks(e.x, e.y, 0, 2 * Math.PI, 100, 1), y.playSound("bullet_hit.mp3")), t.prototype.onBulletHitWall.call(this, e, i, o, s, n)
    }, i.prototype = Object.create(t.prototype), i.prototype.shoot = function() {
        t.prototype.shoot.call(this);
        var e = this.tank.getTurretPosition(26),
            i = this.game.state.getCurrentState().smokeEmitter;
        i.setAlpha(1, .05, 333), i.lifespan = 333, i.emitParticle(e.x, e.y), this.tank.recoil = 5, y.playSound("shotgun.mp3")
    }, i.prototype.spawnBullet = function(e, i) {
        this.velocity = 60 * (6 + Math.floor(4 * Math.random())), t.prototype.spawnBullet.call(this, e, i)
    }, i.prototype.onBulletHitWall = function(e, i, o, s, n) {
        n && e.sprite.alive && (this.game.state.getCurrentState().spawnSparks(e.x, e.y, 0, 2 * Math.PI, 100, 1), y.playSound("bullet_hit.mp3")), t.prototype.onBulletHitWall.call(this, e, i, o, s, n)
    }, o.prototype = Object.create(t.prototype), o.prototype.skipCollision = function(t, e, i, o, s, n) {
        s.SetEnabled(!1)
    }, o.prototype.createBullet = function() {
        var e = t.prototype.createBullet.call(this);
        return this.team === p.PLAYER ? e.body.setCategoryPresolveCallback(c.ENEMY, this.skipCollision, this) : e.body.setCategoryPresolveCallback(c.PLAYER, this.skipCollision, this), e.body.data.SetUserData({
            hits: 0,
            damage: 0
        }), e
    }, o.prototype.spawnBullet = function(e, i) {
        var o = t.prototype.spawnBullet.call(this, e, i);
        o.body.sensor = !1, o.body.restitution = 1, o.body.fixedRotation = !0;
        var s = o.body.data.GetUserData();
        return s.hits = 4, s.damage = this.team === p.PLAYER ? Math.min(this.charge * this.damage, this.damage) : this.damage, o
    }, o.prototype.onBulletHitWall = function(t, e, i, o, s) {
        if (s) {
            var n = t.data.GetUserData();
            n.hits > 0 ? (n.hits -= 1, y.playSound("ricochet_bounce.mp3")) : t.sprite.kill();
            var r = this.game.state.getCurrentState();
            r.starEmitter.emitParticle(t.x, t.y, "game.png", "game/particles/star_object.png"), this.soundAlertRadius && r.alertSound(t.x, t.y, this.soundAlertRadius)
        }
    }, o.prototype.onBulletHitObject = function(t, e, i, o, s, n) {
        if (e !== this.tank.body)
            if (this.team === p.PLAYER) {
                if (s) {
                    var r = t.data.GetUserData();
                    e.sprite && e.sprite.onBulletHit && e.sprite.onBulletHit(r.damage, this, t, s), r.hits > 0 ? r.hits -= 1 : t.sprite.kill()
                }
            } else if (s) {
            t.sprite.alive && e.sprite && e.sprite.onBulletHit && e.sprite.onBulletHit(this.damage, this, t, s);
            var a = this.game.state.getCurrentState();
            a.starEmitter.emitParticle(t.x, t.y, "game.png", "game/particles/star_object.png"), this.soundAlertRadius && a.alertSound(t.x, t.y, this.soundAlertRadius), t.sprite.kill()
        }
    }, o.prototype.shoot = function() {
        if (this.team === p.PLAYER) {
            for (var e = this.tank.turretRotation, i = 0; i < this.spawnCount; i++) {
                var o = 1 === this.spawnCount ? .5 : i / (this.spawnCount - 1);
                this.spawnBullet(o, 1 === this.spawnCount ? e : e - this.spread / 2 + o * this.spread)
            }
            this.onShot(this), this.ammo <= 0 && this.onOutOfAmmo(this)
        } else t.prototype.shoot.call(this);
        this.tank.recoil = 5
    }, o.prototype.startFire = function() {
        this.team === p.PLAYER && (this._fire || (y.playSound("ricochet_start.mp3"), y.playRicochetLoop())), t.prototype.startFire.call(this)
    }, o.prototype.stopFire = function() {
        this.team === p.PLAYER ? this._fire && (this._fire = !1, this.shoot(), this.charge = Math.min(this.ammo, this.game.time.physicsElapsed), y.stopRicochetLoop(), y.playSound("ricochet_shot.mp3")) : t.prototype.stopFire.call(this)
    }, o.prototype.update = function() {
        if (this.team === p.PLAYER) {
            if (this._fire) {
                var e = Math.min(this.ammo, this.game.time.physicsElapsed);
                e > 0 && this.charge < 1 && (this.ammo -= e, this.charge += e)
            }
        } else t.prototype.update.call(this);
        for (var i = Math.random() < .5, o = 0; o < this.children.length; o++) {
            var s = this.children[o].body;
            s.sprite.alive ? (s.rotation = Math.atan2(s.velocity.y, s.velocity.x), i && this.game.state.getCurrentState().spawnSparks(s.x, s.y, 0, Math.PI * Math.random() * 2, 100 + 100 * Math.random(), 2)) : s.kill()
        }
    }, o.prototype.postUpdate = function() {
        if (t.prototype.postUpdate.call(this), this.team === p.PLAYER && this._fire) {
            var e = this.tank.getTurretPosition(29);
            this.game.state.getCurrentState().spawnSparks(e.x, e.y, Math.PI * Math.random() * 2, 0, 200, 1)
        }
    }, s.prototype = Object.create(t.prototype), s.prototype.spawnBullet = function(e, i) {
        var o = t.prototype.spawnBullet.call(this, e, i),
            s = this.tank.getTurretPosition(33),
            n = this.game.state.getCurrentState().smokeEmitter;
        n.setAlpha(1, .05, 333), n.lifespan = 333, n.emitParticle(s.x, s.y), this.game.state.getCurrentState().spawnSparks(o.body.x + 10 * Math.cos(i), o.body.y + 10 * Math.sin(i), i, .1 * Math.PI, 300, 3), this.tank.recoil = 5, y.playSound("cannon.mp3")
    }, s.prototype.onBulletHitObject = s.prototype.onBulletHitWall = function(t, e, i, o, s) {
        e !== this.tank.body && s && t.sprite.alive && (this.game.state.getCurrentState().explosions.explode(t.x, t.y, 75, this.damage, this.team), t.sprite.kill(), t.setZeroVelocity())
    }, s.prototype.onBulletKilled = function(t) {
        t.lifespan <= 0 && (this.game.state.getCurrentState().explosions.explode(t.body.x, t.body.y, 75, this.damage, this.team), t.body.kill(), t.body.setZeroVelocity())
    }, n.prototype = Object.create(t.prototype), n.prototype.startFire = function() {
        this.team === p.PLAYER && (this.tank.follow ? !this._fire && this.tank.follow.alive && this.tank.follow.kill() : !this._fire && this.ammo > 0 && this.shoot()), this._fire = !0
    }, n.prototype.deactivate = function() {
        this.stopFire(), this.tank.follow && this.tank.follow.alive && (this.tank.follow.requestKill = !0)
    }, n.prototype.explodeBullet = function(t) {
        t.body.setZeroVelocity(), this.game.state.getCurrentState().explosions.explode(t.body.x, t.body.y, this.radius, this.damage, this.team)
    }, n.prototype.onBulletKilled = function(t) {
        t === this.tank.follow && (this.tank.follow = null), this.explodeBullet(t)
    }, n.prototype.onBulletHitSomething = function(t, e, i, o, s) {
        if ((!e.sprite || e !== this.tank.body) && s && t.sprite.alive && (t.sprite.kill(), this.team === p.CPU)) {
            o.GetFilterData().categoryBits !== c.PLAYER && m.increaseAchievement("dodger") && this.game.state.getCurrentState().achievements.show("dodger")
        }
    }, n.prototype.onBulletHitWall = n.prototype.onBulletHitObject = n.prototype.onBulletHitSomething, n.prototype.newBullet = function() {
        return new f(this.game, 0, 0, this.team)
    }, n.prototype.spawnBullet = function(e, i) {
        var o = t.prototype.spawnBullet.call(this, e, i);
        return this.tank.follow = o, o.requestKill = !1, o.speed = 0, o.touch = !1, y.playSound("rocket.mp3"), o
    }, r.prototype = Object.create(t.prototype), r.collisionFilterPlayer = function(t, e, i, o) {
        return e.GetFilterData().categoryBits !== c.PROJECTILE
    }, r.collisionFilterCPU = function(t, e, i, o) {
        return !(t.sprite && t.sprite instanceof window.AT.Spawner) && e.GetFilterData().categoryBits !== c.PROJECTILE
    }, r.prototype.onBulletHitWall = function(t, e, i, o, s, n) {}, r.prototype.onBulletHitObject = function(t, e, i, o, s, n) {}, r.prototype.startFire = function() {
        this._fire || (y.playSound("laser_start.mp3"), y.playLaserLoop()), t.prototype.startFire.call(this)
    }, r.prototype.stopFire = function() {
        this._fire && y.stopLaserLoop(), t.prototype.stopFire.call(this)
    }, r.prototype.getBullet = function() {
        return this.children[0].alive || this.children[0].reset(), this.children[0]
    }, r.prototype.createBullet = function() {
        var t = new this.bulletClass(this.game, 0, 0);
        return t.kill(), t.events.onKilled.add(this.onBulletKilled, this), t
    }, r.prototype.spawnBullet = function(t, e) {
        var i = Math.cos(e),
            o = Math.sin(e),
            s = this.getBullet();
        return s.position.x = this.tank.body.x + i * this.spawnDistance, s.position.y = this.tank.body.y + o * this.spawnDistance, s.rotation = e, s.lifespan = 1e3 * this.life, this.onShot(this, s), s
    }, r.prototype.raycast = function() {
        var t = this.tank.turretRotation,
            e = Math.cos(t),
            i = Math.sin(t);
        return this.game.physics.box2d.raycast(this.tank.body.x, this.tank.body.y, this.tank.body.x + 1e4 * e, this.tank.body.y + 1e4 * i, !0, this.team === p.CPU ? r.collisionFilterCPU : r.collisionFilterPlayer)
    }, r.prototype._alert = function(t, e) {
        this.game.state.getCurrentState().alertSound(t, e, this.soundAlertRadius)
    }, r.prototype.postUpdate = function() {
        t.prototype.postUpdate.call(this);
        var e = this.children[0];
        if (e && e.alive && this._fire && this.ammo > 0) {
            var i = this.raycast();
            if (i) {
                var o = this.tank.turretRotation,
                    s = Math.cos(o),
                    n = Math.sin(o);
                e.show(this.tank.body.x + s * this.spawnDistance, this.tank.body.y + n * this.spawnDistance, i[0].point.x, i[0].point.y, o);
                var r = i[0].body;
                r.sprite && r.sprite.onBulletHit && r.sprite.onBulletHit(this.damage, this, null, !0), this.soundAlertRadius && this._alert(r.x, r.y)
            } else e.hide()
        } else e.alive && e.kill()
    }, a.prototype = Object.create(t.prototype), a.prototype.createBullet = function(e) {
        var e = t.prototype.createBullet.call(this);
        return e.body.setCircle(10), e.body.static = !0, e.body.sensor = !0, this.team === p.PLAYER && (e.body.setCollisionCategory(c.PROJECTILE), e.body.setCollisionMask(c.ENEMY), e.body.setCategoryContactCallback(c.ENEMY, this.onBulletHitObject, this)), e
    }, a.prototype.explodeBullet = function(t) {
        var e = this.game.state.getCurrentState();
        e.explosions.explode(t.body.x, t.body.y, this.radius, this.damage, this.team), e.spawnHole(t.body.x, t.body.y)
    }, a.prototype.onBulletKilled = function(t) {
        this.explodeBullet(t)
    }, a.prototype.onBulletHitObject = function(t, e, i, o, s) {
        if ((!e.sprite || e !== this.tank.body) && s && t.sprite.alive && (t.sprite.kill(), m.increaseAchievement("gotcha"))) {
            this.game.state.getCurrentState().achievements.show("gotcha")
        }
    }, a.prototype.onBulletHitWall = function() {}, a.prototype.spawnBullet = function(e, i) {
        var o = t.prototype.spawnBullet.call(this, e, i);
        return o.body.velocity.x = 0, o.body.velocity.y = 0, y.playSound("mine.mp3", .75), o
    }, h.prototype = Object.create(t.prototype), h.collisionFilterPlayer = function(t, e, i, o) {
        var s = e.GetFilterData().categoryBits;
        return s !== c.PROJECTILE && s !== c.BONUS
    }, h.collisionFilterCPU = function(t, e, i, o) {
        if (t.sprite && t.sprite instanceof window.AT.Spawner) return !1;
        var s = e.GetFilterData().categoryBits;
        return s !== c.PROJECTILE && s !== c.BONUS
    }, h.prototype.onBulletHitWall = function(t, e, i, o, s, n) {}, h.prototype.onBulletHitObject = function(t, e, i, o, s, n) {}, h.prototype.createBullet = function() {
        var t = this.newBullet();
        return t.anchor.set(0, .5), t
    }, h.prototype.spawnBullet = function(t, e) {
        var i = Math.cos(e),
            o = Math.sin(e),
            s = this.tank.body.x + i * this.spawnDistance,
            n = this.tank.body.y + o * this.spawnDistance,
            r = this.raycast(this.tank.body.x, this.tank.body.y, s + 1e4 * i, n + 1e4 * o);
        if (r.length > 0) {
            var a = this.getBullet();
            a.x = r.endX, a.y = r.endY, a.rotation = e + Math.PI, a.lifespan = 1e3 * this.life, a.scale.y = 2.5, a.width = Math.max(0, r.distance - this.spawnDistance);
            for (var h = 0, t = 0; t < r.length; t++) {
                var l = r[t].body;
                r[t].point && l.sprite && l.sprite.onBulletHit && (l.sprite.onBulletHit(this.damage, this, null, !0), this.soundAlertRadius && this.alert(r[t].point.x, r[t].point.y), l.sprite.team === p.CPU && (h += 1))
            }
            var d = this.game.state.getCurrentState();
            d.starEmitter.emitParticle(r.endX, r.endY, "game.png", "game/particles/star_object.png");
            var c = d.sparkEmitter;
            c.setXSpeed(-100, 100), c.setYSpeed(-100, 100);
            for (var t = 0; t < 10; t++) c.emitParticle(r.endX, r.endY, "game.png", "game/particles/spark_3.png");
            this.team === p.PLAYER && h >= 3 && m.increaseAchievement("nailed") && d.achievements.show("nailed"), this.tank.recoil = 5, y.playSound("railgun.mp3"), this.onShot(this, a)
        }
        return a
    }, h.prototype.raycast = function(t, e, i, o) {
        var s = this.game.physics.box2d.raycast(t, e, i, o, !1, this.team === p.CPU ? h.collisionFilterCPU : h.collisionFilterPlayer);
        s.distance = 1 / 0, s.distanceSq = 1 / 0, s.endX = 0, s.endY = 0;
        for (var n = 0; n < s.length; n++) {
            if (s[n].fixture.GetFilterData().categoryBits === c.WALL) {
                var r = Phaser.Math.distanceSq(t, e, s[n].point.x, s[n].point.y);
                r < s.distanceSq && (s.distanceSq = r, s.endX = s[n].point.x, s.endY = s[n].point.y)
            }
        }
        for (var n = 0; n < s.length; n++) {
            Phaser.Math.distanceSq(t, e, s[n].point.x, s[n].point.y) > s.distanceSq && (s[n].point = null)
        }
        return s.distance = Math.sqrt(s.distanceSq), s
    }, h.prototype.update = function() {
        t.prototype.update.call(this);
        var e = this.children[0];
        e && e.visible && e.scale.y > 0 && (e.scale.y = e.lifespan / (1e3 * this.life) * 2.5, Math.random() > .5 ? e.loadTexture("game.png", "game/projectiles/railgun_0.png") : e.loadTexture("game.png", "game/projectiles/railgun_1.png"))
    }, h.prototype.alert = function(t, e) {
        this.game.state.getCurrentState().alertSound(t, e, this.soundAlertRadius)
    }, l.prototype = Object.create(r.prototype), l.prototype.startFire = function() {
        this._fire || y.playShockLoop(), t.prototype.startFire.call(this)
    }, l.prototype.stopFire = function() {
        this._fire && y.stopShockLoop(), t.prototype.stopFire.call(this)
    }, l.prototype.getBullet = t.prototype.getBullet, l.prototype.createBullet = function() {
        return new this.bulletClass(this.game, 0, 0)
    }, l.prototype.spawnBullet = function(t, e) {
        var i = this.getBullet();
        return i.revive(), i.lifespan = 1e3 * this.life, this.onShot(this, i), i
    }, l.prototype.raycast = function(t, e, i, o) {
        return this.game.physics.box2d.raycast(t, e, i, o, !0, this.team === p.CPU ? r.collisionFilterCPU : r.collisionFilterPlayer)
    }, l.prototype.findClosestEnemy = function(t, e) {
        for (var i = this.game.state.getCurrentState(), o = 1 / 0, s = null, n = 0; n < i.enemies.length; n++) {
            var r = i.enemies[n];
            if (r.alive && -1 === this.targets.indexOf(r)) {
                var a = Phaser.Math.distanceSq(t, e, r.body.x, r.body.y);
                a < o && a < 4e4 && (o = a, s = r)
            }
        }
        for (var n = 0; n < i.barrels.length; n++) {
            var h = i.barrels[n];
            if (h.alive && -1 === this.targets.indexOf(h)) {
                var a = Phaser.Math.distanceSq(t, e, h.body.x, h.body.y);
                a < o && a < 4e4 && (o = a, s = h)
            }
        }
        if (s) {
            var l = this.raycast(t, e, s.body.x, s.body.y);
            return l && l[0] && l[0].body === s.body ? s : null
        }
        return null
    }, l.prototype.update = function() {
        t.prototype.update.call(this), this.hitColor = Math.random() < .5 ? 8322761 : 16777215
    }, l.prototype.postUpdate = function() {
        t.prototype.postUpdate.call(this);
        for (var e = 0; e < this.children.length; e++) this.children[e].alive && this.children[e].kill();
        if (this._fire && this.ammo > 0) {
            var i = this.tank.turretRotation,
                o = Math.cos(i),
                s = Math.sin(i),
                n = this.raycast(this.tank.body.x, this.tank.body.y, this.tank.body.x + 1e4 * o, this.tank.body.y + 1e4 * s);
            if (n) {
                var r = this.children[0];
                r ? r.alive || r.revive() : r = this.spawnBullet(), this.targets.length = 0, r.show(this.tank.body.x + o * this.spawnDistance, this.tank.body.y + s * this.spawnDistance, n[0].point.x, n[0].point.y, i);
                var a = n[0].body;
                if (a.sprite && a.sprite.onBulletHit && (a.sprite.onBulletHit(this.damage, this, null, !0), this.targets.push(a.sprite), this.soundAlertRadius && this._alert(a.x, a.y), a.sprite.conductsCurrent))
                    do {
                        var h = this.findClosestEnemy(a.x, a.y);
                        h && (h.onBulletHit(this.damage, this, null, !0), this.targets.push(h), this.soundAlertRadius && this._alert(h.body.x, h.body.y), r = this.spawnBullet(), r.show(a.x, a.y, h.body.x, h.body.y, null))
                    } while (null !== h && this.targets.length < 4)
            }
        }
    }, d.prototype = Object.create(t.prototype), d.prototype.startFire = function() {
        this._fire || (y.playSound("flame_start.mp3"), y.playFlameLoop()), t.prototype.startFire.call(this)
    }, d.prototype.stopFire = function() {
        this._fire && y.stopFlameLoop(), t.prototype.stopFire.call(this)
    }, d.prototype.onBulletHitWall = function(t, e, i, o, s) {
        if (s && t.sprite.alive) {
            var n = this.game.state.getCurrentState();
            n.spawnSmoke(t.x, t.y, 3), this.soundAlertRadius && n.alertSound(t.x, t.y, this.soundAlertRadius), t.sprite.kill(), t.setZeroVelocity()
        }
    }, d.prototype.update = function() {
        t.prototype.update.call(this);
        for (var e = 0; e < this.children.length; e++) {
            var i = this.children[e];
            i.alive && (i.alpha = Math.max(0, Math.min(1, u(i.lifespan, 1e3 * this.life, 0, 10, 0)) - .2 * Math.random()), i.body.rotation = Math.random() * Math.PI * 2, i.loadTexture("game.png", Math.random() < .5 ? "game/projectiles/flame_0.png" : "game/projectiles/flame_1.png"), i.scale.set(.2 + Math.min(.8, (1 - i.lifespan / 1e3 / this.life) / .15)))
        }
    }, window.AT.weapon = {
        Weapon: t,
        Minigun: e,
        Shotgun: i,
        Ricochet: o,
        Cannon: s,
        RocketLauncher: n,
        Laser: r,
        Mines: a,
        Railgun: h,
        Shock: l,
        Flamethrower: d
    }
}(),
function() {
    "use strict";

    function t(e, i, o, s, n) {
        Phaser.Sprite.call(this, e, i, o, "game.png", s), this.level = e.state.getCurrentState(), this.tileX = this.level.pxToTile(i), this.tileY = this.level.pxToTile(o), this.name = "turret", this.team = p.CPU, this.searchForPlayer = b(t.prototype.searchForPlayer, 2), this.anchor.set(.5, .5), this.turret = new Phaser.Image(e, 0, 0, "game.png", n), this.turret.anchor.set(.5, .5), this.addChild(this.turret), e.physics.box2d.enableBody(this), this.body.static = !0, this.body.setCollisionCategory(c.ENEMY), this.bodyX = this.body.x, this.bodyY = this.body.y, this.ice = e.make.image(0, 0, "game.png", "game/ice.png"), this.ice.alpha = .85, this.ice.angle = 360 * Math.random(), this.ice.anchor.set(.5, .5), this.fire = null, this.clockwise = Math.random() < .5, this.patrolWaitTime = 0, this.patrolTargetRotation = 0, this.skipFrames = 0, this._alerted = 0, this.hit = 0, this.hitColor = 0, this.killDelay = 2 / 60, this.sightRange = 1 / 0, this.turretRotationSpeed = 3, this.conductsCurrent = !0, this.points = 0, this._recoil = 0, this.lifebar = new f(this, 0, 60), this.weapon = null, this.shootAngle = 0, this._turretPosition = new Phaser.Point
    }

    function e(e, i, o) {
        t.call(this, e, i, o, "game/turrets/minigun_base.png", "game/turrets/minigun.png"), this.turret.anchor.set(14 / 44, .5), this.setHealth(400), this.points = 400, this.sightRange = 600, this.shootAngle = 10, this.weapon = new g(this, {
            id: "turrets/minigun",
            team: p.CPU,
            spawnDistance: 22,
            rate: 6,
            life: .5,
            damage: 10
        })
    }

    function i(e, i, o) {
        t.call(this, e, i, o, "game/turrets/shotgun_base.png", "game/turrets/shotgun.png"), this.turret.anchor.set(14 / 41, .5), this.setHealth(400), this.points = 500, this.sightRange = 600, this.shootAngle = 20, this.weapon = new _(this, {
            id: "turrets/shotgun",
            team: p.CPU,
            spawnCount: 6,
            rate: 1.5,
            damage: 15,
            life: 100 / 60,
            spawnDistance: 20
        })
    }

    function o(e, i, o) {
        t.call(this, e, i, o, "game/turrets/cannon_base.png", "game/turrets/cannon.png"), this.turret.anchor.set(25 / 63, .5), this.setHealth(500), this.points = 800, this.sightRange = 600, this.shootAngle = 20, this.weapon = new v(this, {
            id: "turrets/cannon",
            team: p.CPU,
            damage: 200,
            rate: 1.5,
            life: 100 / 60,
            spawnDistance: 30
        })
    }

    function s(e, i, o) {
        t.call(this, e, i, o, "game/turrets/rockets_base.png", "game/turrets/rockets.png"), this.turret.anchor.set(19 / 54, .5), this.setHealth(1e3), this.points = 900, this.sightRange = 400, this.shootAngle = 25, this.follow = null, this.weapon = new w(this, {
            id: "player/rockets",
            team: p.CPU,
            damage: 180,
            life: 200 / 60,
            spawnDistance: 15,
            rate: .5,
            radius: 100
        })
    }

    function n(e, i, o) {
        t.call(this, e, i, o, "game/turrets/laser_base.png", "game/turrets/laser.png"), this.turret.anchor.set(31 / 57, .5), this.setHealth(1250), this.points = 1e3, this.sightRange = 600, this.shootAngle = 15, this.weapon = new C(this, {
            id: "turrets/laser",
            team: p.CPU,
            damage: 6,
            spawnDistance: 26
        })
    }

    function r(e, i, o) {
        t.call(this, e, i, o, "game/turrets/generic_base.png", "game/turrets/ricochet.png"), this.turret.anchor.set(16 / 43, .5), this.setHealth(2e3), this.points = 600, this.sightRange = 600, this.shootAngle = 30, this.weapon = new x(this, {
            id: "turrets/ricochet",
            team: p.CPU,
            damage: 80,
            rate: 6,
            life: 100 / 60,
            spawnDistance: 23,
            frameName: "game/projectiles/cannon.png"
        })
    }

    function a(e, i, o) {
        t.call(this, e, i, o, "game/turrets/generic_base.png", "game/turrets/railgun.png"), this.turret.anchor.set(16 / 43, .5), this.setHealth(1500), this.points = 1100, this.sightRange = 400, this.shootAngle = 15, this.turretRotationSpeed = 1.75, this.weapon = new S(this, {
            id: "turrets/railgun",
            team: p.CPU,
            damage: 333,
            rate: 1.091,
            spawnDistance: 30
        })
    }

    function h(e, i, o) {
        t.call(this, e, i, o, "game/turrets/generic_base.png", "game/turrets/flamethrower.png"), this.turret.anchor.set(24 / 53, .5), this.setHealth(1250), this.points = 700, this.sightRange = 400, this.shootAngle = 25, this.turretRotationSpeed = 3, this.weapon = new A(this, {
            id: "turrets/flamethrower",
            team: p.CPU,
            damage: 1,
            rate: 10,
            spawnDistance: 26,
            life: 100 / 60
        })
    }
    var l = window.AT.common.rotate,
        d = window.AT.common.rotateToPoint,
        c = window.AT.common.COLLISION_GROUPS,
        p = window.AT.common.TEAMS,
        u = window.AT.common.calculateHitColor,
        b = window.AT.common.debounceCalls,
        m = window.AT.profile,
        y = window.AT.audio,
        f = window.AT.Lifebar,
        g = window.AT.weapon.Minigun,
        x = window.AT.weapon.Ricochet,
        _ = window.AT.weapon.Shotgun,
        v = window.AT.weapon.Cannon,
        w = window.AT.weapon.RocketLauncher,
        C = window.AT.weapon.Laser,
        S = window.AT.weapon.Railgun,
        A = window.AT.weapon.Flamethrower,
        T = window.AT.explosions.Explosion,
        P = window.AT.Fire;
    t.collisionFilter = function(t, e, i, o) {
        var s = e.GetFilterData().categoryBits;
        return s !== c.PROJECTILE && s !== c.ENEMY_SPAWNER
    }, t.prototype = Object.create(Phaser.Sprite.prototype), t.prototype.getTurretPosition = function(t) {
        var e = this.turret.rotation;
        return this._turretPosition.x = this.bodyX + Math.cos(e) * t, this._turretPosition.y = this.bodyY + Math.sin(e) * t, this._turretPosition
    }, t.prototype.setHealth = function(t) {
        this.lifebar.lastHealth = this.health = this.maxHealth = t
    }, t.prototype.onBulletHit = function(t, e, i, o) {
        o && ((e instanceof P || e instanceof window.AT.weapon.Flamethrower) && (this.fire || (this.fire = new P(this, 4)), this.ice.parent && this.onUnfreeze()), e.team === p.CPU ? this.health -= t / 3 : this.health -= t, e instanceof T || this.game.state.getCurrentState().revealFogAtLocation(this.body), e instanceof T || e instanceof C || e instanceof P || y.playEnemyHit(), this.lifebar.show(), this._alerted = 2.5), this.hit = 1, this.hitColor = e.hitColor
    }, t.prototype.kill = function() {
        this.weapon && this.weapon.stopFire(), this.level.spawnSmoke(this.bodyX, this.bodyY, 3), this.level.spawnHole(this.bodyX, this.bodyY), this.level.shakeCamera(8), this.level.explosionEmitter.emitParticle(this.bodyX, this.bodyY), this.level.spawnCoins(this.bodyX, this.bodyY, 4 + Math.floor(3 * Math.random())), this.level.increaseKillCount(), m.current.stats.turretsDestroyed += 1, this.body.kill(), this.parent.removeChild(this), Phaser.Sprite.prototype.kill.call(this), y.playSound("explosion.mp3", 1.25)
    }, t.prototype.isFreeTile = function(t) {
        var e = Math.round(Math.cos(t)),
            i = Math.round(Math.sin(t));
        return null === this.level.getObject(this.tileX + e, this.tileY + i)
    }, t.prototype.patrol = function() {
        if (l(this.turret, this.patrolTargetRotation, this.alerted ? 2 * this.turretRotationSpeed : this.turretRotationSpeed))
            if (this.patrolWaitTime > 0) this.patrolWaitTime -= this.game.time.physicsElapsed;
            else {
                var t = 0;
                do {
                    this.patrolTargetRotation += this.clockwise ? Math.PI / 2 : Math.PI / -2, t += 1
                } while (t < 4 && !this.isFreeTile(this.patrolTargetRotation));
                this.patrolWaitTime = (this.alerted ? 20 + 10 * Math.random() : 100 + 25 * Math.random()) / 60
            }
    }, t.prototype.searchForPlayer = function() {
        var e = this.level.player;
        if (!e.alive) return this._alerted = 0, !1;
        if (Math.abs(this.rotationToPlayer - this.turretRotation) > 120 / 180 * Math.PI) return !1;
        var i = Phaser.Math.distance(e.bodyX, e.bodyY, this.bodyX, this.bodyY);
        if (i > 52) {
            if (i > this.sightRange) return !1;
            var o = this.level.physics.box2d.raycast(this.bodyX, this.bodyY, e.bodyX, e.bodyY, !0, t.collisionFilter);
            if (o && o.length > 0 && o[0].body !== this.body && o[0].body !== e.body) return !1
        }
        return this._alerted = 2.5, !0
    }, t.prototype.shoot = function() {
        var t = this.level.player,
            e = Math.atan2(t.bodyY - this.bodyY, t.bodyX - this.bodyX);
        t.alive && this.weapon && Math.abs(e - this.turret.rotation) <= this.shootAngle / 180 * Math.PI ? (this.weapon.startFire(), this.level.revealFogAtLocation(this.body)) : this.weapon && this.weapon.stopFire()
    }, t.prototype.alertOthers = function() {
        for (var t = this.game.state.getCurrentState().enemies, e = this.bodyX, i = this.bodyY, o = 0; o < t.length; o++) {
            var s = t[o];
            s !== this && s.alive && s.states && Phaser.Math.distanceSq(e, i, s.bodyX, s.bodyY) <= 4e4 && s.states.message("onPlayerInSight")
        }
    }, t.prototype.onFreeze = function() {
        this.fire && (this.fire.time = 0), this.addChild(this.ice), this.game.state.getCurrentState().spawnIce(this.bodyX, this.bodyY), this.weapon && this.weapon.stopFire()
    }, t.prototype.onUnfreeze = function() {
        this.removeChild(this.ice), this.game.state.getCurrentState().spawnIce(this.bodyX, this.bodyY)
    }, t.prototype.update = function() {
        var t = this.level.player;
        if (this.health <= 0) {
            if (this.killDelay -= this.game.time.physicsElapsed, this.hit = 1, this.killDelay <= 0 && this.parent) return this.fire && m.increaseAchievement("fired") && this.level.achievements.show("fired"), void this.kill()
        } else this.hit > 0 && (this.hit = Math.max(0, this.hit - this.game.time.physicsElapsed / .2), this.ice.tint = this.turret.tint = this.tint = u(this.hitColor, this.hit));
        this.fire && (this.fire.update(), this.fire.time <= 0 && (this.fire = null)), this.visible = this.level.isTileVisible(this.position.x, this.position.y, this.tileX, this.tileY), this.ice.parent || (this.turret.position.x = -this._recoil * Math.cos(this.turret.rotation), this.turret.position.y = -this._recoil * Math.sin(this.turret.rotation), this._recoil -= .3, this._recoil < 0 && (this._recoil = 0), this._alerted > 0 && (this._alerted -= this.game.time.physicsElapsed), this.searchForPlayer() ? (d(this.turret, this.body, t.body, this.turretRotationSpeed), this.shoot(), this.alertOthers()) : (this.weapon && this.weapon.stopFire(), this.patrol()))
    }, Object.defineProperties(t.prototype, {
        alerted: {
            get: function() {
                return this._alerted > 0
            }
        },
        turretRotation: {
            get: function() {
                return this.turret.rotation
            }
        },
        recoil: {
            get: function() {
                return this._recoil
            },
            set: function(t) {
                this._recoil < t && (this._recoil = t)
            }
        }
    }), e.prototype = Object.create(t.prototype), i.prototype = Object.create(t.prototype), o.prototype = Object.create(t.prototype), s.prototype = Object.create(t.prototype), n.prototype = Object.create(t.prototype), r.prototype = Object.create(t.prototype), a.prototype = Object.create(t.prototype), h.prototype = Object.create(t.prototype), window.AT.turrets = {
        Turret: t,
        MinigunTurret: e,
        ShotgunTurret: i,
        CannonTurret: o,
        RocketsTurret: s,
        LaserTurret: n,
        RicochetTurret: r,
        RailgunTurret: a,
        FlamethrowerTurret: h
    }
}(),
function() {
    "use strict";

    function t(t, e, i, o, s, n) {
        Phaser.Sprite.call(this, t, e, i, "game.png", o[0]), this.name = "tank", this.team = v.CPU, this.level = t.state.getCurrentState(), this.searchForPlayer = C(this.searchForPlayer, 9), this.lineOfFireClear = C(this.lineOfFireClear, 4), this.spawner = null, this.small = null != n && n, this.hit = 0, this.hitColor = 0, this.killDelay = 2 / 60, this._alerted = 0, this.acceleration = 0, this.speedMax = 200, this.turretSpeed = 3, this.shootRange = 0, this.sightRange = 0, this.sightAngle = 120, this.distanceToPlayer = 1 / 0, this.rotationToPlayer = 0, this._recoil = 0, this.anchor.set(.5, .5), this.animations.add("move", o, 20, !0), this.turret = t.make.image(0, 0, "game.png", s), this.turret.anchor.set(.5, .5), this.addChild(this.turret), this._turretPosition = new Phaser.Point, this.ice = t.make.image(0, 0, "game.png", "game/ice.png"), this.ice.alpha = .85, this.ice.angle = 360 * Math.random(), this.ice.anchor.set(.5, .5), this.fire = null, this.conductsCurrent = !0, this.points = 0, t.physics.box2d.enableBody(this), this.body.setCircle(n ? 22 * .7 : 22), this.body.friction = 0, this.body.restitution = 0, this.body.linearDamping = 10, this.body.angularDamping = 10, this.body.mass *= 200, this.body.fixedRotation = !0, this.body.angle = 90 * Math.floor(4 * Math.random()), this.body.setCollisionCategory(_.ENEMY), this.body.setCollisionMask(_.PLAYER | _.PROJECTILE | _.ENEMY | _.OBSTACLE | _.WALL), this.bodyX = this.body.x, this.bodyY = this.body.y, this.previousTileX = this.tileX = this.level.pxToTile(this.bodyX), this.previousTileY = this.tileY = this.level.pxToTile(this.bodyY), this.level.occupyTile(this.tileX, this.tileY), this.weapon = null, this.lifebar = new P(this, 0, 60), this.states = new T(this), n && this.scale.set(.7, .7)
    }

    function e(e, i, o, s) {
        t.call(this, e, i, o, O, "game/tanks/minigun.png", s), this.turret.position.x = 1, this.turret.anchor.set(10 / 35, .5), this.setHealth(40 * this.level.difficulty * (s ? 1 / 3 : 1)), this.points = 100, this.acceleration = .13 + .01 * this.level.index, this.speedMax = (2.1 + .2 * this.level.index) * (30 + 15 * this.level.difficultyIndex), this.turretSpeed = 2.2 + .2 * this.level.index, this.sightRange = 200 * this.level.difficulty, this.shootRange = this.sightRange / 2, this.shootAngle = 10, this.weapon = new B(this, {
            id: "tanks/minigun",
            team: v.CPU,
            spawnDistance: 14,
            rate: 4,
            life: .5,
            damage: 10
        })
    }

    function i(e, i, o, s) {
        t.call(this, e, i, o, G, "game/tanks/shotgun.png", s), this.turret.position.x = 1, this.turret.anchor.set(11 / 33, .5), this.setHealth(80 * this.level.difficulty * (s ? 1 / 3 : 1)), this.points = 150, this.acceleration = .13 + .01 * this.level.index, this.speedMax = (2.1 + .2 * this.level.index) * (30 + 15 * this.level.difficultyIndex), this.turretSpeed = 2.2 + .2 * this.level.index, this.sightRange = 250 * this.level.difficulty, this.shootRange = this.sightRange / 2, this.shootAngle = 15, this.weapon = new M(this, {
            id: "tanks/shotgun",
            team: v.CPU,
            spawnCount: 6,
            rate: 1.5,
            damage: 15,
            life: 100 / 60,
            spawnDistance: 20
        })
    }

    function o(e, i, o, s) {
        t.call(this, e, i, o, U, "game/tanks/cannon.png", s), this.turret.anchor.set(.4, .5), this.setHealth(200 * this.level.difficulty * (s ? 1 / 3 : 1)), this.points = 300, this.acceleration = .13 + .01 * this.level.index, this.speedMax = (2.1 + .2 * this.level.index) * (30 + 15 * this.level.difficultyIndex), this.turretSpeed = 2.2 + .2 * this.level.index, this.sightRange = 300 * this.level.difficulty, this.shootRange = this.sightRange / 2, this.shootAngle = 20, this.weapon = new I(this, {
            id: "tanks/cannon",
            team: v.CPU,
            damage: 200,
            rate: 1.5,
            life: 100 / 60,
            spawnDistance: 24
        })
    }

    function s(e, i, o, s) {
        t.call(this, e, i, o, N, "game/tanks/rockets.png", s), this.turret.anchor.set(15 / 43, .5), this.setHealth(240 * this.level.difficulty * (s ? 1 / 3 : 1)), this.points = 350, this.acceleration = .13 + .01 * this.level.index, this.speedMax = 3 * (30 + 15 * this.level.difficultyIndex), this.turretSpeed = 2.2 + .2 * this.level.index, this.sightRange = 350 * this.level.difficulty, this.shootRange = this.sightRange / 2, this.shootAngle = 40, this.follow = null, this.weapon = new R(this, {
            id: "tanks/rockets",
            team: v.CPU,
            damage: 180,
            life: 200 / 60,
            spawnDistance: 11,
            rate: .75,
            radius: 100
        })
    }

    function n(e, i, o, s) {
        t.call(this, e, i, o, J, "game/tanks/ricochet.png", s), this.turret.anchor.set(15 / 43, .5), this.setHealth(100 * this.level.difficulty * (s ? 1 / 3 : 1)), this.points = 200, this.acceleration = .13 + .02 * this.level.index, this.speedMax = (2.1 + .2 * this.level.index) * (30 + 15 * this.level.difficultyIndex), this.turretSpeed = 2.2 + .2 * this.level.index, this.sightRange = 350 * this.level.difficulty, this.shootRange = this.sightRange / 2, this.shootAngle = 50, this.follow = null, this.weapon = new k(this, {
            id: "tanks/ricochet",
            team: v.CPU,
            damage: 80,
            life: 100 / 60,
            spawnDistance: 11,
            rate: 1.2,
            frameName: "game/projectiles/cannon.png"
        })
    }

    function r(e, i, o, s) {
        t.call(this, e, i, o, W, "game/tanks/laser.png", s), this.turret.anchor.set(.5, .5), this.setHealth(200 * this.level.difficulty * (s ? 1 / 3 : 1)), this.points = 450, this.acceleration = .13 + .01 * this.level.index, this.speedMax = (2.1 + .2 * this.level.index) * (30 + 15 * this.level.difficultyIndex), this.turretSpeed = 2.2 + .2 * this.level.index, this.sightRange = 350 * this.level.difficulty, this.shootRange = this.sightRange / 2, this.shootAngle = 10, this.weapon = new D(this, {
            id: "tanks/laser",
            team: v.CPU,
            damage: 6,
            spawnDistance: 22
        })
    }

    function a(e, i, o, s) {
        t.call(this, e, i, o, X, "game/tanks/railgun.png", s), this.turret.anchor.set(.5, .5), this.setHealth(550 * this.level.difficulty * (s ? 1 / 3 : 1)), this.points = 500, this.acceleration = .13 + .01 * this.level.index, this.speedMax = (2.1 + .2 * this.level.index) * (30 + 15 * this.level.difficultyIndex), this.turretSpeed = 2.2 + .2 * this.level.index, this.sightRange = 350 * this.level.difficulty, this.shootRange = this.sightRange / 2, this.shootAngle = 10, this.weapon = new V(this, {
            id: "tanks/railgun",
            team: v.CPU,
            damage: 333,
            rate: 1.2,
            spawnDistance: 24
        })
    }

    function h(e, i, o, s) {
        t.call(this, e, i, o, W, "game/tanks/kamikaze.png", s), this.turret.anchor.set(.5, .5), this.setHealth(350 * this.level.difficulty * (s ? 1 / 3 : 1)), this.points = 400, this.speedMax = (2.1 + .2 * this.level.index) * (30 + 15 * this.level.difficultyIndex), this.acceleration = .13 + .01 * this.level.index, this.turretSpeed = 0, this.sightRange = 350 * this.level.difficulty, this.shootRange = 50, this.coins = !0
    }

    function l(e, i, o, s) {
        t.call(this, e, i, o, j, "game/tanks/flamethrower.png", s), this.turret.anchor.set(24 / 53, .5), this.setHealth(160 * this.level.difficulty * (s ? 1 / 3 : 1)), this.points = 250, this.acceleration = .13 + .01 * this.level.index, this.speedMax = (2.1 + .2 * this.level.index) * (30 + 15 * this.level.difficultyIndex), this.turretSpeed = 2.2 + .2 * this.level.index, this.sightRange = 350 * this.level.difficulty, this.shootRange = 200, this.shootAngle = 35, this.weapon = new E(this, {
            id: "tanks/flamethrower",
            team: v.CPU,
            spawnDistance: 26,
            rate: 10,
            life: 1,
            damage: 1
        })
    }

    function d(e, i, o, s) {
        t.call(this, e, i, o, H, s), this.acceleration = .1, this.speedMax = 2 * (30 + 15 * this.level.difficultyIndex), this.turretSpeed = 3
    }

    function c(t, e, i) {
        d.call(this, t, e, i, "game/tanks/shotgun_boss.png"), this.turret.position.x = 1, this.turret.anchor.set(15 / 41, .5), this.setHealth(300 * this.level.difficulty), this.points = 600, this.sightRange = 350 * this.level.difficulty, this.shootRange = this.sightRange / 2, this.shootAngle = 18, this.weapon = new M(this, {
            id: "tanks/shotgun",
            team: v.CPU,
            spawnCount: 6,
            rate: 1.5,
            damage: 15,
            life: 100 / 60,
            spawnDistance: 24
        })
    }

    function p(t, e, i) {
        d.call(this, t, e, i, "game/tanks/cannon_boss.png"), this.turret.anchor.set(25 / 63, .5), this.setHealth(800 * this.level.difficulty), this.points = 900, this.sightRange = 350 * this.level.difficulty, this.shootRange = this.sightRange / 2, this.shootAngle = 24, this.weapon = new I(this, {
            id: "tanks/cannon",
            team: v.CPU,
            damage: 200,
            rate: 1.5,
            life: 100 / 60,
            spawnDistance: 26
        })
    }

    function u(t, e, i) {
        d.call(this, t, e, i, "game/tanks/rockets_boss.png"), this.turret.anchor.set(.4, .5), this.setHealth(2e3 * this.level.difficulty), this.points = 1e3, this.sightRange = 350 * this.level.difficulty, this.shootRange = this.sightRange / 2, this.shootAngle = 48, this.follow = null, this.weapon = new R(this, {
            id: "tanks/rockets",
            team: v.CPU,
            damage: 180,
            life: 200 / 60,
            spawnDistance: 18,
            rate: .75,
            radius: 100
        })
    }

    function b(t, e, i) {
        d.call(this, t, e, i, "game/tanks/laser_boss.png"), this.turret.anchor.set(.5, .5), this.setHealth(5e3 * this.level.difficulty), this.points = 1100, this.sightRange = 350 * this.level.difficulty, this.shootRange = this.sightRange / 2, this.shootAngle = 12, this.weapon = new D(this, {
            id: "tanks/laser",
            team: v.CPU,
            damage: 6,
            spawnDistance: 28.5
        })
    }

    function m(t, e, i) {
        d.call(this, t, e, i, "game/tanks/ricochet_boss.png"), this.turret.position.x = 1, this.turret.anchor.set(15 / 41, .5), this.setHealth(4e3), this.points = 700, this.sightRange = 350 * this.level.difficulty, this.shootRange = this.sightRange / 2, this.shootAngle = 42, this.weapon = new M(this, {
            id: "tanks/ricochet",
            team: v.CPU,
            rate: 4,
            damage: 80,
            life: 100 / 60,
            spawnDistance: 24
        })
    }

    function y(t, e, i) {
        d.call(this, t, e, i, "game/tanks/railgun_boss.png"), this.turret.position.x = 1, this.turret.anchor.set(15 / 41, .5), this.setHealth(4e3), this.points = 1200, this.sightRange = 350 * this.level.difficulty, this.shootRange = this.sightRange / 2, this.shootAngle = 42, this.weapon = new V(this, {
            id: "tanks/railgun",
            team: v.CPU,
            rate: 1.2,
            damage: 333,
            spawnDistance: 34
        })
    }

    function f(t, e, i) {
        d.call(this, t, e, i, "game/tanks/flamethrower_boss.png"), this.turret.anchor.set(25 / 57, .5), this.setHealth(4e3), this.points = 800, this.sightRange = 350 * this.level.difficulty, this.shootRange = 200, this.shootAngle = 42, this.weapon = new E(this, {
            id: "tanks/flamethrower",
            team: v.CPU,
            spawnDistance: 28,
            rate: 10,
            life: 1,
            damage: 1
        })
    }
    var g = window.AT.common.rotate,
        x = window.AT.common.clampVector,
        _ = window.AT.common.COLLISION_GROUPS,
        v = window.AT.common.TEAMS,
        w = window.AT.common.calculateHitColor,
        C = window.AT.common.debounceCalls,
        S = window.AT.profile,
        A = window.AT.audio,
        T = window.AT.states.StateMachine,
        P = window.AT.Lifebar,
        B = window.AT.weapon.Minigun,
        M = window.AT.weapon.Shotgun,
        I = window.AT.weapon.Cannon,
        R = window.AT.weapon.RocketLauncher,
        D = window.AT.weapon.Laser,
        k = window.AT.weapon.Ricochet,
        V = window.AT.weapon.Railgun,
        E = window.AT.weapon.Flamethrower,
        L = window.AT.explosions.Explosion,
        F = window.AT.Fire,
        O = ["game/tanks/minigun_body_0.png", "game/tanks/minigun_body_1.png"],
        G = ["game/tanks/shotgun_body_0.png", "game/tanks/shotgun_body_1.png"],
        U = ["game/tanks/cannon_body_0.png", "game/tanks/cannon_body_1.png"],
        N = ["game/tanks/rockets_body_0.png", "game/tanks/rockets_body_1.png"],
        W = ["game/tanks/laser_body_0.png", "game/tanks/laser_body_1.png"],
        J = ["game/tanks/railgun_body_0.png", "game/tanks/railgun_body_1.png"],
        X = ["game/tanks/railgun_body_0.png", "game/tanks/railgun_body_1.png"],
        j = ["game/tanks/flamethrower_body_0.png", "game/tanks/flamethrower_body_1.png"],
        H = ["game/tanks/boss_body_0.png", "game/tanks/boss_body_1.png"];
    t.visibilityFilter = function(t, e, i, o) {
        var s = e.GetFilterData().categoryBits;
        return s !== _.PROJECTILE && s !== _.ENEMY_SPAWNER && s !== _.ENEMY
    }, t.shootingFilter = function(t, e, i, o) {
        var s = e.GetFilterData().categoryBits;
        return s !== _.PROJECTILE && s !== _.ENEMY_SPAWNER
    }, t.prototype = Object.create(Phaser.Sprite.prototype), t.prototype.getTurretPosition = function(t) {
        var e = this.turretRotation;
        return this._turretPosition.x = this.bodyX + Math.cos(e) * t, this._turretPosition.y = this.bodyY + Math.sin(e) * t, this._turretPosition
    }, t.prototype.setHealth = function(t) {
        this.lifebar.lastHealth = this.health = this.maxHealth = t
    }, t.prototype.alert = function() {
        this._alerted = 2.5, this.alertOthers()
    }, t.prototype.alertOthers = function() {
        for (var t = this.level.enemies, e = this.bodyX, i = this.body.y, o = 0; o < t.length; o++) {
            var s = t[o];
            (s === this || s.alive && s.states && Phaser.Math.distanceSq(e, i, s.bodyX, s.bodyY) <= 4e4) && s.states.message("onPlayerInSight")
        }
    }, t.prototype.onBulletHit = function(t, e, i, o) {
        o && (e.team !== v.CPU && ((e instanceof F || e instanceof window.AT.weapon.Flamethrower) && (this.fire || (this.fire = new F(this, 2)), this.states.message("onUnfreeze")), this.health -= t, this.lifebar.show(), this.hit = 1, this.hitColor = e.hitColor), e instanceof L || this.level.revealFogAtLocation(this.body), e instanceof L || e instanceof D || e instanceof F || A.playEnemyHit(), this.alert())
    }, t.prototype.kill = function() {
        this.states.idle(), this.weapon && this.weapon.stopFire();
        var t = this.level;
        t.spawnHole(this.bodyX, this.bodyY), t.spawnSmoke(this.bodyX, this.bodyY, 3), t.shakeCamera(8), t.explosionEmitter.emitParticle(this.bodyX, this.bodyY), t.spawnCoins(this.bodyX, this.bodyY, 4 + Math.floor(3 * Math.random())), t.leaveTile(this.tileX, this.tileY), t.increaseKillCount(), S.current.stats.tanksDestroyed += 1, S.increaseAchievement("hunter") && t.achievements.show("hunter"), this.body.kill(), this.body.world.removeBody(this.body), this.parent.removeChild(this), Phaser.Sprite.prototype.kill.call(this), A.playSound("explosion.mp3", 1.25)
    }, t.prototype.findPath = function(t, e, i) {
        return this.level.easystar.findPath(this.tileX, this.tileY, t, e, i)
    }, t.prototype.stop = function(t) {
        this.body.applyForce(-this.body.velocity.x * this.body.mass * t, -this.body.velocity.y * this.body.mass * t)
    }, t.prototype.searchForPlayer = function(e) {
        var i = this.level,
            o = i.player;
        if (!o.alive) return !1;
        if (this.distanceToPlayer < 60) return !0;
        if (this.distanceToPlayer > this.sightRange) return !1;
        if (!e && Math.abs(this.rotationToPlayer - this.turretRotation) > 120 / 180 * Math.PI) return !1;
        var s = i.physics.box2d.raycast(this.bodyX, this.bodyY, o.bodyX, o.bodyY, !0, t.visibilityFilter);
        return !(s && s.length > 0 && s[0].body !== this.body && s[0].body !== o.body)
    }, t.prototype.lineOfFireClear = function() {
        var e = this.level,
            i = e.player,
            o = e.physics.box2d.raycast(this.bodyX, this.bodyY, i.bodyX, i.bodyY, !0, t.shootingFilter);
        return !o || 0 === o.length || o[0].body === this.body || o[0].body === i.body
    }, t.prototype.shoot = function() {
        this.level.player.alive && this.weapon && Math.abs(this.rotationToPlayer - this.turretRotation) <= this.shootAngle / 180 * Math.PI && this.lineOfFireClear() ? this.weapon.startFire() : this.weapon && this.weapon.stopFire()
    }, t.prototype._updateTilePosition = function() {
        this.previousTileX = this.tileX, this.previousTileY = this.tileY, this.tileX = this.level.pxToTile(this.bodyX), this.tileY = this.level.pxToTile(this.bodyY), this.tileX === this.previousTileX && this.tileY === this.previousTileY || (this.level.leaveTile(this.previousTileX, this.previousTileY), this.level.occupyTile(this.tileX, this.tileY))
    }, t.prototype._updateTracks = function() {
        this.speed > 20 ? this.animations.currentAnim.isPlaying || this.animations.play("move") : this.animations.currentAnim.isPlaying && this.animations.stop()
    }, t.prototype.patrol = function(t) {
        return null == t && (t = !1), this.searchForPlayer(t) ? (g(this.turret, this.rotationToPlayer - this.body.rotation, this.turretSpeed), this.shoot(), !0) : (this.weapon && this.weapon.stopFire(), g(this.turret, 0, this.turretSpeed), !1)
    }, t.prototype.update = function() {
        if (this.bodyX = this.body.x, this.bodyY = this.body.y, this.health <= 0) {
            if (this.killDelay -= this.game.time.physicsElapsed, this.hit = 1, this.killDelay <= 0 && this.parent) return this.fire && S.increaseAchievement("fired") && this.level.achievements.show("fired"), void this.kill()
        } else this.hit > 0 && (this.hit = Math.max(0, this.hit - this.game.time.physicsElapsed / .2), this.ice.tint = this.turret.tint = this.tint = w(this.hitColor, this.hit));
        this.fire && (this.fire.update(), this.fire.time <= 0 && (this.fire = null));
        var t = this.body.data.m_linearVelocity;
        x(t, 0, this.body.world.pxm(this.speedMax));
        var e = this.bodyX,
            i = this.bodyY,
            o = this.level.player,
            s = o.bodyX,
            n = o.bodyY;
        this.distanceToPlayer = Phaser.Math.distance(s, n, e, i), this.rotationToPlayer = Math.atan2(n - i, s - e), this._updateTilePosition(), this._updateTracks(), this.visible = this.level.isTileVisible(this.position.x, this.position.y, this.tileX, this.tileY), this.turret.position.x = -this._recoil * Math.cos(this.turret.rotation), this.turret.position.y = -this._recoil * Math.sin(this.turret.rotation), this._recoil -= .3, this._recoil < 0 && (this._recoil = 0), this.states.update(), this._alerted > 0 && (this._alerted -= this.game.time.physicsElapsed)
    }, Object.defineProperties(t.prototype, {
        alerted: {
            get: function() {
                return this._alerted > 0
            }
        },
        turretRotation: {
            get: function() {
                return this.turret.rotation + this.body.rotation
            }
        },
        speed: {
            get: function() {
                var t = this.body.data.m_linearVelocity;
                return this.body.world.mpx(-Math.sqrt(t.x * t.x + t.y * t.y))
            }
        },
        recoil: {
            get: function() {
                return this._recoil
            },
            set: function(t) {
                this._recoil < t && (this._recoil = t)
            }
        }
    }), e.prototype = Object.create(t.prototype), i.prototype = Object.create(t.prototype), o.prototype = Object.create(t.prototype), s.prototype = Object.create(t.prototype), n.prototype = Object.create(t.prototype), r.prototype = Object.create(t.prototype), a.prototype = Object.create(t.prototype), h.prototype = Object.create(t.prototype), h.prototype.kill = function() {
        this.states.idle();
        var t = this.level;
        t.spawnHole(this.bodyX, this.bodyY), t.spawnSmoke(this.bodyX, this.bodyY, 3), t.shakeCamera(8), this.coins && t.spawnCoins(this.bodyX, this.bodyY, 4 + Math.floor(3 * Math.random())), t.explosions.explode(this.bodyX, this.bodyY, 150, 1e3, v.CPU), t.leaveTile(this.tileX, this.tileY), t.increaseKillCount(), S.current.stats.tanksDestroyed += 1, this.body.kill(), this.body.world.removeBody(this.body), this.parent.removeChild(this), Phaser.Sprite.prototype.kill.call(this)
    }, h.prototype.patrol = function() {
        this.distanceToPlayer <= this.shootRange && this.alive && (this.coins = !1, this.kill())
    }, l.prototype = Object.create(t.prototype), d.prototype = Object.create(t.prototype), d.prototype.onBulletHit = function(t, e, i, o) {
        o && ((e instanceof F || e instanceof window.AT.weapon.Flamethrower) && !this.fire && (this.fire = new F(this, 2)), e.team === v.CPU ? this.health -= t / 3 : this.health -= t, e instanceof L || this.level.revealFogAtLocation(this.body), e instanceof L || e instanceof D || e instanceof F || A.playSpawnerHit(), this.lifebar.show(), this.alert()), this.hit = 1, this.hitColor = e.hitColor
    }, d.prototype.kill = function() {
        this.weapon && this.weapon.stopFire();
        var t = this.level;
        t.spawnHole(this.bodyX, this.bodyY), t.spawnSmoke(this.bodyX, this.bodyY, 3), t.shakeCamera(16), t.explosions.explode(this.bodyX, this.bodyY, 50, 0), t.spawnCoins(this.bodyX, this.bodyY, 14 + Math.floor(3 * Math.random())), t.leaveTile(this.tileX, this.tileY), S.current.stats.tanksDestroyed += 1, S.increaseAchievement("hunter") && t.achievements.show("hunter"), this.body.kill(), this.parent.removeChild(this), Phaser.Sprite.prototype.kill.call(this), A.playSound("explosion.mp3", 1.25)
    }, c.prototype = Object.create(d.prototype), p.prototype = Object.create(d.prototype), u.prototype = Object.create(t.prototype), b.prototype = Object.create(d.prototype), m.prototype = Object.create(d.prototype), y.prototype = Object.create(d.prototype), f.prototype = Object.create(d.prototype), window.AT.tanks = {
        EnemyTank: t,
        MinigunTank: e,
        ShotgunTank: i,
        CannonTank: o,
        RocketsTank: s,
        LaserTank: r,
        RicochetTank: n,
        RailgunTank: a,
        KamikazeTank: h,
        FlamethrowerTank: l,
        EnemyBoss: d,
        ShotgunBoss: c,
        CannonBoss: p,
        RocketsBoss: u,
        LaserBoss: b,
        RicochetBoss: m,
        RailgunBoss: y,
        FlamethrowerBoss: f
    }
}(),
function() {
    "use strict";

    function t(t, o, s, m) {
        var y = t.state.getCurrentState();
        n.call(this, t, o, s, "game/spawners/" + m + ".png"), this.progress = t.make.image(25, 25, "game.png", "game/spawners/progress_6.png"), this.progress.anchor.set(1, 1), this.addChild(this.progress), this.name = "spawner", this.team = i.CPU, this.ice = t.make.image(0, 0, "game.png", "game/ice.png"), this.ice.alpha = .85, this.ice.angle = 360 * Math.random(), this.ice.anchor.set(.5, .5), this.conductsCurrent = !0, this.body.setCollisionCategory(e.ENEMY_SPAWNER), this.body.setCollisionMask(e.PLAYER | e.PROJECTILE), this.spawnerType = m, this.halfDestructed = !1, this.tileX = y.pxToTile(this.body.x), this.tileY = y.pxToTile(this.body.y), 0 === m ? (this.setHealth((y.number > 2 ? 150 : 75) * y.difficulty), this.spawnTypes = [r, r, r, a, a, h]) : 1 === m ? (this.setHealth(250 * y.difficulty), this.spawnTypes = [a, a, a, h, h, l]) : 2 === m ? (this.setHealth(400 * y.difficulty), this.spawnTypes = [h, h, h, l, l, d]) : 3 === m ? (this.setHealth(600 * y.difficulty), this.spawnTypes = [l, l, l, d, d, c]) : 4 === m ? (this.setHealth(800 * y.difficulty), this.spawnTypes = [d, d, d, c, c, p]) : 5 === m ? (this.setHealth(1e3 * y.difficulty), this.spawnTypes = [c, c, c, p, p, u]) : 6 === m && (this.setHealth(1e3 * y.difficulty),
            this.spawnTypes = [p, p, p, u, u, b]), this.spawnDelay = 1 + Math.random(), this.spawned = 0, this.tanks = []
    }
    var e = window.AT.common.COLLISION_GROUPS,
        i = window.AT.common.TEAMS,
        o = window.AT.profile,
        s = window.AT.audio,
        n = window.AT.Obstacle,
        r = window.AT.tanks.MinigunTank,
        a = window.AT.tanks.ShotgunTank,
        h = window.AT.tanks.RicochetTank,
        l = window.AT.tanks.FlamethrowerTank,
        d = window.AT.tanks.CannonTank,
        c = window.AT.tanks.RocketsTank,
        p = window.AT.tanks.KamikazeTank,
        u = window.AT.tanks.LaserTank,
        b = window.AT.tanks.RailgunTank,
        m = window.AT.ai.Spawn,
        y = window.AT.weapon.Laser,
        f = window.AT.weapon.Flamethrower,
        g = window.AT.explosions.Explosion,
        x = window.AT.Fire,
        _ = ["game/spawners/progress_0.png", "game/spawners/progress_1.png", "game/spawners/progress_2.png", "game/spawners/progress_3.png", "game/spawners/progress_4.png", "game/spawners/progress_5.png", "game/spawners/progress_6.png"];
    t.prototype = Object.create(n.prototype), t.prototype.alertOthers = function() {
        for (var t = 0; t < this.tanks.length; t++) {
            var e = this.tanks[t];
            e !== this && e.alive && e.states && e.states.message("onPlayerInSight")
        }
    }, t.prototype.onBulletHit = function(t, e, i, o) {
        if (o && (e instanceof y || e instanceof g || e instanceof f || e instanceof x || s.playSpawnerHit(), (e instanceof window.AT.weapon.Flamethrower || e instanceof x) && (this.fire || (this.fire = new x(this, .5)), this.ice.parent && this.onUnfreeze())), n.prototype.onBulletHit.call(this, t, e, i, o), !this.halfDestructed && this.health > 0 && this.health < this.maxHealth / 2) {
            this.frameName = "game/spawners/" + this.spawnerType + "_damaged.png";
            var r = this.game.state.getCurrentState();
            r.spawnSmoke(this.body.x, this.body.y, 10), r.shakeCamera(6), this.halfDestructed = !0, s.playSound("explosion.mp3", 1.25)
        }
    }, t.prototype.onFreeze = function() {
        this.fire && (this.fire.time = 0), this.addChild(this.ice), this.game.state.getCurrentState().spawnIce(this.position.x, this.position.y)
    }, t.prototype.onUnfreeze = function() {
        this.removeChild(this.ice), this.game.state.getCurrentState().spawnIce(this.position.x, this.position.y)
    }, t.prototype.kill = function() {
        var t = this.game.state.getCurrentState();
        t.spawnHole(this.body.x, this.body.y), t.spawnSmoke(this.body.x, this.body.y, 7), t.explosionEmitter.emitParticle(this.body.x, this.body.y), t.shakeCamera(15), t.spawnCoins(this.body.x, this.body.y, Math.floor(7 + 3 * Math.random() + (4 + 3 * Math.random()) * (6 - this.spawned))), t.increaseKillCount(), o.current.stats.spawnersDestroyed += 1, o.increaseAchievement("destroyer") && t.achievements.show("destroyer"), n.prototype.kill.call(this), s.playSound("explosion.mp3", 1.25)
    }, t.prototype.aliveCount = function() {
        for (var t = 0, e = 0; e < this.tanks.length; e++) this.tanks[e].alive && (t += 1);
        return t
    }, t.prototype.spawnTank = function() {
        var t = this.game.state.getCurrentState();
        if (!t.isTileFree(this.tileX, this.tileY)) return !1;
        t.spawnSmoke(this.body.x, this.body.y, 3), t.explosions.wave(this.body.x, this.body.y, 50);
        var e = Math.floor(Math.random() * this.spawnTypes.length),
            i = this.spawnTypes[e];
        this.spawnTypes.splice(e, 1);
        var o = t.createTank(this.tileX, this.tileY, i);
        return o.states.change(m, this), this.tanks.push(o), this.spawned += 1, this.progress.loadTexture("game.png", _[6 - this.spawned]), !0
    }, t.prototype.update = function() {
        n.prototype.update.call(this), this.ice.tint = this.tint, this.health > 0 && this.spawned < 6 && !this.ice.parent && (this.spawnDelay -= this.game.time.physicsElapsed, this.spawnDelay <= 0 && this.aliveCount() < 4 && this.spawnTank() && (this.spawnDelay += 250 / 60))
    }, Object.defineProperties(t.prototype, {
        points: {
            get: function() {
                return 500 + 200 * this.spawnerType + (6 - this.spawned) * (150 + 50 * this.spawnerType)
            }
        }
    }), window.AT.Spawner = t
}(),
function() {
    "use strict";

    function t(o, s, n) {
        var r = d.current.game;
        Phaser.Sprite.call(this, o.game, s, n), this.name = "player", this.findAutoAimTarget = h(this.findAutoAimTarget, 3), this.hit = 0, this.hitColor = 0, this.killDelay = .12, this.level = o, this.bodySprite = new Phaser.Sprite(o.game, 0, 0, "game.png", "game/player/body_0.png"), this.bodySprite.anchor.set(.5, .5), this.bodySprite.animations.add("move", ["game/player/body_0.png", "game/player/body_1.png"], 20, !0), this.addChild(this.bodySprite), this.turretSprite = new Phaser.Sprite(o.game, 0, 0, "game.png"), this.turretSprite.anchor.set(24 / 54, .5), this.addChild(this.turretSprite), this._turretPosition = new Phaser.Point, o.physics.box2d.enableBody(this), this.body.setCircle(22), this.body.friction = 0, this.body.restitution = 0, this.body.setCollisionCategory(i.PLAYER), this.bodyX = this.body.x, this.bodyY = this.body.y, this.previousTileX = this.tileX = o.pxToTile(this.bodyX), this.previousTileY = this.tileY = o.pxToTile(this.bodyY), this.invincible = !1, this.health = this.maxHealth = t.ARMOR_LEVELS[r.armor], this.moveSpeed = t.SPEED_LEVELS[r.speed], this.turretSpeed = t.TURRET_LEVELS[r.turret], this.viewAngle = t.VIEW_ANGLE_LEVELS[r.sight], this.viewDistance = t.VIEW_DISTANCE_LEVELS[r.sight], this.follow = null, this.autoAim = !1, this.autoAimTarget = null, this.autoAimDisableDelay = 0, this._recoil = 0, o.objectsLayer.add(this), this.weapons = [new p(this, {
            id: "player/minigun",
            team: l.PLAYER,
            spawnDistance: 15,
            rate: L[r.minigunLevel],
            life: F[r.minigunLevel],
            damage: O[r.minigunLevel],
            soundAlertRadius: 100,
            onShot: this.onMinigunShot.bind(this),
            onOutOfAmmo: this.nextWeaponWithAmmo.bind(this)
        }), -1 === r.shotgunLevel ? null : new u(this, {
            id: "player/shotgun",
            team: l.PLAYER,
            spawnCount: N[r.shotgunLevel],
            rate: G[r.shotgunLevel],
            life: U[r.shotgunLevel],
            spawnDistance: 20,
            damage: W[r.shotgunLevel],
            ammo: r.shotgunAmmo,
            maxAmmo: e.shotgun,
            soundAlertRadius: 100,
            onShot: this.onShotgunShot.bind(this),
            onOutOfAmmo: this.nextWeaponWithAmmo.bind(this)
        }), -1 === r.ricochetLevel ? null : new b(this, {
            id: "player/ricochet",
            team: l.PLAYER,
            soundAlertRadius: 100,
            life: 80 / 60,
            spawnDistance: 20,
            damage: J[r.ricochetLevel],
            ammo: r.ricochetAmmo,
            maxAmmo: e.ricochet,
            onShot: this.onRicochetShot.bind(this),
            onOutOfAmmo: this.nextWeaponWithAmmo.bind(this)
        }), -1 === r.flamethrowerLevel ? null : new v(this, {
            id: "player/flamethrower",
            team: l.PLAYER,
            spawnDistance: 27,
            rate: j[r.flamethrowerLevel],
            life: H[r.flamethrowerLevel],
            damage: X[r.flamethrowerLevel],
            ammo: r.flamethrowerAmmo,
            maxAmmo: e.flamethrower,
            soundAlertRadius: 100,
            onOutOfAmmo: this.nextWeaponWithAmmo.bind(this)
        }), -1 === r.cannonLevel ? null : new m(this, {
            id: "player/cannon",
            team: l.PLAYER,
            damage: Y[r.cannonLevel],
            rate: z[r.cannonLevel],
            life: q[r.cannonLevel],
            ammo: r.cannonAmmo,
            maxAmmo: e.cannon,
            spawnDistance: 9,
            onShot: this.onCannonShot.bind(this),
            onOutOfAmmo: this.nextWeaponWithAmmo.bind(this)
        }), -1 === r.shockLevel ? null : new _(this, {
            id: "player/shock",
            team: l.PLAYER,
            damage: K[r.shockLevel],
            ammo: r.shockAmmo,
            maxAmmo: e.shock,
            spawnDistance: 22,
            soundAlertRadius: 100,
            onOutOfAmmo: this.nextWeaponWithAmmo.bind(this)
        }), -1 === r.rocketsLevel ? null : new y(this, {
            id: "player/rockets",
            team: l.PLAYER,
            damage: Q[r.rocketsLevel],
            life: Z[r.rocketsLevel],
            velocity: $[r.rocketsLevel],
            ammo: r.rocketsAmmo,
            maxAmmo: e.rockets,
            spawnDistance: 15,
            radius: 85,
            onShot: this.onRocketShot.bind(this),
            onOutOfAmmo: this.nextWeaponWithAmmo.bind(this)
        }), -1 === r.laserLevel ? null : new f(this, {
            id: "player/laser",
            team: l.PLAYER,
            damage: tt[r.laserLevel],
            ammo: r.laserAmmo,
            maxAmmo: e.laser,
            spawnDistance: 21.25,
            soundAlertRadius: 100,
            onShot: h(this.onLaserShot.bind(this), 14),
            onOutOfAmmo: this.nextWeaponWithAmmo.bind(this)
        }), -1 === r.railgunLevel ? null : new x(this, {
            id: "player/railgun",
            team: l.PLAYER,
            damage: it[r.railgunLevel],
            rate: et[r.railgunLevel],
            ammo: r.railgunAmmo,
            maxAmmo: e.railgun,
            spawnDistance: 27,
            soundAlertRadius: 100,
            onOutOfAmmo: this.nextWeaponWithAmmo.bind(this)
        })], this.weaponIndex = -1, this.weapon = null, this.mines = -1 === r.minesLevel ? null : new g(this, {
            id: "player/mines",
            team: l.PLAYER,
            damage: ot[0],
            life: 1 / 0,
            ammo: r.minesAmmo,
            maxAmmo: e.mines,
            spawnDistance: 0,
            radius: 75
        }), this.grayscaleShader = new PIXI.AbstractFilter(o.cache.getShader("grayscale.frag")), this.fire = null, this.changeWeapon(0)
    }
    var e = window.AT.SETTINGS.AMMO_LIMITS,
        i = window.AT.common.COLLISION_GROUPS,
        o = window.AT.common.mod,
        s = window.AT.common.rotate,
        n = window.AT.common.rotateToPoint,
        r = window.AT.common.rotateToVector,
        a = window.AT.common.calculateHitColor,
        h = window.AT.common.debounceCalls,
        l = window.AT.common.TEAMS,
        d = window.AT.profile,
        c = window.AT.audio,
        p = window.AT.weapon.Minigun,
        u = window.AT.weapon.Shotgun,
        b = window.AT.weapon.Ricochet,
        m = window.AT.weapon.Cannon,
        y = window.AT.weapon.RocketLauncher,
        f = window.AT.weapon.Laser,
        g = window.AT.weapon.Mines,
        x = window.AT.weapon.Railgun,
        _ = window.AT.weapon.Shock,
        v = window.AT.weapon.Flamethrower,
        w = window.AT.explosions.Explosion,
        C = window.AT.Fire,
        S = window.AT.bonus.Health,
        A = window.AT.bonus.Freeze,
        T = window.AT.bonus.Coin,
        P = window.AT.bonus.ShotgunAmmo,
        B = window.AT.bonus.RicochetAmmo,
        M = window.AT.bonus.FlamethrowerAmmo,
        I = window.AT.bonus.CannonAmmo,
        R = window.AT.bonus.ShockAmmo,
        D = window.AT.bonus.RocketsAmmo,
        R = window.AT.bonus.ShockAmmo,
        k = window.AT.bonus.LaserAmmo,
        V = window.AT.bonus.RailgunAmmo,
        E = window.AT.bonus.MinesAmmo,
        L = [60 / 7, 10, 12, 15, 20, 20],
        F = [8 / 30, 10.3 / 30, .42, .5, .5, .5],
        O = [4, 4, 4, 4, 4, 5],
        G = [1, 60 / 56, 60 / 52, 1.25, 60 / 44, 1.5],
        U = [1.3, 1.3, 1.3, 1.3, 1.3, 1.3],
        N = [4, 5, 6, 8, 9, 10],
        W = [25, 22, 22, 22, 22, 22],
        J = [75, 110, 145, 180, 215, 249],
        X = [20, 24, 28, 32, 36, 40],
        j = [12, 12, 12, 12, 12, 12],
        H = [1.5, 50 / 30, 55 / 30, 2, 65 / 30, 70 / 30],
        z = [60 / 55, 60 / 51, 60 / 47, 60 / 43, 60 / 39, 60 / 35],
        Y = [457, 569, 681, 793, 905, 1017],
        q = [1, 40 / 30, 50 / 30, 2, 2, 2],
        K = [2, 3, 4, 5, 6, 7],
        Z = [5, 400 / 60, 500 / 60, 10, 10, 10],
        Q = [1e3, 1300, 1600, 1900, 2200, 2500],
        $ = [.5, 1, 1.5, 2, 2, 2],
        tt = [8, 12, 16, 20, 24, 28],
        et = [1, 60 / 56, 60 / 52, 1.25, 60 / 44, 1.5],
        it = [500, 550, 600, 650, 700, 750],
        ot = [457, 569, 681, 793, 905, 1017];
    t.ARMOR_LEVELS = [700, 1260, 2100, 3220, 4900, 6300], t.TURRET_LEVELS = [4, 5, 6, 7, 8, 9], t.SPEED_LEVELS = [159.84, 170.88, 3.8 * 48, 192, 4.27 * 48, 216], t.ACCELERATION_LEVELS = [.2, .23, .26, .3, .32, .34], t.VIEW_ANGLE_LEVELS = [Math.PI / 4, Math.PI / 3.5, Math.PI / 2.5, Math.PI / 2, Math.PI / 1.5, Math.PI], t.VIEW_DISTANCE_LEVELS = [230, 250, 270, 300, 320, 350], t.autoAimFilter = function(t, e, o, s) {
        return e.GetFilterData().categoryBits !== i.PROJECTILE
    }, t.prototype = Object.create(Phaser.Sprite.prototype), t.prototype.onMinigunShot = function(t) {
        this.level.alertSound(this.bodyX, this.bodyY, 200)
    }, t.prototype.onShotgunShot = function(t) {
        this.level.alertSound(this.bodyX, this.bodyY, 240)
    }, t.prototype.onRicochetShot = function(t) {
        this.level.alertSound(this.bodyX, this.bodyY, 240)
    }, t.prototype.onCannonShot = function(t) {
        this.level.alertSound(this.bodyX, this.bodyY, 300)
    }, t.prototype.onRocketShot = function(t) {
        this.level.alertSound(this.bodyX, this.bodyY, 240)
    }, t.prototype.onLaserShot = function(t) {
        this.level.alertSound(this.bodyX, this.bodyY, 100)
    }, t.prototype.onBonusHit = function(t) {
        if (!(this.health <= 0)) {
            if (t instanceof S) this.health = Math.min(this.maxHealth, this.health + .25 * this.maxHealth), this.level.hud.healthVial.updateProgress(this.health / this.maxHealth, 5), c.playSound("health.mp3");
            else if (t instanceof T) c.playSound("coin.mp3", .55);
            else if (t instanceof A);
            else {
                var e = null;
                t instanceof P ? e = this.weapons[1] : t instanceof B ? e = this.weapons[2] : t instanceof M ? e = this.weapons[3] : t instanceof I ? e = this.weapons[4] : t instanceof R ? e = this.weapons[5] : t instanceof D ? e = this.weapons[6] : t instanceof k ? e = this.weapons[7] : t instanceof V ? e = this.weapons[8] : t instanceof E && (e = this.mines), e && (e.ammo = Math.min(e.ammo + t.ammo, e.maxAmmo), c.playSound("ammo.mp3"))
            }
            this.level.collect(t)
        }
    }, t.prototype.onBulletHit = function(t, e, i, o) {
        o && !this.invincible && e.team !== l.PLAYER && (!this.fire && (e instanceof window.AT.weapon.Flamethrower || e instanceof C) && (this.fire = new C(this, 2, (55 + 40 * this.level.index) / 60)), this.health -= t, this.hit = 1, this.hitColor = e.hitColor, this.level.hud.healthVial.updateProgress(this.health / this.maxHealth, 5), e instanceof w || e instanceof f || c.playEnemyHit())
    }, t.prototype.kill = function() {
        this.weapon && this.weapon.stopFire(), this.follow && (this.follow.requestKill = !0), Phaser.Sprite.prototype.kill.call(this), this.visible = !0, this.body.static = !0;
        var t = this.game.state.getCurrentState();
        t.shakeCamera(15), t.spawnSmoke(this.bodyX, this.bodyY, 10), t.explosions.explode(this.bodyX, this.bodyY, 50, 0), t.occupyTile(this.tileX, this.tileY), this.bodySprite.shader = this.turretSprite.shader = this.grayscaleShader, c.playSound("explosion.mp3", 1.25)
    }, t.prototype.turnBody = function() {
        var t = this.body.velocity;
        Math.sqrt(t.x * t.x + t.y * t.y) > .01 ? (r(this.bodySprite, this.body.velocity, 8), this.bodySprite.animations.currentAnim.isPlaying || this.bodySprite.animations.play("move")) : this.bodySprite.animations.currentAnim.isPlaying && this.bodySprite.animations.stop()
    }, t.prototype.changeWeapon = function(t) {
        this.weapons[t] && this.weapons[t] !== this.weapon && (this.weapon && this.weapon.deactivate(), this.weaponIndex = t, this.weapon = this.weapons[t], this.weapon.activate(), this.turretSprite.loadTexture("game.png", "game/" + this.weapon.id + ".png"), this.turretSprite.scale.set(.5), this.game.add.tween(this.turretSprite.scale).to({
            x: 1,
            y: 1
        }, 750, Phaser.Easing.Elastic.Out, !0), c.playSound("weapon_change.mp3"))
    }, t.prototype.previousWeapon = function() {
        var t = this.weaponIndex;
        do {
            t = o(t - 1, this.weapons.length)
        } while (!this.weapons[t]);
        this.changeWeapon(t)
    }, t.prototype.nextWeapon = function() {
        var t = this.weaponIndex;
        do {
            t = o(t + 1, this.weapons.length)
        } while (!this.weapons[t]);
        this.changeWeapon(t)
    }, t.prototype.nextWeaponWithAmmo = function() {
        do {
            this.weaponIndex = (this.weaponIndex + 1) % this.weapons.length, this.changeWeapon(this.weaponIndex)
        } while (this.weapon.ammo <= 0)
    }, t.prototype.getTurretPosition = function(t) {
        var e = this.turretSprite.rotation;
        return this._turretPosition.x = this.bodyX + Math.cos(e) * t, this._turretPosition.y = this.bodyY + Math.sin(e) * t, this._turretPosition
    }, t.prototype.rotateTurret = function(t) {
        s(this.turretSprite, t, this.turretSpeed)
    }, t.prototype.move = function(t, e) {
        this.body.velocity.x = t * this.moveSpeed, this.body.velocity.y = e * this.moveSpeed
    }, t.prototype.startFire = function() {
        this.weapon && this.weapon.startFire()
    }, t.prototype.stopFire = function() {
        this.weapon && this.weapon.stopFire()
    }, t.prototype.findAutoAimTarget = function(e) {
        for (var i = this.level.physics.box2d, o = this.bodyX, s = this.bodyY, n = this.level.enemies, r = 1 / 0, a = null, h = !1, l = 1 / 0, d = 0; d < n.length; d++) {
            var c = n[d];
            if (c.alive) {
                var p = Phaser.Math.distanceSq(o, s, c.body.x, c.body.y);
                if (!(p > r || p > 16e4)) {
                    var u = i.raycast(o, s, c.body.x, c.body.y, !0, t.autoAimFilter);
                    u && u.length > 0 && u[0].body !== c.body && u[0].body !== this.body || (c === e && (h = !0, l = p), r = p, a = c)
                }
            }
        }
        return h && l <= r + 1e4 ? e : a
    }, t.prototype.updateAutoAim = function() {
        var t = this.autoAimTarget;
        this.autoAimTarget = this.findAutoAimTarget(t), this.autoAimTarget && this.autoAimTarget.alive ? n(this.turretSprite, this.body, this.autoAimTarget.body, this.turretSpeed) : t && !this.autoAimTarget ? this.autoAimDisableDelay = 1 : this.autoAimDisableDelay > 0 ? this.autoAimDisableDelay -= this.game.time.physicsElapsed : s(this.turretSprite, this.bodySprite.rotation, 1.5 * this.turretSpeed)
    }, t.prototype.update = function() {
        this.health <= 0 && (this.killDelay -= this.game.time.physicsElapsed, this.killDelay <= 0 && this.alive && this.kill()), this.hit = Math.max(0, this.hit - this.game.time.physicsElapsed / .2), this.turretSprite.tint = this.bodySprite.tint = a(this.hitColor, this.hit), this.fire && (this.fire.update(), this.fire.time <= 0 ? this.fire = null : this.invincible && (this.fire.time = 0)), this.alive && (this.autoAim && this.updateAutoAim(), this.turnBody(), this.turretSprite.position.x = -this._recoil * Math.cos(this.turretSprite.rotation), this.turretSprite.position.y = -this._recoil * Math.sin(this.turretSprite.rotation), this._recoil -= .3, this._recoil < 0 && (this._recoil = 0), this.bodyX = this.body.x, this.bodyY = this.body.y, this.previousTileX = this.tileX, this.previousTileY = this.tileY, this.tileX = this.level.pxToTile(this.bodyX), this.tileY = this.level.pxToTile(this.bodyY))
    }, Object.defineProperties(t.prototype, {
        turretRotation: {
            get: function() {
                return this.turretSprite.rotation
            }
        },
        reallyAlive: {
            get: function() {
                return this.alive && this.health > 0
            }
        },
        weaponCount: {
            get: function() {
                for (var t = 0, e = 0; e < this.weapons.length; e++) null != this.weapons[e] && (t += 1);
                return t
            }
        },
        recoil: {
            get: function() {
                return this._recoil
            },
            set: function(t) {
                this._recoil < t && (this._recoil = t)
            }
        }
    }), window.AT.Tank = t
}(),
function() {
    "use strict";

    function t(t, e, i, o) {
        Phaser.Group.call(this, t), this.crates = t.make.image(316, -79, "game.png", "game/tutorial/crates.png"), this.crates.anchor.set(.5, .5), this.crates.alpha = 0, this.add(this.crates), i.events.onKilled.add(this.hideCratesHint, this);
        var s = t.make.sprite(50, -76, "game.png");
        s.animations.add("default", ["game/bonuses/ammo_shotgun.png", "game/bonuses/ammo_ricochet.png", "game/bonuses/ammo_cannon.png", "game/bonuses/ammo_rockets.png", "game/bonuses/.png", "game/bonuses/ammo_laser.png"], 4, !0), s.animations.play("default"), this.crates.addChild(s), this.barrels = t.make.image(257, 300, "game.png", "game/tutorial/barrels.png"), this.barrels.anchor.set(.5, .5), this.barrels.alpha = 0, this.add(this.barrels), o.events.onKilled.add(this.hideBarrelsHint, this), this.gates = t.make.image(152, 254, "game.png", "game/tutorial/gates.png"), this.gates.anchor.set(.5, .5), this.add(this.gates), e.events.onKilled.add(this.hideGatesHint, this), this.objective = t.make.image(678, -55, "game.png", "game/tutorial/objective.png"), this.objective.anchor.set(.5, .5), this.objective.alpha = 0, this.add(this.objective), this.hintsCompleted = 0
    }
    t.prototype = Object.create(Phaser.Group.prototype), t.prototype.hideGatesHint = function() {
        this.game.add.tween(this.gates).to({
            alpha: 0
        }, 500, Phaser.Easing.Linear.None, !0), this.game.add.tween(this.crates).to({
            alpha: 1
        }, 500, Phaser.Easing.Linear.None, !0), this.game.add.tween(this.barrels).to({
            alpha: 1
        }, 500, Phaser.Easing.Linear.None, !0), this.hintsCompleted += 1
    }, t.prototype.hideCratesHint = function() {
        this.game.add.tween(this.crates).to({
            alpha: 0
        }, 500, Phaser.Easing.Linear.None, !0), this.hintsCompleted += 1, this.hintsCompleted >= 3 && this.showObjectiveHint()
    }, t.prototype.hideBarrelsHint = function() {
        this.game.add.tween(this.barrels).to({
            alpha: 0
        }, 500, Phaser.Easing.Linear.None, !0), this.hintsCompleted += 1, this.hintsCompleted >= 3 && this.showObjectiveHint()
    }, t.prototype.showObjectiveHint = function() {
        this.game.add.tween(this.objective).to({
            alpha: 1
        }, 500, Phaser.Easing.Linear.None, !0)
    }, window.AT.TutorialLayer = t
}(),
function() {
    "use strict";

    function t(t, i, o, s, n, r, a) {
        this.fogResolution = 12, Phaser.Image.call(this, t, 0, 0, new Phaser.RenderTexture(t, n * this.fogResolution, r * this.fogResolution, null, 1)), this.fogWidth = n, this.fogHeight = r, this.width = n * a, this.height = r * a, this.circle = t.make.image(0, 0, "game.png", "game/fog_circle.png"), this.circle.anchor.set(.5, .5), this.smallCircle = t.make.image(0, 0, "game.png", "game/fog_tile.png"), this.smallCircle.anchor.set(.5, .5), this.tileSize = a, this.tileOffsetX = o, this.tileOffsetY = s, this.shader = new PIXI.AbstractFilter(t.cache.getShader("inverse_alpha.frag")), this.tiles = e(n, r, !1), i.add(this)
    }
    var e = window.AT.common.create2DArray;
    t.prototype = Object.create(Phaser.Image.prototype), t.prototype.revealTile = function(t, e) {
        t -= this.tileOffsetX, e -= this.tileOffsetY, t >= 0 && e >= 0 && t < this.fogWidth && e < this.fogHeight && !this.tiles[e][t] && (this.texture.renderXY(this.smallCircle, (t + .5) * this.tileSize / this.scale.x, (e + .5) * this.tileSize / this.scale.y, !1), this.tiles[e][t] = !0)
    }, t.prototype.revealTileArea = function(t, e) {
        t -= this.tileOffsetX, e -= this.tileOffsetY, t >= 0 && e >= 0 && t < this.fogWidth && e < this.fogHeight && (this.texture.renderXY(this.circle, (t + .5) * this.tileSize / this.scale.x, (e + .5) * this.tileSize / this.scale.y, !1), this.tiles[e][t] = !0)
    }, window.AT.Fog = t
}(),
function() {
    "use strict";
    window.AT.gui = {}
}(),
function() {
    "use strict";

    function t(t, e) {
        Phaser.Group.call(this, t, e), this.medal = t.add.image(100, 0, "game.png", "game/achievements/hunter.png", this), this.medal.alpha = 0, this.medal.anchor.set(.5, .5), this.queue = [], this.displaying = !1, this.resize(), this.resize = this.resize.bind(this), window.addEventListener("resize", this.resize)
    }
    var e = window.AT.audio;
    t.prototype = Object.create(Phaser.Group.prototype), t.prototype._show = function(t) {
        t || (t = this.queue.shift()), this.medal.loadTexture("game.png", "game/achievements/" + t + ".png"), this.game.add.tween(this.medal).to({
            x: 0,
            alpha: 1
        }, 500, Phaser.Easing.Linear.None, !0).onComplete.add(this._hide, this), this.displaying = !0, e.playSound("achievement.mp3")
    }, t.prototype._hide = function() {
        this.game.add.tween(this.medal).to({
            x: 100,
            alpha: 0
        }, 500, Phaser.Easing.Linear.None, !0, 3e3).onComplete.add(this._completed, this)
    }, t.prototype._completed = function() {
        this.queue.length > 0 ? this._show() : this.displaying = !1
    }, t.prototype.show = function(t) {
        this.displaying ? this.queue.push(t) : this._show(t)
    }, t.prototype.resize = function() {
        this.position.set(.5 * window.innerWidth / this.parent.scale.x - 50, -132)
    }, t.prototype.destroy = function() {
        window.removeEventListener("resize", this.resize)
    }, window.AT.gui.Achievements = t
}(),
function() {
    "use strict";

    function t(t, e, i, o) {
        Phaser.Group.call(this, t, e), this.hiding = !1, i ? this.overlay = null : (this.overlay = t.add.image(0, 0, "game.png", "game/alerts/overlay.png", this), this.overlay.alpha = .5, this.overlay.inputEnabled = !0), this.window = t.add.group(this), this.resize(), o || (this.alpha = 0, t.add.tween(this).to({
            alpha: 1
        }, 250, Phaser.Easing.Linear.None, !0)), this.resize = this.resize.bind(this), window.addEventListener("resize", this.resize)
    }

    function e(e, o, s, n) {
        t.call(this, e, o, !0, !0), e.add.image(0, 0, "game.png", "game/hud/pause_label.png", this.window).anchor.set(.5, .5), this.continueButton = i(e, 0, 60, "game.png", "game/buttons/continue", this.hide, this, this.window), this.continueButton.anchor.set(.5, .5), this.continueButton.events.onInputUp.add(s, n)
    }
    var i = window.AT.common.button;
    t.prototype = Object.create(Phaser.Group.prototype), t.prototype.resize = function() {
        var t = Math.min(window.innerWidth / 600, window.innerHeight / 600);
        this.scale.set(t, t), this.overlay && (this.overlay.width = window.innerWidth / t, this.overlay.height = window.innerHeight / t), this.window.position.set(.5 * window.innerWidth / t, .5 * window.innerHeight / t)
    }, t.prototype.hide = function() {
        this.hiding || (this.game.add.tween(this).to({
            alpha: 0
        }, 250, Phaser.Easing.Linear.None, !0).onComplete.add(this.destroy, this), this.hiding = !0)
    }, t.prototype.destroy = function() {
        this.parent && this.parent.removeChild(this), this.overlay && (this.overlay.inputEnabled = !1), window.removeEventListener("resize", this.resize), Phaser.Group.prototype.destroy.apply(this, arguments)
    }, e.prototype = Object.create(t.prototype), e.prototype.destroy = function() {
        this.continueButton.inputEnabled = !1, t.prototype.destroy.call(this)
    }, window.AT.gui.BaseAlert = t, window.AT.gui.PauseAlert = e
}(),
function() {
    "use strict";

    function t(t, o) {
        e.call(this, t, o), t.add.image(0, 0, "menu/title/parts.png", "menu/title/parts/credits.png", this.window).anchor.set(.5, .5), i(t, 77, -140, "menu/title/parts.png", "menu/title/parts/buttons", this.hide, this, this.window)
    }
    var e = window.AT.gui.BaseAlert,
        i = window.AT.common.closeButton;
    t.prototype = Object.create(e.prototype), window.AT.gui.CreditsAlert = t
}(),
function() {
    "use strict";

    function t(t, n) {
        o.call(this, t, n), t.add.image(0, 0, "menu/upgrades/stats.png", null, this.window).anchor.set(.5, .5), i(t, 175, -265, "menu/upgrades/parts.png", "menu/upgrades/parts/buttons", this.hide, this, this.window);
        var r = s.current.stats;
        this.addLabel(205, -181, r.tanksDestroyed, this.window), this.addLabel(205, -150, r.turretsDestroyed, this.window), this.addLabel(205, -119, r.spawnersDestroyed, this.window), this.addLabel(205, -89, r.wallsDestroyed, this.window), this.addLabel(205, -60, r.coinsCollected, this.window), this.addLabel(205, -29, r.barrelsExploded, this.window), this.addLabel(205, -1, r.cratesDestroyed, this.window);
        var a = t.add.text(205, 10, e(r.moneyEarned), null, this.window);
        a.anchor.set(1, 0), a.font = "Gunplay", a.fontWeight = "400", a.fontSize = 34, a.fill = "#FFB600", this.createAchievement("hunter", -183, 186), this.createAchievement("destroyer", -91, 186), this.createAchievement("dodger", 1, 186), this.createAchievement("treasurer", 93, 186), this.createAchievement("ultracombo", 185, 186), this.createAchievement("gotcha", -133, 270), this.createAchievement("fired", -41, 270), this.createAchievement("nailed", 51, 270), this.createAchievement("survivor", 143, 270), this.hint = null, this.hintHideTween = null
    }
    var e = window.AT.common.formatMoney,
        i = window.AT.common.closeButton,
        o = window.AT.gui.BaseAlert,
        s = window.AT.profile;
    t.prototype = Object.create(o.prototype), t.prototype.showHint = function(t) {
        this.hint || (this.hint = this.game.add.image(15, 72, "menu/upgrades/parts.png", null, this.window), this.hint.anchor.set(.5, .5)), this.hint.alpha = 1, this.hint.loadTexture("menu/upgrades/parts.png", "menu/upgrades/parts/achievements/" + t + "_hint.png"), this.hintHideTween && this.hintHideTween.stop(!1), this.hintHideTween = this.game.add.tween(this.hint).to({
            alpha: 0
        }, 250, Phaser.Easing.Linear.None, !0, 5e3)
    }, t.prototype.createAchievement = function(t, e, i) {
        var o = s.isAchievementCompleted(t) ? ".png" : "_disabled.png";
        this.game.add.button(e, i, "menu/upgrades/parts.png", this.showHint.bind(this, t), this, null, "menu/upgrades/parts/achievements/" + t + o, null, null, this.window).anchor.set(.5, 1)
    }, t.prototype.addLabel = function(t, e, i, o) {
        var s = this.game.add.text(t, e, i, null, o);
        return s.anchor.set(1, .5), s.font = "Gunplay", s.fontWeight = "400", s.fontSize = 28, s.fill = "#AAC641", s
    }, window.AT.gui.StatsAlert = t
}(),
function() {
    "use strict";

    function t(t, e, s, a, c, p) {
        n.call(this, t, e), this.buyCallback = a, this.refillCallback = c, this.context = p, this.weaponLevel = r.current.game[s + "Level"], this.weaponKey = s, t.add.image(0, 0, "menu/upgrades/upgrade.png", null, this.window).anchor.set(.5, .5), o(t, 160, -134, h, "menu/upgrades/parts/buttons", this.hide, this, this.window), t.add.text(0, -114, s, {
            font: "Gunplay",
            fontSize: 32,
            fontWeight: "400",
            fill: "#a0a80a"
        }, this.window).anchor.set(.5, .5);
        var u = t.device.touch && "mines" === s;
        if (t.add.text(-69, -60, u ? d.minesTouch : d[s], {
                font: "Gunplay",
                fontSize: 18,
                fontWeight: "400",
                fill: "#ffb600"
            }, this.window), u) {
            t.add.image(8, -64, h, "menu/upgrades/parts/mines_icon.png", this.window).scale.set(.5, .5)
        }
        this.icon = t.add.image(-200, -60, h, "menu/upgrades/parts/" + s + ".png", this.window), this.levels = [t.add.image(-97, 17, h, l, this.window), t.add.image(-97, -2, h, l, this.window), t.add.image(-97, -21, h, l, this.window), t.add.image(-97, -40, h, l, this.window), t.add.image(-97, -59, h, l, this.window)], this.priceLabel = t.add.text(-155, 40, "", {
            font: "Gunplay",
            fontSize: 20,
            fontWeight: "400",
            fill: "#a0a80a"
        }, this.window), this.priceLabel.anchor.set(.5, 0), this.buyButton = null, "minigun" !== s ? (this.refill = i(t, 82, 70, h, "menu/upgrades/parts/buttons/refill", this.refillClick, this, this.window), this.ammoPriceLabel = t.add.text(148, 40, "", {
            font: "Gunplay",
            fontSize: 20,
            fontWeight: "400",
            fill: "#a0a80a"
        }, this.window), this.ammoPriceLabel.anchor.set(.5, 0), this.ammoBackground = t.add.image(137, 28, h, "menu/upgrades/parts/ammo_big.png", this.window), this.ammoBackground.anchor.set(0, 1), this.ammoTitle = t.add.text(148, -74, "Ammo", {
            font: "Gunplay",
            fontSize: 20,
            fontWeight: "400",
            fill: "#a0a80a"
        }, this.window), this.ammoTitle.anchor.set(.5, 0), this.ammoBar = t.add.image(140, 25, h, "menu/upgrades/parts/ammo_bar.png", this.window), this.ammoBar.anchor.set(0, 1), this.ammoBar.scale.x = 1.6) : (this.ammoPriceLabel = null, this.refill = null), this.setLevel(r.current.game[s + "Level"])
    }
    var e = window.AT.common.formatMoney,
        i = window.AT.common.button,
        o = window.AT.common.closeButton,
        s = window.AT.common.flashElement,
        n = window.AT.gui.BaseAlert,
        r = window.AT.profile,
        a = window.AT.SETTINGS,
        h = "menu/upgrades/parts.png",
        l = "menu/upgrades/parts/buttons/off.png",
        d = {
            minigun: "Low damage.\nInfinite ammo.",
            shotgun: "Moderate\nspread damage.",
            ricochet: "Hold fire button\nto charge.\nBounces off walls.",
            flamethrower: "Sets enemies\non fire, dealing\nextra damage.",
            cannon: "Great firepower,\nsplash damage.",
            shock: "Electrocutes\nmultiple enemies.",
            rockets: "Guided rockets.\nWhen fired,\nfollows mouse cursor.",
            laser: "Great damage.\nUninterrupted\nfirepower.",
            railgun: "Piercing projectiles.\nGreat damage.",
            mines: 'Set with "R" key.\nMines won\'t damage\nyour tank.',
            minesTouch: "Set with        button.\nMines won't damage\nyour tank."
        };
    t.prototype = Object.create(n.prototype), t.prototype.setLevel = function(t) {
        if (this.weaponLevel = t, "minigun" !== this.weaponKey && (this.refill.visible = !1, this.ammoPriceLabel.visible = !1, this.ammoBackground.visible = !1, this.ammoTitle.visible = !1, this.ammoBar.visible = !1), t > -1) {
            if (this.window.remove(this.buyButton), this.buyButton = t < 5 ? i(this.game, -200, 70, h, "menu/upgrades/parts/buttons/upgrade", this.buyClick, this, this.window) : null, "minigun" !== this.weaponKey) {
                var o = r.getAmmoPercent(this.weaponKey);
                o < 1 ? (this.refill.visible = !0, this.ammoPriceLabel.text = e(a.AMMO_PRICES[this.weaponKey])) : this.ammoPriceLabel.text = "MAX", this.ammoPriceLabel.visible = !0, this.ammoBackground.visible = !0, this.ammoTitle.visible = !0, this.ammoBar.visible = !0, this.ammoBar.height = 65 * o
            } else t < 5 && (this.buyButton.position.x = -61);
            for (var s = 0; s < this.levels.length; s++) this.levels[s].visible = !0, t > s && this.levels[s].loadTexture(h, "menu/upgrades/parts/buttons/on.png")
        } else {
            for (var s = 0; s < this.levels.length; s++) this.levels[s].visible = !1;
            this.buyButton = i(this.game, -61, 70, h, "menu/upgrades/parts/buttons/buy", this.buyClick, this, this.window)
        }
        this.priceLabel.text = t < 5 ? e(a.PRICES[this.weaponKey][t + 1]) : "MAX"
    }, t.prototype.buyClick = function() {
        this.buyCallback.call(this.context, this.weaponKey) ? (this.setLevel(r.current.game[this.weaponKey + "Level"]), s(this.icon), this.weaponLevel > 0 && s(this.levels[this.weaponLevel - 1]), 0 === this.weaponLevel && ("mines" === this.weaponKey ? r.current.game.helpMinesBought = !0 : r.current.game.helpWeaponBought = !0)) : s(this.priceLabel)
    }, t.prototype.refillClick = function() {
        if (this.refillCallback.call(this.context, this.weaponKey)) {
            var t = r.getAmmoPercent(this.weaponKey);
            this.ammoBar.height = 65 * t, 1 === t && (this.ammoPriceLabel.text = "MAX", this.refill.visible = !1), s(this.ammoBar)
        } else s(this.ammoPriceLabel)
    }, window.AT.gui.BuyUpgradeAlert = t
}(),
function() {
    "use strict";

    function t(t, o) {
        i.call(this, t, o), t.add.image(0, 0, "menu/upgrades/difficulty.png", null, this.window).anchor.set(.5, .5), e(this.game, -104, -40, "menu/upgrades/parts.png", "menu/upgrades/parts/buttons/easy", this.chooseDifficulty.bind(this, 0), this, this.window), e(this.game, -104, 15, "menu/upgrades/parts.png", "menu/upgrades/parts/buttons/medium", this.chooseDifficulty.bind(this, 1), this, this.window), e(this.game, -104, 70, "menu/upgrades/parts.png", "menu/upgrades/parts/buttons/hard", this.chooseDifficulty.bind(this, 2), this, this.window)
    }
    var e = window.AT.common.button,
        i = window.AT.gui.BaseAlert,
        o = window.AT.profile;
    t.onSelect = function() {}, t.prototype = Object.create(i.prototype), t.prototype.chooseDifficulty = function(e) {
        o.current.game.difficulty = e, o.save(), this.hide(), t.onSelect(e)
    }, window.AT.gui.DifficultyAlert = t
}(),
function() {
    "use strict";

    function t(t, e, o, n) {
        i.call(this, t, e), t.add.image(0, 0, "menu/help/" + o + ".png", null, this.window).anchor.set(.5, .5);
        var r = new Phaser.Point;
        "keyboard_moving" === o ? r.set(90, -150) : o.startsWith("touch") && r.set(210, -220), s(t, r.x, r.y, "menu/upgrades/parts.png", "menu/upgrades/parts/buttons", this.hide, this, this.window)
    }

    function e(t, e, s, n, r, a, h) {
        i.call(this, t, e), t.add.image(0, 0, "menu/help/" + s + ".png", null, this.window).anchor.set(.5, .5), o(t, n, r, a, h, this.hide, this, this.window)
    }
    var i = window.AT.gui.BaseAlert,
        o = window.AT.common.button,
        s = window.AT.common.closeButton;
    t.prototype = Object.create(i.prototype), e.prototype = Object.create(i.prototype), window.AT.gui.HelpAlert = t, window.AT.gui.HelpAlertAlt = e
}(),
function() {
    "use strict";

    function t(t, e, i) {
        Phaser.Group.call(this, t, e), this._progress = 1, this.shake = 0, this.shakeGroup = t.make.group(this), t.add.image(2, 0, "game.png", "game/hud/bar_empty.png", this.shakeGroup), this.bar = t.add.image(2, 0, "game.png", i, this.shakeGroup), this.bar.crop(new Phaser.Rectangle(0, 0, 106, 21), !1), t.add.image(0, 0, "game.png", "game/hud/bar_frame.png", this.shakeGroup)
    }
    t.prototype = Object.create(Phaser.Group.prototype), t.prototype.updateProgress = function(t, e) {
        this.progress = t, this.shake = e
    }, t.prototype.update = function() {
        this.shake > 0 ? (this.shakeGroup.position.set(-this.shake + 2 * this.shake * Math.random(), -this.shake + 2 * this.shake * Math.random()), this.shake -= 12 * this.game.time.physicsElapsed) : this.shakeGroup.position.set(0, 0)
    }, Object.defineProperties(t.prototype, {
        progress: {
            set: function(t) {
                (t = Math.min(Math.max(t, 0), 1)) !== this._progress && (this._progress = t, this.bar.cropRect.width = 106 * t, this.bar.updateCrop())
            },
            get: function() {
                return this._progress
            }
        }
    }), window.AT.gui.Vial = t
}(),
function() {
    "use strict";

    function t(t, e) {
        this.normalFrame = "game/hud/" + e + ".png", this.activeFrame = "game/hud/" + e + "_active.png", Phaser.Button.call(this, t, 0, 0, "game.png", null, null, null, this.normalFrame, null, null), this._tank = null, this._weapon = null, this.active = !1, this.ammoBar = t.make.image(0, 0, "game.png", "game/hud/bar_ammo_small.png"), this.ammoBar.anchor.set(1, 1), this.ammoBar.position.set(51, 37), this.addChild(this.ammoBar), this.lastAmmo = -1
    }
    t.prototype = Object.create(Phaser.Button.prototype), t.prototype.shutdown = function() {
        this.inputEnabled = !1
    }, t.prototype.update = function() {
        null != this._weapon ? (this.alpha = 1,
            this.active || this._tank.weapon !== this._weapon ? this.active && this._tank.weapon !== this._weapon && (this.setFrames(this.normalFrame, this.normalFrame, this.normalFrame, this.normalFrame), this.active = !1) : (this.setFrames(this.activeFrame, this.activeFrame, this.activeFrame, this.activeFrame), this.active = !0), this.lastAmmo !== this._weapon.ammo && this._weapon.maxAmmo !== 1 / 0 && (this.ammoBar.scale.y = this._weapon.ammo / this._weapon.maxAmmo, this.lastAmmo = this._weapon.ammo)) : (this.alpha = .5, this.ammoBar.scale.y = 0)
    }, Object.defineProperties(t.prototype, {
        weapon: {
            get: function() {
                return this._weapon
            },
            set: function(t) {
                this._weapon = t, t && (this._tank = t.tank)
            }
        }
    }), window.AT.gui.Weapon = t
}(),
function() {
    "use strict";

    function t(t, e, i, o, s) {
        Phaser.Sprite.call(this, t, e, i, o, s), this.anchor.set(.5, .5), this.inputEnabled = !0, this.input.useHandCursor = !0, this.events.onInputOver.add(this.pointerOver, this), this.events.onInputOut.add(this.pointerOut, this)
    }

    function e(e, i, o, s, n, r, a, h, l) {
        t.call(this, e, i, o, s, a ? r : n), this.onFrame = r, this.offFrame = n, this._checked = !!a, this.callback = h, this.context = l, this.events.onInputUp.add(this.click, this)
    }
    t.prototype = Object.create(Phaser.Sprite.prototype), t.prototype.pointerOver = function() {
        this.scale.set(1.2, 1.2)
    }, t.prototype.pointerOut = function() {
        this.scale.set(1, 1)
    }, t.prototype.shutdown = function() {
        this.inputEnabled = !1
    }, e.prototype = Object.create(t.prototype), e.prototype.click = function() {
        this.checked = !this.checked, this.callback && this.callback.call(this.context, this._checked)
    }, Object.defineProperties(e.prototype, {
        checked: {
            get: function() {
                return this._checked
            },
            set: function(t) {
                this._checked != t && (this._checked = !!t, this.loadTexture(this.key, t ? this.onFrame : this.offFrame))
            }
        }
    }), window.AT.gui.Icon = t, window.AT.gui.CheckboxIcon = e
}(),
function() {
    "use strict";

    function t(t, e, i, o, s, n, r) {
        Phaser.Group.call(this, t, e), this._checked = !1, this.key = i, this.iconOff = o, this.iconOn = s, this.bulletOff = n, this.bulletOn = r, this.icon = t.add.sprite(0, -12, i, o, this), this.icon.anchor.set(.5, 1), this.icon.inputEnabled = !0, this.icon.input.useHandCursor = !0, this.icon.events.onInputDown.add(this.toggle, this), this.bullet = t.add.sprite(0, 0, i, n, this), this.bullet.anchor.set(.5, .5), this.bullet.inputEnabled = !0, this.bullet.input.useHandCursor = !0, this.bullet.events.onInputDown.add(this.toggle, this), this.onToggle = null
    }
    t.prototype = Object.create(Phaser.Group.prototype), t.prototype.shutdown = function() {
        this.icon.inputEnabled = !1, this.bullet.inputEnabled = !1
    }, t.prototype.toggle = function() {
        this.checked = !this.checked, this.onToggle && this.onToggle(this.checked)
    }, Object.defineProperties(t.prototype, {
        checked: {
            get: function() {
                return this._checked
            },
            set: function(t) {
                t !== this._checked && (this._checked = t, this.icon.loadTexture(this.key, t ? this.iconOn : this.iconOff), this.bullet.loadTexture(this.key, t ? this.bulletOn : this.bulletOff))
            }
        }
    }), window.AT.gui.Checkbox = t
}(),
function() {
    "use strict";

    function t(t, e, i, o, s, n, r, a) {
        o = "menu/upgrades/parts/" + o + ".png", Phaser.Button.call(this, t, e, i, "menu/upgrades/parts.png", n, r, o, o, o, o), this.upgradeLevel = s, this.gauge = t.make.image(9, 9, "menu/upgrades/parts.png", "menu/upgrades/parts/gauge_" + s + ".png"), this.addChild(this.gauge), a && a.add ? a.add(this) : a && a.addChild && a.addChild(this), 5 === s && (this.inputEnabled = !1)
    }
    var e = window.AT.common.flashElement;
    t.prototype = Object.create(Phaser.Button.prototype), t.prototype.increase = function() {
        this.upgradeLevel < 5 && (e(this), e(this.gauge), this.upgradeLevel += 1, this.gauge.loadTexture("menu/upgrades/parts.png", "menu/upgrades/parts/gauge_" + this.upgradeLevel + ".png"), 5 === this.upgradeLevel && (this.inputEnabled = !1))
    }, window.AT.gui.Gauge = t
}(),
function() {
    "use strict";

    function t(t, e, i, s, a, h, l, d, c) {
        Phaser.Group.call(this, t, c), this.position.set(e, i), this.cancelClick = !1, this.clickCallback = h, this.holdCallback = l, this.callbackContext = d, this.frameName = s, this.weaponButton = t.add.button(0, 0, n, null, this, null, "menu/upgrades/parts/frame.png", null, null, this), this.weaponButton.onInputDown.add(this.startHold, this), this.weaponButton.onInputUp.add(this.stopHold, this), this.weaponButton.onInputOut.add(this.stopHold, this), this.weaponButton.onInputUp.add(this.click, this), this.holdEvent = null, this.title = t.add.text(47, 4, a, {
            font: "Gunplay",
            fontWeight: "400",
            fontSize: 12,
            fill: "#E9B300"
        }, this), this.title.anchor.set(.5, 0), this.levels = [t.make.image(62, 63, n, r), t.make.image(62, 52.5, n, r), t.make.image(62, 42, n, r), t.make.image(62, 31.5, n, r), t.make.image(62, 21, n, r)];
        for (var p = 0; p < this.levels.length; p++) this.levels[p].visible = !1, this.levels[p].scale.set(.5, .5), this.weaponButton.addChild(this.levels[p]);
        this.icon = t.make.image(21, 20, n, "menu/upgrades/parts/" + s + ".png"), this.icon.scale.set(50 / 90, 50 / 90), this.weaponButton.addChild(this.icon), this.weaponPrice = t.add.text(46, 86, "", null, this), this.weaponPrice.anchor.set(.5, 0), this.weaponPrice.font = "Gunplay", this.weaponPrice.fontWeight = "400", this.weaponPrice.fontSize = 21, this.weaponPrice.fill = "#E9B300", "minigun" !== s ? (this.ammoBackground = t.make.image(73, 70, n, "menu/upgrades/parts/ammo_small.png"), this.ammoBackground.anchor.set(0, 1), this.ammoBackground.visible = !1, this.weaponButton.addChild(this.ammoBackground), this.ammoBar = t.make.image(75, 68, n, "menu/upgrades/parts/ammo_bar.png"), this.ammoBar.anchor.set(0, 1), this.ammoBar.scale.x = .8, this.ammoBar.visible = !1, this.weaponButton.addChild(this.ammoBar), this.setAmmoPercent(o.getAmmoPercent(s))) : (this.ammoBackground = null, this.ammoBar = null), this.setLevel(o.current.game[s + "Level"])
    }
    var e = window.AT.SETTINGS,
        i = window.AT.common.formatMoney,
        o = window.AT.profile,
        s = window.AT.audio,
        n = "menu/upgrades/parts.png",
        r = "menu/upgrades/parts/buttons/off.png";
    t.prototype = Object.create(Phaser.Group.prototype), t.prototype.setAmmoPercent = function(t) {
        this.ammoBar.height = 44 * t
    }, t.prototype.setLevel = function(t) {
        if (this.upgradeLevel = t, t >= 0) {
            this.ammoBar && (this.ammoBackground.visible = this.ammoBar.visible = !0);
            for (var o = 0; o < this.levels.length; o++) this.levels[o].visible = !0, o < t && this.levels[o].loadTexture(n, "menu/upgrades/parts/buttons/on.png");
            this.icon.position.x = 8, 5 === t && "minigun" === this.frameName && (this.weaponButton.inputEnabled = !1)
        }
        this.weaponPrice.text = t < 5 ? i(e.PRICES[this.frameName][t + 1]) : "MAX"
    }, t.prototype.click = function() {
        this.cancelClick ? this.cancelClick = !1 : (s.playButtonUp(), this.clickCallback.call(this.callbackContext, this.frameName))
    }, t.prototype.startHold = function() {
        s.playButtonDown(), this.upgradeLevel >= 0 && "minigun" !== this.frameName && (null !== this.holdEvent && this.stopHold(), this.holdEvent = this.game.time.events.loop(333, this.hold, this))
    }, t.prototype.hold = function() {
        this.cancelClick = !0, this.holdCallback.call(this.callbackContext, this.frameName)
    }, t.prototype.stopHold = function() {
        null !== this.holdEvent && (this.game.time.events.remove(this.holdEvent), this.holdEvent = null)
    }, window.AT.gui.UpgradeableWeapon = t
}(),
function() {
    "use strict";

    function t(t, i, o, s, n, r) {
        Phaser.Group.call(this, t, i), this.overlay = t.make.image(0, 0, "game.png", "game/alerts/overlay.png"), this.overlay.alpha = .5, this.overlay.inputEnabled = !0, this.add(this.overlay), this.window = t.make.image(0, 0, "game.png", "game/alerts/abandon.png"), this.window.anchor.set(.5, .5), this.add(this.window), this.abandonButton = e(this.game, -133, 40, "game.png", "game/buttons/yes", o, s, this.window), this.cancelButton = e(this.game, 5, 40, "game.png", "game/buttons/no", n, r, this.window), this.alpha = 0, this.game.add.tween(this).to({
            alpha: 1
        }, 250, Phaser.Easing.Linear.None, !0), this.resize(), this.resize = this.resize.bind(this), window.addEventListener("resize", this.resize)
    }
    var e = window.AT.common.button;
    t.prototype = Object.create(Phaser.Group.prototype), t.prototype.resize = function() {
        var t = Math.max(.8, Math.min(window.innerWidth / 600, window.innerHeight / 600));
        this.scale.set(t, t), this.overlay.width = window.innerWidth / t, this.overlay.height = window.innerHeight / t, this.window.position.set(.5 * window.innerWidth / t, .5 * window.innerHeight / t)
    }, t.prototype.hide = function() {
        this.game.add.tween(this).to({
            alpha: 0
        }, 250, Phaser.Easing.Linear.None, !0).onComplete.addOnce(this.shutdown, this)
    }, t.prototype.shutdown = function() {
        window.removeEventListener("resize", this.resize), this.overlay.inputEnabled = !1, this.abandonButton.inputEnabled = !1, this.cancelButton.inputEnabled = !1, this.parent.removeChild(this)
    }, window.AT.gui.AbandonAlert = t
}(),
function() {
    "use strict";

    function t(t, i, s, n, r, a) {
        Phaser.Group.call(this, t, i), this.onContinue = r, this.onContinueContext = a, this.overlay = t.make.image(0, 0, "game.png", "game/alerts/overlay.png"), this.overlay.alpha = .5, this.overlay.inputEnabled = !0, this.add(this.overlay), this.window = t.add.group(this), this.header = t.make.image(0, -200, "game.png", s ? "game/summary/header_complete.png" : "game/summary/header_failed.png"), this.header.alpha = 0, this.header.anchor.set(.5, .5), this.window.add(this.header), this.profit = t.make.image(0, -10, "game.png", "game/summary/profit.png"), this.profit.alpha = 0, this.profit.anchor.set(.5, .5), this.window.add(this.profit), this.profitValue = t.make.text(132, 4, ""), this.profitValue.anchor.set(1, .5), this.profitValue.font = "Gunplay", this.profitValue.fontWeight = "400", this.profitValue.fontSize = 34, this.profitValue.fill = "#FFA700", this.profit.addChild(this.profitValue), this.updateProfit(n), s ? this.continueButton = null : (this.continueButton = e(t, 0, 275, "game.png", "game/buttons/continue", this.continue, this, this.window), this.continueButton.alpha = 0, this.continueButton.anchor.set(.5, .5), t.add.tween(this.continueButton).to({
            y: 175,
            alpha: 1
        }, 250, Phaser.Easing.Quadratic.Out, !0, 2775)), this.alpha = 0, this.game.add.tween(this).to({
            alpha: 1
        }, 250, Phaser.Easing.Linear.None, !0, 2e3), this.resize(), t.add.tween(this.header).to({
            y: -100,
            alpha: 1
        }, 250, Phaser.Easing.Quadratic.Out, !0, 2250), t.add.tween(this.profit).to({
            y: 90,
            alpha: 1
        }, 250, Phaser.Easing.Quadratic.Out, !0, 2425), s && t.time.events.add(4500, this.continue, this), o.stopMusic(), o.playSound(s ? "level_won.mp3" : "level_lost.mp3"), this.resize = this.resize.bind(this), window.addEventListener("resize", this.resize)
    }
    var e = window.AT.common.button,
        i = window.AT.common.formatMoney,
        o = window.AT.audio;
    t.prototype = Object.create(Phaser.Group.prototype), t.prototype.updateProfit = function(t) {
        this.profitValue.text = t >= 1e5 ? i(Math.floor(t / 1e3)) + "k" : i(t)
    }, t.prototype.resize = function() {
        var t = Math.min(window.innerWidth / 600, window.innerHeight / 600);
        this.scale.set(t, t), this.overlay.width = window.innerWidth / t, this.overlay.height = window.innerHeight / t, this.window.position.set(.5 * window.innerWidth / t, .5 * window.innerHeight / t)
    }, t.prototype.continue = function() {
        var t = (.5 * window.innerWidth + 300) / this.scale.x;
        this.game.add.tween(this.header).to({
            x: t
        }, 700, Phaser.Easing.Back.In, !0, 0), this.game.add.tween(this.profit).to({
            x: -t
        }, 700, Phaser.Easing.Back.In, !0, 200), this.continueButton && this.game.add.tween(this.continueButton).to({
            y: .6 * window.innerHeight / this.scale.y
        }, 700, Phaser.Easing.Back.In, !0, 100);
        var e = this.game.add.tween(this.overlay).to({
            alpha: 1
        }, 250, Phaser.Easing.Linear.None, !0, 900);
        this.onContinue && e.onComplete.add(this.onContinue, this.onContinueContext)
    }, t.prototype.shutdown = function() {
        window.removeEventListener("resize", this.resize), this.overlay.inputEnabled = !1, this.continueButton && (this.continueButton.inputEnabled = !1), this.parent.removeChild(this)
    }, window.AT.gui.SummaryAlert = t
}(),
function() {
    "use strict";

    function t(t, e) {
        Phaser.Group.call(this, t, e), this.fight = t.add.image(0, 0, "game.png", "game/hud/fight.png", this), this.fight.anchor.set(.5, .5), this.fight.visible = !1, this.fightMessageComplete = !1, this.profitBg = t.add.image(-118, -65, "game.png", "game/hud/profit.png", this), this._hideProfit(), this.profitValue = t.make.text(204, 17, "0$"), this.profitValue.anchor.set(1, .5), this.profitValue.font = "Gunplay", this.profitValue.fontWeight = "400", this.profitValue.fontSize = 20, this.profitValue.fill = "#DBB400", this.profitBg.addChild(this.profitValue), this.profitShowTween = null, this.profitHideTween = null, this.profitDisplayTime = 0, this.bg = t.add.image(0, 0, "game.png", "game/hud/background.png", this), this.bg.anchor.set(.5, 1), this.bg.inputEnabled = !0, this.healthVial = new r(t, this, "game/hud/bar_health.png"), this.healthVial.position.set(-240, -80), this.minigun = new a(t, "minigun"), this.minigun.position.set(-287.5, -52), this.add(this.minigun), this.shotgun = new a(t, "shotgun"), this.shotgun.position.set(-229.5, -52), this.add(this.shotgun), this.flamethrower = new a(t, "flamethrower"), this.flamethrower.position.set(-112.5, -52), this.add(this.flamethrower), this.ricochet = new a(t, "ricochet"), this.ricochet.position.set(-171.5, -52), this.add(this.ricochet), this.cannon = new a(t, "cannon"), this.cannon.position.set(-54.5, -51), this.add(this.cannon), this.shock = new a(t, "shock"), this.shock.position.set(3.5, -50), this.add(this.shock), this.rockets = new a(t, "rockets"), this.rockets.position.set(59.5, -49), this.add(this.rockets), this.laser = new a(t, "laser"), this.laser.position.set(117.5, -48), this.add(this.laser), this.railgun = new a(t, "railgun"), this.railgun.position.set(175.5, -47), this.add(this.railgun), this.mines = new a(t, "mines"), this.mines.position.set(233.5, -49), this.add(this.mines), this.menuButton = i(t, 205, -90, "game.png", "game/buttons/menu", null, this, this), this.helpIcon = new h(t, 193, -73, "game.png", "game/hud/help.png"), this.add(this.helpIcon), this.pauseIcon = new h(t, 170, -73, "game.png", "game/hud/pause.png"), this.add(this.pauseIcon), this.musicIcon = new l(t, 145, -73, "game.png", "game/hud/music_off.png", "game/hud/music_on.png", s.current.game.music, n.toggleMusic), this.add(this.musicIcon), this.soundIcon = new l(t, 115, -73, "game.png", "game/hud/sound_off.png", "game/hud/sound_on.png", s.current.game.sound, n.toggleSound), this.add(this.soundIcon)
    }
    var e = window.Phaser.Easing.Exponential,
        i = window.AT.common.button,
        o = window.AT.common.formatMoney,
        s = window.AT.profile,
        n = window.AT.audio,
        r = window.AT.gui.Vial,
        a = window.AT.gui.Weapon,
        h = window.AT.gui.Icon,
        l = window.AT.gui.CheckboxIcon;
    t.prototype = Object.create(Phaser.Group.prototype), t.prototype.setTank = function(t) {
        this.minigun.weapon = t.weapons[0], this.shotgun.weapon = t.weapons[1], this.ricochet.weapon = t.weapons[2], this.flamethrower.weapon = t.weapons[3], this.cannon.weapon = t.weapons[4], this.shock.weapon = t.weapons[5], this.rockets.weapon = t.weapons[6], this.laser.weapon = t.weapons[7], this.railgun.weapon = t.weapons[8], this.mines.weapon = t.mines
    }, t.prototype.showFightMessage = function() {
        var t = window.innerHeight / this.parent.scale.y / 600,
            i = this.fight;
        i.position.y = -700 * t, i.visible = !0;
        var o = this.game.add.tween(i.position).to({
                y: -450 * t
            }, 600, e.Out, !0, 500),
            s = this.game.add.tween(i.position).to({
                y: 100 * t
            }, 500, e.In, !1, 1300);
        s.onComplete.addOnce(this.hideFightMessage, this), o.chain(s)
    }, t.prototype.hideFightMessage = function() {
        this.fight.visible = this.fight.exists = !1, this.fightMessageComplete = !0
    }, t.prototype.showProfit = function(t) {
        this.profitValue.text = o(t), this.profitDisplayTime = 1.5, this.profitHideTween && (this.profitHideTween.stop(), this.profitHideTween = null), this.profitShowTween || (this.profitBg.visible = this.profitBg.exists = !0, this.profitShowTween = this.game.add.tween(this.profitBg.position).to({
            y: -95
        }, 300, Phaser.Easing.Cubic.Out, !0))
    }, t.prototype._hideProfit = function() {
        this.profitBg.visible = this.profitBg.exists = !1
    }, t.prototype.hideProfit = function() {
        this.profitHideTween || (this.profitShowTween = null, this.profitHideTween = this.game.add.tween(this.profitBg.position).to({
            y: -65
        }, 300, Phaser.Easing.Cubic.In, !0), this.profitHideTween.onComplete.add(this._hideProfit, this))
    }, t.prototype.pointerOver = function(t) {
        return this.bg.input.pointerOver(t) || this.menuButton.input.pointerOver(t) || this.helpIcon.input.pointerOver(t) || this.pauseIcon.input.pointerOver(t) || this.musicIcon.input.pointerOver(t) || this.soundIcon.input.pointerOver(t) || this.minigun.input.pointerOver(t) || this.shotgun.input.pointerOver(t) || this.ricochet.input.pointerOver(t) || this.flamethrower.input.pointerOver(t) || this.cannon.input.pointerOver(t) || this.shock.input.pointerOver(t) || this.rockets.input.pointerOver(t) || this.laser.input.pointerOver(t) || this.railgun.input.pointerOver(t) || this.mines.input.pointerOver(t)
    }, t.prototype.pointerDown = function(t) {
        return this.bg.input.pointerDown(t) || this.menuButton.input.pointerDown(t) || this.helpIcon.input.pointerDown(t) || this.pauseIcon.input.pointerDown(t) || this.soundIcon.input.pointerDown(t) || this.musicIcon.input.pointerDown(t) || this.minigun.input.pointerDown(t) || this.shotgun.input.pointerDown(t) || this.ricochet.input.pointerDown(t) || this.flamethrower.input.pointerDown(t) || this.cannon.input.pointerDown(t) || this.shock.input.pointerDown(t) || this.rockets.input.pointerDown(t) || this.laser.input.pointerDown(t) || this.railgun.input.pointerDown(t) || this.mines.input.pointerDown(t)
    }, t.prototype.update = function() {
        Phaser.Group.prototype.update.call(this), this.profitDisplayTime > 0 && (this.profitDisplayTime -= this.game.time.physicsElapsed, this.profitDisplayTime <= 0 && this.hideProfit())
    }, t.prototype.shutdown = function() {
        this.menuButton.inputEnabled = !1, this.bg.inputEnabled = !1, this.helpIcon.shutdown(), this.pauseIcon.shutdown(), this.soundIcon.shutdown(), this.musicIcon.shutdown(), this.minigun.shutdown(), this.shotgun.shutdown(), this.ricochet.shutdown(), this.flamethrower.shutdown(), this.cannon.shutdown(), this.shock.shutdown(), this.rockets.shutdown(), this.laser.shutdown(), this.railgun.shutdown(), this.mines.shutdown()
    }, window.AT.gui.HUD = t
}(),
function() {
    "use strict";
    window.AT.menu = {}
}(),
function() {
    "use strict";

    function t() {
        this.name = "Site lock", this.root = null
    }
    window.AT.SITE_LOCK_TARGET;
    t.prototype.preload = function() {
        this.load.atlasJSONHash("lock.png", "images/lock.png", "images/lock.json")
    }, t.prototype.create = function() {
        this.stage.backgroundColor = 0, this.root = this.add.group(), this.add.image(300, 400, "lock.png", "lock/message.png", this.root).anchor.set(.5, 1), this.add.button(300, 420, "lock.png", this.playClick, this, "lock/button_hover.png", "lock/button.png", "lock/button.png", "lock/button.png", this.root).anchor.set(.5, .5), this.camera.bounds = null, this.resize(window.innerWidth, window.innerHeight), this.camera.flash(0, 250)
    }, t.prototype.playClick = function() {
        window.location = AT.SITE_LOCK_TARGET
    }, t.prototype.resize = function(t, e) {
        if (this.root) {
            var i = Math.min(t / 600, e / 600);
            this.camera.setSize(t, e), this.root.scale.set(i), this.root.position.x = t / 2 - 300 * i, this.root.position.y = e / 2 - 300 * i
        }
    }, window.AT.menu.Lock = t
}(),
function() {
    "use strict";

    function t() {
        this.name = "Loading", this.root = null, this._allLoaded = !1, this._allDecoded = !1
    }
    var e = window.AT.common.button,
        i = window.AT.common.padTileFrame,
        o = window.AT.audio,
        s = ["achievement.mp3", "ammo.mp3", "bricks.mp3", "bomb.mp3", "bullet_hit.mp3", "button_off.mp3", "button_on.mp3", "buy.mp3", "cannon.mp3", "coin.mp3", "crate_hit.mp3", "crate_kill.mp3", "enemy_hit_1.mp3", "enemy_hit_2.mp3", "enemy_hit_3.mp3", "explosion.mp3", "flame_loop.mp3", "flame_start.mp3", "freeze.mp3", "health.mp3", "laser_loop.mp3", "laser_start.mp3", "level.mp3", "level_lost.mp3", "level_won.mp3", "mine.mp3", "minigun.mp3", "mouth_pop.mp3", "music_congratulations.mp3", "music_game.mp3", "music_menu.mp3", "not_available.mp3", "railgun.mp3", "ricochet_bounce.mp3", "ricochet_loop.mp3", "ricochet_shot.mp3", "ricochet_start.mp3", "rocket.mp3", "shock_loop.mp3", "shotgun.mp3", "spawner_hit_1.mp3", "spawner_hit_2.mp3", "spawner_hit_3.mp3", "unfreeze.mp3", "weapon_change.mp3"];
    t.prototype.init = function() {
        this._allLoaded = !1, this._allDecoded = !1
    }, t.prototype.preload = function() {
        this.load.atlasJSONHash("menu/loading.png", "images/menu/loading.png", "images/menu/loading.json")
    }, t.prototype.create = function() {
        this.stage.backgroundColor = 0, o.init(this.game), this.root = this.add.group(), this.add.image(0, -20, "menu/loading.png", "menu/loading/tank.png", this.root).anchor.set(.5, .5), this.add.image(-53, 118, "menu/loading.png", "menu/loading/bar_empty.png", this.root), this.progress = this.add.image(-53, 118, "menu/loading.png", "menu/loading/bar_ammo.png", this.root), this.progress.crop(new Phaser.Rectangle(0, 0, 0, 21), !1), this.add.image(-54.5, 118, "menu/loading.png", "menu/loading/bar_frame.png", this.root), this.playButton = e(this.game, 0, 115, "menu/loading.png", "menu/loading/buttons/play", this.playClick, this, this.root), this.playButton.anchor.set(.5, .5), this.playButton.visible = !1, this.camera.bounds = null, this.resize(window.innerWidth, window.innerHeight), setTimeout(this.loadAssets.bind(this), 500)
    }, t.prototype.loadAssets = function() {
        this.load.onFileComplete.add(this.fileLoaded, this), this.load.onLoadComplete.add(this.allLoaded, this), this.load.shader("add_tint.frag", "scripts/shaders/add_tint.frag"), this.load.shader("grayscale.frag", "scripts/shaders/grayscale.frag"), this.load.shader("inverse_alpha.frag", "scripts/shaders/inverse_alpha.frag"), this.load.image("menu/logo.jpg", "images/menu/logo.jpg"), this.load.atlasJSONHash("game.png", "images/game.png", "images/game.json"), this.load.atlasJSONHash("menu/title/parts.png", "images/menu/title/parts.png", "images/menu/title/parts.json"), this.load.image("menu/title/background.png", "images/menu/title/background.png"), this.load.atlasJSONHash("menu/upgrades/parts.png", "images/menu/upgrades/parts.png", "images/menu/upgrades/parts.json"), this.load.image("menu/upgrades/background.png", "images/menu/upgrades/background.png"), this.load.image("menu/upgrades/stats.png", "images/menu/upgrades/stats.png"), this.load.image("menu/upgrades/difficulty.png", "images/menu/upgrades/difficulty.png"), this.load.image("menu/upgrades/performance.png", "images/menu/upgrades/performance.png"), this.load.image("menu/upgrades/weapons.png", "images/menu/upgrades/weapons.png"), this.load.image("menu/upgrades/upgrade.png", "images/menu/upgrades/upgrade.png"), this.load.atlasJSONHash("menu/levels.png", "images/menu/levels.png", "images/menu/levels.json"), this.load.image("menu/congratulations.png", "images/menu/congratulations.png"), this.game.device.touch ? (this.load.image("menu/help/touch.png", "images/menu/help/touch.png"), this.load.image("menu/help/touch_auto_aim.png", "images/menu/help/touch_auto_aim.png"), this.load.image("menu/help/touch_moving.png", "images/menu/help/touch_moving.png"), this.load.image("menu/help/touch_shooting.png", "images/menu/help/touch_shooting.png"), this.load.image("menu/help/touch_weapons_mines.png", "images/menu/help/touch_weapons_mines.png"), this.load.image("menu/help/touch_weapons.png", "images/menu/help/touch_weapons.png"), this.load.image("menu/help/touch_mines.png", "images/menu/help/touch_mines.png")) : (this.load.image("menu/help/keyboard.png", "images/menu/help/keyboard.png"), this.load.image("menu/help/keyboard_moving.png", "images/menu/help/keyboard_moving.png"), this.load.image("menu/help/keyboard_weapons_mines.png", "images/menu/help/keyboard_weapons_mines.png"), this.load.image("menu/help/keyboard_weapons.png", "images/menu/help/keyboard_weapons.png"), this.load.image("menu/help/keyboard_mines.png", "images/menu/help/keyboard_mines.png"));
        for (var t = 0; t < s.length; t++) this.load.audio(s[t], "sounds/" + s[t]);
        this.load.start()
    }, t.prototype.fileLoaded = function(t, e, i, o, s) {
        this.progress.cropRect.width = 106 * t / 100, this.progress.updateCrop()
    }, t.prototype.playClick = function() {
        this.state.start("MenuBoot");
        try {
            window.cmgGameEvent ? window.cmgGameEvent("start") : window.parent.cmgGameEvent && window.parent.cmgGameEvent("start")
        } catch (t) {}
    }, t.prototype.allLoaded = function() {
        this.sound.setDecodedCallback(s, this.go, this)
    }, t.prototype.go = function() {
        this.game.renderer.spriteBatch.defaultShader = new PIXI.AbstractFilter(this.cache.getShader("add_tint.frag")), this.game.renderer.spriteBatch.setContext(this.game.renderer.gl), i(this.cache.getFrameByName("game.png", "game/grass.png")), i(this.cache.getFrameByName("game.png", "game/snow.png")), i(this.cache.getFrameByName("game.png", "game/desert.png")), i(this.cache.getFrameByName("game.png", "game/wall_0.png")), i(this.cache.getFrameByName("game.png", "game/wall_1.png")), i(this.cache.getFrameByName("game.png", "game/wall_2.png")), i(this.cache.getFrameByName("game.png", "game/secret.png")), i(this.cache.getFrameByName("game.png", "game/alerts/overlay.png")), this.playButton.visible = !0
    }, t.prototype.resize = function(t, e) {
        if (this.root) {
            var i = Math.min(t / 600, e / 600);
            this.camera.setSize(t, e), this.root.scale.set(i), this.root.position.x = t / 2, this.root.position.y = e / 2
        }
    }, t.prototype.shutdown = function() {
        this.load.onFileComplete.remove(this.fileLoaded, this), this.load.onLoadComplete.remove(this.allLoaded, this), this.cache.removeImage("menu/loading.png")
    }, window.AT.menu.Loading = t
}(),
function() {
    "use strict";

    function t() {
        this.name = "Boot", this.root = null
    }
    window.AT.common.button, window.AT.profile;
    t.prototype.create = function() {
        this.stage.backgroundColor = 0, this.root = this.add.group();
        var t = this.add.image(300, 300, "menu/logo.jpg", null, this.root);
        t.anchor.set(.5, .5), t.inputEnabled = !0, this.add.tween(t).to({
            alpha: 0
        }, 250, Phaser.Easing.Linear.None, !0, 2e3).onComplete.add(this.next, this), this.camera.bounds = null, this.camera.flash(0, 250), this.resize(window.innerWidth, window.innerHeight)
    }, t.prototype.next = function() {
        this.state.start("MenuTitle")
    }, t.prototype.resize = function(t, e) {
        if (this.root) {
            var i = Math.min(t / 600, e / 600);
            this.camera.setSize(t, e), this.root.scale.set(i), this.root.position.x = t / 2 - 300 * i, this.root.position.y = e / 2 - 300 * i
        }
    }, window.AT.menu.Boot = t
}(),
function() {
    "use strict";

    function t() {
        this.name = "Title", this.root = null
    }
    var e = window.AT.common.button,
        i = window.AT.common.calculateHitColor,
        o = window.AT.profile,
        s = window.AT.audio,
        n = window.AT.gui.CreditsAlert,
        r = window.AT.gui.Checkbox,
        a = "menu/title/parts.png";
    t.prototype.create = function() {
        this.sound.muteOnPause = !0, this.stage.backgroundColor = 621368, this.root = this.add.group(), this.add.image(-5, -10, "menu/title/background.png", null, this.root).anchor.set(.5, .5), e(this.game, -290, 257, a, "menu/title/parts/buttons/about", this.showCredits, this, this.root), this.logo = this.add.image(0, -130, a, "menu/title/parts/logo.png", this.root), this.logo.anchor.set(.5, .5), this.logo.scale.set(1.5, 1.5), this.logo.tint = 0, this.logo.alpha = 0, this.add.tween(this.logo).to({
            alpha: 1
        }, 100, Phaser.Easing.Linear.None, !0, 300), this.add.tween(this.logo.scale).to({
            x: 1,
            y: 1
        }, 200, Phaser.Easing.Linear.None, !0, 300), this.time.events.add(300, this.playMouthPop), this.tank = this.add.image(40, 80, a, "menu/title/parts/tank.png", this.root), this.tank.anchor.set(.5, .5), this.tank.scale.set(1.5, 1.5), this.tank.tint = 0, this.tank.alpha = 0, this.add.tween(this.tank).to({
            alpha: 1
        }, 100, Phaser.Easing.Linear.None, !0, 600), this.add.tween(this.tank.scale).to({
            x: 1,
            y: 1
        }, 200, Phaser.Easing.Linear.None, !0, 600), this.time.events.add(600, this.playMouthPop), this.upgrades = this.add.image(148, -40, a, "menu/title/parts/upgrades.png", this.root), this.upgrades.anchor.set(.5, .5), this.upgrades.scale.set(1.5, 1.5), this.upgrades.tint = 0, this.upgrades.alpha = 0, this.add.tween(this.upgrades).to({
            alpha: 1
        }, 100, Phaser.Easing.Linear.None, !0, 900), this.add.tween(this.upgrades.scale).to({
            x: 1,
            y: 1
        }, 200, Phaser.Easing.Linear.None, !0, 900), this.time.events.add(900, this.playMouthPop), this.soundCheckbox = new r(this.game, this.root, a, "menu/title/parts/buttons/sound_off.png", "menu/title/parts/buttons/sound_on.png", "menu/title/parts/buttons/off.png", "menu/title/parts/buttons/on.png"), this.soundCheckbox.position.set(240, -249), this.soundCheckbox.checked = o.current.game.sound, this.soundCheckbox.onToggle = s.toggleSound, this.musicCheckbox = new r(this.game, this.root, a, "menu/title/parts/buttons/music_off.png", "menu/title/parts/buttons/music_on.png", "menu/title/parts/buttons/off.png", "menu/title/parts/buttons/on.png"), this.musicCheckbox.position.set(278, -249), this.musicCheckbox.checked = o.current.game.music, this.musicCheckbox.onToggle = s.toggleMusic, this.add.image(285, 285, a, "menu/title/parts/water_flame.png", this.root).anchor.set(1, 1), e(this.game, -102, 134, a, "menu/title/parts/buttons/play", this.playClick, this, this.root), this.camera.bounds = null, this.resize(window.innerWidth, window.innerHeight), this.camera.flash(0, 250), s.playMusic("music_menu.mp3", .75)
    }, t.prototype.resize = function(t, e) {
        if (this.root) {
            var i = Math.min(t / 600, e / 600);
            this.camera.setSize(t, e), this.root.scale.set(i), this.root.position.x = t / 2, this.root.position.y = e / 2
        }
    }, t.prototype.showCredits = function() {
        new n(this.game)
    }, t.prototype.playMouthPop = function() {
        s.playSound("mouth_pop.mp3")
    }, t.prototype.playClick = function() {
        this.camera.fade(0, 250), this.camera.onFadeComplete.addOnce(this.next, this);
        try {
            window.cmgGameEvent ? window.cmgGameEvent("start") : window.parent.cmgGameEvent && window.parent.cmgGameEvent("start")
        } catch (t) {}
    }, t.prototype.next = function() {
        this.state.start("MenuUpgrades")
    }, t.prototype.update = function() {
        this.camera.setPosition(0, 0), this.logo.tint = i(16777215, 1 - this.logo.alpha), this.tank.tint = i(16777215, 1 - this.tank.alpha), this.upgrades.tint = i(16777215, 1 - this.upgrades.alpha)
    }, window.AT.menu.Title = t
}(),
function() {
    "use strict";

    function t() {
        this.name = "Upgrades", this.root = null, this.soundCheckbox = null, this.musicCheckbox = null, this.animatedMoney = null, this.money = null, this.performanceTabContents = null, this.weaponsTabContents = null, this.performanceTab = null, this.weaponsTab = null, this.tabActive = 0, this.armorPrice = null, this.sightPrice = null, this.turretPrice = null, this.speedPrice = null, this.armorButton = null, this.sightButton = null, this.turretButton = null, this.speedButton = null, this.minigun = null, this.shotgun = null, this.ricochet = null, this.cannon = null, this.rockets = null, this.laser = null, this.check = null, this.refillHint = null
    }
    var e = window.AT.SETTINGS.PRICES,
        i = window.AT.SETTINGS.AMMO_PRICES,
        o = window.AT.SETTINGS.AMMO_AMOUNT,
        s = window.AT.SETTINGS.AMMO_LIMITS,
        n = window.AT.common.button,
        r = window.AT.common.formatMoney,
        a = window.AT.common.flashElement,
        h = window.AT.profile,
        l = window.AT.audio,
        d = window.AT.gui.Checkbox,
        c = window.AT.gui.StatsAlert,
        p = window.AT.gui.DifficultyAlert,
        u = window.AT.gui.Gauge,
        b = window.AT.gui.UpgradeableWeapon,
        m = window.AT.gui.BuyUpgradeAlert,
        y = "menu/upgrades/parts.png",
        f = "menu/upgrades/parts/tab_performance.png";
    t.prototype.createBigPriceLabel = function(t, e, i, o) {
        var s = this.add.text(t, e, i, null, o);
        return s.anchor.set(.5, 1), s.font = "Gunplay", s.fontWeight = "400", s.fontSize = 24, s.fill = "#E9B300", s
    }, t.prototype.createGaugeButton = function(t, e, i, o, s) {
        i = "menu/upgrades/parts/" + i + ".png";
        var n = this.add.button(t, e, y, null, null, i, i, i, i, s),
            r = this.make.image(9, 9, y, "menu/upgrades/parts/gauge_" + o + ".png");
        return n.addChild(r), n
    }, t.prototype.create = function() {
        var t = h.current.game;
        this.sound.muteOnPause = !0, this.stage.backgroundColor = 1609549, this.root = this.add.group(), this.add.image(300, 310, "menu/upgrades/background.png", null, this.root).anchor.set(.5, .5), this.soundCheckbox = new d(this.game, this.root, y, "menu/upgrades/parts/buttons/sound_normal.png", "menu/upgrades/parts/buttons/sound_hover.png", "menu/upgrades/parts/buttons/off.png", "menu/upgrades/parts/buttons/on.png"), this.soundCheckbox.position.set(540, 90), this.soundCheckbox.checked = h.current.game.sound, this.soundCheckbox.onToggle = l.toggleSound, this.musicCheckbox = new d(this.game, this.root, y, "menu/upgrades/parts/buttons/music_normal.png", "menu/upgrades/parts/buttons/music_hover.png", "menu/upgrades/parts/buttons/off.png", "menu/upgrades/parts/buttons/on.png"), this.musicCheckbox.position.set(578, 90), this.musicCheckbox.checked = h.current.game.music, this.musicCheckbox.onToggle = l.toggleMusic, this.animatedMoney = {
                value: h.current.game.money,
                tween: null
            }, this.money = this.add.text(432, 74, "", null, this.root), this.money.anchor.set(1, .5), this.money.font = "Gunplay", this.money.fontWeight = "400", this.money.fontSize = 33, this.money.fill = "#FFB600", this.setMoney(), n(this.game, 25, 523, y, "menu/upgrades/parts/buttons/menu", this.menuClick, this, this.root), n(this.game, 156, 523, y, "menu/upgrades/parts/buttons/stats", this.statsClick, this, this.root), n(this.game, 294, 523, y, "menu/upgrades/parts/buttons/difficulty", this.difficultyClick, this, this.root), n(this.game, 458, 522, y, "menu/upgrades/parts/buttons/play", this.playClick, this, this.root), this.performanceTabContents = this.add.group(this.root), this.performanceTabContents.position.set(10, 192), this.performanceTabContents.visible = !1, this.add.image(0, 0, "menu/upgrades/performance.png", null, this.performanceTabContents), this.weaponsTabContents = this.add.group(this.root), this.weaponsTabContents.position.set(10, 192), this.add.image(0, 0, "menu/upgrades/weapons.png", null, this.weaponsTabContents), this.performanceTab = this.add.button(10, 140, y, this.performanceClick, this, null, f, null, null, this.root), this.performanceTab.onInputDown.add(l.playButtonDown), this.performanceTab.onInputUp.add(l.playButtonUp), this.weaponsTab = this.add.button(301, 140, y, this.weaponsClick, this, null, "menu/upgrades/parts/tab_weapons_active.png", null, null, this.root), this.weaponsTab.onInputDown.add(l.playButtonDown), this.weaponsTab.onInputUp.add(l.playButtonUp),
            this.tabActive = 1, this.armorPrice = this.createBigPriceLabel(102, 210, this.getUpgradeCost("armor"), this.performanceTabContents), this.sightPrice = this.createBigPriceLabel(223, 210, this.getUpgradeCost("sight"), this.performanceTabContents), this.turretPrice = this.createBigPriceLabel(346, 210, this.getUpgradeCost("turret"), this.performanceTabContents), this.speedPrice = this.createBigPriceLabel(467, 210, this.getUpgradeCost("speed"), this.performanceTabContents), this.armorButton = new u(this.game, 60, 80, "armor", t.armor, this.upgradeClick.bind(this, "armor"), this, this.performanceTabContents), this.sightButton = new u(this.game, 181, 80, "sight", t.sight, this.upgradeClick.bind(this, "sight"), this, this.performanceTabContents), this.turretButton = new u(this.game, 301, 80, "turret", t.turret, this.upgradeClick.bind(this, "turret"), this, this.performanceTabContents), this.speedButton = new u(this.game, 421, 80, "speed", t.speed, this.upgradeClick.bind(this, "speed"), this, this.performanceTabContents), this.minigun = new b(this.game, 20, 30, "minigun", "minigun", this.weaponClick, this.ammoHold, this, this.weaponsTabContents), this.shotgun = new b(this.game, 130, 30, "shotgun", "shotgun", this.weaponClick, this.ammoHold, this, this.weaponsTabContents), this.ricochet = new b(this.game, 240, 30, "ricochet", "ricochet", this.weaponClick, this.ammoHold, this, this.weaponsTabContents), this.flamethrower = new b(this.game, 350, 30, "flamethrower", "flamethrower", this.weaponClick, this.ammoHold, this, this.weaponsTabContents), this.cannon = new b(this.game, 460, 30, "cannon", "cannon", this.weaponClick, this.ammoHold, this, this.weaponsTabContents), this.shock = new b(this.game, 20, 170, "shock", "shock", this.weaponClick, this.ammoHold, this, this.weaponsTabContents), this.rockets = new b(this.game, 130, 170, "rockets", "rockets", this.weaponClick, this.ammoHold, this, this.weaponsTabContents), this.laser = new b(this.game, 240, 170, "laser", "laser", this.weaponClick, this.ammoHold, this, this.weaponsTabContents), this.railgun = new b(this.game, 350, 170, "railgun", "railgun", this.weaponClick, this.ammoHold, this, this.weaponsTabContents), this.mines = new b(this.game, 460, 170, "mines", "mines", this.weaponClick, this.ammoHold, this, this.weaponsTabContents);
        var e = this.firstWeaponWithoutAmmo();
        if (!h.current.game.refillHintDiscarded && e) {
            var i = this[e];
            this.refillHint = this.add.image(i.position.x + 14, i.position.y + 250, y, this.game.device.touch ? "menu/upgrades/parts/ammo_refill_hint_touch.png" : "menu/upgrades/parts/ammo_refill_hint_mouse.png", this.root), this.add.tween(this.refillHint).to({
                y: i.position.y + 260
            }, 1e3, Phaser.Easing.Sinusoidal.InOut, !0, 500, -1).yoyo(!0, 0)
        }!h.current.game.weaponTabOpened && h.current.game.money > 0 ? (this.check = this.add.image(130, 100, y, "menu/upgrades/parts/check.png", this.root), this.add.tween(this.check).to({
            y: 110
        }, 1e3, Phaser.Easing.Sinusoidal.InOut, !0, 500, -1).yoyo(!0, 0)) : this.check = null, -1 === h.current.game.difficulty && new p(this.game), this.camera.bounds = null, this.resize(window.innerWidth, window.innerHeight), this.camera.flash(0, 250), l.playMusic("music_menu.mp3", .75)
    }, t.prototype.setMoney = function(t) {
        "number" != typeof t && (t = h.current.game.money), this.money.text = t >= 1e9 ? "$" + (t / 1e9).toFixed(3) + "b" : t >= 1e8 ? "$" + (t / 1e6).toFixed(1) + "m" : t >= 1e6 ? "$" + (t / 1e6).toFixed(2) + "m" : t >= 1e5 ? "$" + (t / 1e3).toFixed(1) + "k" : r(t)
    }, t.prototype._setAnimatedMoney = function() {
        this.setMoney(this.animatedMoney.value)
    }, t.prototype.animateMoney = function() {
        this.animatedMoney.tween && this.animatedMoney.tween.stop(), this.animatedMoney.tween = this.add.tween(this.animatedMoney).to({
            value: h.current.game.money
        }, 500, Phaser.Easing.Linear.None, !0, 0), this.animatedMoney.tween.onUpdateCallback(this._setAnimatedMoney, this), this.animatedMoney.tween.onComplete.add(this.setMoney, this)
    }, t.prototype.getUpgradeCost = function(t) {
        var i = h.current.game;
        return i[t] < 5 ? r(e[t][i[t]]) : "MAX"
    }, t.prototype.upgradeClick = function(t) {
        var i = h.current.game,
            o = e[t][i[t]];
        o <= i.money ? (this.animatedMoney.value = i.money, i.money -= o, i[t] += 1, h.save(), this[t + "Price"].text = this.getUpgradeCost(t), this[t + "Button"].increase(), this.animateMoney(), l.playSound("buy.mp3")) : (a(this.money), a(this[t + "Price"]), l.playSound("not_available.mp3"))
    }, t.prototype.performanceClick = function() {
        0 !== this.tabActive && (this.performanceTab.setFrames("menu/upgrades/parts/tab_performance_active.png", "menu/upgrades/parts/tab_performance_active.png", "menu/upgrades/parts/tab_performance_active.png", "menu/upgrades/parts/tab_performance_active.png"), this.weaponsTab.setFrames("menu/upgrades/parts/tab_weapons.png", "menu/upgrades/parts/tab_weapons.png", "menu/upgrades/parts/tab_weapons.png", "menu/upgrades/parts/tab_weapons.png"), this.performanceTabContents.visible = !0, this.weaponsTabContents.visible = !1, this.tabActive = 0, this.refillHint && (this.add.tween(this.refillHint).to({
            alpha: 0
        }, 500, Phaser.Easing.Cubic.Out, !0), this.refillHint = null), h.current.game.weaponTabOpened || (h.current.game.weaponTabOpened = !0, h.save()), this.check && this.add.tween(this.check).to({
            alpha: 0
        }, 500, Phaser.Easing.Cubic.Out, !0))
    }, t.prototype.weaponsClick = function() {
        1 !== this.tabActive && (this.performanceTab.setFrames(f, f, f, f), this.weaponsTab.setFrames("menu/upgrades/parts/tab_weapons_active.png", "menu/upgrades/parts/tab_weapons_active.png", "menu/upgrades/parts/tab_weapons_active.png", "menu/upgrades/parts/tab_weapons_active.png"), this.performanceTabContents.visible = !1, this.weaponsTabContents.visible = !0, this.tabActive = 1)
    }, t.prototype.weaponClick = function(t) {
        new m(this.game, void 0, t, this.weaponUpgrade, this.ammoBuy, this)
    }, t.prototype.firstWeaponWithoutAmmo = function() {
        for (var t = ["shotgun", "ricochet", "flamethrower", "cannon", "shock", "rockets", "laser", "railgun", "mines"], e = 0; e < t.length; e++)
            if (h.getAmmoPercent(t[e]) < .99) return t[e];
        return null
    }, t.prototype.weaponUpgrade = function(t) {
        var i = h.current.game,
            o = e[t][i[t + "Level"] + 1];
        return o <= i.money ? (i.money -= o, i[t + "Level"] += 1, this[t].setLevel(i[t + "Level"]), a(this[t].weaponButton), this[t].ammoButton && a(this[t].ammoButton), h.save(), this.animateMoney(), l.playSound("buy.mp3"), !0) : (a(this.money), a(this[t].weaponPrice), l.playSound("not_available.mp3"), !1)
    }, t.prototype.ammoHold = function(t) {
        this.ammoBuy(t), this.refillHint && (this.add.tween(this.refillHint).to({
            alpha: 0
        }, 500, Phaser.Easing.Cubic.Out, !0), this.refillHint = null, h.current.game.refillHintDiscarded = !0, h.save())
    }, t.prototype.ammoBuy = function(t) {
        var e = h.current.game,
            n = t + "Ammo";
        if (e[n] >= s[t]) return !0;
        var r = i[t];
        return r <= e.money ? (e.money -= r, e[n] = Math.min(s[t], e[n] + o[t]), this[t].setAmmoPercent(h.getAmmoPercent(t)), h.save(), a(this[t].ammoBar), this.animateMoney(), l.playSound("buy.mp3"), !0) : (a(this.money), l.playSound("not_available.mp3"), !1)
    }, t.prototype.menuClick = function() {
        this.camera.fade(0, 250), this.camera.onFadeComplete.addOnce(this.back, this)
    }, t.prototype.back = function() {
        this.state.start("MenuTitle")
    }, t.prototype.difficultyClick = function() {
        new p(this.game)
    }, t.prototype.statsClick = function() {
        new c(this.game)
    }, t.prototype.playClick = function() {
        this.camera.fade(0, 250), this.camera.onFadeComplete.addOnce(this.next, this);
        try {
            window.cmgGameEvent ? window.cmgGameEvent("start") : window.parent.cmgGameEvent && window.parent.cmgGameEvent("start")
        } catch (t) {}
    }, t.prototype.next = function() {
        this.state.start("MenuLevels")
    }, t.prototype.resize = function(t, e) {
        if (this.root) {
            var i = Math.min(t / 600, e / 600);
            this.camera.setSize(t, e), this.root.scale.set(i), this.root.position.x = t / 2 - 300 * i, this.root.position.y = e / 2 - 300 * i
        }
    }, window.AT.menu.Upgrades = t
}(),
function() {
    "use strict";

    function t() {
        this.name = "Level selection", this.root = null
    }
    var e = window.AT.common.button,
        i = window.AT.common.formatNumber,
        o = window.AT.profile,
        s = window.AT.audio;
    window.AT.LEVELS;
    t.prototype.create = function() {
        this.sound.muteOnPause = !0, this.stage.backgroundColor = 1611091, this.root = this.add.group(), this.add.image(-24, -13, "menu/levels.png", "menu/levels/background.png", this.root), e(this.game, 300, 527, "menu/levels.png", "menu/levels/buttons/back_to_upgrades", this.backClick, this, this.root).anchor.x = .5;
        for (var t = 0; t < 15; t++) {
            var n = t <= o.current.game.levels,
                r = t === o.current.game.levels,
                a = "menu/levels/buttons/" + (r ? "active" : n ? "normal" : "disabled") + "/" + (t + 1) + ".png",
                h = this.add.button(133 + t % 5 * 80, 244 + 80 * Math.floor(t / 5), "menu/levels.png", n ? this.selectLevel.bind(this, t + 1) : null, null, null, a, null, this, this.root);
            h.anchor.set(.5, .5), h.inputEnabled = n, n && (h.onInputOver.add(this.buttonHover, this), h.onInputOut.add(this.buttonOut, this))
        }
        var l = this.add.text(300, 480, " Total score: " + i(o.getTotalPoints()) + " Pts. ", {
            font: "Gunplay",
            fontSize: 27,
            fontWeight: "400",
            fill: "#FFB601"
        }, this.root);
        l.anchor.set(.5, .5), l.setShadow(0, 0, "#000", 10, !0, !0), this.camera.bounds = null, this.resize(window.innerWidth, window.innerHeight), this.camera.flash(0, 250), s.playMusic("music_menu.mp3", .75)
    }, t.prototype.resize = function(t, e) {
        if (this.root) {
            var i = Math.min(t / 600, e / 600);
            this.camera.setSize(t, e), this.root.scale.set(i), this.root.position.x = t / 2 - 300 * i, this.root.position.y = e / 2 - 300 * i
        }
    }, t.prototype.buttonHover = function(t) {
        this.add.tween(t.scale).to({
            x: 1.3,
            y: 1.3
        }, 300, Phaser.Easing.Elastic.Out, !0)
    }, t.prototype.buttonOut = function(t) {
        this.add.tween(t.scale).to({
            x: 1,
            y: 1
        }, 300, Phaser.Easing.Elastic.Out, !0)
    }, t.prototype.backClick = function() {
        this.camera.fade(0, 250), this.camera.onFadeComplete.addOnce(this.back, this)
    }, t.prototype.back = function() {
        this.state.start("MenuUpgrades")
    }, t.prototype.selectLevel = function(t, e) {
        e.bringToTop(), this.add.tween(e.scale).to({
            x: 3,
            y: 3
        }, 400, Phaser.Easing.Linear.None, !0), this.camera.fade(0, 250), this.camera.onFadeComplete.add(this.game.state.start.bind(this.game.state, "Level" + t, !0, !1, 1)), s.stopMusic(), s.playSound("level.mp3")
    }, window.AT.menu.Levels = t
}(),
function() {
    "use strict";

    function t() {
        this.name = "Congratulations", this.root = null
    }
    var e = window.AT.common.button,
        i = window.AT.common.formatNumber,
        o = window.AT.profile,
        s = window.AT.audio;
    t.prototype.preload = function() {
        this.load.image("menu/congratulations.png", "images/menu/congratulations.png")
    }, t.prototype.create = function() {
        this.sound.muteOnPause = !0, this.stage.backgroundColor = 24333, this.root = this.add.group(), this.add.image(0, 0, "menu/congratulations.png", null, this.root).anchor.set(.5, .5), e(this.game, 0, 225, "game.png", "game/buttons/continue", this.continueClick, this, this.root).anchor.set(.5, .5);
        var t = this.add.text(0, 160, " " + i(o.getTotalPoints()) + " Points ", {
            font: "Gunplay",
            fontSize: 40,
            fontWeight: "400",
            fill: "#FFB601"
        }, this.root);
        t.anchor.set(.5, .5), t.setShadow(0, 0, "#000", 8, !0, !0), this.camera.bounds = null, this.resize(window.innerWidth, window.innerHeight), this.camera.flash(0, 250), s.playMusic("music_congratulations.mp3")
    }, t.prototype.continueClick = function() {
        this.camera.fade(0, 250), this.camera.onFadeComplete.addOnce(this.next, this), s.stopMusic()
    }, t.prototype.next = function() {
        this.state.start("MenuTitle")
    }, t.prototype.resize = function(t, e) {
        if (this.root) {
            var i = Math.min(t / 600, e / 600);
            this.camera.setSize(t, e), this.root.scale.set(i), this.root.position.x = t / 2, this.root.position.y = e / 2
        }
    }, window.AT.menu.Congratulations = t
}(),
function() {
    "use strict";

    function t() {
        this.game.state.getCurrentState().gamePaused || Phaser.Group.prototype.preUpdate.call(this)
    }

    function e() {
        this.game.state.getCurrentState().gamePaused || Phaser.Group.prototype.update.call(this)
    }

    function i() {
        this.game.state.getCurrentState().gamePaused || Phaser.Group.prototype.postUpdate.call(this)
    }

    function o(t, e) {
        this.strings = t, this.name = t[0], this.number = e, this.index = e - 1, this.width = 0, this.height = 0, this.difficultyIndex = 0, this.difficulty = 0, this.points = 0, this.mapBounds = new Phaser.Rectangle, this.root = null, this.hudLayer = null, this.player = null, this.sceneryLayer = null, this.sceneryBackground = null, this.sceneryMiddleground = null, this.sceneryForeground = null, this.sceneryImage = null, this.groundLayer = null, this.objectsLayer = null, this.weaponsLayer = null, this.topLayer = null, this.topLayer = null, this._walls = null, this.walls = null, this.enemies = null, this.barrels = null, this.enemiesAlive = 0, this.objects = null, this.grid = null, this.shake = 0, this.freeCamera = !1, this.freezeTime = 0, this.hud = null, this.gamePaused = !1, this.showHealth = !1, this.abandonAlert = null, this.summaryAlert = null, this.pauseAlert = null, this.profit = 0, this.kills = 0, this.combo = 0, this.comboTime = 0, this.explosionEmitter = null, this.smokeEmitter = null, this.sparkEmitter = null, this.starEmitter = null, this.disappearingEmitter = null, this.boardEmitter = null, this.iceEmitter = null, this.collectiblesEmitter = null, this.upKey = null, this.downKey = null, this.leftKey = null, this.rightKey = null, this._touchMove = new Phaser.Point, this._touchAimTarget = new Phaser.Point, this.touchAimCrosshair = null, this.movePointer = null, this.aimPointer = null, this._hole = null, this._holeTempMatrix = new PIXI.Matrix, this.updateFogLazy = r(this.updateFog, 3)
    }
    var s = window.AT.common.create2DArray,
        n = window.AT.common.COLLISION_GROUPS,
        r = window.AT.common.debounceCalls,
        a = (window.AT.common.rotate, window.AT.common.button, window.AT.profile),
        h = window.AT.audio,
        l = window.AT.TILES,
        d = window.AT.particles.Emitter,
        c = window.AT.Tank,
        p = window.AT.explosion,
        u = window.AT.Barrel,
        b = window.AT.Bricks,
        m = window.AT.Wood,
        y = window.AT.Secret,
        f = window.AT.Gate,
        g = window.AT.Crate,
        x = window.AT.Spawner,
        _ = window.AT.explosions.ExplosionManager,
        v = window.AT.Fog,
        w = window.AT.bonus.Coin,
        C = window.AT.bonus.Freeze,
        S = window.AT.bonus.SmallEnemy,
        A = window.AT.turrets.MinigunTurret,
        T = window.AT.turrets.ShotgunTurret,
        P = window.AT.turrets.CannonTurret,
        B = window.AT.turrets.RocketsTurret,
        M = window.AT.turrets.LaserTurret,
        I = window.AT.turrets.RicochetTurret,
        R = window.AT.turrets.RailgunTurret,
        D = window.AT.turrets.FlamethrowerTurret,
        k = (window.AT.tanks.EnemyTank, window.AT.tanks.MinigunTank),
        V = window.AT.tanks.ShotgunTank,
        E = window.AT.tanks.CannonTank,
        L = window.AT.tanks.RocketsTank,
        F = window.AT.tanks.LaserTank,
        O = window.AT.tanks.RicochetTank,
        G = window.AT.tanks.RailgunTank,
        U = window.AT.tanks.KamikazeTank,
        N = window.AT.tanks.FlamethrowerTank,
        W = window.AT.tanks.ShotgunBoss,
        J = window.AT.tanks.CannonBoss,
        X = window.AT.tanks.RocketsBoss,
        j = window.AT.tanks.LaserBoss,
        H = window.AT.tanks.RicochetBoss,
        z = window.AT.tanks.RailgunBoss,
        Y = window.AT.tanks.FlamethrowerBoss,
        q = window.AT.gui.AbandonAlert,
        K = window.AT.gui.SummaryAlert,
        Z = window.AT.gui.HelpAlert,
        Q = window.AT.gui.HelpAlertAlt,
        $ = window.AT.gui.PauseAlert,
        tt = window.AT.gui.Achievements,
        et = window.AT.gui.HUD,
        it = [0, 90, 180, 270],
        ot = ["game/wall_0.png", "game/wall_1.png", "game/wall_2.png"];
    o.TILE_SIZE = 52, o.DIFFICULTIES = [.65, .85, 1], o.onCreate = function() {}, o.onUpdate = function() {}, o.onRender = function() {}, o.tileToPx = o.prototype.tileToPx = function(t) {
        return 52 * t + 26 - 52
    }, o.pxToTile = o.prototype.pxToTile = function(t) {
        return Math.round((t - 26) / 52) + 1
    }, o.prototype.init = function() {
        this.profit = 0, this.points = 0, this.kills = 0, this.combo = 0, this.comboTime = 0, this.enemiesAlive = 0, this.gamePaused = !1, this.difficultyIndex = -1 === a.current.game.difficulty ? 1 : a.current.game.difficulty, this.difficulty = o.DIFFICULTIES[this.difficultyIndex], this.easystar = new EasyStar.js, this.easystar.setIterationsPerCalculation(100), this.easystar.enableDiagonals(), this.easystar.disableCornerCutting(), this._touchMove.set(0, 0), this._touchAimTarget.set(0, 0)
    }, o.prototype.occupyTile = function(t, e) {
        this.grid[e][t] = 1
    }, o.prototype.leaveTile = function(t, e) {
        this.grid[e][t] = 0
    }, o.prototype.isTileFree = function(t, e) {
        return 0 === this.grid[e][t]
    }, o.prototype.isTilePathFree = function(t, e, i) {
        i = null == i ? t.length : Math.min(i, t.length);
        for (var o = e || 0; o < i; o++)
            if (0 !== this.grid[t[o].y][t[o].x]) return !1;
        return !0
    };
    var st = new Array(4);
    o.prototype.getRandomFreeTileAround = function(t, e, i) {
        if (st[0] = 0 === this.grid[e][t + 1], st[1] = 0 === this.grid[e + 1][t], st[2] = 0 === this.grid[e][t - 1], st[3] = 0 === this.grid[e - 1][t], !(st[0] || st[1] || st[2] || st[3])) return !1;
        for (var o = this.rnd.integerInRange(0, 3), s = 0; s < 4 && !st[o]; s++) o = (o + 1) % 4;
        return i.x = t + Math.round(Math.cos(o * Math.PI * .5)), i.y = e + Math.round(Math.sin(o * Math.PI * .5)), !0
    }, o.prototype.clearTile = function(t, e) {
        this.objects[e][t] = null, this.grid[e][t] = 0
    }, o.prototype.createPlayer = function(t, e) {
        this.player = new c(this, o.tileToPx(t), o.tileToPx(e)), this.player.autoAim = this.game.device.touch;
        for (var i = 0; i < this.player.weapons.length; i++) this.player.weapons[i] && this.player.weapons[i].spawnsChildren && this.weaponsLayer.add(this.player.weapons[i]);
        this.player.mines && this.groundLayer.add(this.player.mines), this.player.events.onKilled.add(this.playerKilled, this)
    }, o.prototype.createTile = function(t, e, i, s) {
        var n = this.add.image(o.tileToPx(t), o.tileToPx(e), "game.png", i, s);
        return n.anchor.set(.5, .5), n.scale.set(this.rnd.sign(), this.rnd.sign()), n.angle = this.rnd.pick(it), n
    }, o.prototype.createDebris = function(t, e, i, o, s, n) {
        for (var r = s ? "game/debris/spawner_" : "game/debris/", a = 0; a < n; a++) {
            var h = Phaser.Utils.pad(this.rnd.between(i, o), 2, "0", 1),
                l = this.add.image(t + this.rnd.realInRange(-30, 30), e + this.rnd.realInRange(-30, 30), "game.png", r + h + ".png", this.sceneryMiddleground);
            l.anchor.set(.5, .5), l.angle = this.rnd.angle()
        }
    }, o.prototype.createGrass = function(t, e, i) {
        var o = this.createTile(t, e, "game/" + i + ".png", this.sceneryBackground);
        return Math.random() > .6 && this.createDebris(o.position.x, o.position.y, 0, 24, !1, 1), o
    }, o.prototype.createWall = function(t, e, i, o) {
        var s = this.createTile(t, e, this.rnd.pick(ot), this.sceneryForeground);
        return t > 0 && e > 0 && t < i - 1 && e < o - 1 && (this._walls[e][t] = !0), this.objects[e][t] = s, this.occupyTile(t, e), s
    }, o.prototype._findHorizontalWallSegment = function(t, e) {
        for (var i = 0; t < this.width - 1 && this._walls[e][t]; t++, i++);
        return i
    }, o.prototype._findVerticalWallSegment = function(t, e) {
        for (var i = 0; e < this.height - 1 && this._walls[e][t]; e++, i++);
        return i
    }, o.prototype._findHorizontalWallRectangle = function(t, e) {
        var i = this._findHorizontalWallSegment(t, e),
            o = 1;
        if (i > 1)
            for (; this._findHorizontalWallSegment(t, e + 1) === i;) o += 1, e += 1;
        return {
            width: i,
            height: o
        }
    }, o.prototype._findVerticalWallRectangle = function(t, e) {
        for (var i = 0; e < this.height - 1 && this._walls[e][t]; e++, i++);
        var o = 1;
        if (i > 0)
            for (; this._findVerticalWallSegment(t + 1, e) === i;) o += 1, t += 1;
        return {
            width: o,
            height: i
        }
    }, o.prototype._createWallBodyFromRect = function(t) {
        var e = o.TILE_SIZE * t.width,
            i = o.TILE_SIZE * t.height;
        this.walls.addRectangle(e, i, o.tileToPx(t.x + t.width / 2 - .5), o.tileToPx(t.y + t.height / 2 - .5))
    }, o.prototype._useWalls = function(t, e, i, o) {
        for (var s = e; s < e + o; s++)
            for (var n = t; n < t + i; n++) this._walls[s][n] = !1
    }, o.prototype.createWallBodies = function() {
        for (var t = [], e = 1; e < this.height - 1; e++) {
            var i = 1;
            do {
                if (this._walls[e][i]) {
                    var o = this._findHorizontalWallRectangle(i, e);
                    o.width > 1 ? (this._useWalls(i, e, o.width, o.height), t.push({
                        x: i,
                        y: e,
                        width: o.width,
                        height: o.height
                    }), i += o.width) : i += 1
                } else i += 1
            } while (i < this.width - 1)
        }
        for (var i = 1; i < this.width - 1; i++) {
            var e = 1;
            do {
                if (this._walls[e][i]) {
                    var o = this._findVerticalWallRectangle(i, e);
                    o.height > 0 ? (this._useWalls(i, e, o.width, o.height), t.push({
                        x: i,
                        y: e,
                        width: o.width,
                        height: o.height
                    }), e += o.height) : e += 1
                } else e += 1
            } while (e < this.height - 1)
        }
        for (var s = 0; s < t.length; s++) this._createWallBodyFromRect(t[s])
    }, o.prototype.createBarrel = function(t, e) {
        var i = new u(this.game, o.tileToPx(t), o.tileToPx(e));
        return this.objectsLayer.add(i), this.barrels.push(i), this.objects[e][t] = i, this.occupyTile(t, e), i.events.onKilled.add(this.clearTile.bind(this, t, e)), i
    }, o.prototype.createBricks = function(t, e, i) {
        var s = new b(this.game, o.tileToPx(t), o.tileToPx(e), i);
        return this.objectsLayer.add(s), this.objects[e][t] = s, this.occupyTile(t, e), s.events.onKilled.add(this.clearTile.bind(this, t, e)), i ? this.createDebris(s.position.x, s.position.y, 7, 14, !1, 2 + 4 * Math.random()) : this.createDebris(s.position.x, s.position.y, 1, 7, !1, 2 + 4 * Math.random()), s
    }, o.prototype.createWood = function(t, e) {
        var i = new m(this.game, o.tileToPx(t), o.tileToPx(e));
        return this.objectsLayer.add(i), this.objects[e][t] = i, this.occupyTile(t, e), i.events.onKilled.add(this.clearTile.bind(this, t, e)), this.createDebris(i.position.x, i.position.y, 0, 24, !1, 2 + 4 * Math.random()), i
    }, o.prototype.createSecret = function(t, e) {
        var i = new y(this.game, o.tileToPx(t), o.tileToPx(e));
        return this.objectsLayer.add(i), this.objects[e][t] = i, this.occupyTile(t, e), i.events.onKilled.add(this.clearTile.bind(this, t, e)), this.createDebris(i.position.x, i.position.y, 0, 24, !1, 2 + 4 * Math.random()), i
    }, o.prototype.createGate = function(t, e) {
        var i = new f(this.game, o.tileToPx(t), o.tileToPx(e));
        this.objectsLayer.add(i), this.objects[e][t] = i, this.occupyTile(t, e), i.events.onKilled.add(this.clearTile.bind(this, t, e));
        var s = this.objects[e][t - 1];
        s && s instanceof f && (i.gateLeft = s, s.gateRight = i);
        var n = this.objects[e][t + 1];
        n && n instanceof f && (i.gateRight = n, n.gateLeft = i);
        var r = this.objects[e - 1][t];
        r && r instanceof f && (i.gateUp = r, r.gateDown = i);
        var a = this.objects[e + 1][t];
        return a && a instanceof f && (i.gateDown = a, a.gateUp = i), this.createDebris(i.position.x, i.position.y, 16, 24, !1, 2 + 4 * Math.random()), i
    }, o.prototype.createCrate = function(t, e) {
        var i = new g(this.game, o.tileToPx(t) + this.rnd.realInRange(-2, 2), o.tileToPx(e) + this.rnd.realInRange(-2, 2));
        return this.objectsLayer.add(i), this.objects[e][t] = i, this.occupyTile(t, e), i.events.onKilled.add(this.clearTile.bind(this, t, e)), i
    }, o.prototype.createSpawner = function(t, e, i) {
        var s = new x(this.game, o.tileToPx(t), o.tileToPx(e), i);
        return this.groundLayer.add(s), this.objects[e][t] = s, this.enemies.push(s), s.events.onKilled.add(this.enemyKilled, this), this.enemiesAlive += 1, this.createDebris(s.position.x, s.position.y, 0, 3, !0, 2 + 4 * Math.random()), s
    }, o.prototype.createTurret = function(t, e, i) {
        var s = new i(this.game, o.tileToPx(t), o.tileToPx(e));
        return this.objectsLayer.add(s), s.weapon && this.weaponsLayer.add(s.weapon), this.objects[e][t] = s, this.occupyTile(t, e), this.enemies.push(s), s.events.onKilled.add(this.clearTile.bind(this, t, e)), s.events.onKilled.add(this.enemyKilled, this), this.enemiesAlive += 1, s
    }, o.prototype.createTank = function(t, e, i, s) {
        var n = new i(this.game, o.tileToPx(t), o.tileToPx(e), s);
        return n.states.change(window.AT.ai.Idle), this.objectsLayer.add(n), this.enemies.push(n), n.weapon && this.weaponsLayer.add(n.weapon), n.events.onKilled.add(this.enemyKilled, this), this.enemiesAlive += 1, n
    }, o.prototype.addKey = function(t, e, i, o) {
        if (!(t in Phaser.Keyboard)) throw new Error('Unknown key: "' + n + '"');
        var s = Phaser.Keyboard[t],
            n = this.input.keyboard.addKey(s);
        return e && n.onDown.add(e.bind.apply(e, [i].concat(o))), this.input.keyboard.addKeyCapture(s), n
    }, o.prototype.createDisappearingEmitter = function() {
        var t = new d(this.game, 0, 0, 20);
        return t.makeParticles("game.png", ["game/particles/disappearing.png"]), t.setAlpha(1, .05, 200), t.setRotation(0, 0), t.setScale(.5, 1.5, .5, 1.5, 200), t.setXSpeed(0, 0), t.setYSpeed(0, 0), t.gravity = 0, t.lifespan = 200, this.objectsLayer.add(t), t
    }, o.prototype.createStarEmitter = function() {
        var t = new d(this.game, 0, 0, 20);
        return t.makeParticles("game.png", ["game/particles/star_coin.png", "game/particles/star_enemy.png", "game/particles/star_laser.png", "game/particles/star_object.png"]), t.setAlpha(1, .05, 200), t.setRotation(-720, 720), t.setXSpeed(0, 0), t.setYSpeed(0, 0), t.gravity = 0, t.lifespan = 200, this.objectsLayer.add(t), t
    }, o.prototype.createSparkEmitter = function() {
        var t = new d(this.game, 0, 0, 40);
        return t.makeParticles("game.png", ["game/particles/spark_0.png", "game/particles/spark_1.png", "game/particles/spark_2.png", "game/particles/spark_3.png"]), t.setAlpha(1, .05, 200), t.setRotation(0, 0), t.setXSpeed(0, 0), t.setYSpeed(0, 0), t.gravity = 0, t.lifespan = 200, this.objectsLayer.add(t), t
    }, o.prototype.createSmokeEmitter = function() {
        var t = new d(this.game, 0, 0, 20);
        return t.makeParticles("game.png", ["game/particles/smoke_0.png", "game/particles/smoke_1.png", "game/particles/smoke_2.png", "game/particles/smoke_3.png"]), t.setAlpha(1, .05, 333), t.setRotation(-360, 360), t.setXSpeed(-50, 50), t.setYSpeed(-50, 50), t.gravity = 0, t.lifespan = 333, this.objectsLayer.add(t), t
    }, o.prototype.createBoardEmitter = function() {
        var t = new d(this.game, 0, 0, 12);
        return t.makeParticles("game.png", ["game/particles/board.png"]), t.setAlpha(1, .05, 333), t.setRotation(-1080, 1080), t.setXSpeed(-100, 100), t.setYSpeed(-100, 100), t.gravity = 0, t.lifespan = 333, this.objectsLayer.add(t), t
    }, o.prototype.createIceEmitter = function() {
        var t = new d(this.game, 0, 0, 48);
        return t.makeParticles("game.png", ["game/particles/ice.png"]), t.setAlpha(1, .05, 333), t.setRotation(-1080, 1080), t.setXSpeed(-100, 100), t.setYSpeed(-100, 100), t.gravity = 0, t.lifespan = 333, this.objectsLayer.add(t), t
    }, o.prototype.createExplosionEmitter = function() {
        var t = new d(this.game, 0, 0, 20);
        return t.particleClass = p, t.makeParticles(), t.setRotation(0, 0), t.setScale(1.25, 1.25, 1.25, 1.25), t.setXSpeed(0, 0), t.setYSpeed(0, 0), t.gravity = 0, t.lifespan = 400, this.objectsLayer.add(t), t
    }, o.prototype.createCollectiblesEmitter = function() {
        var t = new d(this.game, 0, 0, 20);
        return t.makeParticles("game.png", ["game/bonuses/coin.png", "game/bonuses/health.png", "game/bonuses/ammo_shotgun.png", "game/bonuses/ammo_ricochet.png", "game/bonuses/ammo_cannon.png", "game/bonuses/ammo_rockets.png", "game/bonuses/ammo_laser.png"]), t.setAlpha(1, 0, 700), t.setRotation(0, 0), t.setXSpeed(0, 0), t.setYSpeed(0, 0), t.gravity = 0, t.lifespan = 700, this.hudLayer.add(t), t
    }, o.prototype.assignPointer = function(t) {
        t.isMouse || (!this.movePointer && t.x < .5 * window.innerWidth ? this.movePointer = t : !this.aimPointer && t.x > .5 * window.innerWidth && (this.aimPointer = t))
    }, o.prototype.forgetPointer = function(t) {
        t === this.movePointer ? this.movePointer = null : t === this.aimPointer && (this.aimPointer = null)
    }, o.prototype.create = function() {
        var r = o.TILE_SIZE,
            d = this.width = this.strings[2].length,
            c = this.height = this.strings.length - 2,
            p = this.strings[1];
        this.sound.muteOnPause = !0, this.stage.backgroundColor = 0, this.root = this.add.group(this.world, "root"), this.root.preUpdate = t, this.root.update = e, this.root.postUpdate = i, this.hudLayer = this.add.group(this.stage, "hudLayer"), this.topLayer = this.add.group(this.stage, "topLayer"), this.resize(window.innerWidth, window.innerHeight), this.sceneryLayer = new Phaser.Group(this.game, null), this.sceneryBackground = new Phaser.Group(this.game, this.sceneryLayer), this.sceneryMiddleground = new Phaser.Group(this.game, this.sceneryLayer), this.sceneryForeground = new Phaser.Group(this.game, this.sceneryLayer), this.sceneryImage = this.make.image(-r, -r), this.root.add(this.sceneryImage), this.groundLayer = this.add.group(this.root, "groundLayer"), this.objectsLayer = this.add.group(this.root, "objectsLayer"), this.weaponsLayer = this.add.group(this.root, "weaponsLayer"), this.explosions = new _(this.game, this.root), this.touchAimCrosshair = this.make.image(0, 0, "game.png", "game/hud/crosshair.png"), this.touchAimCrosshair.anchor.set(.5, .5), this.touchAimCrosshair.visible = !1, this.topLayer.addChild(this.touchAimCrosshair), this.hud = new et(this.game, this.hudLayer), this.hud.position.set(0, -1), this.hud.pauseIcon.events.onInputUp.add(this.pauseToggle, this), this.hud.menuButton.onInputUp.add(this.showAbandonAlert, this), this.achievements = new tt(this.game, this.hudLayer), this.fog = new v(this.game, this.root, 1, 1, d - 2, c - 2, r), this.physics.box2d.ptmRatio = r, this.physics.box2d.paused = !1, this.world.setBounds(0, 0, (d - 2) * r, (c - 2) * r), this.walls = new Phaser.Physics.Box2D.Body(this.game, null, 0, 0, 2), this.walls.static = !0, this._walls = s(d, c, !1), this.objects = s(d, c, null), this.grid = s(d, c, 0), this.enemies = [], this.barrels = [];
        for (var u = 0; u < c; u++)
            for (var b = 0; b < d; b++) {
                var m = this.strings[u + 2][b];
                m === l.WALL ? this.createWall(b, u, d, c) : this.createGrass(b, u, p), m === l.PLAYER ? this.createPlayer(b, u) : m === l.BRICKS_1 ? this.createBricks(b, u, !1) : m === l.BRICKS_2 ? this.createBricks(b, u, !0) : m === l.WOOD ? this.createWood(b, u) : m === l.SECRET ? this.createSecret(b, u) : m === l.BARREL ? this.createBarrel(b, u) : m === l.GATE ? this.createGate(b, u) : m === l.CRATE ? this.createCrate(b, u) : m === l.SPAWNER_1 ? this.createSpawner(b, u, 0) : m === l.SPAWNER_2 ? this.createSpawner(b, u, 1) : m === l.SPAWNER_3 ? this.createSpawner(b, u, 2) : m === l.SPAWNER_4 ? this.createSpawner(b, u, 3) : m === l.SPAWNER_5 ? this.createSpawner(b, u, 4) : m === l.SPAWNER_6 ? this.createSpawner(b, u, 5) : m === l.SPAWNER_7 ? this.createSpawner(b, u, 6) : m === l.TURRET_MINIGUN ? this.createTurret(b, u, A) : m === l.TURRET_SHOTGUN ? this.createTurret(b, u, T) : m === l.TURRET_CANNON ? this.createTurret(b, u, P) : m === l.TURRET_ROCKETS ? this.createTurret(b, u, B) : m === l.TURRET_LASER ? this.createTurret(b, u, M) : m === l.TURRET_RICOCHET ? this.createTurret(b, u, I) : m === l.TURRET_RAILGUN ? this.createTurret(b, u, R) : m === l.TURRET_FLAMETHROWER ? this.createTurret(b, u, D) : m === l.TANK_MINIGUN ? this.createTank(b, u, k, !1) : m === l.TANK_SHOTGUN ? this.createTank(b, u, V, !1) : m === l.TANK_CANNON ? this.createTank(b, u, E, !1) : m === l.TANK_ROCKETS ? this.createTank(b, u, L, !1) : m === l.TANK_LASER ? this.createTank(b, u, F, !1) : m === l.TANK_RICOCHET ? this.createTank(b, u, O, !1) : m === l.TANK_RAILGUN ? this.createTank(b, u, G, !1) : m === l.TANK_KAMIKAZE ? this.createTank(b, u, U, !1) : m === l.TANK_FLAMETHROWER ? this.createTank(b, u, N, !1) : m === l.BOSS_SHOTGUN ? this.createTank(b, u, W, !1) : m === l.BOSS_CANNON ? this.createTank(b, u, J, !1) : m === l.BOSS_ROCKETS ? this.createTank(b, u, X, !1) : m === l.BOSS_LASER ? this.createTank(b, u, j, !1) : m === l.BOSS_RICOCHET ? this.createTank(b, u, H, !1) : m === l.BOSS_RAILGUN ? this.createTank(b, u, z, !1) : m === l.BOSS_FLAMETHROWER && this.createTank(b, u, Y, !1)
            }
        this.createWallBodies(), this._hole = this.make.image(0, 0, "game.png", "game/hole.png"), this._hole.anchor.set(.5, .5), this.sceneryLayer.cacheAsBitmap = !0, this.sceneryImage.setTexture(this.sceneryLayer._cachedSprite.texture), this.sceneryLayer = null, this.hud.setTank(this.player), this.hud.minigun.onInputUp.add(this.changeWeapon.bind(this, 0)), this.hud.shotgun.onInputUp.add(this.changeWeapon.bind(this, 1)), this.hud.ricochet.onInputUp.add(this.changeWeapon.bind(this, 2)), this.hud.flamethrower.onInputUp.add(this.changeWeapon.bind(this, 3)), this.hud.cannon.onInputUp.add(this.changeWeapon.bind(this, 4)), this.hud.shock.onInputUp.add(this.changeWeapon.bind(this, 5)), this.hud.rockets.onInputUp.add(this.changeWeapon.bind(this, 6)), this.hud.laser.onInputUp.add(this.changeWeapon.bind(this, 7)), this.hud.railgun.onInputUp.add(this.changeWeapon.bind(this, 8)), this.hud.mines.onInputUp.add(this.layMine, this), this.hud.helpIcon.events.onInputUp.add(this.showHelp, this);
        var y = this.physics.box2d.walls;
        if (y.left.setCollisionCategory(n.WALL), y.left.friction = 0, y.right.setCollisionCategory(n.WALL), y.right.friction = 0, y.top.setCollisionCategory(n.WALL), y.top.friction = 0, y.bottom.setCollisionCategory(n.WALL), y.bottom.friction = 0, this.easystar.setGrid(this.grid), this.easystar.setAcceptableTiles([0]), this.physics.box2d.frictionJoint(this.player.body, this.physics.box2d.walls.left, 5, 0).m_collideConnected = !0, this.explosionEmitter = this.createExplosionEmitter(), this.smokeEmitter = this.createSmokeEmitter(), this.sparkEmitter = this.createSparkEmitter(), this.starEmitter = this.createStarEmitter(), this.disappearingEmitter = this.createDisappearingEmitter(), this.boardEmitter = this.createBoardEmitter(), this.iceEmitter = this.createIceEmitter(), this.collectiblesEmitter = this.createCollectiblesEmitter(), this.camera.flash(0, 250), this.camera.bounds = null, this.updateFog(!0), this.updateCamera(!0), this.upKey = this.addKey("UP"), this.downKey = this.addKey("DOWN"), this.leftKey = this.addKey("LEFT"), this.rightKey = this.addKey("RIGHT"), this.wKey = this.addKey("W"), this.sKey = this.addKey("S"), this.aKey = this.addKey("A"), this.dKey = this.addKey("D"), this.addKey("SPACEBAR", this.nextWeapon, this), this.addKey("Q", this.previousWeapon, this), this.addKey("E", this.nextWeapon, this), this.addKey("ONE", this.changeWeapon, this, [0]), this.addKey("TWO", this.changeWeapon, this, [1]), this.addKey("THREE", this.changeWeapon, this, [2]), this.addKey("FOUR", this.changeWeapon, this, [3]), this.addKey("FIVE", this.changeWeapon, this, [4]), this.addKey("SIX", this.changeWeapon, this, [5]), this.addKey("SEVEN", this.changeWeapon, this, [6]), this.addKey("EIGHT", this.changeWeapon, this, [7]), this.addKey("NINE", this.changeWeapon, this, [8]), this.addKey("R", this.layMine, this), this.addKey("P", this.pauseToggle, this), this.input.mouse.mouseWheelCallback = this.mouseWheel.bind(this), this.game.device.touch && (this.input.onDown.add(this.assignPointer, this), this.input.onUp.add(this.forgetPointer, this)), this.gamePaused = !0, a.current.game.helpMovingShown)
            if (a.current.game.helpWeaponBought && !a.current.game.helpWeaponsShown || a.current.game.helpMinesBought && !a.current.game.helpMinesShown) {
                var f, g = this.game.device.touch ? "touch_" : "keyboard_";
                a.current.game.helpWeaponBought && !a.current.game.helpWeaponsShown && a.current.game.helpMinesBought && !a.current.game.helpMinesShown ? (f = new Q(this.game, this.stage, g + "weapons_mines", -56, 101, "game.png", "game/buttons/play"), a.current.game.helpWeaponsShown = a.current.game.helpMinesShown = !0) : a.current.game.helpWeaponBought && !a.current.game.helpWeaponsShown ? (f = new Q(this.game, this.stage, g + "weapons", -56, 54, "game.png", "game/buttons/play"),
                    a.current.game.helpWeaponsShown = !0) : a.current.game.helpMinesBought && !a.current.game.helpMinesShown && (f = new Q(this.game, this.stage, g + "mines", -56, 37, "game.png", "game/buttons/play"), a.current.game.helpMinesShown = !0), f.onDestroy.add(this.helpAdvance, this)
            } else this.helpAdvance();
        else {
            if (this.game.device.touch) {
                var x = new Z(this.game, this.stage, "touch_shooting");
                new Z(this.game, this.stage, "touch_auto_aim"), new Z(this.game, this.stage, "touch_moving"), x.onDestroy.add(this.helpAdvance, this)
            } else {
                var f = new Q(this.game, this.stage, "keyboard_moving", -56, 112, "game.png", "game/buttons/play");
                f.onDestroy.add(this.helpAdvance, this)
            }
            a.current.game.helpMovingShown = !0
        }
        h.playMusic("music_game.mp3"), this.game.onPause.add(this.pauseOn, this);
        try {
            window.cmgGameEvent ? window.cmgGameEvent("start", String(this.number)) : window.parent.cmgGameEvent && window.parent.cmgGameEvent("start", String(this.number))
        } catch (t) {}
        o.onCreate(this)
    }, o.prototype.showHelp = function() {
        this.gamePaused = !0, new Q(this.game, this.stage, this.game.device.touch ? "touch" : "keyboard", -56, this.game.device.touch ? 183 : 192, "game.png", "game/buttons/play").onDestroy.add(this.helpResume, this)
    }, o.prototype.helpResume = function() {
        this.pauseAlert ? this.pauseToggle() : (this.gamePaused = !1, this.undimGame())
    }, o.prototype.helpAdvance = function() {
        this.hud.showFightMessage(), this.gamePaused = !1
    }, o.prototype.getObject = function(t, e) {
        return e < 0 || t < 0 || t >= this.width || e >= this.height ? null : this.objects[e][t]
    }, o.prototype.removeObjectAtPosition = function(t, e) {
        this.objects[this.pxToTile(e)][this.pxToTile(t)] = null
    }, o.prototype.resize = function(t, e) {
        if (this.root) {
            var i = Math.min(t / 600, e / 600);
            this.camera.setSize(t, e), this.root.scale.set(Math.max(.7, i)), this.topLayer.scale.set(this.root.scale.x, this.root.scale.y), this.hudLayer.scale.set(Math.min(t / 600, e / 600 * this.game.renderer.resolution * .8)), this.hudLayer.position.set(t / 2, e - 1)
        }
    }, o.prototype.updateCamera = function(t) {
        if (!this.freeCamera) {
            var e = this.player.follow ? this.player.follow.body : this.player.body,
                i = this.root.scale.x,
                o = .2;
            if (t) this.camera.focusOnXY(e.x * i, e.y * i);
            else {
                if (!this.player.reallyAlive || this.game.device.touch && this.player.follow) var s = e.x * i,
                    n = e.y * i;
                else if (this.game.device.touch) {
                    var r = this.player.getTurretPosition(75),
                        s = r.x * i,
                        n = r.y * i;
                    o = .1
                } else var a = this.input.mousePointer,
                    s = Phaser.Math.linear(e.x * i, a.worldX, .25),
                    n = Phaser.Math.linear(e.y * i, a.worldY, .25);
                this.camera.view.x += (s - this.camera.view.halfWidth - this.camera.view.x) * o, this.camera.view.y += (n - this.camera.view.halfHeight - this.camera.view.y) * o
            }
        }
        this.shake > 0 ? (this.root.position.x = this.rnd.realInRange(-this.shake, this.shake) * i, this.root.position.y = this.rnd.realInRange(-this.shake, this.shake) * i, this.shake -= 30 * this.time.physicsElapsed) : this.root.position.x = this.root.position.y = 0
    }, o.prototype.updateFog = function(t) {
        if (this.player.follow) this.fog.revealTileArea(o.pxToTile(this.player.follow.position.x), o.pxToTile(this.player.follow.position.y));
        else {
            this.fog.revealTileArea(this.player.tileX, this.player.tileY);
            var e = this.player.turretRotation - this.player.viewAngle,
                i = e + 2 * this.player.viewAngle;
            this.revealFogArc(this.player.bodyX, this.player.bodyY, e, i, this.player.viewDistance, t)
        }
    }, o.prototype.shakeCamera = function(t) {
        t > this.shake && (this.shake = t)
    }, o.prototype.spawnSparks = function(t, e, i, o, s, n) {
        for (var r = 0; r < n; r++) {
            0 !== o && (i += (2 * Math.random() - 1) * o);
            var a = Math.cos(i),
                h = Math.sin(i);
            this.sparkEmitter.setXSpeed(a * s, a * s), this.sparkEmitter.setYSpeed(h * s, h * s), this.sparkEmitter.emitParticle(t, e)
        }
    }, o.prototype.spawnSmoke = function(t, e, i) {
        var o = this.smokeEmitter;
        o.setAlpha(1, .05, 1e3), o.lifespan = 1e3;
        for (var s = 0; s < i; s++) o.emitParticle(t + this.rnd.realInRange(-20, 20), e + this.rnd.realInRange(-20, 20))
    }, o.prototype.spawnBonus = function(t, e, i, s) {
        if (t === w)
            for (var n = 0; n < s; n++) this.groundLayer.add(new w(this.game, e, i));
        else t === S ? this.createTank(o.pxToTile(e), o.pxToTile(i), t(this.game), !0) : this.groundLayer.add(new t(this.game, e, i))
    }, o.prototype.spawnCoins = function(t, e, i) {
        for (var o = 0; o < i; o++) this.groundLayer.add(new w(this.game, t, e))
    }, o.prototype.spawnHole = function(t, e) {
        this._hole.angle = 10 * Math.random() - 5, this._hole.updateTransform(), this._holeTempMatrix.copyFrom(this._hole.worldTransform), this._holeTempMatrix.tx = t + this.rnd.realInRange(-2, 2) + o.TILE_SIZE, this._holeTempMatrix.ty = e + this.rnd.realInRange(-2, 2) + o.TILE_SIZE, this.sceneryImage.texture.renderWebGL(this._hole, this._holeTempMatrix, !1)
    }, o.prototype.spawnIce = function(t, e) {
        for (var i = 0; i < 6; i++) {
            var o = 2 * Math.PI / 6 * i,
                s = Math.cos(o),
                n = Math.sin(o);
            this.iceEmitter.setXSpeed(s * (80 + 30 * Math.random()), s * (80 + 30 * Math.random())), this.iceEmitter.setYSpeed(n * (80 + 30 * Math.random()), n * (80 + 30 * Math.random())), this.iceEmitter.emitParticle(t + s * Math.random() * 15, e + n * Math.random() * 15)
        }
    }, o.prototype.freezeEnemies = function() {
        this.freezeTime = 250 / 60;
        for (var t = 0; t < this.enemies.length; t++) {
            var e = this.enemies[t];
            e.alive && (e.states ? e.states.message("onFreeze") : e.onFreeze())
        }
        h.playSound("freeze.mp3", 1.3)
    }, o.prototype.unfreezeEnemies = function() {
        for (var t = 0; t < this.enemies.length; t++) {
            var e = this.enemies[t];
            e.alive && (e.states ? e.states.message("onUnfreeze") : e.onUnfreeze())
        }
        h.playSound("unfreeze.mp3", 1.25)
    }, o.prototype.alertSound = function(t, e, i) {
        for (var o = this.pxToTile(t), s = this.pxToTile(e), n = 0; n < this.enemies.length; n++) {
            var r = this.enemies[n];
            r.alive && r.states && Phaser.Math.distanceSq(t, e, r.bodyX, r.bodyY) <= i * i && r.states.message("onSoundEmitted", o, s)
        }
    }, o.prototype.revealFogAtLocation = function(t) {
        this.fog.revealTile(o.pxToTile(t.x), o.pxToTile(t.y), !1)
    }, o.prototype.revealFogArc = function(t, e, i, s, n, r) {
        for (var a = 2 * Math.PI / 36, h = i; h < s; h += a)
            for (var l = t + Math.cos(h) * n, d = e + Math.sin(h) * n, c = (l - t) / 20, p = (d - e) / 20, u = t, b = e, m = 0; m < 20; m++) {
                var y = o.pxToTile(u),
                    f = o.pxToTile(b);
                if (y < 0 || f < 0 || y >= this.width || f >= this.height) break;
                if (this.fog.revealTile(y, f, r), null !== this.objects[f][y] && this.objects[f][y].alive) break;
                u += c, b += p
            }
    };
    var nt = new Phaser.Rectangle;
    o.prototype.isTileVisible = function(t, e, i, o) {
        var s = this.root.scale.x,
            n = this.root.scale.y;
        return nt.x = (t - 26) * s, nt.y = (e - 26) * n, nt.width = 52 * s, nt.height = 52 * n, this.camera.view.intersects(nt)
    }, o.prototype.previousWeapon = function() {
        if (this.player.reallyAlive && !this.gamePaused)
            do {
                this.player.previousWeapon()
            } while (this.player.weapon.ammo <= 0)
    }, o.prototype.nextWeapon = function() {
        if (this.player.reallyAlive && !this.gamePaused)
            do {
                this.player.nextWeapon()
            } while (this.player.weapon.ammo <= 0)
    }, o.prototype.changeWeapon = function(t) {
        this.player.reallyAlive && !this.gamePaused && this.player.weapons[t] && this.player.weapons[t].ammo > 0 && this.player.changeWeapon(t)
    }, o.prototype.mouseWheel = function(t) {
        -1 === this.input.mouse.wheelDelta ? this.nextWeapon() : 1 === this.input.mouse.wheelDelta && this.previousWeapon()
    }, o.prototype.layMine = function() {
        this.player.alive && this.player.mines && this.player.mines.ammo > 0 && this.player.mines.shoot()
    }, o.prototype.collect = function(t) {
        if (t instanceof w) {
            var e = (this.number < 11 ? 12 : 15) * (1 + .8567 * this.index) * this.difficulty;
            this.profit += e, a.current.stats.coinsCollected += 1, a.current.stats.moneyEarned += e, this.hud.showProfit(Math.round(this.profit)), this.starEmitter.emitParticle(t.position.x, t.position.y, "game.png", "game/particles/star_object.png"), this.summaryAlert && this.summaryAlert.updateProfit(Math.round(this.profit))
        }
        if (!(t instanceof C)) {
            var i = this.root.scale.x,
                o = this.hudLayer.scale.x,
                s = (t.position.x * i - this.camera.view.x - this.hudLayer.position.x) / o,
                n = (t.position.y * i - this.camera.view.y - this.hudLayer.position.y) / o,
                r = 1.4 * (-100 - s),
                h = 1.4 * (-100 - n);
            this.collectiblesEmitter.setXSpeed(r, r), this.collectiblesEmitter.setYSpeed(h, h), this.collectiblesEmitter.setScale(t.scale.x, .99 * t.scale.x, t.scale.y, .99 * t.scale.y, 0), this.collectiblesEmitter.emitParticle(s, n, "game.png", t.constructor.FRAME_NAME)
        }
    }, o.prototype.increaseKillCount = function() {
        this.kills += 1, this.increaseCombo()
    }, o.prototype.increaseCombo = function() {
        this.combo += 1, this.comboTime = 1.7, 5 === this.combo && a.increaseAchievement("ultracombo") && this.achievements.show("ultracombo")
    }, o.prototype.dimGame = function(t) {
        this.camera.fx.clear(), this.camera.fx.beginFill(0), this.camera.fx.drawRect(0, 0, this.camera.width, this.camera.height), this.camera.fx.endFill(), t ? this.camera.fx.alpha = .5 : this.add.tween(this.camera.fx).to({
            alpha: .5
        }, 250, Phaser.Easing.Linear.None, !0)
    }, o.prototype.undimGame = function() {
        this.add.tween(this.camera.fx).to({
            alpha: 0
        }, 250, Phaser.Easing.Linear.None, !0)
    }, o.prototype.pauseOn = function() {
        this.gamePaused || this.pauseToggle()
    }, o.prototype.pauseToggle = function() {
        this.abandonAlert || this.summaryAlert || (this.gamePaused = !this.gamePaused, this.physics.box2d.paused = this.gamePaused, this.gamePaused ? (this.dimGame(!0), this.pauseAlert = new $(this.game, this.stage, this.pauseToggle, this), this.stage.updateTransform(), h.muteMusic()) : (this.undimGame(), this.pauseAlert.hide(), this.pauseAlert = null, h.unmuteMusic()))
    }, o.prototype.showAbandonAlert = function() {
        this.abandonAlert || this.summaryAlert || (this.abandonAlert = new q(this.game, this.stage, this.abandonClick, this, this.hideAbandonAlert, this), this.gamePaused = !0)
    }, o.prototype.hideAbandonAlert = function() {
        this.abandonAlert && (this.abandonAlert.hide(), this.abandonAlert = null, this.pauseAlert ? this.pauseToggle() : (this.gamePaused = !1, this.physics.box2d.paused = !1, this.undimGame()))
    }, o.prototype.updateCombo = function() {
        this.comboTime > 0 && (this.comboTime -= this.time.physicsElapsed, this.comboTime <= 0 && (this.combo = 0))
    }, o.prototype.updateTouchMove = function(t) {
        if (t && !this.freeCamera) {
            var e = t.x - t.positionDown.x,
                i = t.y - t.positionDown.y;
            if (Math.abs(e) > 5 || Math.abs(i) > 5) {
                var o = Math.sqrt(e * e + i * i);
                o > 10 && (t.positionDown.x += e * (o - 10) / o, t.positionDown.y += i * (o - 10) / o), this._touchMove.set(Phaser.Math.clamp(e, -10, 10) / 10, Phaser.Math.clamp(i, -10, 10) / 10)
            } else this._touchMove.set(0, 0)
        } else this._touchMove.set(0, 0);
        return this._touchMove
    }, o.prototype.updateTouchAim = function(t) {
        if (this.topLayer.position.x = -this.camera.position.x, this.topLayer.position.y = -this.camera.position.y, !t || this.freeCamera || this.player.follow || this.player.weapon === this.player.weapons[6]) this.player.autoAim = !0, this.touchAimCrosshair.visible = !1;
        else {
            var e = t.x - t.positionDown.x,
                i = t.y - t.positionDown.y,
                o = Math.sqrt(e * e + i + i);
            if (o > 100 && (t.positionDown.x += e * (o - 100) / o, t.positionDown.y += i * (o - 100) / o), Math.abs(e) >= 50 || Math.abs(i) >= 50 || this.touchAimCrosshair.visible) {
                if (e || i) {
                    this.player.rotateTurret(Math.atan2(i, e));
                    var s = this.player.getTurretPosition(150);
                    this.touchAimCrosshair.visible ? (this.touchAimCrosshair.x += .5 * (s.x - this.touchAimCrosshair.x), this.touchAimCrosshair.y += .5 * (s.y - this.touchAimCrosshair.y)) : (this.touchAimCrosshair.x = this.player.bodyX, this.touchAimCrosshair.y = this.player.bodyY)
                }
                this.player.autoAim = !1, this.touchAimCrosshair.visible = !0
            } else this.player.autoAim = !0, this.touchAimCrosshair.visible = !1
        }
    }, o.prototype.update = function() {
        if (!this.gamePaused) {
            this.easystar.calculate();
            var t = this.player;
            if (t.reallyAlive) {
                var e = this.updateTouchMove(this.movePointer),
                    i = -1 * this.pressingLeft + 1 * this.pressingRight + e.x,
                    s = -1 * this.pressingUp + 1 * this.pressingDown + e.y;
                (i || s) && t.move(Phaser.Math.clamp(i, -1, 1), Phaser.Math.clamp(s, -1, 1));
                var n = this.aimPointer && !this.hud.pointerDown(this.aimPointer.id) || this.input.mousePointer.isDown && !this.hud.pointerOver(this.input.mousePointer.id);
                this.freeCamera || this.summaryAlert || !n ? t.stopFire() : t.startFire(), this.game.device.touch ? this.updateTouchAim(this.aimPointer) : t.rotateTurret(Math.atan2(this.input.mousePointer.worldY - t.world.y, this.input.mousePointer.worldX - t.world.x))
            }
            this.fog.visible && this.updateFogLazy(!1), this.hud.fightMessageComplete && this.updateCamera(!1), this.freezeTime > 0 && (this.freezeTime -= this.time.physicsElapsed, this.freezeTime <= 0 && this.unfreezeEnemies()), this.updateCombo(), o.onUpdate(this)
        }
    }, o.prototype.render = function() {
        o.onRender(this)
    }, o.prototype.shutdown = function() {
        this.player && this.player.stopFire(), this.game.onPause.remove(this.pauseOn, this), this.abandonAlert && (this.abandonAlert.shutdown(), this.abandonAlert = null), this.summaryAlert && (this.summaryAlert.shutdown(), this.summaryAlert = null), this.pauseAlert && (this.pauseAlert.destroy(), this.pauseAlert = null), this.hud && (this.hud.shutdown(), this.hudLayer.parent.removeChild(this.hudLayer), this.hudLayer = this.hud = null), this.topLayer && (this.topLayer.parent.removeChild(this.topLayer), this.topLayer = null), this.player.weapons[1] && (a.current.game.shotgunAmmo = this.player.weapons[1].ammo), this.player.weapons[2] && (a.current.game.ricochetAmmo = this.player.weapons[2].ammo), this.player.weapons[3] && (a.current.game.flamethrowerAmmo = this.player.weapons[3].ammo), this.player.weapons[4] && (a.current.game.cannonAmmo = this.player.weapons[4].ammo), this.player.weapons[5] && (a.current.game.shockAmmo = this.player.weapons[5].ammo), this.player.weapons[6] && (a.current.game.rocketsAmmo = this.player.weapons[6].ammo), this.player.weapons[7] && (a.current.game.laserAmmo = this.player.weapons[7].ammo), this.player.weapons[8] && (a.current.game.railgunAmmo = this.player.weapons[8].ammo), this.player.mines && (a.current.game.minesAmmo = this.player.mines.ammo), a.current.game.money += Math.round(this.profit), a.save()
    }, o.prototype.abandonClick = function() {
        this.state.start("MenuUpgrades")
    }, o.prototype.enemyKilled = function(t) {
        this.enemiesAlive -= 1, this.points += t.points, !this.summaryAlert && 0 === this.enemiesAlive && this.player.reallyAlive && (h.cancelLaserLoop(), this.player.invincible = !0, this.summaryAlert = new K(this.game, this.stage, !0, Math.round(this.profit), this.successContinue, this), a.current.game.levels = Math.max(a.current.game.levels, this.number), this.index < a.current.game.points.length && (a.current.game.points[this.index] = Math.max(this.points, a.current.game.points[this.index])), this.player.health / this.player.maxHealth < .1 && a.increaseAchievement("survivor") && this.achievements.show("survivor"))
    }, o.prototype.playerKilled = function() {
        this.touchAimCrosshair.visible = !1, h.cancelLaserLoop(), this.summaryAlert || (this.summaryAlert = new K(this.game, this.stage, !1, Math.round(this.profit), this.failContinue, this))
    }, o.prototype.successContinue = function() {
        this.index < a.current.game.points.length && (a.current.game.points[this.index] = Math.max(this.points, a.current.game.points[this.index])), 15 === this.number ? a.current.game.completed ? this.state.start("MenuUpgrades") : (a.current.game.completed = !0, this.state.start("MenuCongratulations")) : this.state.start("MenuUpgrades")
    }, o.prototype.failContinue = function() {
        this.index < a.current.game.points.length && (a.current.game.points[this.index] = Math.max(this.points, a.current.game.points[this.index])), this.state.start("MenuUpgrades")
    }, Object.defineProperties(o.prototype, {
        pressingLeft: {
            get: function() {
                return this.leftKey.isDown || this.aKey.isDown
            }
        },
        pressingRight: {
            get: function() {
                return this.rightKey.isDown || this.dKey.isDown
            }
        },
        pressingUp: {
            get: function() {
                return this.upKey.isDown || this.wKey.isDown
            }
        },
        pressingDown: {
            get: function() {
                return this.downKey.isDown || this.sKey.isDown
            }
        }
    }), window.AT.Level = o
}(),
function() {
    "use strict";

    function t() {
        var t = window.innerWidth,
            e = window.innerHeight;
        t * window.devicePixelRatio === m.renderer.width && e * window.devicePixelRatio === m.renderer.height || (m.renderer.resize(t, e), m.scale.setUserScale(t / m.width, e / m.height, 0, 0), m.state.resize(t, e))
    }

    function e() {
        this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height)
    }

    function i() {
        this.scale.scaleMode = Phaser.ScaleManager.USER_SCALE
    }

    function o() {
        this.scale.updateScalingAndBounds = e, this.scale.setResizeCallback(t), this.stage.disableVisibilityChange = !1, this.stage.backgroundColor = 0, this.input.maxPointers = 2;
        var i = window.location.hostname.split(".");
        "snokido" || "coolmath-games" === i[i.length - 2] && "com" === i[i.length - 1] ? (this.physics.startSystem(Phaser.Physics.BOX2D), this.physics.box2d.friction = 0, this.physics.box2d.positionIterations = 1, this.physics.box2d.velocityIterations = 1, this.state.start("MenuLoading")) : this.state.start("MenuLock")
    }
    var s = window.AT.profile,
        n = window.AT.LEVELS,
        r = window.AT.Level,
        a = window.AT.menu.Levels,
        h = window.AT.menu.Upgrades,
        l = window.AT.menu.Title,
        d = window.AT.menu.Loading,
        c = window.AT.menu.Boot,
        p = window.AT.menu.Congratulations,
        u = window.AT.menu.Lock,
        b = (Math.min(window.innerWidth / 600, window.innerHeight / 600), {
            width: window.innerWidth,
            height: window.innerHeight,
            antialias: !1,
            resolution: 1,
            renderer: Phaser.WEBGL,
            clearBeforeRender: !0,
            preserveDrawingBuffer: !0,
            state: {
                preload: i,
                create: o
            },
            enableDebug: !1
        }),
        m = new Phaser.Game(b);
    m.state.add("MenuLoading", new d), m.state.add("MenuBoot", new c), m.state.add("MenuTitle", new l), m.state.add("MenuUpgrades", new h), m.state.add("MenuLevels", new a), m.state.add("MenuCongratulations", new p), m.state.add("MenuLock", new u);
    for (var y = 0; y < n.length; y++) m.state.add("Level" + (y + 1), new r(n[y], y + 1));
    s.load(), document.addEventListener("contextmenu", function(t) {
        t.preventDefault()
    }), document.addEventListener("click", function(t) {
        window.focus()
    }), window.unlockAllLevels = function() {
        s.current.game.levels = 15, s.save(), "MenuLevels" === m.state.current && (m.state.restart(), m.focusGain())
    }, window.AT.game = m
}();