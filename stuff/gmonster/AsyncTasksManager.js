var gdjs;(function(n){class o{constructor(){this.tasksWithCallback=new Array}processTasks(e){for(let s=0;s<this.tasksWithCallback.length;s++){const i=this.tasksWithCallback[s];i.asyncTask.update(e)&&(i.callback(e),this.tasksWithCallback.splice(s--,1))}}addTask(e,s){this.tasksWithCallback.push({asyncTask:e,callback:s})}clearTasks(){this.tasksWithCallback.length=0}}n.AsyncTasksManager=o;class t{}n.AsyncTask=t;class l extends t{constructor(){super(...arguments);this.tasks=new Array}addTask(e){this.tasks.push(e)}update(e){for(let s=0;s<this.tasks.length;s++)this.tasks[s].update(e)&&this.tasks.splice(s--,1);return this.tasks.length===0}}n.TaskGroup=l;class c extends t{update(){return!0}}n.ResolveTask=c;const r=new n.Logger("Internal PromiseTask");class h extends t{constructor(e){super();this.isResolved=!1;this.promise=e.catch(s=>{r.error(`A promise error has not been handled, this should never happen!
If you are using JavaScript promises in an asynchronous action, make sure to add a .catch().
Otherwise, report this as a bug on the GDevelop forums!
${s?"The following error was thrown: "+s:""}`)}).then(()=>{this.isResolved=!0})}update(){return this.isResolved}}n.PromiseTask=h;class k extends t{constructor(){super(...arguments);this.isResolved=!1}resolve(){this.isResolved=!0}update(){return this.isResolved}}n.ManuallyResolvableTask=k})(gdjs||(gdjs={}));
//# sourceMappingURL=AsyncTasksManager.js.map
